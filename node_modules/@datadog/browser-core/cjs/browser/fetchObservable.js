"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initFetchObservable = initFetchObservable;
exports.resetFetchObservable = resetFetchObservable;
var instrumentMethod_1 = require("../tools/instrumentMethod");
var monitor_1 = require("../tools/monitor");
var observable_1 = require("../tools/observable");
var polyfills_1 = require("../tools/utils/polyfills");
var timeUtils_1 = require("../tools/utils/timeUtils");
var urlPolyfill_1 = require("../tools/utils/urlPolyfill");
var fetchObservable;
function initFetchObservable() {
    if (!fetchObservable) {
        fetchObservable = createFetchObservable();
    }
    return fetchObservable;
}
function resetFetchObservable() {
    fetchObservable = undefined;
}
function createFetchObservable() {
    return new observable_1.Observable(function (observable) {
        if (!window.fetch) {
            return;
        }
        var stop = (0, instrumentMethod_1.instrumentMethod)(window, 'fetch', function (call) { return beforeSend(call, observable); }, {
            computeHandlingStack: true,
        }).stop;
        return stop;
    });
}
function beforeSend(_a, observable) {
    var parameters = _a.parameters, onPostCall = _a.onPostCall, handlingStack = _a.handlingStack;
    var input = parameters[0], init = parameters[1];
    var methodFromParams = init && init.method;
    if (methodFromParams === undefined && input instanceof Request) {
        methodFromParams = input.method;
    }
    var method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET';
    var url = input instanceof Request ? input.url : (0, urlPolyfill_1.normalizeUrl)(String(input));
    var startClocks = (0, timeUtils_1.clocksNow)();
    var context = {
        state: 'start',
        init: init,
        input: input,
        method: method,
        startClocks: startClocks,
        url: url,
        handlingStack: handlingStack,
    };
    observable.notify(context);
    // Those properties can be changed by observable subscribers
    parameters[0] = context.input;
    parameters[1] = context.init;
    onPostCall(function (responsePromise) { return afterSend(observable, responsePromise, context); });
}
function afterSend(observable, responsePromise, startContext) {
    var context = startContext;
    function reportFetch(partialContext) {
        context.state = 'resolve';
        (0, polyfills_1.assign)(context, partialContext);
        observable.notify(context);
    }
    responsePromise.then((0, monitor_1.monitor)(function (response) {
        reportFetch({
            response: response,
            responseType: response.type,
            status: response.status,
            isAborted: false,
        });
    }), (0, monitor_1.monitor)(function (error) {
        var _a, _b;
        reportFetch({
            status: 0,
            isAborted: ((_b = (_a = context.init) === null || _a === void 0 ? void 0 : _a.signal) === null || _b === void 0 ? void 0 : _b.aborted) || (error instanceof DOMException && error.code === DOMException.ABORT_ERR),
            error: error,
        });
    }));
}
//# sourceMappingURL=fetchObservable.js.map