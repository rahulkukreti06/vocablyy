"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_TASK_TIME = void 0;
exports.requestIdleCallback = requestIdleCallback;
exports.requestIdleCallbackShim = requestIdleCallbackShim;
var timer_1 = require("./timer");
var monitor_1 = require("./monitor");
var timeUtils_1 = require("./utils/timeUtils");
/**
 * 'requestIdleCallback' with a shim.
 */
function requestIdleCallback(callback, opts) {
    // Note: check both 'requestIdleCallback' and 'cancelIdleCallback' existence because some polyfills only implement 'requestIdleCallback'.
    if (window.requestIdleCallback && window.cancelIdleCallback) {
        var id_1 = window.requestIdleCallback((0, monitor_1.monitor)(callback), opts);
        return function () { return window.cancelIdleCallback(id_1); };
    }
    return requestIdleCallbackShim(callback);
}
exports.MAX_TASK_TIME = 50;
/*
 * Shim from https://developer.chrome.com/blog/using-requestidlecallback#checking_for_requestidlecallback
 * Note: there is no simple way to support the "timeout" option, so we ignore it.
 */
function requestIdleCallbackShim(callback) {
    var start = (0, timeUtils_1.dateNow)();
    var timeoutId = (0, timer_1.setTimeout)(function () {
        callback({
            didTimeout: false,
            timeRemaining: function () { return Math.max(0, exports.MAX_TASK_TIME - ((0, timeUtils_1.dateNow)() - start)); },
        });
    }, 0);
    return function () { return (0, timer_1.clearTimeout)(timeoutId); };
}
//# sourceMappingURL=requestIdleCallback.js.map