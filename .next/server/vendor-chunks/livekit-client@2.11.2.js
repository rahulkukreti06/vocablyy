"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client@2.11.2";
exports.ids = ["vendor-chunks/livekit-client@2.11.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/livekit-client@2.11.2/node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/livekit-client@2.11.2/node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BackupCodecPolicy: () => (/* binding */ BackupCodecPolicy),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   CheckStatus: () => (/* binding */ CheckStatus),\n/* harmony export */   Checker: () => (/* binding */ Checker),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionErrorReason: () => (/* binding */ ConnectionErrorReason),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorError: () => (/* binding */ CryptorError),\n/* harmony export */   CryptorErrorReason: () => (/* binding */ CryptorErrorReason),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   LoggerNames: () => (/* binding */ LoggerNames),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   Mutex: () => (/* binding */ _),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   ParticipantKind: () => (/* binding */ ParticipantInfo_Kind),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   PublishTrackError: () => (/* binding */ PublishTrackError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   SignalRequestError: () => (/* binding */ SignalRequestError),\n/* harmony export */   SubscriptionError: () => (/* binding */ SubscriptionError),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   TrackType: () => (/* binding */ TrackType),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getBrowser: () => (/* binding */ getBrowser),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isAudioTrack: () => (/* binding */ isAudioTrack),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isLocalParticipant: () => (/* binding */ isLocalParticipant),\n/* harmony export */   isLocalTrack: () => (/* binding */ isLocalTrack),\n/* harmony export */   isRemoteParticipant: () => (/* binding */ isRemoteParticipant),\n/* harmony export */   isRemoteTrack: () => (/* binding */ isRemoteTrack),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   isVideoTrack: () => (/* binding */ isVideoTrack),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== \"default\" && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar e = Object.defineProperty;\nvar h = (i, s, t)=>s in i ? e(i, s, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: t\n    }) : i[s] = t;\nvar o = (i, s, t)=>h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\nclass _ {\n    constructor(){\n        o(this, \"_locking\");\n        o(this, \"_locks\");\n        this._locking = Promise.resolve(), this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let s;\n        const t = new Promise((l)=>s = ()=>{\n                this._locks -= 1, l();\n            }), c = this._locking.then(()=>s);\n        return this._locking = this._locking.then(()=>t), c;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -2147483648;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   * Note that this function disregards extensions and unknown fields.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(\"int64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(\"uint64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the zero value for the given scalar type.\n */ function scalarZeroValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\n *\n * In proto3, zero-values are not written to the wire, unless the field is\n * optional or repeated.\n */ function isScalarZeroValue(type, value) {\n    switch(type){\n        case ScalarType.BOOL:\n            return value === false;\n        case ScalarType.STRING:\n            return value === \"\";\n        case ScalarType.BYTES:\n            return value instanceof Uint8Array && !value.byteLength;\n        default:\n            return value == 0;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n   * in editions with message_encoding = DELIMITED.\n   */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n   * End of a tag-delimited aggregate.\n   */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element and return the skipped data.\n   *\n   * When skipping StartGroup, provide the tags field number to check for\n   * matching field number in the EndGroup tag.\n   */ skip(wireType, fieldNo) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                for(;;){\n                    const [fn, wt] = this.tag();\n                    if (wt === WireType.EndGroup) {\n                        if (fieldNo !== undefined && fn !== fieldNo) {\n                            throw new Error(\"invalid end group tag\");\n                        }\n                        break;\n                    }\n                    this.skip(wt, fn);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new extension using the given runtime.\n */ function makeExtension(runtime, typeName, extendee, field) {\n    let fi;\n    return {\n        typeName,\n        extendee,\n        get field () {\n            if (!fi) {\n                const i = typeof field == \"function\" ? field() : field;\n                i.name = typeName.split(\".\").pop();\n                i.jsonName = \"[\".concat(typeName, \"]\");\n                fi = runtime.util.newFieldList([\n                    i\n                ]).list()[0];\n            }\n            return fi;\n        },\n        runtime\n    };\n}\n/**\n * Create a container that allows us to read extension fields into it with the\n * same logic as regular fields.\n */ function createExtensionContainer(extension) {\n    const localName = extension.field.localName;\n    const container = Object.create(null);\n    container[localName] = initExtensionField(extension);\n    return [\n        container,\n        ()=>container[localName]\n    ];\n}\nfunction initExtensionField(ext) {\n    const field = ext.field;\n    if (field.repeated) {\n        return [];\n    }\n    if (field.default !== undefined) {\n        return field.default;\n    }\n    switch(field.kind){\n        case \"enum\":\n            return field.T.values[0].no;\n        case \"scalar\":\n            return scalarZeroValue(field.T, field.L);\n        case \"message\":\n            // eslint-disable-next-line no-case-declarations\n            const T = field.T, value = new T();\n            return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\n        case \"map\":\n            throw \"map fields are not allowed to be extensions\";\n    }\n}\n/**\n * Helper to filter unknown fields, optimized based on field type.\n */ function filterUnknownFields(unknownFields, field) {\n    if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\n        // singular scalar fields do not merge, we pick the last\n        for(let i = unknownFields.length - 1; i >= 0; --i){\n            if (unknownFields[i].no == field.no) {\n                return [\n                    unknownFields[i]\n                ];\n            }\n        }\n        return [];\n    }\n    return unknownFields.filter((uf)=>uf.no === field.no);\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\t\":\n                    case \" \":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Retrieve an extension value from a message.\n *\n * The function never returns undefined. Use hasExtension() to check whether an\n * extension is set. If the extension is not set, this function returns the\n * default value (if one was specified in the protobuf source), or the zero value\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\n * an empty message instance for message fields).\n *\n * Extensions are stored as unknown fields on a message. To mutate an extension\n * value, make sure to store the new value with setExtension() after mutating.\n *\n * If the extension does not extend the given message, an error is raised.\n */ function getExtension(message, extension, options) {\n    assertExtendee(extension, message);\n    const opt = extension.runtime.bin.makeReadOptions(options);\n    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\n    const [container, get] = createExtensionContainer(extension);\n    for (const uf of ufs){\n        extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\n    }\n    return get();\n}\n/**\n * Set an extension value on a message. If the message already has a value for\n * this extension, the value is replaced.\n *\n * If the extension does not extend the given message, an error is raised.\n */ function setExtension(message, extension, value, options) {\n    assertExtendee(extension, message);\n    const readOpt = extension.runtime.bin.makeReadOptions(options);\n    const writeOpt = extension.runtime.bin.makeWriteOptions(options);\n    if (hasExtension(message, extension)) {\n        const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf)=>uf.no != extension.field.no);\n        message.getType().runtime.bin.discardUnknownFields(message);\n        for (const uf of ufs){\n            message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\n        }\n    }\n    const writer = writeOpt.writerFactory();\n    let f = extension.field;\n    // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\n    // We patch the field info to use explicit presence:\n    if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\n        f = Object.assign(Object.assign({}, extension.field), {\n            opt: true\n        });\n    }\n    extension.runtime.bin.writeField(f, value, writer, writeOpt);\n    const reader = readOpt.readerFactory(writer.finish());\n    while(reader.pos < reader.len){\n        const [no, wireType] = reader.tag();\n        const data = reader.skip(wireType, no);\n        message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\n    }\n}\n/**\n * Check whether an extension is set on a message.\n */ function hasExtension(message, extension) {\n    const messageType = message.getType();\n    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf)=>uf.no == extension.field.no);\n}\nfunction assertExtendee(extension, message) {\n    assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if the field is set.\n */ function isFieldSet(field, target) {\n    const localName = field.localName;\n    if (field.repeated) {\n        return target[localName].length > 0;\n    }\n    if (field.oneof) {\n        return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\n    }\n    switch(field.kind){\n        case \"enum\":\n        case \"scalar\":\n            if (field.opt || field.req) {\n                // explicit presence\n                return target[localName] !== undefined;\n            }\n            // implicit presence\n            if (field.kind == \"enum\") {\n                return target[localName] !== field.T.values[0].no;\n            }\n            return !isScalarZeroValue(field.T, target[localName]);\n        case \"message\":\n            return target[localName] !== undefined;\n        case \"map\":\n            return Object.keys(target[localName]).length > 0;\n    }\n}\n/**\n * Resets the field, so that isFieldSet() will return false.\n */ function clearField(field, target) {\n    const localName = field.localName;\n    const implicitPresence = !field.opt && !field.req;\n    if (field.repeated) {\n        target[localName] = [];\n    } else if (field.oneof) {\n        target[field.oneof.localName] = {\n            case: undefined\n        };\n    } else {\n        switch(field.kind){\n            case \"map\":\n                target[localName] = {};\n                break;\n            case \"enum\":\n                target[localName] = implicitPresence ? field.T.values[0].no : undefined;\n                break;\n            case \"scalar\":\n                target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\n                break;\n            case \"message\":\n                target[localName] = undefined;\n                break;\n        }\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Check whether the given object is any subtype of Message or is a specific\n * Message by passing the type.\n *\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\n * `isMessage` is that it compares identity by the message type name, not by\n * class identity. This makes it robust against the dual package hazard and\n * similar situations, where the same message is duplicated.\n *\n * This function is _mostly_ equivalent to the `instanceof` operator. For\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\n * `isMessage` should be preferred over `instanceof`.\n *\n * However, due to the fact that `isMessage` does not use class identity, there\n * are subtle differences between this function and `instanceof`. Notably,\n * calling `isMessage` on an explicit type of Message will return false.\n */ function isMessage(arg, type) {\n    if (arg === null || typeof arg != \"object\") {\n        return false;\n    }\n    if (!Object.getOwnPropertyNames(Message.prototype).every((m)=>m in arg && typeof arg[m] == \"function\")) {\n        return false;\n    }\n    const actualType = arg.getType();\n    if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\n        return false;\n    }\n    return type === undefined ? true : actualType.typeName == type.typeName;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (isMessage(value) || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nconst tokenNull = Symbol();\nconst tokenIgnoredUnknownEnum = Symbol();\nfunction makeJsonFormat() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = new Map();\n            const registry = options.typeRegistry;\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (field) {\n                    if (field.oneof) {\n                        if (jsonValue === null && field.kind == \"scalar\") {\n                            continue;\n                        }\n                        const seen = oneofSeen.get(field.oneof);\n                        if (seen !== undefined) {\n                            throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: multiple keys for oneof \"').concat(field.oneof.name, '\" present: \"').concat(seen, '\", \"').concat(jsonKey, '\"'));\n                        }\n                        oneofSeen.set(field.oneof, jsonKey);\n                    }\n                    readField$1(message, jsonValue, field, options, type);\n                } else {\n                    let found = false;\n                    if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\n                        const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\n                        if (ext && ext.extendee.typeName == type.typeName) {\n                            found = true;\n                            const [container, get] = createExtensionContainer(ext);\n                            readField$1(container, jsonValue, ext.field, options, ext);\n                            // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\n                            // so that users can bring their own binary reader and writer factories\n                            // if necessary.\n                            setExtension(message, ext, get(), options);\n                        }\n                    }\n                    if (!found && !options.ignoreUnknownFields) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: key \"').concat(jsonKey, '\" is unknown'));\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (field of type.fields.byNumber()){\n                    if (!isFieldSet(field, message)) {\n                        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                        if (field.req) {\n                            throw \"required field not set\";\n                        }\n                        if (!options.emitDefaultValues) {\n                            continue;\n                        }\n                        if (!canEmitFieldDefaultValue(field)) {\n                            continue;\n                        }\n                    }\n                    const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n                    const jsonValue = writeField$1(field, value, options);\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n                const registry = options.typeRegistry;\n                if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\n                    for (const uf of type.runtime.bin.listUnknownFields(message)){\n                        const ext = registry.findExtensionFor(type.typeName, uf.no);\n                        if (ext && hasExtension(message, ext)) {\n                            // We pass on the options as BinaryReadOptions, so that users can bring their own\n                            // binary reader factory if necessary.\n                            const value = getExtension(message, ext, options);\n                            const jsonValue = writeField$1(ext.field, value, options);\n                            if (jsonValue !== undefined) {\n                                json[ext.field.jsonName] = jsonValue;\n                            }\n                        }\n                    }\n                }\n            } catch (e) {\n                const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n            }\n            return json;\n        },\n        readScalar (type, json, longType) {\n            // The signature of our internal function has changed. For backwards-\n            // compatibility, we support the old form that is part of the public API\n            // through the interface JsonFormat.\n            return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\n        },\n        writeScalar (type, value, emitDefaultValues) {\n            // The signature of our internal function has changed. For backwards-\n            // compatibility, we support the old form that is part of the public API\n            // through the interface JsonFormat.\n            if (value === undefined) {\n                return undefined;\n            }\n            if (emitDefaultValues || isScalarZeroValue(type, value)) {\n                return writeScalar$1(type, value);\n            }\n            return undefined;\n        },\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : '\"'.concat(json.split('\"').join('\\\\\"'), '\"');\n        default:\n            return String(json);\n    }\n}\n// Read a JSON value for a field.\n// The \"parentType\" argument is only used to provide context in errors.\nfunction readField$1(target, jsonValue, field, options, parentType) {\n    let localName = field.localName;\n    if (field.repeated) {\n        assert(field.kind != \"map\");\n        if (jsonValue === null) {\n            return;\n        }\n        if (!Array.isArray(jsonValue)) {\n            throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n        }\n        const targetArray = target[localName];\n        for (const jsonItem of jsonValue){\n            if (jsonItem === null) {\n                throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\n            }\n            switch(field.kind){\n                case \"message\":\n                    targetArray.push(field.T.fromJson(jsonItem, options));\n                    break;\n                case \"enum\":\n                    const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\n                    if (enumValue !== tokenIgnoredUnknownEnum) {\n                        targetArray.push(enumValue);\n                    }\n                    break;\n                case \"scalar\":\n                    try {\n                        targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\n                    } catch (e) {\n                        let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\n                        if (e instanceof Error && e.message.length > 0) {\n                            m += \": \".concat(e.message);\n                        }\n                        throw new Error(m);\n                    }\n                    break;\n            }\n        }\n    } else if (field.kind == \"map\") {\n        if (jsonValue === null) {\n            return;\n        }\n        if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\n            throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n        }\n        const targetMap = target[localName];\n        for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n            if (jsonMapValue === null) {\n                throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n            }\n            let key;\n            try {\n                key = readMapKey(field.K, jsonMapKey);\n            } catch (e) {\n                let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                if (e instanceof Error && e.message.length > 0) {\n                    m += \": \".concat(e.message);\n                }\n                throw new Error(m);\n            }\n            switch(field.V.kind){\n                case \"message\":\n                    targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\n                    break;\n                case \"enum\":\n                    const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\n                    if (enumValue !== tokenIgnoredUnknownEnum) {\n                        targetMap[key] = enumValue;\n                    }\n                    break;\n                case \"scalar\":\n                    try {\n                        targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\n                    } catch (e) {\n                        let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                        if (e instanceof Error && e.message.length > 0) {\n                            m += \": \".concat(e.message);\n                        }\n                        throw new Error(m);\n                    }\n                    break;\n            }\n        }\n    } else {\n        if (field.oneof) {\n            target = target[field.oneof.localName] = {\n                case: localName\n            };\n            localName = \"value\";\n        }\n        switch(field.kind){\n            case \"message\":\n                const messageType = field.T;\n                if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                    return;\n                }\n                let currentValue = target[localName];\n                if (isMessage(currentValue)) {\n                    currentValue.fromJson(jsonValue, options);\n                } else {\n                    target[localName] = currentValue = messageType.fromJson(jsonValue, options);\n                    if (messageType.fieldWrapper && !field.oneof) {\n                        target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\n                    }\n                }\n                break;\n            case \"enum\":\n                const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\n                switch(enumValue){\n                    case tokenNull:\n                        clearField(field, target);\n                        break;\n                    case tokenIgnoredUnknownEnum:\n                        break;\n                    default:\n                        target[localName] = enumValue;\n                        break;\n                }\n                break;\n            case \"scalar\":\n                try {\n                    const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\n                    switch(scalarValue){\n                        case tokenNull:\n                            clearField(field, target);\n                            break;\n                        default:\n                            target[localName] = scalarValue;\n                            break;\n                    }\n                } catch (e) {\n                    let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                    if (e instanceof Error && e.message.length > 0) {\n                        m += \": \".concat(e.message);\n                    }\n                    throw new Error(m);\n                }\n                break;\n        }\n    }\n}\nfunction readMapKey(type, json) {\n    if (type === ScalarType.BOOL) {\n        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n        switch(json){\n            case \"true\":\n                json = true;\n                break;\n            case \"false\":\n                json = false;\n                break;\n        }\n    }\n    return readScalar$1(type, json, LongType.BIGINT, true).toString();\n}\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\n    if (json === null) {\n        if (nullAsZeroValue) {\n            return scalarZeroValue(type, longType);\n        }\n        return tokenNull;\n    }\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\n    if (json === null) {\n        if (type.typeName == \"google.protobuf.NullValue\") {\n            return 0; // google.protobuf.NullValue.NULL_VALUE = 0\n        }\n        return nullAsZeroValue ? type.values[0].no : tokenNull;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            if (value !== undefined) {\n                return value.no;\n            }\n            if (ignoreUnknownFields) {\n                return tokenIgnoredUnknownEnum;\n            }\n            break;\n    }\n    throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\nfunction canEmitFieldDefaultValue(field) {\n    if (field.repeated || field.kind == \"map\") {\n        // maps are {}, repeated fields are []\n        return true;\n    }\n    if (field.oneof) {\n        // oneof fields are never emitted\n        return false;\n    }\n    if (field.kind == \"message\") {\n        // singular message field are allowed to emit JSON null, but we do not\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (field.opt || field.req) {\n        // the field uses explicit presence, so we cannot emit a zero value\n        return false;\n    }\n    return true;\n}\nfunction writeField$1(field, value, options) {\n    if (field.kind == \"map\") {\n        assert(typeof value == \"object\" && value != null);\n        const jsonObj = {};\n        const entries = Object.entries(value);\n        switch(field.V.kind){\n            case \"scalar\":\n                for (const [entryKey, entryValue] of entries){\n                    jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\n                }\n                break;\n            case \"message\":\n                for (const [entryKey, entryValue] of entries){\n                    // JSON standard allows only (double quoted) string as property key\n                    jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                }\n                break;\n            case \"enum\":\n                const enumType = field.V.T;\n                for (const [entryKey, entryValue] of entries){\n                    // JSON standard allows only (double quoted) string as property key\n                    jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\n                }\n                break;\n        }\n        return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\n    }\n    if (field.repeated) {\n        assert(Array.isArray(value));\n        const jsonArr = [];\n        switch(field.kind){\n            case \"scalar\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(writeScalar$1(field.T, value[i]));\n                }\n                break;\n            case \"enum\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\n                }\n                break;\n            case \"message\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(value[i].toJson(options));\n                }\n                break;\n        }\n        return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n    }\n    switch(field.kind){\n        case \"scalar\":\n            return writeScalar$1(field.T, value);\n        case \"enum\":\n            return writeEnum(field.T, value, options.enumAsInteger);\n        case \"message\":\n            return wrapField(field.T, value).toJson(options);\n    }\n}\nfunction writeEnum(type, value, enumAsInteger) {\n    var _a;\n    assert(typeof value == \"number\");\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar$1(type, value) {\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            return value.toString();\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return protoBase64.enc(value);\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormat() {\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\n            const type = message.getType();\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\n            let fieldNo, wireType;\n            while(reader.pos < end){\n                [fieldNo, wireType] = reader.tag();\n                if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\n                    break;\n                }\n                const field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType, fieldNo);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                readField(message, reader, field, wireType, options);\n            }\n            if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n            (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\n                throw new Error(\"invalid end group tag\");\n            }\n        },\n        readField,\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                if (!isFieldSet(field, message)) {\n                    if (field.req) {\n                        throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\n                    }\n                    continue;\n                }\n                const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n                writeField(field, value, writer, options);\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        },\n        writeField (field, value, writer, options) {\n            // The behavior of our internal function has changed, it does no longer\n            // accept `undefined` values for singular scalar and map.\n            // For backwards-compatibility, we support the old form that is part of\n            // the public API through the interface BinaryFormat.\n            if (value === undefined) {\n                return undefined;\n            }\n            writeField(field, value, writer, options);\n        }\n    };\n}\nfunction readField(target, // eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\nreader, field, wireType, options) {\n    let { repeated, localName } = field;\n    if (field.oneof) {\n        target = target[field.oneof.localName];\n        if (target.case != localName) {\n            delete target.value;\n        }\n        target.case = localName;\n        localName = \"value\";\n    }\n    switch(field.kind){\n        case \"scalar\":\n        case \"enum\":\n            const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n            let read = readScalar;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            if (field.kind == \"scalar\" && field.L > 0) {\n                read = readScalarLTString;\n            }\n            if (repeated) {\n                let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\n                if (isPacked) {\n                    let e = reader.uint32() + reader.pos;\n                    while(reader.pos < e){\n                        arr.push(read(reader, scalarType));\n                    }\n                } else {\n                    arr.push(read(reader, scalarType));\n                }\n            } else {\n                target[localName] = read(reader, scalarType);\n            }\n            break;\n        case \"message\":\n            const messageType = field.T;\n            if (repeated) {\n                // safe to assume presence of array, oneof cannot contain repeated values\n                target[localName].push(readMessageField(reader, new messageType(), options, field));\n            } else {\n                if (isMessage(target[localName])) {\n                    readMessageField(reader, target[localName], options, field);\n                } else {\n                    target[localName] = readMessageField(reader, new messageType(), options, field);\n                    if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                        target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                    }\n                }\n            }\n            break;\n        case \"map\":\n            let [mapKey, mapVal] = readMapEntry(field, reader, options);\n            // safe to assume presence of map object, oneof cannot contain repeated values\n            target[localName][mapKey] = mapVal;\n            break;\n    }\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options, field) {\n    const format = message.getType().runtime.bin;\n    const delimited = field === null || field === void 0 ? void 0 : field.delimited;\n    format.readMessage(message, reader, delimited ? field.no : reader.uint32(), // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n    options, delimited);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        const [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options, undefined);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        key = scalarZeroValue(field.K, LongType.BIGINT);\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarZeroValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = field.V.T.values[0].no;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeField(field, value, writer, options) {\n    assert(value !== undefined);\n    const repeated = field.repeated;\n    switch(field.kind){\n        case \"scalar\":\n        case \"enum\":\n            let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n            if (repeated) {\n                assert(Array.isArray(value));\n                if (field.packed) {\n                    writePacked(writer, scalarType, field.no, value);\n                } else {\n                    for (const item of value){\n                        writeScalar(writer, scalarType, field.no, item);\n                    }\n                }\n            } else {\n                writeScalar(writer, scalarType, field.no, value);\n            }\n            break;\n        case \"message\":\n            if (repeated) {\n                assert(Array.isArray(value));\n                for (const item of value){\n                    writeMessageField(writer, options, field, item);\n                }\n            } else {\n                writeMessageField(writer, options, field, value);\n            }\n            break;\n        case \"map\":\n            assert(typeof value == \"object\" && value != null);\n            for (const [key, val] of Object.entries(value)){\n                writeMapEntry(writer, options, field, key, val);\n            }\n            break;\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar(writer, field.K, 1, keyValue);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar(writer, field.V.T, 2, value);\n            break;\n        case \"enum\":\n            writeScalar(writer, ScalarType.INT32, 2, value);\n            break;\n        case \"message\":\n            assert(value !== undefined);\n            writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\n            break;\n    }\n    writer.join();\n}\n// Value must not be undefined\nfunction writeMessageField(writer, options, field, value) {\n    const message = wrapField(field.T, value);\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);\n    else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\n}\nfunction writeScalar(writer, type, fieldNo, value) {\n    assert(value !== undefined);\n    let [wireType, method] = scalarTypeInfo(type);\n    writer.tag(fieldNo, wireType)[method](value);\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ // TODO replace call-sites writeScalar() and writePacked(), then remove\nfunction scalarTypeInfo(type) {\n    let wireType = WireType.Varint;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.BYTES:\n        case ScalarType.STRING:\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.DOUBLE:\n        case ScalarType.FIXED64:\n        case ScalarType.SFIXED64:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method\n    ];\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] == null) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>isMessage(val, mt) ? val : new mt(val));\n                        } else {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = isMessage(val, mt) ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        // TODO use isFieldSet() here to support future field presence\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(\"repeated cannot contain \".concat(m.kind));\n                }\n                switch(m.kind){\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(\"oneof cannot contain \".concat(s.kind));\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        // TODO use isFieldSet() here to support future field presence\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            for (const uf of type.runtime.bin.listUnknownFields(message)){\n                type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (isMessage(value)) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\n    return {\n        syntax,\n        json: makeJsonFormat(),\n        bin: makeBinaryFormat(),\n        util: Object.assign(Object.assign({}, makeUtilCommon()), {\n            newFieldList,\n            initFields\n        }),\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType,\n        makeExtension (typeName, extendee, field) {\n            return makeExtension(this, typeName, extendee, field);\n        }\n    };\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>\"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.req = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Convert a collection of field info to an array of normalized FieldInfo.\n *\n * The argument `packedByDefault` specifies whether fields that do not specify\n * `packed` should be packed (proto3) or unpacked (proto2).\n */ function normalizeFieldInfos(fieldInfos, packedByDefault) {\n    var _a, _b, _c, _d, _e, _f;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\n        f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\n        f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\n        if (field.packed === undefined) {\n            {\n                f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n            }\n        }\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", (fields)=>{\n    return new InternalFieldList(fields, (source)=>normalizeFieldInfos(source));\n}, // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\n(target)=>{\n    for (const member of target.getType().fields.byMember()){\n        if (member.opt) {\n            continue;\n        }\n        const name = member.localName, t = target;\n        if (member.repeated) {\n            t[name] = [];\n            continue;\n        }\n        switch(member.kind){\n            case \"oneof\":\n                t[name] = {\n                    case: undefined\n                };\n                break;\n            case \"enum\":\n                t[name] = 0;\n                break;\n            case \"map\":\n                t[name] = {};\n                break;\n            case \"scalar\":\n                t[name] = scalarZeroValue(member.T, member.L);\n                break;\n        }\n    }\n});\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        if (this.nanos < 0) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            } else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            } else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"seconds\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"nanos\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst MetricsBatch = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MetricsBatch\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"normalized_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"str_data\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"time_series\",\n            kind: \"message\",\n            T: TimeSeriesMetric,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"events\",\n            kind: \"message\",\n            T: EventMetric,\n            repeated: true\n        }\n    ]);\nconst TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TimeSeriesMetric\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"samples\",\n            kind: \"message\",\n            T: MetricSample,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"rid\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst MetricSample = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MetricSample\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"normalized_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"value\",\n            kind: \"scalar\",\n            T: 2\n        }\n    ]);\nconst EventMetric = /* @__PURE__ */ proto3.makeMessageType(\"livekit.EventMetric\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"start_timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 5,\n            name: \"end_timestamp_ms\",\n            kind: \"scalar\",\n            T: 3,\n            opt: true\n        },\n        {\n            no: 6,\n            name: \"normalized_start_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 7,\n            name: \"normalized_end_timestamp\",\n            kind: \"message\",\n            T: Timestamp,\n            opt: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"rid\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst BackupCodecPolicy$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.BackupCodecPolicy\", [\n    {\n        no: 0,\n        name: \"PREFER_REGRESSION\"\n    },\n    {\n        no: 1,\n        name: \"SIMULCAST\"\n    },\n    {\n        no: 2,\n        name: \"REGRESSION\"\n    }\n]);\nconst TrackType = /* @__PURE__ */ proto3.makeEnum(\"livekit.TrackType\", [\n    {\n        no: 0,\n        name: \"AUDIO\"\n    },\n    {\n        no: 1,\n        name: \"VIDEO\"\n    },\n    {\n        no: 2,\n        name: \"DATA\"\n    }\n]);\nconst TrackSource = /* @__PURE__ */ proto3.makeEnum(\"livekit.TrackSource\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"CAMERA\"\n    },\n    {\n        no: 2,\n        name: \"MICROPHONE\"\n    },\n    {\n        no: 3,\n        name: \"SCREEN_SHARE\"\n    },\n    {\n        no: 4,\n        name: \"SCREEN_SHARE_AUDIO\"\n    }\n]);\nconst VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.VideoQuality\", [\n    {\n        no: 0,\n        name: \"LOW\"\n    },\n    {\n        no: 1,\n        name: \"MEDIUM\"\n    },\n    {\n        no: 2,\n        name: \"HIGH\"\n    },\n    {\n        no: 3,\n        name: \"OFF\"\n    }\n]);\nconst ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.ConnectionQuality\", [\n    {\n        no: 0,\n        name: \"POOR\"\n    },\n    {\n        no: 1,\n        name: \"GOOD\"\n    },\n    {\n        no: 2,\n        name: \"EXCELLENT\"\n    },\n    {\n        no: 3,\n        name: \"LOST\"\n    }\n]);\nconst ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum(\"livekit.ClientConfigSetting\", [\n    {\n        no: 0,\n        name: \"UNSET\"\n    },\n    {\n        no: 1,\n        name: \"DISABLED\"\n    },\n    {\n        no: 2,\n        name: \"ENABLED\"\n    }\n]);\nconst DisconnectReason = /* @__PURE__ */ proto3.makeEnum(\"livekit.DisconnectReason\", [\n    {\n        no: 0,\n        name: \"UNKNOWN_REASON\"\n    },\n    {\n        no: 1,\n        name: \"CLIENT_INITIATED\"\n    },\n    {\n        no: 2,\n        name: \"DUPLICATE_IDENTITY\"\n    },\n    {\n        no: 3,\n        name: \"SERVER_SHUTDOWN\"\n    },\n    {\n        no: 4,\n        name: \"PARTICIPANT_REMOVED\"\n    },\n    {\n        no: 5,\n        name: \"ROOM_DELETED\"\n    },\n    {\n        no: 6,\n        name: \"STATE_MISMATCH\"\n    },\n    {\n        no: 7,\n        name: \"JOIN_FAILURE\"\n    },\n    {\n        no: 8,\n        name: \"MIGRATION\"\n    },\n    {\n        no: 9,\n        name: \"SIGNAL_CLOSE\"\n    },\n    {\n        no: 10,\n        name: \"ROOM_CLOSED\"\n    },\n    {\n        no: 11,\n        name: \"USER_UNAVAILABLE\"\n    },\n    {\n        no: 12,\n        name: \"USER_REJECTED\"\n    },\n    {\n        no: 13,\n        name: \"SIP_TRUNK_FAILURE\"\n    }\n]);\nconst ReconnectReason = /* @__PURE__ */ proto3.makeEnum(\"livekit.ReconnectReason\", [\n    {\n        no: 0,\n        name: \"RR_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"RR_SIGNAL_DISCONNECTED\"\n    },\n    {\n        no: 2,\n        name: \"RR_PUBLISHER_FAILED\"\n    },\n    {\n        no: 3,\n        name: \"RR_SUBSCRIBER_FAILED\"\n    },\n    {\n        no: 4,\n        name: \"RR_SWITCH_CANDIDATE\"\n    }\n]);\nconst SubscriptionError = /* @__PURE__ */ proto3.makeEnum(\"livekit.SubscriptionError\", [\n    {\n        no: 0,\n        name: \"SE_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"SE_CODEC_UNSUPPORTED\"\n    },\n    {\n        no: 2,\n        name: \"SE_TRACK_NOTFOUND\"\n    }\n]);\nconst AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum(\"livekit.AudioTrackFeature\", [\n    {\n        no: 0,\n        name: \"TF_STEREO\"\n    },\n    {\n        no: 1,\n        name: \"TF_NO_DTX\"\n    },\n    {\n        no: 2,\n        name: \"TF_AUTO_GAIN_CONTROL\"\n    },\n    {\n        no: 3,\n        name: \"TF_ECHO_CANCELLATION\"\n    },\n    {\n        no: 4,\n        name: \"TF_NOISE_SUPPRESSION\"\n    },\n    {\n        no: 5,\n        name: \"TF_ENHANCED_NOISE_CANCELLATION\"\n    }\n]);\nconst Room$1 = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Room\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 14,\n            name: \"departure_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"creation_time\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 15,\n            name: \"creation_time_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 6,\n            name: \"turn_password\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"enabled_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"num_participants\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 11,\n            name: \"num_publishers\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 10,\n            name: \"active_recording\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 13,\n            name: \"version\",\n            kind: \"message\",\n            T: TimedVersion\n        }\n    ]);\nconst Codec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Codec\", ()=>[\n        {\n            no: 1,\n            name: \"mime\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"fmtp_line\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantPermission\", ()=>[\n        {\n            no: 1,\n            name: \"can_subscribe\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"can_publish\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"can_publish_data\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 9,\n            name: \"can_publish_sources\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"hidden\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"recorder\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 10,\n            name: \"can_update_metadata\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 11,\n            name: \"agent\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 12,\n            name: \"can_subscribe_metrics\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: \"tracks\",\n            kind: \"message\",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"joined_at\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 17,\n            name: \"joined_at_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 9,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 11,\n            name: \"permission\",\n            kind: \"message\",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 13,\n            name: \"is_publisher\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 14,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_Kind)\n        },\n        {\n            no: 15,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 16,\n            name: \"disconnect_reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        },\n        {\n            no: 18,\n            name: \"kind_details\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_KindDetail),\n            repeated: true\n        }\n    ]);\nconst ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.State\", [\n    {\n        no: 0,\n        name: \"JOINING\"\n    },\n    {\n        no: 1,\n        name: \"JOINED\"\n    },\n    {\n        no: 2,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 3,\n        name: \"DISCONNECTED\"\n    }\n]);\nconst ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.Kind\", [\n    {\n        no: 0,\n        name: \"STANDARD\"\n    },\n    {\n        no: 1,\n        name: \"INGRESS\"\n    },\n    {\n        no: 2,\n        name: \"EGRESS\"\n    },\n    {\n        no: 3,\n        name: \"SIP\"\n    },\n    {\n        no: 4,\n        name: \"AGENT\"\n    }\n]);\nconst ParticipantInfo_KindDetail = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.KindDetail\", [\n    {\n        no: 0,\n        name: \"CLOUD_AGENT\"\n    },\n    {\n        no: 1,\n        name: \"FORWARDED\"\n    }\n]);\nconst Encryption_Type = /* @__PURE__ */ proto3.makeEnum(\"livekit.Encryption.Type\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GCM\"\n    },\n    {\n        no: 2,\n        name: \"CUSTOM\"\n    }\n]);\nconst SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulcastCodecInfo\", ()=>[\n        {\n            no: 1,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\nconst TrackInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 7,\n            name: \"simulcast\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 9,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 12,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 13,\n            name: \"codecs\",\n            kind: \"message\",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 15,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 16,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 18,\n            name: \"version\",\n            kind: \"message\",\n            T: TimedVersion\n        },\n        {\n            no: 19,\n            name: \"audio_features\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioTrackFeature),\n            repeated: true\n        },\n        {\n            no: 20,\n            name: \"backup_codec_policy\",\n            kind: \"enum\",\n            T: proto3.getEnumType(BackupCodecPolicy$1)\n        }\n    ]);\nconst VideoLayer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.VideoLayer\", ()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"ssrc\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst DataPacket = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataPacket\", ()=>[\n        {\n            no: 1,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"speaker\",\n            kind: \"message\",\n            T: ActiveSpeakerUpdate,\n            oneof: \"value\"\n        },\n        {\n            no: 6,\n            name: \"sip_dtmf\",\n            kind: \"message\",\n            T: SipDTMF,\n            oneof: \"value\"\n        },\n        {\n            no: 7,\n            name: \"transcription\",\n            kind: \"message\",\n            T: Transcription,\n            oneof: \"value\"\n        },\n        {\n            no: 8,\n            name: \"metrics\",\n            kind: \"message\",\n            T: MetricsBatch,\n            oneof: \"value\"\n        },\n        {\n            no: 9,\n            name: \"chat_message\",\n            kind: \"message\",\n            T: ChatMessage,\n            oneof: \"value\"\n        },\n        {\n            no: 10,\n            name: \"rpc_request\",\n            kind: \"message\",\n            T: RpcRequest,\n            oneof: \"value\"\n        },\n        {\n            no: 11,\n            name: \"rpc_ack\",\n            kind: \"message\",\n            T: RpcAck,\n            oneof: \"value\"\n        },\n        {\n            no: 12,\n            name: \"rpc_response\",\n            kind: \"message\",\n            T: RpcResponse,\n            oneof: \"value\"\n        },\n        {\n            no: 13,\n            name: \"stream_header\",\n            kind: \"message\",\n            T: DataStream_Header,\n            oneof: \"value\"\n        },\n        {\n            no: 14,\n            name: \"stream_chunk\",\n            kind: \"message\",\n            T: DataStream_Chunk,\n            oneof: \"value\"\n        },\n        {\n            no: 15,\n            name: \"stream_trailer\",\n            kind: \"message\",\n            T: DataStream_Trailer,\n            oneof: \"value\"\n        }\n    ]);\nconst DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum(\"livekit.DataPacket.Kind\", [\n    {\n        no: 0,\n        name: \"RELIABLE\"\n    },\n    {\n        no: 1,\n        name: \"LOSSY\"\n    }\n]);\nconst ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ActiveSpeakerUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\nconst SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SpeakerInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"level\",\n            kind: \"scalar\",\n            T: 2\n        },\n        {\n            no: 3,\n            name: \"active\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst UserPacket = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UserPacket\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 3,\n            name: \"destination_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 8,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 9,\n            name: \"start_time\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 10,\n            name: \"end_time\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 11,\n            name: \"nonce\",\n            kind: \"scalar\",\n            T: 12\n        }\n    ]);\nconst SipDTMF = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SipDTMF\", ()=>[\n        {\n            no: 3,\n            name: \"code\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"digit\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst Transcription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Transcription\", ()=>[\n        {\n            no: 2,\n            name: \"transcribed_participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"track_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"segments\",\n            kind: \"message\",\n            T: TranscriptionSegment,\n            repeated: true\n        }\n    ]);\nconst TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TranscriptionSegment\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"text\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"start_time\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 4,\n            name: \"end_time\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 5,\n            name: \"final\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 6,\n            name: \"language\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ChatMessage = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ChatMessage\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 3,\n            name: \"edit_timestamp\",\n            kind: \"scalar\",\n            T: 3,\n            opt: true\n        },\n        {\n            no: 4,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"deleted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 6,\n            name: \"generated\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst RpcRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcRequest\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"method\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"response_timeout_ms\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst RpcAck = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcAck\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst RpcResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcResponse\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 9,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"error\",\n            kind: \"message\",\n            T: RpcError$1,\n            oneof: \"value\"\n        }\n    ]);\nconst RpcError$1 = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcError\", ()=>[\n        {\n            no: 1,\n            name: \"code\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"data\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantTracks\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        }\n    ]);\nconst ServerInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ServerInfo\", ()=>[\n        {\n            no: 1,\n            name: \"edition\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"node_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"debug_info\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"agent_protocol\",\n            kind: \"scalar\",\n            T: 5\n        }\n    ]);\nconst ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum(\"livekit.ServerInfo.Edition\", [\n    {\n        no: 0,\n        name: \"Standard\"\n    },\n    {\n        no: 1,\n        name: \"Cloud\"\n    }\n]);\nconst ClientInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ClientInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sdk\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"os\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"os_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"device_model\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"browser\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 8,\n            name: \"browser_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"address\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"network\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 11,\n            name: \"other_sdks\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum(\"livekit.ClientInfo.SDK\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"JS\"\n    },\n    {\n        no: 2,\n        name: \"SWIFT\"\n    },\n    {\n        no: 3,\n        name: \"ANDROID\"\n    },\n    {\n        no: 4,\n        name: \"FLUTTER\"\n    },\n    {\n        no: 5,\n        name: \"GO\"\n    },\n    {\n        no: 6,\n        name: \"UNITY\"\n    },\n    {\n        no: 7,\n        name: \"REACT_NATIVE\"\n    },\n    {\n        no: 8,\n        name: \"RUST\"\n    },\n    {\n        no: 9,\n        name: \"PYTHON\"\n    },\n    {\n        no: 10,\n        name: \"CPP\"\n    },\n    {\n        no: 11,\n        name: \"UNITY_WEB\"\n    },\n    {\n        no: 12,\n        name: \"NODE\"\n    }\n]);\nconst ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ClientConfiguration\", ()=>[\n        {\n            no: 1,\n            name: \"video\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: \"screen\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: \"resume_connection\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: \"disabled_codecs\",\n            kind: \"message\",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: \"force_relay\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\nconst VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType(\"livekit.VideoConfiguration\", ()=>[\n        {\n            no: 1,\n            name: \"hardware_encoder\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\nconst DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DisabledCodecs\", ()=>[\n        {\n            no: 1,\n            name: \"codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"publish\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        }\n    ]);\nconst TimedVersion = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TimedVersion\", ()=>[\n        {\n            no: 1,\n            name: \"unix_micro\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"ticks\",\n            kind: \"scalar\",\n            T: 5\n        }\n    ]);\nconst DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum(\"livekit.DataStream.OperationType\", [\n    {\n        no: 0,\n        name: \"CREATE\"\n    },\n    {\n        no: 1,\n        name: \"UPDATE\"\n    },\n    {\n        no: 2,\n        name: \"DELETE\"\n    },\n    {\n        no: 3,\n        name: \"REACTION\"\n    }\n]);\nconst DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.TextHeader\", ()=>[\n        {\n            no: 1,\n            name: \"operation_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataStream_OperationType)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 3,\n            name: \"reply_to_stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"attached_stream_ids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"generated\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ], {\n    localName: \"DataStream_TextHeader\"\n});\nconst DataStream_ByteHeader = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.ByteHeader\", ()=>[\n        {\n            no: 1,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ], {\n    localName: \"DataStream_ByteHeader\"\n});\nconst DataStream_Header = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Header\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 3,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"total_length\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 7,\n            name: \"encryption_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 8,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 9,\n            name: \"text_header\",\n            kind: \"message\",\n            T: DataStream_TextHeader,\n            oneof: \"content_header\"\n        },\n        {\n            no: 10,\n            name: \"byte_header\",\n            kind: \"message\",\n            T: DataStream_ByteHeader,\n            oneof: \"content_header\"\n        }\n    ], {\n    localName: \"DataStream_Header\"\n});\nconst DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Chunk\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"chunk_index\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 3,\n            name: \"content\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 4,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 5,\n            name: \"iv\",\n            kind: \"scalar\",\n            T: 12,\n            opt: true\n        }\n    ], {\n    localName: \"DataStream_Chunk\"\n});\nconst DataStream_Trailer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Trailer\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        }\n    ], {\n    localName: \"DataStream_Trailer\"\n});\nconst SignalTarget = /* @__PURE__ */ proto3.makeEnum(\"livekit.SignalTarget\", [\n    {\n        no: 0,\n        name: \"PUBLISHER\"\n    },\n    {\n        no: 1,\n        name: \"SUBSCRIBER\"\n    }\n]);\nconst StreamState = /* @__PURE__ */ proto3.makeEnum(\"livekit.StreamState\", [\n    {\n        no: 0,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 1,\n        name: \"PAUSED\"\n    }\n]);\nconst CandidateProtocol = /* @__PURE__ */ proto3.makeEnum(\"livekit.CandidateProtocol\", [\n    {\n        no: 0,\n        name: \"UDP\"\n    },\n    {\n        no: 1,\n        name: \"TCP\"\n    },\n    {\n        no: 2,\n        name: \"TLS\"\n    }\n]);\nconst SignalRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SignalRequest\", ()=>[\n        {\n            no: 1,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription,\n            oneof: \"message\"\n        },\n        {\n            no: 7,\n            name: \"track_setting\",\n            kind: \"message\",\n            T: UpdateTrackSettings,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"update_layers\",\n            kind: \"message\",\n            T: UpdateVideoLayers,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"subscription_permission\",\n            kind: \"message\",\n            T: SubscriptionPermission,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"simulate\",\n            kind: \"message\",\n            T: SimulateScenario,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"ping\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"ping_req\",\n            kind: \"message\",\n            T: Ping,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"update_audio_track\",\n            kind: \"message\",\n            T: UpdateLocalAudioTrack,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"update_video_track\",\n            kind: \"message\",\n            T: UpdateLocalVideoTrack,\n            oneof: \"message\"\n        }\n    ]);\nconst SignalResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SignalResponse\", ()=>[\n        {\n            no: 1,\n            name: \"join\",\n            kind: \"message\",\n            T: JoinResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"update\",\n            kind: \"message\",\n            T: ParticipantUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"track_published\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 9,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"speakers_changed\",\n            kind: \"message\",\n            T: SpeakersChanged,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"room_update\",\n            kind: \"message\",\n            T: RoomUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"connection_quality\",\n            kind: \"message\",\n            T: ConnectionQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"stream_state_update\",\n            kind: \"message\",\n            T: StreamStateUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"subscribed_quality_update\",\n            kind: \"message\",\n            T: SubscribedQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"subscription_permission_update\",\n            kind: \"message\",\n            T: SubscriptionPermissionUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"refresh_token\",\n            kind: \"scalar\",\n            T: 9,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"track_unpublished\",\n            kind: \"message\",\n            T: TrackUnpublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"pong\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"message\"\n        },\n        {\n            no: 19,\n            name: \"reconnect\",\n            kind: \"message\",\n            T: ReconnectResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 20,\n            name: \"pong_resp\",\n            kind: \"message\",\n            T: Pong,\n            oneof: \"message\"\n        },\n        {\n            no: 21,\n            name: \"subscription_response\",\n            kind: \"message\",\n            T: SubscriptionResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 22,\n            name: \"request_response\",\n            kind: \"message\",\n            T: RequestResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 23,\n            name: \"track_subscribed\",\n            kind: \"message\",\n            T: TrackSubscribed,\n            oneof: \"message\"\n        }\n    ]);\nconst SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulcastCodec\", ()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.AddTrackRequest\", ()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 7,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"simulcast_codecs\",\n            kind: \"message\",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 12,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 13,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 14,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 16,\n            name: \"backup_codec_policy\",\n            kind: \"enum\",\n            T: proto3.getEnumType(BackupCodecPolicy$1)\n        }\n    ]);\nconst TrickleRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrickleRequest\", ()=>[\n        {\n            no: 1,\n            name: \"candidateInit\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        },\n        {\n            no: 3,\n            name: \"final\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MuteTrackRequest\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst JoinResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.JoinResponse\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"server_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"subscriber_primary\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 7,\n            name: \"alternative_url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 8,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: \"server_region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"ping_timeout\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 11,\n            name: \"ping_interval\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 12,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: \"sif_trailer\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 14,\n            name: \"enabled_publish_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 15,\n            name: \"fast_publish\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ReconnectResponse\", ()=>[\n        {\n            no: 1,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        }\n    ]);\nconst TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackPublishedResponse\", ()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track\",\n            kind: \"message\",\n            T: TrackInfo\n        }\n    ]);\nconst TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackUnpublishedResponse\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SessionDescription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SessionDescription\", ()=>[\n        {\n            no: 1,\n            name: \"type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"sdp\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\nconst UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateSubscription\", ()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"subscribe\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"participant_tracks\",\n            kind: \"message\",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\nconst UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateTrackSettings\", ()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"disabled\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 4,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 7,\n            name: \"fps\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 8,\n            name: \"priority\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateLocalAudioTrack\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"features\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioTrackFeature),\n            repeated: true\n        }\n    ]);\nconst UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateLocalVideoTrack\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst LeaveRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.LeaveRequest\", ()=>[\n        {\n            no: 1,\n            name: \"can_reconnect\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        },\n        {\n            no: 3,\n            name: \"action\",\n            kind: \"enum\",\n            T: proto3.getEnumType(LeaveRequest_Action)\n        },\n        {\n            no: 4,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionSettings\n        }\n    ]);\nconst LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum(\"livekit.LeaveRequest.Action\", [\n    {\n        no: 0,\n        name: \"DISCONNECT\"\n    },\n    {\n        no: 1,\n        name: \"RESUME\"\n    },\n    {\n        no: 2,\n        name: \"RECONNECT\"\n    }\n]);\nconst UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateVideoLayers\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\nconst UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateParticipantMetadata\", ()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 4,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst ICEServer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ICEServer\", ()=>[\n        {\n            no: 1,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"credential\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SpeakersChanged\", ()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\nconst RoomUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        }\n    ]);\nconst ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ConnectionQualityInfo\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 2\n        }\n    ]);\nconst ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ConnectionQualityUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"updates\",\n            kind: \"message\",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\nconst StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.StreamStateInfo\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\nconst StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.StreamStateUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"stream_states\",\n            kind: \"message\",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\nconst SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedQuality\", ()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedCodec\", ()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\nconst SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedQualityUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"subscribed_qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"subscribed_codecs\",\n            kind: \"message\",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\nconst TrackPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackPermission\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"all_tracks\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionPermission\", ()=>[\n        {\n            no: 1,\n            name: \"all_participants\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"track_permissions\",\n            kind: \"message\",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\nconst SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionPermissionUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"allowed\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst SyncState = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SyncState\", ()=>[\n        {\n            no: 1,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: \"publish_tracks\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"data_channels\",\n            kind: \"message\",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 6,\n            name: \"track_sids_disabled\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        }\n    ]);\nconst DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataChannelInfo\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\nconst SimulateScenario = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulateScenario\", ()=>[\n        {\n            no: 1,\n            name: \"speaker_update\",\n            kind: \"scalar\",\n            T: 5,\n            oneof: \"scenario\"\n        },\n        {\n            no: 2,\n            name: \"node_failure\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 3,\n            name: \"migration\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 4,\n            name: \"server_leave\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 5,\n            name: \"switch_candidate_protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: \"scenario\"\n        },\n        {\n            no: 6,\n            name: \"subscriber_bandwidth\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"scenario\"\n        },\n        {\n            no: 7,\n            name: \"disconnect_signal_on_resume\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 8,\n            name: \"disconnect_signal_on_resume_no_messages\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 9,\n            name: \"leave_request_full_reconnect\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        }\n    ]);\nconst Ping = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Ping\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"rtt\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst Pong = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Pong\", ()=>[\n        {\n            no: 1,\n            name: \"last_ping_timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst RegionSettings = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RegionSettings\", ()=>[\n        {\n            no: 1,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\nconst RegionInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RegionInfo\", ()=>[\n        {\n            no: 1,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"distance\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionResponse\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"err\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nconst RequestResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RequestResponse\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(RequestResponse_Reason)\n        },\n        {\n            no: 3,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum(\"livekit.RequestResponse.Reason\", [\n    {\n        no: 0,\n        name: \"OK\"\n    },\n    {\n        no: 1,\n        name: \"NOT_FOUND\"\n    },\n    {\n        no: 2,\n        name: \"NOT_ALLOWED\"\n    },\n    {\n        no: 3,\n        name: \"LIMIT_EXCEEDED\"\n    }\n]);\nconst TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackSubscribed\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar loglevel$1 = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ var loglevel = loglevel$1.exports;\nvar hasRequiredLoglevel;\nfunction requireLoglevel() {\n    if (hasRequiredLoglevel) return loglevel$1.exports;\n    hasRequiredLoglevel = 1;\n    (function(module) {\n        (function(root, definition) {\n            if (module.exports) {\n                module.exports = definition();\n            } else {\n                root.log = definition();\n            }\n        })(loglevel, function() {\n            // Slightly dubious tricks to cut down minimized file size\n            var noop = function() {};\n            var undefinedType = \"undefined\";\n            var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n            var logMethods = [\n                \"trace\",\n                \"debug\",\n                \"info\",\n                \"warn\",\n                \"error\"\n            ];\n            var _loggersByName = {};\n            var defaultLogger = null;\n            // Cross-browser bind equivalent that works at least back to IE6\n            function bindMethod(obj, methodName) {\n                var method = obj[methodName];\n                if (typeof method.bind === \"function\") {\n                    return method.bind(obj);\n                } else {\n                    try {\n                        return Function.prototype.bind.call(method, obj);\n                    } catch (e) {\n                        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                        return function() {\n                            return Function.prototype.apply.apply(method, [\n                                obj,\n                                arguments\n                            ]);\n                        };\n                    }\n                }\n            }\n            // Trace() doesn't print the message in IE, so for that case we need to wrap it\n            function traceForIE() {\n                if (console.log) {\n                    if (console.log.apply) {\n                        console.log.apply(console, arguments);\n                    } else {\n                        // In old IE, native console methods themselves don't have apply().\n                        Function.prototype.apply.apply(console.log, [\n                            console,\n                            arguments\n                        ]);\n                    }\n                }\n                if (console.trace) console.trace();\n            }\n            // Build the best logging method possible for this env\n            // Wherever possible we want to bind, not wrap, to preserve stack traces\n            function realMethod(methodName) {\n                if (methodName === \"debug\") {\n                    methodName = \"log\";\n                }\n                if (typeof console === undefinedType) {\n                    return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n                } else if (methodName === \"trace\" && isIE) {\n                    return traceForIE;\n                } else if (console[methodName] !== undefined) {\n                    return bindMethod(console, methodName);\n                } else if (console.log !== undefined) {\n                    return bindMethod(console, \"log\");\n                } else {\n                    return noop;\n                }\n            }\n            // These private functions always need `this` to be set properly\n            function replaceLoggingMethods() {\n                /*jshint validthis:true */ var level = this.getLevel();\n                // Replace the actual methods.\n                for(var i = 0; i < logMethods.length; i++){\n                    var methodName = logMethods[i];\n                    this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n                }\n                // Define log.log as an alias for log.debug\n                this.log = this.debug;\n                // Return any important warnings.\n                if (typeof console === undefinedType && level < this.levels.SILENT) {\n                    return \"No console available for logging\";\n                }\n            }\n            // In old IE versions, the console isn't present until you first open it.\n            // We build realMethod() replacements here that regenerate logging methods\n            function enableLoggingWhenConsoleArrives(methodName) {\n                return function() {\n                    if (typeof console !== undefinedType) {\n                        replaceLoggingMethods.call(this);\n                        this[methodName].apply(this, arguments);\n                    }\n                };\n            }\n            // By default, we use closely bound real methods wherever possible, and\n            // otherwise we wait for a console to appear, and then try again.\n            function defaultMethodFactory(methodName, _level, _loggerName) {\n                /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n            }\n            function Logger(name, factory) {\n                // Private instance variables.\n                var self = this;\n                /**\n         * The level inherited from a parent logger (or a global default). We\n         * cache this here rather than delegating to the parent so that it stays\n         * in sync with the actual logging methods that we have installed (the\n         * parent could change levels but we might not have rebuilt the loggers\n         * in this child yet).\n         * @type {number}\n         */ var inheritedLevel;\n                /**\n         * The default level for this logger, if any. If set, this overrides\n         * `inheritedLevel`.\n         * @type {number|null}\n         */ var defaultLevel;\n                /**\n         * A user-specific level for this logger. If set, this overrides\n         * `defaultLevel`.\n         * @type {number|null}\n         */ var userLevel;\n                var storageKey = \"loglevel\";\n                if (typeof name === \"string\") {\n                    storageKey += \":\" + name;\n                } else if (typeof name === \"symbol\") {\n                    storageKey = undefined;\n                }\n                function persistLevelIfPossible(levelNum) {\n                    var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    // Use localStorage if available\n                    try {\n                        window.localStorage[storageKey] = levelName;\n                        return;\n                    } catch (ignore) {}\n                    // Use session cookie as fallback\n                    try {\n                        window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n                    } catch (ignore) {}\n                }\n                function getPersistedLevel() {\n                    var storedLevel;\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    try {\n                        storedLevel = window.localStorage[storageKey];\n                    } catch (ignore) {}\n                    // Fallback to cookies if local storage gives us nothing\n                    if (typeof storedLevel === undefinedType) {\n                        try {\n                            var cookie = window.document.cookie;\n                            var cookieName = encodeURIComponent(storageKey);\n                            var location = cookie.indexOf(cookieName + \"=\");\n                            if (location !== -1) {\n                                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n                            }\n                        } catch (ignore) {}\n                    }\n                    // If the stored level is not valid, treat it as if nothing was stored.\n                    if (self.levels[storedLevel] === undefined) {\n                        storedLevel = undefined;\n                    }\n                    return storedLevel;\n                }\n                function clearPersistedLevel() {\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    // Use localStorage if available\n                    try {\n                        window.localStorage.removeItem(storageKey);\n                    } catch (ignore) {}\n                    // Use session cookie as fallback\n                    try {\n                        window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n                    } catch (ignore) {}\n                }\n                function normalizeLevel(input) {\n                    var level = input;\n                    if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                        level = self.levels[level.toUpperCase()];\n                    }\n                    if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                        return level;\n                    } else {\n                        throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n                    }\n                }\n                /*\n         *\n         * Public logger API - see https://github.com/pimterry/loglevel for details\n         *\n         */ self.name = name;\n                self.levels = {\n                    \"TRACE\": 0,\n                    \"DEBUG\": 1,\n                    \"INFO\": 2,\n                    \"WARN\": 3,\n                    \"ERROR\": 4,\n                    \"SILENT\": 5\n                };\n                self.methodFactory = factory || defaultMethodFactory;\n                self.getLevel = function() {\n                    if (userLevel != null) {\n                        return userLevel;\n                    } else if (defaultLevel != null) {\n                        return defaultLevel;\n                    } else {\n                        return inheritedLevel;\n                    }\n                };\n                self.setLevel = function(level, persist) {\n                    userLevel = normalizeLevel(level);\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(userLevel);\n                    }\n                    // NOTE: in v2, this should call rebuild(), which updates children.\n                    return replaceLoggingMethods.call(self);\n                };\n                self.setDefaultLevel = function(level) {\n                    defaultLevel = normalizeLevel(level);\n                    if (!getPersistedLevel()) {\n                        self.setLevel(level, false);\n                    }\n                };\n                self.resetLevel = function() {\n                    userLevel = null;\n                    clearPersistedLevel();\n                    replaceLoggingMethods.call(self);\n                };\n                self.enableAll = function(persist) {\n                    self.setLevel(self.levels.TRACE, persist);\n                };\n                self.disableAll = function(persist) {\n                    self.setLevel(self.levels.SILENT, persist);\n                };\n                self.rebuild = function() {\n                    if (defaultLogger !== self) {\n                        inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n                    }\n                    replaceLoggingMethods.call(self);\n                    if (defaultLogger === self) {\n                        for(var childName in _loggersByName){\n                            _loggersByName[childName].rebuild();\n                        }\n                    }\n                };\n                // Initialize all the internal levels.\n                inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n                var initialLevel = getPersistedLevel();\n                if (initialLevel != null) {\n                    userLevel = normalizeLevel(initialLevel);\n                }\n                replaceLoggingMethods.call(self);\n            }\n            /*\n       *\n       * Top-level API\n       *\n       */ defaultLogger = new Logger();\n            defaultLogger.getLogger = function getLogger(name) {\n                if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n                    throw new TypeError(\"You must supply a name when creating a logger.\");\n                }\n                var logger = _loggersByName[name];\n                if (!logger) {\n                    logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n                }\n                return logger;\n            };\n            // Grab the current global log variable in case of overwrite\n            var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n            defaultLogger.noConflict = function() {\n                if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n                    window.log = _log;\n                }\n                return defaultLogger;\n            };\n            defaultLogger.getLoggers = function getLoggers() {\n                return _loggersByName;\n            };\n            // ES6 default export, for compatibility\n            defaultLogger[\"default\"] = defaultLogger;\n            return defaultLogger;\n        });\n    })(loglevel$1);\n    return loglevel$1.exports;\n}\nvar loglevelExports = requireLoglevel();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n    LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n    LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n    LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n    LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n    LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(LoggerNames) {\n    LoggerNames[\"Default\"] = \"livekit\";\n    LoggerNames[\"Room\"] = \"livekit-room\";\n    LoggerNames[\"Participant\"] = \"livekit-participant\";\n    LoggerNames[\"Track\"] = \"livekit-track\";\n    LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n    LoggerNames[\"Engine\"] = \"livekit-engine\";\n    LoggerNames[\"Signal\"] = \"livekit-signal\";\n    LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n    LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n    LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger(\"livekit\");\nconst livekitLoggers = Object.values(LoggerNames).map((name)=>loglevelExports.getLogger(name));\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */ function getLogger(name) {\n    const logger = loglevelExports.getLogger(name);\n    logger.setDefaultLevel(livekitLogger.getLevel());\n    return logger;\n}\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    } else {\n        for (const logger of livekitLoggers){\n            logger.setLevel(level);\n        }\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension, logger) {\n    const loggers = logger ? [\n        logger\n    ] : livekitLoggers;\n    loggers.forEach((logR)=>{\n        const originalFactory = logR.methodFactory;\n        logR.methodFactory = (methodName, configLevel, loggerName)=>{\n            const rawMethod = originalFactory(methodName, configLevel, loggerName);\n            const logLevel = LogLevel[methodName];\n            const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n            return (msg, context)=>{\n                if (context) rawMethod(msg, context);\n                else rawMethod(msg);\n                if (needLog) {\n                    extension(logLevel, msg, context);\n                }\n            };\n        };\n        logR.setLevel(logR.getLevel());\n    });\n}\nconst workerLogger = loglevelExports.getLogger(\"lk-e2ee\");\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar hasRequiredEvents;\nfunction requireEvents() {\n    if (hasRequiredEvents) return events.exports;\n    hasRequiredEvents = 1;\n    var R = typeof Reflect === \"object\" ? Reflect : null;\n    var ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply(target, receiver, args) {\n        return Function.prototype.apply.call(target, receiver, args);\n    };\n    var ReflectOwnKeys;\n    if (R && typeof R.ownKeys === \"function\") {\n        ReflectOwnKeys = R.ownKeys;\n    } else if (Object.getOwnPropertySymbols) {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n        };\n    } else {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target);\n        };\n    }\n    function ProcessEmitWarning(warning) {\n        if (console && console.warn) console.warn(warning);\n    }\n    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n        return value !== value;\n    };\n    function EventEmitter() {\n        EventEmitter.init.call(this);\n    }\n    events.exports = EventEmitter;\n    events.exports.once = once;\n    // Backwards-compat with node 0.10.x\n    EventEmitter.EventEmitter = EventEmitter;\n    EventEmitter.prototype._events = undefined;\n    EventEmitter.prototype._eventsCount = 0;\n    EventEmitter.prototype._maxListeners = undefined;\n    // By default EventEmitters will print a warning if more than 10 listeners are\n    // added to it. This is a useful default which helps finding memory leaks.\n    var defaultMaxListeners = 10;\n    function checkListener(listener) {\n        if (typeof listener !== \"function\") {\n            throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n        }\n    }\n    Object.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n        enumerable: true,\n        get: function() {\n            return defaultMaxListeners;\n        },\n        set: function(arg) {\n            if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n                throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n            }\n            defaultMaxListeners = arg;\n        }\n    });\n    EventEmitter.init = function() {\n        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        }\n        this._maxListeners = this._maxListeners || undefined;\n    };\n    // Obviously not all Emitters should be limited to 10. This function allows\n    // that to be increased. Set to zero for unlimited.\n    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n            throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n        }\n        this._maxListeners = n;\n        return this;\n    };\n    function _getMaxListeners(that) {\n        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n    }\n    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return _getMaxListeners(this);\n    };\n    EventEmitter.prototype.emit = function emit(type) {\n        var args = [];\n        for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n        var doError = type === \"error\";\n        var events = this._events;\n        if (events !== undefined) doError = doError && events.error === undefined;\n        else if (!doError) return false;\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n            var er;\n            if (args.length > 0) er = args[0];\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        var handler = events[type];\n        if (handler === undefined) return false;\n        if (typeof handler === \"function\") {\n            ReflectApply(handler, this, args);\n        } else {\n            var len = handler.length;\n            var listeners = arrayClone(handler, len);\n            for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n        }\n        return true;\n    };\n    function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n        checkListener(listener);\n        events = target._events;\n        if (events === undefined) {\n            events = target._events = Object.create(null);\n            target._eventsCount = 0;\n        } else {\n            // To avoid recursion in the case that type === \"newListener\"! Before\n            // adding it to the listeners, first emit \"newListener\".\n            if (events.newListener !== undefined) {\n                target.emit(\"newListener\", type, listener.listener ? listener.listener : listener);\n                // Re-assign `events` because a newListener handler could have caused the\n                // this._events to be assigned to a new object\n                events = target._events;\n            }\n            existing = events[type];\n        }\n        if (existing === undefined) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            existing = events[type] = listener;\n            ++target._eventsCount;\n        } else {\n            if (typeof existing === \"function\") {\n                // Adding the second element, need to change to array.\n                existing = events[type] = prepend ? [\n                    listener,\n                    existing\n                ] : [\n                    existing,\n                    listener\n                ];\n            // If we've already got an array, just append.\n            } else if (prepend) {\n                existing.unshift(listener);\n            } else {\n                existing.push(listener);\n            }\n            // Check for listener leak\n            m = _getMaxListeners(target);\n            if (m > 0 && existing.length > m && !existing.warned) {\n                existing.warned = true;\n                // No error code for this since it is a Warning\n                // eslint-disable-next-line no-restricted-syntax\n                var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners \" + \"added. Use emitter.setMaxListeners() to \" + \"increase limit\");\n                w.name = \"MaxListenersExceededWarning\";\n                w.emitter = target;\n                w.type = type;\n                w.count = existing.length;\n                ProcessEmitWarning(w);\n            }\n        }\n        return target;\n    }\n    EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n    };\n    EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n    EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n    };\n    function onceWrapper() {\n        if (!this.fired) {\n            this.target.removeListener(this.type, this.wrapFn);\n            this.fired = true;\n            if (arguments.length === 0) return this.listener.call(this.target);\n            return this.listener.apply(this.target, arguments);\n        }\n    }\n    function _onceWrap(target, type, listener) {\n        var state = {\n            fired: false,\n            wrapFn: undefined,\n            target: target,\n            type: type,\n            listener: listener\n        };\n        var wrapped = onceWrapper.bind(state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n    }\n    EventEmitter.prototype.once = function once(type, listener) {\n        checkListener(listener);\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n    };\n    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n        checkListener(listener);\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n    };\n    // Emits a 'removeListener' event if and only if the listener was removed.\n    EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n        checkListener(listener);\n        events = this._events;\n        if (events === undefined) return this;\n        list = events[type];\n        if (list === undefined) return this;\n        if (list === listener || list.listener === listener) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else {\n                delete events[type];\n                if (events.removeListener) this.emit(\"removeListener\", type, list.listener || listener);\n            }\n        } else if (typeof list !== \"function\") {\n            position = -1;\n            for(i = list.length - 1; i >= 0; i--){\n                if (list[i] === listener || list[i].listener === listener) {\n                    originalListener = list[i].listener;\n                    position = i;\n                    break;\n                }\n            }\n            if (position < 0) return this;\n            if (position === 0) list.shift();\n            else {\n                spliceOne(list, position);\n            }\n            if (list.length === 1) events[type] = list[0];\n            if (events.removeListener !== undefined) this.emit(\"removeListener\", type, originalListener || listener);\n        }\n        return this;\n    };\n    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n        var listeners, events, i;\n        events = this._events;\n        if (events === undefined) return this;\n        // not listening for removeListener, no need to emit\n        if (events.removeListener === undefined) {\n            if (arguments.length === 0) {\n                this._events = Object.create(null);\n                this._eventsCount = 0;\n            } else if (events[type] !== undefined) {\n                if (--this._eventsCount === 0) this._events = Object.create(null);\n                else delete events[type];\n            }\n            return this;\n        }\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n            var keys = Object.keys(events);\n            var key;\n            for(i = 0; i < keys.length; ++i){\n                key = keys[i];\n                if (key === \"removeListener\") continue;\n                this.removeAllListeners(key);\n            }\n            this.removeAllListeners(\"removeListener\");\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n            return this;\n        }\n        listeners = events[type];\n        if (typeof listeners === \"function\") {\n            this.removeListener(type, listeners);\n        } else if (listeners !== undefined) {\n            // LIFO order\n            for(i = listeners.length - 1; i >= 0; i--){\n                this.removeListener(type, listeners[i]);\n            }\n        }\n        return this;\n    };\n    function _listeners(target, type, unwrap) {\n        var events = target._events;\n        if (events === undefined) return [];\n        var evlistener = events[type];\n        if (evlistener === undefined) return [];\n        if (typeof evlistener === \"function\") return unwrap ? [\n            evlistener.listener || evlistener\n        ] : [\n            evlistener\n        ];\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n    }\n    EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n    };\n    EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n    };\n    EventEmitter.listenerCount = function(emitter, type) {\n        if (typeof emitter.listenerCount === \"function\") {\n            return emitter.listenerCount(type);\n        } else {\n            return listenerCount.call(emitter, type);\n        }\n    };\n    EventEmitter.prototype.listenerCount = listenerCount;\n    function listenerCount(type) {\n        var events = this._events;\n        if (events !== undefined) {\n            var evlistener = events[type];\n            if (typeof evlistener === \"function\") {\n                return 1;\n            } else if (evlistener !== undefined) {\n                return evlistener.length;\n            }\n        }\n        return 0;\n    }\n    EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n    };\n    function arrayClone(arr, n) {\n        var copy = new Array(n);\n        for(var i = 0; i < n; ++i)copy[i] = arr[i];\n        return copy;\n    }\n    function spliceOne(list, index) {\n        for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n        list.pop();\n    }\n    function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n        for(var i = 0; i < ret.length; ++i){\n            ret[i] = arr[i].listener || arr[i];\n        }\n        return ret;\n    }\n    function once(emitter, name) {\n        return new Promise(function(resolve, reject) {\n            function errorListener(err) {\n                emitter.removeListener(name, resolver);\n                reject(err);\n            }\n            function resolver() {\n                if (typeof emitter.removeListener === \"function\") {\n                    emitter.removeListener(\"error\", errorListener);\n                }\n                resolve([].slice.call(arguments));\n            }\n            eventTargetAgnosticAddListener(emitter, name, resolver, {\n                once: true\n            });\n            if (name !== \"error\") {\n                addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                    once: true\n                });\n            }\n        });\n    }\n    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n        if (typeof emitter.on === \"function\") {\n            eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n        }\n    }\n    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n        if (typeof emitter.on === \"function\") {\n            if (flags.once) {\n                emitter.once(name, listener);\n            } else {\n                emitter.on(name, listener);\n            }\n        } else if (typeof emitter.addEventListener === \"function\") {\n            // EventTarget does not have `error` event semantics like Node\n            // EventEmitters, we do not listen for `error` events here.\n            emitter.addEventListener(name, function wrapListener(arg) {\n                // IE does not have builtin `{ once: true }` support so we\n                // have to do it manually.\n                if (flags.once) {\n                    emitter.removeEventListener(name, wrapListener);\n                }\n                listener(arg);\n            });\n        } else {\n            throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n        }\n    }\n    return events.exports;\n}\nvar eventsExports = requireEvents();\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n        get () {\n            return this[\"_on\" + eventNameToWrap];\n        },\n        set (cb) {\n            if (this[\"_on\" + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]);\n                delete this[\"_on\" + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    logDisabled_ = bool;\n    return bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\";\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    deprecationWarnings_ = !bool;\n    return \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\");\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it's not a browser\n    if (typeof window1 === \"undefined\" || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = \"Not a browser.\";\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    // Prefer navigator.userAgentData.\n    if (navigator1.userAgentData && navigator1.userAgentData.brands) {\n        const chromium = navigator1.userAgentData.brands.find((brand)=>{\n            return brand.brand === \"Chromium\";\n        });\n        if (chromium) {\n            return {\n                browser: \"chrome\",\n                version: parseInt(chromium.version, 10)\n            };\n        }\n    }\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = \"firefox\";\n        result.version = extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = \"chrome\";\n        result.version = extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = \"safari\";\n        result.version = extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && \"currentDirection\" in window1.RTCRtpTransceiver.prototype;\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = \"Not a supported browser.\";\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject(val) {\n    return Object.prototype.toString.call(val) === \"[object Object]\";\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */ function compactObject(data) {\n    if (!isObject(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith(\"Id\")) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith(\"Ids\")) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\";\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === \"track\" && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== \"object\" || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === \"require\" || key === \"advanced\" || key === \"mediaSource\") {\n                return;\n            }\n            const r = typeof c[key] === \"object\" ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === \"number\") {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === \"deviceId\" ? \"sourceId\" : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === \"number\") {\n                    oc[oldname_(\"min\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_(\"max\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_(\"\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== \"number\") {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_(\"\", key)] = r.exact;\n            } else {\n                [\n                    \"min\",\n                    \"max\"\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === \"object\") {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\");\n            remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === \"object\") {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === \"object\" ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === \"user\" || face.exact === \"environment\" || face.ideal === \"user\" || face.ideal === \"environment\") && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === \"environment\" || face.ideal === \"environment\") {\n                    matches = [\n                        \"back\",\n                        \"rear\"\n                    ];\n                } else if (face.exact === \"user\" || face.ideal === \"user\") {\n                    matches = [\n                        \"front\"\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === \"videoinput\");\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes(\"back\")) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging(\"chrome: \" + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging(\"chrome: \" + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: \"NotAllowedError\",\n                PermissionDismissedError: \"NotAllowedError\",\n                InvalidStateError: \"NotAllowedError\",\n                DevicesNotFoundError: \"NotFoundError\",\n                ConstraintNotSatisfiedError: \"OverconstrainedError\",\n                TrackStartError: \"NotReadableError\",\n                MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n                MediaDeviceKillSwitchOn: \"NotAllowedError\",\n                TabCaptureError: \"AbortError\",\n                ScreenCaptureError: \"AbortError\",\n                DeviceCaptureError: \"AbortError\"\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && \": \") + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException(\"\", \"NotFoundError\");\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"ontrack\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"ontrack\", {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener(\"track\", this._ontrack);\n                }\n                this.addEventListener(\"track\", this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener(\"addtrack\", (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener(\"addstream\", this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, \"transceiver\", {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"getSenders\" in window1.RTCPeerConnection.prototype) && \"createDTMFSender\" in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === \"audio\") {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === \"object\" && window1.RTCPeerConnection && \"getSenders\" in window1.RTCPeerConnection.prototype && \"createDTMFSender\" in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !(\"dtmf\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, \"dtmf\", {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === \"audio\") {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!(\"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype && \"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\"));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException(\"The adapter.js addTrack polyfill only supports a single \" + \" stream which is associated with the specified track.\", \"NotSupportedError\");\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event(\"negotiationneeded\"));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        \"createOffer\",\n        \"createAnswer\"\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === \"function\";\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, \"localDescription\");\n    Object.defineProperty(window1.RTCPeerConnection.prototype, \"localDescription\", {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === \"\") {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack \" + \"does not implement interface RTCRtpSender.\", \"TypeError\");\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event(\"negotiationneeded\"));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, \"negotiationneeded\", (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === \"plan-b\") {\n            if (pc.signalingState !== \"stable\") {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+'s deprecation warning with unprefixed version.\n        deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === \"object\" && typeof c.audio === \"object\") {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\");\n                remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\");\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, \"mozAutoGainControl\", \"autoGainControl\");\n                remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\");\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === \"audio\" && typeof c === \"object\") {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, \"autoGainControl\", \"mozAutoGainControl\");\n                    remap(c, \"noiseSuppression\", \"mozNoiseSuppression\");\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && \"getDisplayMedia\" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException(\"getDisplayMedia without video \" + \"constraints is undefined\");\n            err.name = \"NotFoundError\";\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== \"object\" || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== \"TypeError\") {\n                        throw e;\n                    }\n                    // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || \"removeStream\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated(\"removeStream\", \"removeTrack\");\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if (\"rid\" in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError(\"Invalid RID value provided.\");\n                        }\n                    }\n                    if (\"scaleResolutionDownBy\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n                        }\n                    }\n                    if (\"maxFramerate\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError(\"max_framerate must be >= 0.0\");\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!(\"encodings\" in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!(\"encodings\" in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getLocalStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!(\"addStream\" in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome's behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!(\"removeStream\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getRemoteStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!(\"onaddstream\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"onaddstream\", {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener(\"addstream\", this._onaddstream);\n                    this.removeEventListener(\"track\", this._onaddstreampoly);\n                }\n                this.addEventListener(\"addstream\", this._onaddstream = f);\n                this.addEventListener(\"track\", this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener(\"track\", this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if (\"generateCertificate\" in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, \"generateCertificate\", {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"audio\");\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === \"sendrecv\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        audioTransceiver.direction = \"sendonly\";\n                    }\n                } else if (audioTransceiver.direction === \"recvonly\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"inactive\");\n                    } else {\n                        audioTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver(\"audio\", {\n                    direction: \"recvonly\"\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"video\");\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === \"sendrecv\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        videoTransceiver.direction = \"sendonly\";\n                    }\n                } else if (videoTransceiver.direction === \"recvonly\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"inactive\");\n                    } else {\n                        videoTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver(\"video\", {\n                    direction: \"recvonly\"\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== \"object\" || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ var hasRequiredSdp;\nfunction requireSdp() {\n    if (hasRequiredSdp) return sdp$1.exports;\n    hasRequiredSdp = 1;\n    (function(module) {\n        // SDP helpers.\n        const SDPUtils = {};\n        // Generate an alphanumeric identifier for cname or mids.\n        // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n        SDPUtils.generateIdentifier = function() {\n            return Math.random().toString(36).substring(2, 12);\n        };\n        // The RTCP CNAME used by all peerconnections from the same JS.\n        SDPUtils.localCName = SDPUtils.generateIdentifier();\n        // Splits SDP into lines, dealing with both CRLF and LF.\n        SDPUtils.splitLines = function(blob) {\n            return blob.trim().split(\"\\n\").map((line)=>line.trim());\n        };\n        // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n        SDPUtils.splitSections = function(blob) {\n            const parts = blob.split(\"\\nm=\");\n            return parts.map((part, index)=>(index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\");\n        };\n        // Returns the session description.\n        SDPUtils.getDescription = function(blob) {\n            const sections = SDPUtils.splitSections(blob);\n            return sections && sections[0];\n        };\n        // Returns the individual media sections.\n        SDPUtils.getMediaSections = function(blob) {\n            const sections = SDPUtils.splitSections(blob);\n            sections.shift();\n            return sections;\n        };\n        // Returns lines that start with a certain prefix.\n        SDPUtils.matchPrefix = function(blob, prefix) {\n            return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n        };\n        // Parses an ICE candidate line. Sample input:\n        // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n        // rport 55996\"\n        // Input can be prefixed with a=.\n        SDPUtils.parseCandidate = function(line) {\n            let parts;\n            // Parse both variants.\n            if (line.indexOf(\"a=candidate:\") === 0) {\n                parts = line.substring(12).split(\" \");\n            } else {\n                parts = line.substring(10).split(\" \");\n            }\n            const candidate = {\n                foundation: parts[0],\n                component: {\n                    1: \"rtp\",\n                    2: \"rtcp\"\n                }[parts[1]] || parts[1],\n                protocol: parts[2].toLowerCase(),\n                priority: parseInt(parts[3], 10),\n                ip: parts[4],\n                address: parts[4],\n                // address is an alias for ip.\n                port: parseInt(parts[5], 10),\n                // skip parts[6] == 'typ'\n                type: parts[7]\n            };\n            for(let i = 8; i < parts.length; i += 2){\n                switch(parts[i]){\n                    case \"raddr\":\n                        candidate.relatedAddress = parts[i + 1];\n                        break;\n                    case \"rport\":\n                        candidate.relatedPort = parseInt(parts[i + 1], 10);\n                        break;\n                    case \"tcptype\":\n                        candidate.tcpType = parts[i + 1];\n                        break;\n                    case \"ufrag\":\n                        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                        candidate.usernameFragment = parts[i + 1];\n                        break;\n                    default:\n                        // extension handling, in particular ufrag. Don't overwrite.\n                        if (candidate[parts[i]] === undefined) {\n                            candidate[parts[i]] = parts[i + 1];\n                        }\n                        break;\n                }\n            }\n            return candidate;\n        };\n        // Translates a candidate object into SDP candidate attribute.\n        // This does not include the a= prefix!\n        SDPUtils.writeCandidate = function(candidate) {\n            const sdp = [];\n            sdp.push(candidate.foundation);\n            const component = candidate.component;\n            if (component === \"rtp\") {\n                sdp.push(1);\n            } else if (component === \"rtcp\") {\n                sdp.push(2);\n            } else {\n                sdp.push(component);\n            }\n            sdp.push(candidate.protocol.toUpperCase());\n            sdp.push(candidate.priority);\n            sdp.push(candidate.address || candidate.ip);\n            sdp.push(candidate.port);\n            const type = candidate.type;\n            sdp.push(\"typ\");\n            sdp.push(type);\n            if (type !== \"host\" && candidate.relatedAddress && candidate.relatedPort) {\n                sdp.push(\"raddr\");\n                sdp.push(candidate.relatedAddress);\n                sdp.push(\"rport\");\n                sdp.push(candidate.relatedPort);\n            }\n            if (candidate.tcpType && candidate.protocol.toLowerCase() === \"tcp\") {\n                sdp.push(\"tcptype\");\n                sdp.push(candidate.tcpType);\n            }\n            if (candidate.usernameFragment || candidate.ufrag) {\n                sdp.push(\"ufrag\");\n                sdp.push(candidate.usernameFragment || candidate.ufrag);\n            }\n            return \"candidate:\" + sdp.join(\" \");\n        };\n        // Parses an ice-options line, returns an array of option tags.\n        // Sample input:\n        // a=ice-options:foo bar\n        SDPUtils.parseIceOptions = function(line) {\n            return line.substring(14).split(\" \");\n        };\n        // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n        // a=rtpmap:111 opus/48000/2\n        SDPUtils.parseRtpMap = function(line) {\n            let parts = line.substring(9).split(\" \");\n            const parsed = {\n                payloadType: parseInt(parts.shift(), 10) // was: id\n            };\n            parts = parts[0].split(\"/\");\n            parsed.name = parts[0];\n            parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n            parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n            // legacy alias, got renamed back to channels in ORTC.\n            parsed.numChannels = parsed.channels;\n            return parsed;\n        };\n        // Generates a rtpmap line from RTCRtpCodecCapability or\n        // RTCRtpCodecParameters.\n        SDPUtils.writeRtpMap = function(codec) {\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            const channels = codec.channels || codec.numChannels || 1;\n            return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (channels !== 1 ? \"/\" + channels : \"\") + \"\\r\\n\";\n        };\n        // Parses a extmap line (headerextension from RFC 5285). Sample input:\n        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n        // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n        SDPUtils.parseExtmap = function(line) {\n            const parts = line.substring(9).split(\" \");\n            return {\n                id: parseInt(parts[0], 10),\n                direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n                uri: parts[1],\n                attributes: parts.slice(2).join(\" \")\n            };\n        };\n        // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n        // RTCRtpHeaderExtension.\n        SDPUtils.writeExtmap = function(headerExtension) {\n            return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== \"sendrecv\" ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + (headerExtension.attributes ? \" \" + headerExtension.attributes : \"\") + \"\\r\\n\";\n        };\n        // Parses a fmtp line, returns dictionary. Sample input:\n        // a=fmtp:96 vbr=on;cng=on\n        // Also deals with vbr=on; cng=on\n        SDPUtils.parseFmtp = function(line) {\n            const parsed = {};\n            let kv;\n            const parts = line.substring(line.indexOf(\" \") + 1).split(\";\");\n            for(let j = 0; j < parts.length; j++){\n                kv = parts[j].trim().split(\"=\");\n                parsed[kv[0].trim()] = kv[1];\n            }\n            return parsed;\n        };\n        // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n        SDPUtils.writeFmtp = function(codec) {\n            let line = \"\";\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            if (codec.parameters && Object.keys(codec.parameters).length) {\n                const params = [];\n                Object.keys(codec.parameters).forEach((param)=>{\n                    if (codec.parameters[param] !== undefined) {\n                        params.push(param + \"=\" + codec.parameters[param]);\n                    } else {\n                        params.push(param);\n                    }\n                });\n                line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n            }\n            return line;\n        };\n        // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n        // a=rtcp-fb:98 nack rpsi\n        SDPUtils.parseRtcpFb = function(line) {\n            const parts = line.substring(line.indexOf(\" \") + 1).split(\" \");\n            return {\n                type: parts.shift(),\n                parameter: parts.join(\" \")\n            };\n        };\n        // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n        SDPUtils.writeRtcpFb = function(codec) {\n            let lines = \"\";\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n                // FIXME: special handling for trr-int?\n                codec.rtcpFeedback.forEach((fb)=>{\n                    lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n                });\n            }\n            return lines;\n        };\n        // Parses a RFC 5576 ssrc media attribute. Sample input:\n        // a=ssrc:3735928559 cname:something\n        SDPUtils.parseSsrcMedia = function(line) {\n            const sp = line.indexOf(\" \");\n            const parts = {\n                ssrc: parseInt(line.substring(7, sp), 10)\n            };\n            const colon = line.indexOf(\":\", sp);\n            if (colon > -1) {\n                parts.attribute = line.substring(sp + 1, colon);\n                parts.value = line.substring(colon + 1);\n            } else {\n                parts.attribute = line.substring(sp + 1);\n            }\n            return parts;\n        };\n        // Parse a ssrc-group line (see RFC 5576). Sample input:\n        // a=ssrc-group:semantics 12 34\n        SDPUtils.parseSsrcGroup = function(line) {\n            const parts = line.substring(13).split(\" \");\n            return {\n                semantics: parts.shift(),\n                ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n            };\n        };\n        // Extracts the MID (RFC 5888) from a media section.\n        // Returns the MID or undefined if no mid line was found.\n        SDPUtils.getMid = function(mediaSection) {\n            const mid = SDPUtils.matchPrefix(mediaSection, \"a=mid:\")[0];\n            if (mid) {\n                return mid.substring(6);\n            }\n        };\n        // Parses a fingerprint line for DTLS-SRTP.\n        SDPUtils.parseFingerprint = function(line) {\n            const parts = line.substring(14).split(\" \");\n            return {\n                algorithm: parts[0].toLowerCase(),\n                // algorithm is case-sensitive in Edge.\n                value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n            };\n        };\n        // Extracts DTLS parameters from SDP media section or sessionpart.\n        // FIXME: for consistency with other functions this should only\n        //   get the fingerprint line as input. See also getIceParameters.\n        SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n            const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\");\n            // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n            return {\n                role: \"auto\",\n                fingerprints: lines.map(SDPUtils.parseFingerprint)\n            };\n        };\n        // Serializes DTLS parameters to SDP.\n        SDPUtils.writeDtlsParameters = function(params, setupType) {\n            let sdp = \"a=setup:\" + setupType + \"\\r\\n\";\n            params.fingerprints.forEach((fp)=>{\n                sdp += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n            });\n            return sdp;\n        };\n        // Parses a=crypto lines into\n        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n        SDPUtils.parseCryptoLine = function(line) {\n            const parts = line.substring(9).split(\" \");\n            return {\n                tag: parseInt(parts[0], 10),\n                cryptoSuite: parts[1],\n                keyParams: parts[2],\n                sessionParams: parts.slice(3)\n            };\n        };\n        SDPUtils.writeCryptoLine = function(parameters) {\n            return \"a=crypto:\" + parameters.tag + \" \" + parameters.cryptoSuite + \" \" + (typeof parameters.keyParams === \"object\" ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? \" \" + parameters.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n        };\n        // Parses the crypto key parameters into\n        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n        SDPUtils.parseCryptoKeyParams = function(keyParams) {\n            if (keyParams.indexOf(\"inline:\") !== 0) {\n                return null;\n            }\n            const parts = keyParams.substring(7).split(\"|\");\n            return {\n                keyMethod: \"inline\",\n                keySalt: parts[0],\n                lifeTime: parts[1],\n                mkiValue: parts[2] ? parts[2].split(\":\")[0] : undefined,\n                mkiLength: parts[2] ? parts[2].split(\":\")[1] : undefined\n            };\n        };\n        SDPUtils.writeCryptoKeyParams = function(keyParams) {\n            return keyParams.keyMethod + \":\" + keyParams.keySalt + (keyParams.lifeTime ? \"|\" + keyParams.lifeTime : \"\") + (keyParams.mkiValue && keyParams.mkiLength ? \"|\" + keyParams.mkiValue + \":\" + keyParams.mkiLength : \"\");\n        };\n        // Extracts all SDES parameters.\n        SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n            const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=crypto:\");\n            return lines.map(SDPUtils.parseCryptoLine);\n        };\n        // Parses ICE information from SDP media section or sessionpart.\n        // FIXME: for consistency with other functions this should only\n        //   get the ice-ufrag and ice-pwd lines as input.\n        SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n            const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-ufrag:\")[0];\n            const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-pwd:\")[0];\n            if (!(ufrag && pwd)) {\n                return null;\n            }\n            return {\n                usernameFragment: ufrag.substring(12),\n                password: pwd.substring(10)\n            };\n        };\n        // Serializes ICE parameters to SDP.\n        SDPUtils.writeIceParameters = function(params) {\n            let sdp = \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\n\" + \"a=ice-pwd:\" + params.password + \"\\r\\n\";\n            if (params.iceLite) {\n                sdp += \"a=ice-lite\\r\\n\";\n            }\n            return sdp;\n        };\n        // Parses the SDP media section and returns RTCRtpParameters.\n        SDPUtils.parseRtpParameters = function(mediaSection) {\n            const description = {\n                codecs: [],\n                headerExtensions: [],\n                fecMechanisms: [],\n                rtcp: []\n            };\n            const lines = SDPUtils.splitLines(mediaSection);\n            const mline = lines[0].split(\" \");\n            description.profile = mline[2];\n            for(let i = 3; i < mline.length; i++){\n                // find all codecs from mline[3..]\n                const pt = mline[i];\n                const rtpmapline = SDPUtils.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n                if (rtpmapline) {\n                    const codec = SDPUtils.parseRtpMap(rtpmapline);\n                    const fmtps = SDPUtils.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n                    // Only the first a=fmtp:<pt> is considered.\n                    codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                    codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils.parseRtcpFb);\n                    description.codecs.push(codec);\n                    // parse FEC mechanisms from rtpmap lines.\n                    switch(codec.name.toUpperCase()){\n                        case \"RED\":\n                        case \"ULPFEC\":\n                            description.fecMechanisms.push(codec.name.toUpperCase());\n                            break;\n                    }\n                }\n            }\n            SDPUtils.matchPrefix(mediaSection, \"a=extmap:\").forEach((line)=>{\n                description.headerExtensions.push(SDPUtils.parseExtmap(line));\n            });\n            const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:* \").map(SDPUtils.parseRtcpFb);\n            description.codecs.forEach((codec)=>{\n                wildcardRtcpFb.forEach((fb)=>{\n                    const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                        return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                    });\n                    if (!duplicate) {\n                        codec.rtcpFeedback.push(fb);\n                    }\n                });\n            });\n            // FIXME: parse rtcp.\n            return description;\n        };\n        // Generates parts of the SDP media section describing the capabilities /\n        // parameters.\n        SDPUtils.writeRtpDescription = function(kind, caps) {\n            let sdp = \"\";\n            // Build the mline.\n            sdp += \"m=\" + kind + \" \";\n            sdp += caps.codecs.length > 0 ? \"9\" : \"0\"; // reject if no codecs.\n            sdp += \" \" + (caps.profile || \"UDP/TLS/RTP/SAVPF\") + \" \";\n            sdp += caps.codecs.map((codec)=>{\n                if (codec.preferredPayloadType !== undefined) {\n                    return codec.preferredPayloadType;\n                }\n                return codec.payloadType;\n            }).join(\" \") + \"\\r\\n\";\n            sdp += \"c=IN IP4 0.0.0.0\\r\\n\";\n            sdp += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n            // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n            caps.codecs.forEach((codec)=>{\n                sdp += SDPUtils.writeRtpMap(codec);\n                sdp += SDPUtils.writeFmtp(codec);\n                sdp += SDPUtils.writeRtcpFb(codec);\n            });\n            let maxptime = 0;\n            caps.codecs.forEach((codec)=>{\n                if (codec.maxptime > maxptime) {\n                    maxptime = codec.maxptime;\n                }\n            });\n            if (maxptime > 0) {\n                sdp += \"a=maxptime:\" + maxptime + \"\\r\\n\";\n            }\n            if (caps.headerExtensions) {\n                caps.headerExtensions.forEach((extension)=>{\n                    sdp += SDPUtils.writeExtmap(extension);\n                });\n            }\n            // FIXME: write fecMechanisms.\n            return sdp;\n        };\n        // Parses the SDP media section and returns an array of\n        // RTCRtpEncodingParameters.\n        SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n            const encodingParameters = [];\n            const description = SDPUtils.parseRtpParameters(mediaSection);\n            const hasRed = description.fecMechanisms.indexOf(\"RED\") !== -1;\n            const hasUlpfec = description.fecMechanisms.indexOf(\"ULPFEC\") !== -1;\n            // filter a=ssrc:... cname:, ignore PlanB-msid\n            const ssrcs = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === \"cname\");\n            const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n            let secondarySsrc;\n            const flows = SDPUtils.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map((line)=>{\n                const parts = line.substring(17).split(\" \");\n                return parts.map((part)=>parseInt(part, 10));\n            });\n            if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n                secondarySsrc = flows[0][1];\n            }\n            description.codecs.forEach((codec)=>{\n                if (codec.name.toUpperCase() === \"RTX\" && codec.parameters.apt) {\n                    let encParam = {\n                        ssrc: primarySsrc,\n                        codecPayloadType: parseInt(codec.parameters.apt, 10)\n                    };\n                    if (primarySsrc && secondarySsrc) {\n                        encParam.rtx = {\n                            ssrc: secondarySsrc\n                        };\n                    }\n                    encodingParameters.push(encParam);\n                    if (hasRed) {\n                        encParam = JSON.parse(JSON.stringify(encParam));\n                        encParam.fec = {\n                            ssrc: primarySsrc,\n                            mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n                        };\n                        encodingParameters.push(encParam);\n                    }\n                }\n            });\n            if (encodingParameters.length === 0 && primarySsrc) {\n                encodingParameters.push({\n                    ssrc: primarySsrc\n                });\n            }\n            // we support both b=AS and b=TIAS but interpret AS as TIAS.\n            let bandwidth = SDPUtils.matchPrefix(mediaSection, \"b=\");\n            if (bandwidth.length) {\n                if (bandwidth[0].indexOf(\"b=TIAS:\") === 0) {\n                    bandwidth = parseInt(bandwidth[0].substring(7), 10);\n                } else if (bandwidth[0].indexOf(\"b=AS:\") === 0) {\n                    // use formula from JSEP to convert b=AS to TIAS value.\n                    bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n                } else {\n                    bandwidth = undefined;\n                }\n                encodingParameters.forEach((params)=>{\n                    params.maxBitrate = bandwidth;\n                });\n            }\n            return encodingParameters;\n        };\n        // parses http://draft.ortc.org/#rtcrtcpparameters*\n        SDPUtils.parseRtcpParameters = function(mediaSection) {\n            const rtcpParameters = {};\n            // Gets the first SSRC. Note that with RTX there might be multiple\n            // SSRCs.\n            const remoteSsrc = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === \"cname\")[0];\n            if (remoteSsrc) {\n                rtcpParameters.cname = remoteSsrc.value;\n                rtcpParameters.ssrc = remoteSsrc.ssrc;\n            }\n            // Edge uses the compound attribute instead of reducedSize\n            // compound is !reducedSize\n            const rsize = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n            rtcpParameters.reducedSize = rsize.length > 0;\n            rtcpParameters.compound = rsize.length === 0;\n            // parses the rtcp-mux attrbute.\n            // Note that Edge does not support unmuxed RTCP.\n            const mux = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-mux\");\n            rtcpParameters.mux = mux.length > 0;\n            return rtcpParameters;\n        };\n        SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n            let sdp = \"\";\n            if (rtcpParameters.reducedSize) {\n                sdp += \"a=rtcp-rsize\\r\\n\";\n            }\n            if (rtcpParameters.mux) {\n                sdp += \"a=rtcp-mux\\r\\n\";\n            }\n            if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n                sdp += \"a=ssrc:\" + rtcpParameters.ssrc + \" cname:\" + rtcpParameters.cname + \"\\r\\n\";\n            }\n            return sdp;\n        };\n        // parses either a=msid: or a=ssrc:... msid lines and returns\n        // the id of the MediaStream and MediaStreamTrack.\n        SDPUtils.parseMsid = function(mediaSection) {\n            let parts;\n            const spec = SDPUtils.matchPrefix(mediaSection, \"a=msid:\");\n            if (spec.length === 1) {\n                parts = spec[0].substring(7).split(\" \");\n                return {\n                    stream: parts[0],\n                    track: parts[1]\n                };\n            }\n            const planB = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === \"msid\");\n            if (planB.length > 0) {\n                parts = planB[0].value.split(\" \");\n                return {\n                    stream: parts[0],\n                    track: parts[1]\n                };\n            }\n        };\n        // SCTP\n        // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n        // to draft-ietf-mmusic-sctp-sdp-05\n        SDPUtils.parseSctpDescription = function(mediaSection) {\n            const mline = SDPUtils.parseMLine(mediaSection);\n            const maxSizeLine = SDPUtils.matchPrefix(mediaSection, \"a=max-message-size:\");\n            let maxMessageSize;\n            if (maxSizeLine.length > 0) {\n                maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n            }\n            if (isNaN(maxMessageSize)) {\n                maxMessageSize = 65536;\n            }\n            const sctpPort = SDPUtils.matchPrefix(mediaSection, \"a=sctp-port:\");\n            if (sctpPort.length > 0) {\n                return {\n                    port: parseInt(sctpPort[0].substring(12), 10),\n                    protocol: mline.fmt,\n                    maxMessageSize\n                };\n            }\n            const sctpMapLines = SDPUtils.matchPrefix(mediaSection, \"a=sctpmap:\");\n            if (sctpMapLines.length > 0) {\n                const parts = sctpMapLines[0].substring(10).split(\" \");\n                return {\n                    port: parseInt(parts[0], 10),\n                    protocol: parts[1],\n                    maxMessageSize\n                };\n            }\n        };\n        // SCTP\n        // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n        // support by now receiving in this format, unless we originally parsed\n        // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n        // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n        SDPUtils.writeSctpDescription = function(media, sctp) {\n            let output = [];\n            if (media.protocol !== \"DTLS/SCTP\") {\n                output = [\n                    \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.protocol + \"\\r\\n\",\n                    \"c=IN IP4 0.0.0.0\\r\\n\",\n                    \"a=sctp-port:\" + sctp.port + \"\\r\\n\"\n                ];\n            } else {\n                output = [\n                    \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.port + \"\\r\\n\",\n                    \"c=IN IP4 0.0.0.0\\r\\n\",\n                    \"a=sctpmap:\" + sctp.port + \" \" + sctp.protocol + \" 65535\\r\\n\"\n                ];\n            }\n            if (sctp.maxMessageSize !== undefined) {\n                output.push(\"a=max-message-size:\" + sctp.maxMessageSize + \"\\r\\n\");\n            }\n            return output.join(\"\");\n        };\n        // Generate a session ID for SDP.\n        // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n        // recommends using a cryptographically random +ve 64-bit value\n        // but right now this should be acceptable and within the right range\n        SDPUtils.generateSessionId = function() {\n            return Math.random().toString().substr(2, 22);\n        };\n        // Write boiler plate for start of SDP\n        // sessId argument is optional - if not supplied it will\n        // be generated randomly\n        // sessVersion is optional and defaults to 2\n        // sessUser is optional and defaults to 'thisisadapterortc'\n        SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n            let sessionId;\n            const version = sessVer !== undefined ? sessVer : 2;\n            if (sessId) {\n                sessionId = sessId;\n            } else {\n                sessionId = SDPUtils.generateSessionId();\n            }\n            const user = sessUser || \"thisisadapterortc\";\n            // FIXME: sess-id should be an NTP timestamp.\n            return \"v=0\\r\\n\" + \"o=\" + user + \" \" + sessionId + \" \" + version + \" IN IP4 127.0.0.1\\r\\n\" + \"s=-\\r\\n\" + \"t=0 0\\r\\n\";\n        };\n        // Gets the direction from the mediaSection or the sessionpart.\n        SDPUtils.getDirection = function(mediaSection, sessionpart) {\n            // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n            const lines = SDPUtils.splitLines(mediaSection);\n            for(let i = 0; i < lines.length; i++){\n                switch(lines[i]){\n                    case \"a=sendrecv\":\n                    case \"a=sendonly\":\n                    case \"a=recvonly\":\n                    case \"a=inactive\":\n                        return lines[i].substring(2);\n                }\n            }\n            if (sessionpart) {\n                return SDPUtils.getDirection(sessionpart);\n            }\n            return \"sendrecv\";\n        };\n        SDPUtils.getKind = function(mediaSection) {\n            const lines = SDPUtils.splitLines(mediaSection);\n            const mline = lines[0].split(\" \");\n            return mline[0].substring(2);\n        };\n        SDPUtils.isRejected = function(mediaSection) {\n            return mediaSection.split(\" \", 2)[1] === \"0\";\n        };\n        SDPUtils.parseMLine = function(mediaSection) {\n            const lines = SDPUtils.splitLines(mediaSection);\n            const parts = lines[0].substring(2).split(\" \");\n            return {\n                kind: parts[0],\n                port: parseInt(parts[1], 10),\n                protocol: parts[2],\n                fmt: parts.slice(3).join(\" \")\n            };\n        };\n        SDPUtils.parseOLine = function(mediaSection) {\n            const line = SDPUtils.matchPrefix(mediaSection, \"o=\")[0];\n            const parts = line.substring(2).split(\" \");\n            return {\n                username: parts[0],\n                sessionId: parts[1],\n                sessionVersion: parseInt(parts[2], 10),\n                netType: parts[3],\n                addressType: parts[4],\n                address: parts[5]\n            };\n        };\n        // a very naive interpretation of a valid SDP.\n        SDPUtils.isValidSDP = function(blob) {\n            if (typeof blob !== \"string\" || blob.length === 0) {\n                return false;\n            }\n            const lines = SDPUtils.splitLines(blob);\n            for(let i = 0; i < lines.length; i++){\n                if (lines[i].length < 2 || lines[i].charAt(1) !== \"=\") {\n                    return false;\n                }\n            // TODO: check the modifier a bit more.\n            }\n            return true;\n        };\n        // Expose public methods.\n        {\n            module.exports = SDPUtils;\n        }\n    })(sdp$1);\n    return sdp$1.exports;\n}\nvar sdpExports = requireSdp();\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"foundation\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn't be part of the candidate string.\n        if (typeof args === \"object\" && args.candidate && args.candidate.indexOf(\"a=\") === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, \"candidate\", {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: \"false\"\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"relayProtocol\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === \"relay\") {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: \"tls\",\n                    1: \"tcp\",\n                    2: \"udp\"\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"sctp\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"sctp\", {\n            get () {\n                return typeof this._sctp === \"undefined\" ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === \"application\" && mLine.protocol.indexOf(\"SCTP\") !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === \"firefox\") {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === \"firefox\" && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === \"firefox\" && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an 'ugly worakaround'\n        // to cover up the mess.\n        if (browserDetails.browser === \"chrome\" && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === \"plan-b\") {\n                Object.defineProperty(this, \"sctp\", {\n                    get () {\n                        return typeof this._sctp === \"undefined\" ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, \"maxMessageSize\", {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && \"createDataChannel\" in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === \"open\" && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, \"datachannel\", (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || \"connectionState\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, \"connectionState\", {\n        get () {\n            return ({\n                completed: \"connected\",\n                checking: \"connecting\"\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, \"onconnectionstatechange\", {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        \"setLocalDescription\",\n        \"setRemoteDescription\"\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event(\"connectionstatechange\", e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === \"chrome\" && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === \"safari\" && browserDetails.version >= 605) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf(\"\\na=extmap-allow-mixed\") !== -1) {\n            const sdp = desc.sdp.split(\"\\n\").filter((line)=>{\n                return line.trim() !== \"a=extmap-allow-mixed\";\n            }).join(\"\\n\");\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: \"\", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === \"chrome\" && browserDetails.version < 78 || browserDetails.browser === \"firefox\" && browserDetails.version < 68 || browserDetails.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\") {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== \"object\" || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection's operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can't reduce the glare\n        // window to zero on imperfect implementations, there's value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case \"stable\":\n                case \"have-local-offer\":\n                case \"have-remote-pranswer\":\n                    desc.type = \"offer\";\n                    break;\n                default:\n                    desc.type = \"answer\";\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== \"offer\" && desc.type !== \"answer\") {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === \"offer\" ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case \"chrome\":\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging(\"Chrome shim is not included in this adapter release.\");\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging(\"Chrome shim can not determine version, not shimming.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming chrome.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case \"firefox\":\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging(\"Firefox shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming firefox.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case \"safari\":\n            if (!safariShim || !options.shimSafari) {\n                logging(\"Safari shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming safari.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging(\"Unsupported browser!\");\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = \"AES-GCM\";\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = \"lk_e2ee\";\nconst SALT = \"LKFrameEncryptionKey\";\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n    keyringSize: 16\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent[\"SetKey\"] = \"setKey\";\n    KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n    KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== \"undefined\";\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== \"undefined\" && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== \"undefined\";\n}\nfunction isVideoFrame(frame) {\n    return \"type\" in frame;\n}\nfunction importKey(keyBytes_1) {\n    return __awaiter(this, arguments, void 0, function(keyBytes) {\n        let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            name: ENCRYPTION_ALGORITHM\n        };\n        let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"encrypt\";\n        return function*() {\n            // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n            return crypto.subtle.importKey(\"raw\", keyBytes, algorithm, false, usage === \"derive\" ? [\n                \"deriveBits\",\n                \"deriveKey\"\n            ] : [\n                \"encrypt\",\n                \"decrypt\"\n            ]);\n        }();\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", enc.encode(password), {\n            name: \"PBKDF2\"\n        }, false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", cryptoBuffer, \"HKDF\", false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case \"HKDF\":\n            return {\n                name: \"HKDF\",\n                salt: encodedSalt,\n                hash: \"SHA-256\",\n                info: new ArrayBuffer(128)\n            };\n        case \"PBKDF2\":\n            {\n                return {\n                    name: \"PBKDF2\",\n                    salt: encodedSalt,\n                    hash: \"SHA-256\",\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */ this.onKeyRatcheted = (material, keyIndex)=>{\n            livekitLogger.debug(\"key ratcheted event received\", {\n                material,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        if (!this.options.sharedKey && !participantIdentity) {\n            throw new Error(\"participant identity needs to be passed for encryption key if sharedKey option is false\");\n        }\n        this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : \"shared\", \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won't try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === \"string\" ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || \"an error has occured\");\n        this.name = \"LiveKitError\";\n        this.code = code;\n    }\n}\nvar ConnectionErrorReason;\n(function(ConnectionErrorReason) {\n    ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\n    ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\n    ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n    ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\n    ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status, context){\n        super(1, message);\n        this.name = \"ConnectionError\";\n        this.status = status;\n        this.reason = reason;\n        this.context = context;\n        this.reasonName = ConnectionErrorReason[reason];\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : \"device is unsupported\");\n        this.name = \"DeviceUnsupportedError\";\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : \"track is invalid\");\n        this.name = \"TrackInvalidError\";\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : \"unsupported server\");\n        this.name = \"UnsupportedServer\";\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : \"unexpected connection state\");\n        this.name = \"UnexpectedConnectionState\";\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : \"unable to negotiate\");\n        this.name = \"NegotiationError\";\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(14, message !== null && message !== void 0 ? message : \"unable to publish data\");\n        this.name = \"PublishDataError\";\n    }\n}\nclass PublishTrackError extends LivekitError {\n    constructor(message, status){\n        super(15, message);\n        this.name = \"PublishTrackError\";\n        this.status = status;\n    }\n}\nclass SignalRequestError extends LivekitError {\n    constructor(message, reason){\n        super(15, message);\n        this.reason = reason;\n        this.reasonName = typeof reason === \"string\" ? reason : RequestResponse_Reason[reason];\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n    // device is not available\n    MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n    MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && \"name\" in error) {\n            if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\nvar CryptorErrorReason;\n(function(CryptorErrorReason) {\n    CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\n    CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\n    CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n})(CryptorErrorReason || (CryptorErrorReason = {}));\nclass CryptorError extends LivekitError {\n    constructor(message){\n        let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\n        let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\n        super(40, message);\n        this.reason = reason;\n        this.participantIdentity = participantIdentity;\n    }\n}\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent[\"Connected\"] = \"connected\";\n    /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */ RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n    /**\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\n   */ RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent[\"Reconnected\"] = \"reconnected\";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured.\n   *\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\n   *\n   * args: ([[DisconnectReason]])\n   */ RoomEvent[\"Disconnected\"] = \"disconnected\";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * SIP DTMF tones received from another participant.\n   *\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\n   */ RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n    /**\n   * Transcription received from a participant's track.\n   * @beta\n   */ RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n    RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n    RoomEvent[\"ChatMessage\"] = \"chatMessage\";\n    /**\n   * fired when the first remote participant has subscribed to the localParticipant's track\n   */ RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    /**\n   * fired when the client receives connection metrics from other participants\n   */ RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * SIP DTMF tones received from this participant as sender.\n   *\n   * args: (dtmf: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n    /**\n   * Transcription received from this participant as data source.\n   * @beta\n   */ ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n    /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /** @internal */ ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n    /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\n   * args: (changedAttributes: [[Record<string, string]])\n   */ ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\n    /**\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\n   */ ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    /** only emitted on local participant */ ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n    EngineEvent[\"Connected\"] = \"connected\";\n    EngineEvent[\"Disconnected\"] = \"disconnected\";\n    EngineEvent[\"Resuming\"] = \"resuming\";\n    EngineEvent[\"Resumed\"] = \"resumed\";\n    EngineEvent[\"Restarting\"] = \"restarting\";\n    EngineEvent[\"Restarted\"] = \"restarted\";\n    EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n    EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n    EngineEvent[\"Closing\"] = \"closing\";\n    EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n    EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n    EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n    EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n    EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n    EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n    EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n    EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n    EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n    EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n    EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n    EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n    EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n    EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    EngineEvent[\"Offline\"] = \"offline\";\n    EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\n    EngineEvent[\"SignalConnected\"] = \"signalConnected\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent[\"Message\"] = \"message\";\n    TrackEvent[\"Muted\"] = \"muted\";\n    TrackEvent[\"Unmuted\"] = \"unmuted\";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent[\"Restarted\"] = \"restarted\";\n    TrackEvent[\"Ended\"] = \"ended\";\n    TrackEvent[\"Subscribed\"] = \"subscribed\";\n    TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n    /** @internal */ TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n    /** @internal */ TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n    /** @internal */ TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n    /** @internal */ TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n    /** @internal */ TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n    /** @internal */ TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n    /** @internal */ TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n    /** @internal */ TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n    /** @internal */ TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n    /** @internal */ TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n    /**\n   * @internal\n   */ TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\n    /**\n   * @internal\n   */ TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\n    /**\n   * @beta\n   */ TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * @experimental\n   */ TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\n})(TrackEvent || (TrackEvent = {}));\nfunction cloneDeep(value) {\n    if (typeof value === \"undefined\") {\n        return;\n    }\n    if (typeof structuredClone === \"function\") {\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === \"undefined\" && typeof navigator === \"undefined\") {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: \"Firefox\",\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"fxios\") ? \"iOS\" : undefined,\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: \"Chrome\",\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"crios\") ? \"iOS\" : undefined,\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: \"Safari\",\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes(\"mobile/\") ? \"iOS\" : \"macOS\",\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || \"\";\n}\nfunction getOSVersion(ua) {\n    return ua.includes(\"mac os\") ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, \".\") : undefined;\n}\nvar version$1 = \"2.11.2\";\nconst version = version$1;\nconst protocolVersion = 15;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\nCriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval\nfunction() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nvar VideoQuality;\n(function(VideoQuality) {\n    VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n    VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n})(VideoQuality || (VideoQuality = {}));\nclass Track extends eventsExports.EventEmitter {\n    constructor(mediaTrack, kind){\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */ this.streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.log = livekitLogger;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === \"hidden\") {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = \"audio\";\n        if (this.kind === Track.Kind.Video) {\n            elementType = \"video\";\n        }\n        if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === \"audio\") {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it's already attached to the element, it's possible\n        // the element's srcObject was set to something else out of band.\n        // we'll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === \"audio\");\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === \"NotAllowedError\") {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === \"AbortError\") {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug(\"\".concat(hasAudio ? \"audio\" : \"video\", \" playback aborted, likely due to new play request\"));\n            } else {\n                livekitLogger.warn(\"could not playback \".concat(hasAudio ? \"audio\" : \"video\"), e);\n            }\n            // If audio playback isn't allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === \"video\") && e.name === \"NotAllowedError\") {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n        if (this.timeSyncHandle) {\n            cancelAnimationFrame(this.timeSyncHandle);\n        }\n    }\n    /** @internal */ updateLoggerOptions(loggerOptions) {\n        if (loggerOptions.loggerName) {\n            this.log = getLogger(loggerOptions.loggerName);\n        }\n        if (loggerOptions.loggerContextCb) {\n            this.loggerContextCb = loggerOptions.loggerContextCb;\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            if (!this.isInBackground && this.kind === Track.Kind.Video) {\n                setTimeout(()=>this.attachedElements.forEach((el)=>el.play().catch(()=>{\n                        /** catch clause necessary for Safari */ })), 0);\n            }\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === \"audio\") {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn't actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind[\"Audio\"] = \"audio\";\n        Kind[\"Video\"] = \"video\";\n        Kind[\"Unknown\"] = \"unknown\";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source[\"Camera\"] = \"camera\";\n        Source[\"Microphone\"] = \"microphone\";\n        Source[\"ScreenShare\"] = \"screen_share\";\n        Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n        Source[\"Unknown\"] = \"unknown\";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState[\"Active\"] = \"active\";\n        StreamState[\"Paused\"] = \"paused\";\n        StreamState[\"Unknown\"] = \"unknown\";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nclass VideoPreset {\n    constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority){\n        if (typeof widthOrOptions === \"object\") {\n            this.width = widthOrOptions.width;\n            this.height = widthOrOptions.height;\n            this.aspectRatio = widthOrOptions.aspectRatio;\n            this.encoding = {\n                maxBitrate: widthOrOptions.maxBitrate,\n                maxFramerate: widthOrOptions.maxFramerate,\n                priority: widthOrOptions.priority\n            };\n        } else if (height !== undefined && maxBitrate !== undefined) {\n            this.width = widthOrOptions;\n            this.height = height;\n            this.aspectRatio = widthOrOptions / height;\n            this.encoding = {\n                maxBitrate,\n                maxFramerate,\n                priority\n            };\n        } else {\n            throw new TypeError(\"Unsupported options: provide at least width, height and maxBitrate\");\n        }\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.aspectRatio\n        };\n    }\n}\nconst backupCodecs = [\n    \"vp8\",\n    \"h264\"\n];\nconst videoCodecs = [\n    \"vp8\",\n    \"h264\",\n    \"vp9\",\n    \"av1\"\n];\nfunction isBackupCodec(codec) {\n    return !!backupCodecs.find((backup)=>backup === codec);\n}\nvar BackupCodecPolicy;\n(function(BackupCodecPolicy) {\n    // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed\n    BackupCodecPolicy[BackupCodecPolicy[\"PREFER_REGRESSION\"] = 0] = \"PREFER_REGRESSION\";\n    // multi-codec simulcast, publish both primary and backup codec at the same time\n    BackupCodecPolicy[BackupCodecPolicy[\"SIMULCAST\"] = 1] = \"SIMULCAST\";\n    // always use backup codec only\n    BackupCodecPolicy[BackupCodecPolicy[\"REGRESSION\"] = 2] = \"REGRESSION\";\n})(BackupCodecPolicy || (BackupCodecPolicy = {}));\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 24000\n    };\n    AudioPresets.music = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 96000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 128000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, \"medium\"),\n    h360fps15: new VideoPreset(640, 360, 400000, 15, \"medium\"),\n    h720fps5: new VideoPreset(1280, 720, 800000, 5, \"medium\"),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, \"medium\"),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, \"medium\"),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, \"medium\"),\n    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, \"medium\"),\n    // original resolution, without resizing\n    original: new VideoPreset(0, 0, 7000000, 30, \"medium\")\n};\nconst separator = \"|\";\nconst ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        \"\"\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/AV1\") {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, \"16\") < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/VP9\") {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === \"av1\" || codec === \"vp9\";\n}\nfunction supportsSetSinkId(elm) {\n    if (!document) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement(\"audio\");\n    }\n    return \"setSinkId\" in elm;\n}\nfunction isBrowserSupported() {\n    if (typeof RTCPeerConnection === \"undefined\") {\n        return false;\n    }\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Firefox\";\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Safari\";\n}\nfunction isSafari17() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === \"Safari\" && b.version.startsWith(\"17.\");\n}\nfunction isMobile() {\n    var _a, _b;\n    if (!isWeb()) return false;\n    return(// @ts-expect-error `userAgentData` is not yet part of typescript\n    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent));\n}\nfunction isE2EESimulcastSupported() {\n    const browser = getBrowser();\n    const supportedSafariVersion = \"17.2\"; // see https://bugs.webkit.org/show_bug.cgi?id=257803\n    if (browser) {\n        if (browser.name !== \"Safari\" && browser.os !== \"iOS\") {\n            return true;\n        } else if (browser.os === \"iOS\" && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {\n            return true;\n        } else if (browser.name === \"Safari\" && compareVersions(supportedSafariVersion, browser.version) >= 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\nfunction isWeb() {\n    return typeof document !== \"undefined\";\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == \"ReactNative\";\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith(\".livekit.cloud\") || serverUrl.hostname.endsWith(\".livekit.run\");\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\nfunction compareVersions(v1, v2) {\n    const parts1 = v1.split(\".\");\n    const parts2 = v2.split(\".\");\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === \"\" && v2 !== \"\") {\n        return -1;\n    } else if (v2 === \"\") {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: \"0px\"\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : \"\";\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement(\"canvas\");\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = \"grey\";\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error(\"Could not get empty media stream video track\");\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error(\"Could not get empty media stream audio track\");\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    constructor(futureBase, onFinally){\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error(\"Audio Context not supported on this browser\");\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === \"string\" || typeof constraint === \"number\") {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error(\"could not unwrap constraint\");\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith(\"ws\")) {\n        return url.replace(/^(ws)/, \"http\");\n    }\n    return url;\n}\nfunction extractTranscriptionSegments(transcription, firstReceivedTimesMap) {\n    return transcription.segments.map((_ref)=>{\n        let { id, text, language, startTime, endTime, final } = _ref;\n        var _a;\n        const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();\n        const lastReceivedTime = Date.now();\n        if (final) {\n            firstReceivedTimesMap.delete(id);\n        } else {\n            firstReceivedTimesMap.set(id, firstReceivedTime);\n        }\n        return {\n            id,\n            text,\n            startTime: Number.parseInt(startTime.toString()),\n            endTime: Number.parseInt(endTime.toString()),\n            final,\n            language,\n            firstReceivedTime,\n            lastReceivedTime\n        };\n    });\n}\nfunction extractChatMessage(msg) {\n    const { id, timestamp, message, editTimestamp } = msg;\n    return {\n        id,\n        timestamp: Number.parseInt(timestamp.toString()),\n        editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,\n        message\n    };\n}\nfunction getDisconnectReasonFromConnectionError(e) {\n    switch(e.reason){\n        case ConnectionErrorReason.LeaveRequest:\n            return e.context;\n        case ConnectionErrorReason.Cancelled:\n            return DisconnectReason.CLIENT_INITIATED;\n        case ConnectionErrorReason.NotAllowed:\n            return DisconnectReason.USER_REJECTED;\n        case ConnectionErrorReason.ServerUnreachable:\n            return DisconnectReason.JOIN_FAILURE;\n        default:\n            return DisconnectReason.UNKNOWN_REASON;\n    }\n}\n/** convert bigints to numbers preserving undefined values */ function bigIntToNumber(value) {\n    return value !== undefined ? Number(value) : undefined;\n}\n/** convert numbers to bigints preserving undefined values */ function numberToBigInt(value) {\n    return value !== undefined ? BigInt(value) : undefined;\n}\nfunction isLocalTrack(track) {\n    return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;\n}\nfunction isAudioTrack(track) {\n    return !!track && track.kind == Track.Kind.Audio;\n}\nfunction isVideoTrack(track) {\n    return !!track && track.kind == Track.Kind.Video;\n}\nfunction isLocalVideoTrack(track) {\n    return isLocalTrack(track) && isVideoTrack(track);\n}\nfunction isLocalAudioTrack(track) {\n    return isLocalTrack(track) && isAudioTrack(track);\n}\nfunction isRemoteTrack(track) {\n    return !!track && !track.isLocal;\n}\nfunction isRemotePub(pub) {\n    return !!pub && !pub.isLocal;\n}\nfunction isRemoteVideoTrack(track) {\n    return isRemoteTrack(track) && isVideoTrack(track);\n}\nfunction isLocalParticipant(p) {\n    return p.isLocal;\n}\nfunction isRemoteParticipant(p) {\n    return !p.isLocal;\n}\nfunction splitUtf8(s, n) {\n    // adapted from https://stackoverflow.com/a/6043797\n    const result = [];\n    let encoded = new TextEncoder().encode(s);\n    while(encoded.length > n){\n        let k = n;\n        while(k > 0){\n            const byte = encoded[k];\n            if (byte !== undefined && (byte & 0xc0) !== 0x80) {\n                break;\n            }\n            k--;\n        }\n        result.push(encoded.slice(0, k));\n        encoded = encoded.slice(k);\n    }\n    if (encoded.length > 0) {\n        result.push(encoded);\n    }\n    return result;\n}\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a, _b, _c;\n    var _d, _e;\n    const { optionsWithoutProcessor, audioProcessor, videoProcessor } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});\n    const defaultAudioProcessor = audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;\n    const defaultVideoProcessor = videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;\n    const clonedOptions = (_a = cloneDeep(optionsWithoutProcessor)) !== null && _a !== void 0 ? _a : {};\n    if (clonedOptions.audio === true) clonedOptions.audio = {};\n    if (clonedOptions.video === true) clonedOptions.video = {};\n    // use defaults\n    if (clonedOptions.audio) {\n        mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);\n        (_b = (_d = clonedOptions.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n            ideal: \"default\"\n        };\n        if (audioProcessor || defaultAudioProcessor) {\n            clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;\n        }\n    }\n    if (clonedOptions.video) {\n        mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);\n        (_c = (_e = clonedOptions.video).deviceId) !== null && _c !== void 0 ? _c : _e.deviceId = {\n            ideal: \"default\"\n        };\n        if (videoProcessor || defaultVideoProcessor) {\n            clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;\n        }\n    }\n    return clonedOptions;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    var _a, _b;\n    var _c, _d;\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === \"object\") {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case \"resolution\":\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n            (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n                ideal: \"default\"\n            };\n        } else {\n            constraints.video = options.video ? {\n                deviceId: {\n                    ideal: \"default\"\n                }\n            } : false;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === \"object\") {\n            constraints.audio = options.audio;\n            (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n                ideal: \"default\"\n            };\n        } else {\n            constraints.audio = {\n                deviceId: {\n                    ideal: \"default\"\n                }\n            };\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track_1) {\n    return __awaiter(this, arguments, void 0, function(track) {\n        let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n        return function*() {\n            const ctx = getNewAudioContext();\n            if (ctx) {\n                const analyser = ctx.createAnalyser();\n                analyser.fftSize = 2048;\n                const bufferLength = analyser.frequencyBinCount;\n                const dataArray = new Uint8Array(bufferLength);\n                const source = ctx.createMediaStreamSource(new MediaStream([\n                    track.mediaStreamTrack\n                ]));\n                source.connect(analyser);\n                yield sleep(timeOffset);\n                analyser.getByteTimeDomainData(dataArray);\n                const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n                ctx.close();\n                return !someNoise;\n            }\n            return false;\n        }();\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    var _a;\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        const audioContext = new AudioContext1({\n            latencyHint: \"interactive\"\n        });\n        // If the audio context is suspended, we need to resume it when the user clicks on the page\n        if (audioContext.state === \"suspended\" && \"undefined\" !== \"undefined\" && (0)) {}\n        return audioContext;\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return \"audioinput\";\n    } else if (source === Track.Source.Camera) {\n        return \"videoinput\";\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    // treat 0 as uncapped\n    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n        videoConstraints = typeof videoConstraints === \"boolean\" ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio,\n        preferCurrentTab: options.preferCurrentTab\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    return mimeType.split(\"/\")[1].toLowerCase();\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nfunction getLogContextFromTrack(track) {\n    if (\"mediaStreamTrack\" in track) {\n        return {\n            trackID: track.sid,\n            source: track.source,\n            muted: track.isMuted,\n            enabled: track.mediaStreamTrack.enabled,\n            kind: track.kind,\n            streamID: track.mediaStreamID,\n            streamTrackID: track.mediaStreamTrack.id\n        };\n    } else {\n        return {\n            trackID: track.trackSid,\n            enabled: track.isEnabled,\n            muted: track.isMuted,\n            trackInfo: Object.assign({\n                mimeType: track.mimeType,\n                name: track.trackName,\n                encrypted: track.isEncrypted,\n                kind: track.kind,\n                source: track.source\n            }, track.track ? getLogContextFromTrack(track.track) : {})\n        };\n    }\n}\nfunction supportsSynchronizationSources() {\n    return typeof RTCRtpReceiver !== \"undefined\" && \"getSynchronizationSources\" in RTCRtpReceiver;\n}\nfunction diffAttributes(oldValues, newValues) {\n    var _a;\n    if (oldValues === undefined) {\n        oldValues = {};\n    }\n    if (newValues === undefined) {\n        newValues = {};\n    }\n    const allKeys = [\n        ...Object.keys(newValues),\n        ...Object.keys(oldValues)\n    ];\n    const diff = {};\n    for (const key of allKeys){\n        if (oldValues[key] !== newValues[key]) {\n            diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : \"\";\n        }\n    }\n    return diff;\n}\n/** @internal */ function extractProcessorsFromOptions(options) {\n    const newOptions = Object.assign({}, options);\n    let audioProcessor;\n    let videoProcessor;\n    if (typeof newOptions.audio === \"object\" && newOptions.audio.processor) {\n        audioProcessor = newOptions.audio.processor;\n        newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {\n            processor: undefined\n        });\n    }\n    if (typeof newOptions.video === \"object\" && newOptions.video.processor) {\n        videoProcessor = newOptions.video.processor;\n        newOptions.video = Object.assign(Object.assign({}, newOptions.video), {\n            processor: undefined\n        });\n    }\n    return {\n        audioProcessor,\n        videoProcessor,\n        optionsWithoutProcessor: newOptions\n    };\n}\nfunction getTrackSourceFromProto(source) {\n    switch(source){\n        case TrackSource.CAMERA:\n            return Track.Source.Camera;\n        case TrackSource.MICROPHONE:\n            return Track.Source.Microphone;\n        case TrackSource.SCREEN_SHARE:\n            return Track.Source.ScreenShare;\n        case TrackSource.SCREEN_SHARE_AUDIO:\n            return Track.Source.ScreenShareAudio;\n        default:\n            return Track.Source.Unknown;\n    }\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options){\n        super();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case \"error\":\n                    livekitLogger.error(data.error.message);\n                    this.emit(EncryptionEvent.EncryptionError, data.error);\n                    break;\n                case \"initAck\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case \"enable\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    break;\n                case \"ratchetKey\":\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error(\"e2ee worker encountered an error:\", {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError(\"tried to setup end-to-end encryption on an unsupported browser\");\n        }\n        livekitLogger.info(\"setting up e2ee\");\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker('');\n            const msg = {\n                kind: \"init\",\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions(),\n                    loglevel: workerLogger.getLevel()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info(\"initializing worker\", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.remoteParticipants.forEach((participant)=>{\n                    participant.trackPublications.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: \"removeTransform\",\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError(\"expected room to be present on signal connect\");\n            }\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n        });\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(publication.track, publication.track.sender);\n            }));\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex));\n    }\n    postRatchetRequest(participantIdentity, keyIndex) {\n        if (!this.worker) {\n            throw Error(\"could not ratchet key, worker is missing\");\n        }\n        const msg = {\n            kind: \"ratchetRequest\",\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error(\"could not set key, worker is missing\");\n        }\n        const msg = {\n            kind: \"setKey\",\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: \"enable\",\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError(\"failed to enable e2ee, worker is not ready\");\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError(\"could not post rtp map, worker is missing\");\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError(\"could not post rtp map, local participant identity is missing\");\n        }\n        const msg = {\n            kind: \"setRTPMap\",\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error(\"could not post SIF trailer, worker is missing\");\n        }\n        const msg = {\n            kind: \"setSifTrailer\",\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === \"\") {\n            throw new TypeError(\"MimeType missing from trackInfo, cannot set up E2EE cryptor\");\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === \"video\" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!isLocalTrack(track) || !sender) {\n            if (!sender) livekitLogger.warn(\"early return because sender is not ready\");\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported()) {\n                const options = {\n                    kind: \"decode\",\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: \"updateCodec\",\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: \"decode\",\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === \"\") {\n            throw TypeError(\"local identity needs to be known in order to set up encrypted sender\");\n        }\n        if (isScriptTransformSupported()) {\n            livekitLogger.info(\"initialize script transform\");\n            const options = {\n                kind: \"encode\",\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info(\"initialize encoded streams\");\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: \"encode\",\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nconst defaultId = \"default\";\nclass DeviceManager {\n    constructor(){\n        this._previousDevices = [];\n    }\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    get previousDevices() {\n        return this._previousDevices;\n    }\n    getDevices(kind_1) {\n        return __awaiter(this, arguments, void 0, function(kind) {\n            var _this = this;\n            let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a;\n                if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                    livekitLogger.debug(\"awaiting getUserMedia promise\");\n                    try {\n                        if (kind) {\n                            yield DeviceManager.userMediaPromiseMap.get(kind);\n                        } else {\n                            yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                        }\n                    } catch (e) {\n                        livekitLogger.warn(\"error waiting for media permissons\");\n                    }\n                }\n                let devices = yield navigator.mediaDevices.enumerateDevices();\n                if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n                !(isSafari() && _this.hasDeviceInUse(kind))) {\n                    const isDummyDeviceOrEmpty = devices.filter((d)=>d.kind === kind).length === 0 || devices.some((device)=>{\n                        const noLabel = device.label === \"\";\n                        const isRelevant = kind ? device.kind === kind : true;\n                        return noLabel && isRelevant;\n                    });\n                    if (isDummyDeviceOrEmpty) {\n                        const permissionsToAcquire = {\n                            video: kind !== \"audioinput\" && kind !== \"audiooutput\",\n                            audio: kind !== \"videoinput\" && {\n                                deviceId: {\n                                    ideal: \"default\"\n                                }\n                            }\n                        };\n                        const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                        devices = yield navigator.mediaDevices.enumerateDevices();\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                    }\n                }\n                _this._previousDevices = devices;\n                if (kind) {\n                    devices = devices.filter((device)=>device.kind === kind);\n                }\n                return devices;\n            }();\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it's 'default': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const defaultDevice = devices.find((d)=>d.deviceId === defaultId);\n            if (!defaultDevice) {\n                livekitLogger.warn(\"could not reliably determine default device\");\n                return undefined;\n            }\n            const device = devices.find((d)=>d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));\n            if (!device) {\n                livekitLogger.warn(\"could not reliably determine default device\");\n                return undefined;\n            }\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    \"audioinput\",\n    \"audiooutput\",\n    \"videoinput\"\n];\nDeviceManager.userMediaPromiseMap = new Map();\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n    QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new _();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\nfunction createRtcUrl(url, searchParams) {\n    const urlObj = new URL(url);\n    searchParams.forEach((value, key)=>{\n        urlObj.searchParams.set(key, value);\n    });\n    return appendUrlPath(urlObj, \"rtc\");\n}\nfunction createValidateUrl(rtcWsUrl) {\n    const urlObj = new URL(toHttpUrl(rtcWsUrl));\n    return appendUrlPath(urlObj, \"validate\");\n}\nfunction ensureTrailingSlash(path) {\n    return path.endsWith(\"/\") ? path : \"\".concat(path, \"/\");\n}\nfunction appendUrlPath(urlObj, path) {\n    urlObj.pathname = \"\".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);\n    return urlObj.toString();\n}\nconst passThroughQueueSignals = [\n    \"syncState\",\n    \"trickle\",\n    \"offer\",\n    \"answer\",\n    \"simulate\",\n    \"leave\"\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace(\"request allowed to bypass queue:\", {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    get isEstablishingConnection() {\n        return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n    }\n    getNextRequestId() {\n        this._requestId += 1;\n        return this._requestId;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        this.log = livekitLogger;\n        this._requestId = 0;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new _();\n        this.connectionLock = new _();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    get logContext() {\n        var _a, _b;\n        return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we'd want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                this.log.warn(\"attempted to reconnect without signal options being set, ignoring\", this.logContext);\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        this.connectOptions = opts;\n        const clientInfo = getClientInfo();\n        const params = createConnectionParams(token, clientInfo, opts);\n        const rtcUrl = createRtcUrl(url, params);\n        const validateUrl = createValidateUrl(rtcUrl);\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                const unlock = yield this.connectionLock.lock();\n                try {\n                    const abortHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                            this.close();\n                            clearTimeout(wsTimeout);\n                            reject(new ConnectionError(\"room connection has been cancelled (signal)\", ConnectionErrorReason.Cancelled));\n                        });\n                    const wsTimeout = setTimeout(()=>{\n                        this.close();\n                        reject(new ConnectionError(\"room connection has timed out (signal)\", ConnectionErrorReason.ServerUnreachable));\n                    }, opts.websocketTimeout);\n                    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                        abortHandler();\n                    }\n                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", abortHandler);\n                    const redactedUrl = new URL(rtcUrl);\n                    if (redactedUrl.searchParams.has(\"access_token\")) {\n                        redactedUrl.searchParams.set(\"access_token\", \"<redacted>\");\n                    }\n                    this.log.debug(\"connecting to \".concat(redactedUrl), Object.assign({\n                        reconnect: opts.reconnect,\n                        reconnectReason: opts.reconnectReason\n                    }, this.logContext));\n                    if (this.ws) {\n                        yield this.close(false);\n                    }\n                    this.ws = new WebSocket(rtcUrl);\n                    this.ws.binaryType = \"arraybuffer\";\n                    this.ws.onopen = ()=>{\n                        clearTimeout(wsTimeout);\n                    };\n                    this.ws.onerror = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                this.state = SignalConnectionState.DISCONNECTED;\n                                clearTimeout(wsTimeout);\n                                try {\n                                    const resp = yield fetch(validateUrl);\n                                    if (resp.status.toFixed(0).startsWith(\"4\")) {\n                                        const msg = yield resp.text();\n                                        reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));\n                                    } else {\n                                        reject(new ConnectionError(\"Encountered unknown websocket error during connection: \".concat(ev.toString()), ConnectionErrorReason.InternalError, resp.status));\n                                    }\n                                } catch (e) {\n                                    reject(new ConnectionError(e instanceof Error ? e.message : \"server was not reachable\", ConnectionErrorReason.ServerUnreachable));\n                                }\n                                return;\n                            }\n                            // other errors, handle\n                            this.handleWSError(ev);\n                        });\n                    this.ws.onmessage = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, _b, _c;\n                            // not considered connected until JoinResponse is received\n                            let resp;\n                            if (typeof ev.data === \"string\") {\n                                const json = JSON.parse(ev.data);\n                                resp = SignalResponse.fromJson(json, {\n                                    ignoreUnknownFields: true\n                                });\n                            } else if (ev.data instanceof ArrayBuffer) {\n                                resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n                            } else {\n                                this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\n                                return;\n                            }\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                let shouldProcessMessage = false;\n                                // handle join message only\n                                if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === \"join\") {\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.pingTimeoutDuration = resp.message.value.pingTimeout;\n                                    this.pingIntervalDuration = resp.message.value.pingInterval;\n                                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                        this.log.debug(\"ping config\", Object.assign(Object.assign({}, this.logContext), {\n                                            timeout: this.pingTimeoutDuration,\n                                            interval: this.pingIntervalDuration\n                                        }));\n                                        this.startPingInterval();\n                                    }\n                                    resolve(resp.message.value);\n                                } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== \"leave\") {\n                                    // in reconnecting, any message received means signal reconnected\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.startPingInterval();\n                                    if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === \"reconnect\") {\n                                        resolve(resp.message.value);\n                                    } else {\n                                        this.log.debug(\"declaring signal reconnected without reconnect response received\", this.logContext);\n                                        resolve(undefined);\n                                        shouldProcessMessage = true;\n                                    }\n                                } else if (this.isEstablishingConnection && resp.message.case === \"leave\") {\n                                    reject(new ConnectionError(\"Received leave request while trying to (re)connect\", ConnectionErrorReason.LeaveRequest, undefined, resp.message.value.reason));\n                                } else if (!opts.reconnect) {\n                                    // non-reconnect case, should receive join response first\n                                    reject(new ConnectionError(\"did not receive join response, got \".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, \" instead\"), ConnectionErrorReason.InternalError));\n                                }\n                                if (!shouldProcessMessage) {\n                                    return;\n                                }\n                            }\n                            if (this.signalLatency) {\n                                yield sleep(this.signalLatency);\n                            }\n                            this.handleSignalResponse(resp);\n                        });\n                    this.ws.onclose = (ev)=>{\n                        if (this.isEstablishingConnection) {\n                            reject(new ConnectionError(\"Websocket got closed during a (re)connection attempt\", ConnectionErrorReason.InternalError));\n                        }\n                        this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n                            reason: ev.reason,\n                            code: ev.code,\n                            wasClean: ev.wasClean,\n                            state: this.state\n                        }));\n                        this.handleOnClose(ev.reason);\n                    };\n                } finally{\n                    unlock();\n                }\n            }));\n    }\n    close() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this = this;\n            let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                const unlock = yield _this.closingLock.lock();\n                try {\n                    _this.clearPingInterval();\n                    if (updateState) {\n                        _this.state = SignalConnectionState.DISCONNECTING;\n                    }\n                    if (_this.ws) {\n                        _this.ws.onmessage = null;\n                        _this.ws.onopen = null;\n                        _this.ws.onclose = null;\n                        // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                        const closePromise = new Promise((resolve)=>{\n                            if (_this.ws) {\n                                _this.ws.onclose = ()=>{\n                                    resolve();\n                                };\n                            } else {\n                                resolve();\n                            }\n                        });\n                        if (_this.ws.readyState < _this.ws.CLOSING) {\n                            _this.ws.close();\n                            // 250ms grace period for ws to close gracefully\n                            yield Promise.race([\n                                closePromise,\n                                sleep(250)\n                            ]);\n                        }\n                        _this.ws = undefined;\n                    }\n                } finally{\n                    if (updateState) {\n                        _this.state = SignalConnectionState.DISCONNECTED;\n                    }\n                    unlock();\n                }\n            }();\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer) {\n        this.log.debug(\"sending offer\", Object.assign(Object.assign({}, this.logContext), {\n            offerSdp: offer.sdp\n        }));\n        this.sendRequest({\n            case: \"offer\",\n            value: toProtoSessionDescription(offer)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer) {\n        this.log.debug(\"sending answer\", Object.assign(Object.assign({}, this.logContext), {\n            answerSdp: answer.sdp\n        }));\n        return this.sendRequest({\n            case: \"answer\",\n            value: toProtoSessionDescription(answer)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        this.log.debug(\"sending ice candidate\", Object.assign(Object.assign({}, this.logContext), {\n            candidate\n        }));\n        return this.sendRequest({\n            case: \"trickle\",\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: \"mute\",\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: \"addTrack\",\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata_1, name_1) {\n        return __awaiter(this, arguments, void 0, function(metadata, name) {\n            var _this2 = this;\n            let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            return function*() {\n                const requestId = _this2.getNextRequestId();\n                yield _this2.sendRequest({\n                    case: \"updateMetadata\",\n                    value: new UpdateParticipantMetadata({\n                        requestId,\n                        metadata,\n                        name,\n                        attributes\n                    })\n                });\n                return requestId;\n            }();\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: \"trackSetting\",\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: \"subscription\",\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: \"syncState\",\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: \"updateLayers\",\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: \"subscriptionPermission\",\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: \"simulate\",\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: \"ping\",\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: \"pingReq\",\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendUpdateLocalAudioTrack(trackSid, features) {\n        return this.sendRequest({\n            case: \"updateAudioTrack\",\n            value: new UpdateLocalAudioTrack({\n                trackSid,\n                features\n            })\n        });\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: \"leave\",\n            value: new LeaveRequest({\n                reason: DisconnectReason.CLIENT_INITIATED,\n                // server doesn't process this field, keeping it here to indicate the intent of a full disconnect\n                action: LeaveRequest_Action.DISCONNECT\n            })\n        });\n    }\n    sendRequest(message_1) {\n        return __awaiter(this, arguments, void 0, function(message) {\n            var _this3 = this;\n            let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            return function*() {\n                // capture all requests while reconnecting and put them in a queue\n                // unless the request originates from the queue, then don't enqueue again\n                const canQueue = !fromQueue && !canPassThroughQueue(message);\n                if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {\n                    _this3.queuedRequests.push(()=>__awaiter(_this3, void 0, void 0, function*() {\n                            yield this.sendRequest(message, true);\n                        }));\n                    return;\n                }\n                // make sure previously queued requests are being sent first\n                if (!fromQueue) {\n                    yield _this3.requestQueue.flush();\n                }\n                if (_this3.signalLatency) {\n                    yield sleep(_this3.signalLatency);\n                }\n                if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {\n                    _this3.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);\n                    return;\n                }\n                const req = new SignalRequest({\n                    message\n                });\n                try {\n                    if (_this3.useJSON) {\n                        _this3.ws.send(req.toJsonString());\n                    } else {\n                        _this3.ws.send(req.toBinary());\n                    }\n                } catch (e) {\n                    _this3.log.error(\"error sending signal message\", Object.assign(Object.assign({}, _this3.logContext), {\n                        error: e\n                    }));\n                }\n            }();\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            this.log.debug(\"received unsupported message\", this.logContext);\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === \"answer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd);\n            }\n        } else if (msg.case === \"offer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd);\n            }\n        } else if (msg.case === \"trickle\") {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === \"update\") {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === \"trackPublished\") {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === \"speakersChanged\") {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === \"leave\") {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === \"mute\") {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === \"roomUpdate\") {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === \"connectionQuality\") {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === \"streamStateUpdate\") {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscribedQualityUpdate\") {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscriptionPermissionUpdate\") {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === \"refreshToken\") {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === \"trackUnpublished\") {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === \"subscriptionResponse\") {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === \"pong\") ;\n        else if (msg.case === \"pongResp\") {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else if (msg.case === \"requestResponse\") {\n            if (this.onRequestResponse) {\n                this.onRequestResponse(msg.value);\n            }\n        } else if (msg.case === \"trackSubscribed\") {\n            if (this.onLocalTrackSubscribed) {\n                this.onLocalTrackSubscribed(msg.value.trackSid);\n            }\n        } else {\n            this.log.debug(\"unsupported message\", Object.assign(Object.assign({}, this.logContext), {\n                msgCase: msg.case\n            }));\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close();\n            this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n                reason\n            }));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(ev) {\n        this.log.error(\"websocket error\", Object.assign(Object.assign({}, this.logContext), {\n            error: ev\n        }));\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            this.log.warn(\"ping timeout duration not set\", this.logContext);\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n            this.handleOnClose(\"ping timeout\");\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            this.log.warn(\"ping interval duration not set\", this.logContext);\n            return;\n        }\n        this.log.debug(\"start ping interval\", this.logContext);\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        this.log.debug(\"clearing ping interval\", this.logContext);\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: \"offer\",\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case \"answer\":\n        case \"offer\":\n        case \"pranswer\":\n        case \"rollback\":\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set(\"access_token\", token);\n    // opts\n    if (opts.reconnect) {\n        params.set(\"reconnect\", \"1\");\n        if (opts.sid) {\n            params.set(\"sid\", opts.sid);\n        }\n    }\n    params.set(\"auto_subscribe\", opts.autoSubscribe ? \"1\" : \"0\");\n    // ClientInfo\n    params.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\");\n    params.set(\"version\", info.version);\n    params.set(\"protocol\", info.protocol.toString());\n    if (info.deviceModel) {\n        params.set(\"device_model\", info.deviceModel);\n    }\n    if (info.os) {\n        params.set(\"os\", info.os);\n    }\n    if (info.osVersion) {\n        params.set(\"os_version\", info.osVersion);\n    }\n    if (info.browser) {\n        params.set(\"browser\", info.browser);\n    }\n    if (info.browserVersion) {\n        params.set(\"browser_version\", info.browserVersion);\n    }\n    if (opts.adaptiveStream) {\n        params.set(\"adaptive_stream\", \"1\");\n    }\n    if (opts.reconnectReason) {\n        params.set(\"reconnect_reason\", opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set(\"network\", navigator.connection.type);\n    }\n    return params;\n}\nvar lib = {};\nvar parser = {};\nvar grammar = {\n    exports: {}\n};\nvar hasRequiredGrammar;\nfunction requireGrammar() {\n    if (hasRequiredGrammar) return grammar.exports;\n    hasRequiredGrammar = 1;\n    var grammar$1 = grammar.exports = {\n        v: [\n            {\n                name: \"version\",\n                reg: /^(\\d*)$/\n            }\n        ],\n        o: [\n            {\n                // o=- 20518 0 IN IP4 203.0.113.1\n                // NB: sessionId will be a String in most cases because it is huge\n                name: \"origin\",\n                reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n                names: [\n                    \"username\",\n                    \"sessionId\",\n                    \"sessionVersion\",\n                    \"netType\",\n                    \"ipVer\",\n                    \"address\"\n                ],\n                format: \"%s %s %d %s IP%d %s\"\n            }\n        ],\n        // default parsing of these only (though some of these feel outdated)\n        s: [\n            {\n                name: \"name\"\n            }\n        ],\n        i: [\n            {\n                name: \"description\"\n            }\n        ],\n        u: [\n            {\n                name: \"uri\"\n            }\n        ],\n        e: [\n            {\n                name: \"email\"\n            }\n        ],\n        p: [\n            {\n                name: \"phone\"\n            }\n        ],\n        z: [\n            {\n                name: \"timezones\"\n            }\n        ],\n        // TODO: this one can actually be parsed properly...\n        r: [\n            {\n                name: \"repeats\"\n            }\n        ],\n        // TODO: this one can also be parsed properly\n        // k: [{}], // outdated thing ignored\n        t: [\n            {\n                // t=0 0\n                name: \"timing\",\n                reg: /^(\\d*) (\\d*)/,\n                names: [\n                    \"start\",\n                    \"stop\"\n                ],\n                format: \"%d %d\"\n            }\n        ],\n        c: [\n            {\n                // c=IN IP4 10.47.197.26\n                name: \"connection\",\n                reg: /^IN IP(\\d) (\\S*)/,\n                names: [\n                    \"version\",\n                    \"ip\"\n                ],\n                format: \"IN IP%d %s\"\n            }\n        ],\n        b: [\n            {\n                // b=AS:4000\n                push: \"bandwidth\",\n                reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n                names: [\n                    \"type\",\n                    \"limit\"\n                ],\n                format: \"%s:%s\"\n            }\n        ],\n        m: [\n            {\n                // m=video 51744 RTP/AVP 126 97 98 34 31\n                // NB: special - pushes to session\n                // TODO: rtp/fmtp should be filtered by the payloads found here?\n                reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n                names: [\n                    \"type\",\n                    \"port\",\n                    \"protocol\",\n                    \"payloads\"\n                ],\n                format: \"%s %d %s %s\"\n            }\n        ],\n        a: [\n            {\n                // a=rtpmap:110 opus/48000/2\n                push: \"rtp\",\n                reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n                names: [\n                    \"payload\",\n                    \"codec\",\n                    \"rate\",\n                    \"encoding\"\n                ],\n                format: function(o) {\n                    return o.encoding ? \"rtpmap:%d %s/%s/%s\" : o.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n                }\n            },\n            {\n                // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n                // a=fmtp:111 minptime=10; useinbandfec=1\n                push: \"fmtp\",\n                reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n                names: [\n                    \"payload\",\n                    \"config\"\n                ],\n                format: \"fmtp:%d %s\"\n            },\n            {\n                // a=control:streamid=0\n                name: \"control\",\n                reg: /^control:(.*)/,\n                format: \"control:%s\"\n            },\n            {\n                // a=rtcp:65179 IN IP4 193.84.77.194\n                name: \"rtcp\",\n                reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n                names: [\n                    \"port\",\n                    \"netType\",\n                    \"ipVer\",\n                    \"address\"\n                ],\n                format: function(o) {\n                    return o.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n                }\n            },\n            {\n                // a=rtcp-fb:98 trr-int 100\n                push: \"rtcpFbTrrInt\",\n                reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n                names: [\n                    \"payload\",\n                    \"value\"\n                ],\n                format: \"rtcp-fb:%s trr-int %d\"\n            },\n            {\n                // a=rtcp-fb:98 nack rpsi\n                push: \"rtcpFb\",\n                reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n                names: [\n                    \"payload\",\n                    \"type\",\n                    \"subtype\"\n                ],\n                format: function(o) {\n                    return o.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n                }\n            },\n            {\n                // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n                // a=extmap:1/recvonly URI-gps-string\n                // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n                push: \"ext\",\n                reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"value\",\n                    \"direction\",\n                    \"encrypt-uri\",\n                    \"uri\",\n                    \"config\"\n                ],\n                format: function(o) {\n                    return \"extmap:%d\" + (o.direction ? \"/%s\" : \"%v\") + (o[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (o.config ? \" %s\" : \"\");\n                }\n            },\n            {\n                // a=extmap-allow-mixed\n                name: \"extmapAllowMixed\",\n                reg: /^(extmap-allow-mixed)/\n            },\n            {\n                // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n                push: \"crypto\",\n                reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"id\",\n                    \"suite\",\n                    \"config\",\n                    \"sessionConfig\"\n                ],\n                format: function(o) {\n                    return o.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n                }\n            },\n            {\n                // a=setup:actpass\n                name: \"setup\",\n                reg: /^setup:(\\w*)/,\n                format: \"setup:%s\"\n            },\n            {\n                // a=connection:new\n                name: \"connectionType\",\n                reg: /^connection:(new|existing)/,\n                format: \"connection:%s\"\n            },\n            {\n                // a=mid:1\n                name: \"mid\",\n                reg: /^mid:([^\\s]*)/,\n                format: \"mid:%s\"\n            },\n            {\n                // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n                name: \"msid\",\n                reg: /^msid:(.*)/,\n                format: \"msid:%s\"\n            },\n            {\n                // a=ptime:20\n                name: \"ptime\",\n                reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n                format: \"ptime:%d\"\n            },\n            {\n                // a=maxptime:60\n                name: \"maxptime\",\n                reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n                format: \"maxptime:%d\"\n            },\n            {\n                // a=sendrecv\n                name: \"direction\",\n                reg: /^(sendrecv|recvonly|sendonly|inactive)/\n            },\n            {\n                // a=ice-lite\n                name: \"icelite\",\n                reg: /^(ice-lite)/\n            },\n            {\n                // a=ice-ufrag:F7gI\n                name: \"iceUfrag\",\n                reg: /^ice-ufrag:(\\S*)/,\n                format: \"ice-ufrag:%s\"\n            },\n            {\n                // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n                name: \"icePwd\",\n                reg: /^ice-pwd:(\\S*)/,\n                format: \"ice-pwd:%s\"\n            },\n            {\n                // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n                name: \"fingerprint\",\n                reg: /^fingerprint:(\\S*) (\\S*)/,\n                names: [\n                    \"type\",\n                    \"hash\"\n                ],\n                format: \"fingerprint:%s %s\"\n            },\n            {\n                // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n                // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n                // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n                // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n                // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n                push: \"candidates\",\n                reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n                names: [\n                    \"foundation\",\n                    \"component\",\n                    \"transport\",\n                    \"priority\",\n                    \"ip\",\n                    \"port\",\n                    \"type\",\n                    \"raddr\",\n                    \"rport\",\n                    \"tcptype\",\n                    \"generation\",\n                    \"network-id\",\n                    \"network-cost\"\n                ],\n                format: function(o) {\n                    var str = \"candidate:%s %d %s %d %s %d typ %s\";\n                    str += o.raddr != null ? \" raddr %s rport %d\" : \"%v%v\";\n                    // NB: candidate has three optional chunks, so %void middles one if it's missing\n                    str += o.tcptype != null ? \" tcptype %s\" : \"%v\";\n                    if (o.generation != null) {\n                        str += \" generation %d\";\n                    }\n                    str += o[\"network-id\"] != null ? \" network-id %d\" : \"%v\";\n                    str += o[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\";\n                    return str;\n                }\n            },\n            {\n                // a=end-of-candidates (keep after the candidates line for readability)\n                name: \"endOfCandidates\",\n                reg: /^(end-of-candidates)/\n            },\n            {\n                // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n                name: \"remoteCandidates\",\n                reg: /^remote-candidates:(.*)/,\n                format: \"remote-candidates:%s\"\n            },\n            {\n                // a=ice-options:google-ice\n                name: \"iceOptions\",\n                reg: /^ice-options:(\\S*)/,\n                format: \"ice-options:%s\"\n            },\n            {\n                // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n                push: \"ssrcs\",\n                reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n                names: [\n                    \"id\",\n                    \"attribute\",\n                    \"value\"\n                ],\n                format: function(o) {\n                    var str = \"ssrc:%d\";\n                    if (o.attribute != null) {\n                        str += \" %s\";\n                        if (o.value != null) {\n                            str += \":%s\";\n                        }\n                    }\n                    return str;\n                }\n            },\n            {\n                // a=ssrc-group:FEC 1 2\n                // a=ssrc-group:FEC-FR 3004364195 1080772241\n                push: \"ssrcGroups\",\n                // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n                reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n                names: [\n                    \"semantics\",\n                    \"ssrcs\"\n                ],\n                format: \"ssrc-group:%s %s\"\n            },\n            {\n                // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n                name: \"msidSemantic\",\n                reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n                names: [\n                    \"semantic\",\n                    \"token\"\n                ],\n                format: \"msid-semantic: %s %s\" // space after ':' is not accidental\n            },\n            {\n                // a=group:BUNDLE audio video\n                push: \"groups\",\n                reg: /^group:(\\w*) (.*)/,\n                names: [\n                    \"type\",\n                    \"mids\"\n                ],\n                format: \"group:%s %s\"\n            },\n            {\n                // a=rtcp-mux\n                name: \"rtcpMux\",\n                reg: /^(rtcp-mux)/\n            },\n            {\n                // a=rtcp-rsize\n                name: \"rtcpRsize\",\n                reg: /^(rtcp-rsize)/\n            },\n            {\n                // a=sctpmap:5000 webrtc-datachannel 1024\n                name: \"sctpmap\",\n                reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"sctpmapNumber\",\n                    \"app\",\n                    \"maxMessageSize\"\n                ],\n                format: function(o) {\n                    return o.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n                }\n            },\n            {\n                // a=x-google-flag:conference\n                name: \"xGoogleFlag\",\n                reg: /^x-google-flag:([^\\s]*)/,\n                format: \"x-google-flag:%s\"\n            },\n            {\n                // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n                push: \"rids\",\n                reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n                names: [\n                    \"id\",\n                    \"direction\",\n                    \"params\"\n                ],\n                format: function(o) {\n                    return o.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n                }\n            },\n            {\n                // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n                // a=imageattr:* send [x=800,y=640] recv *\n                // a=imageattr:100 recv [x=320,y=240]\n                push: \"imageattrs\",\n                reg: new RegExp(// a=imageattr:97\n                \"^imageattr:(\\\\d+|\\\\*)\" + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n                \"[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)\" + // recv [x=330,y=250]\n                \"(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"),\n                names: [\n                    \"pt\",\n                    \"dir1\",\n                    \"attrs1\",\n                    \"dir2\",\n                    \"attrs2\"\n                ],\n                format: function(o) {\n                    return \"imageattr:%s %s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n                }\n            },\n            {\n                // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n                // a=simulcast:recv 1;4,5 send 6;7\n                name: \"simulcast\",\n                reg: new RegExp(// a=simulcast:\n                \"^simulcast:\" + // send 1,2,3;~4,~5\n                \"(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)\" + // space + recv 6;~7,~8\n                \"(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?\" + // end\n                \"$\"),\n                names: [\n                    \"dir1\",\n                    \"list1\",\n                    \"dir2\",\n                    \"list2\"\n                ],\n                format: function(o) {\n                    return \"simulcast:%s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n                }\n            },\n            {\n                // old simulcast draft 03 (implemented by Firefox)\n                //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n                // a=simulcast: recv pt=97;98 send pt=97\n                // a=simulcast: send rid=5;6;7 paused=6,7\n                name: \"simulcast_03\",\n                reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n                names: [\n                    \"value\"\n                ],\n                format: \"simulcast: %s\"\n            },\n            {\n                // a=framerate:25\n                // a=framerate:29.97\n                name: \"framerate\",\n                reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n                format: \"framerate:%s\"\n            },\n            {\n                // RFC4570\n                // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n                name: \"sourceFilter\",\n                reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n                names: [\n                    \"filterMode\",\n                    \"netType\",\n                    \"addressTypes\",\n                    \"destAddress\",\n                    \"srcList\"\n                ],\n                format: \"source-filter: %s %s %s %s %s\"\n            },\n            {\n                // a=bundle-only\n                name: \"bundleOnly\",\n                reg: /^(bundle-only)/\n            },\n            {\n                // a=label:1\n                name: \"label\",\n                reg: /^label:(.+)/,\n                format: \"label:%s\"\n            },\n            {\n                // RFC version 26 for SCTP over DTLS\n                // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n                name: \"sctpPort\",\n                reg: /^sctp-port:(\\d+)$/,\n                format: \"sctp-port:%s\"\n            },\n            {\n                // RFC version 26 for SCTP over DTLS\n                // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n                name: \"maxMessageSize\",\n                reg: /^max-message-size:(\\d+)$/,\n                format: \"max-message-size:%s\"\n            },\n            {\n                // RFC7273\n                // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n                push: \"tsRefClocks\",\n                reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n                names: [\n                    \"clksrc\",\n                    \"clksrcExt\"\n                ],\n                format: function(o) {\n                    return \"ts-refclk:%s\" + (o.clksrcExt != null ? \"=%s\" : \"\");\n                }\n            },\n            {\n                // RFC7273\n                // a=mediaclk:direct=963214424\n                name: \"mediaClk\",\n                reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n                names: [\n                    \"id\",\n                    \"mediaClockName\",\n                    \"mediaClockValue\",\n                    \"rateNumerator\",\n                    \"rateDenominator\"\n                ],\n                format: function(o) {\n                    var str = \"mediaclk:\";\n                    str += o.id != null ? \"id=%s %s\" : \"%v%s\";\n                    str += o.mediaClockValue != null ? \"=%s\" : \"\";\n                    str += o.rateNumerator != null ? \" rate=%s\" : \"\";\n                    str += o.rateDenominator != null ? \"/%s\" : \"\";\n                    return str;\n                }\n            },\n            {\n                // a=keywds:keywords\n                name: \"keywords\",\n                reg: /^keywds:(.+)$/,\n                format: \"keywds:%s\"\n            },\n            {\n                // a=content:main\n                name: \"content\",\n                reg: /^content:(.+)/,\n                format: \"content:%s\"\n            },\n            // BFCP https://tools.ietf.org/html/rfc4583\n            {\n                // a=floorctrl:c-s\n                name: \"bfcpFloorCtrl\",\n                reg: /^floorctrl:(c-only|s-only|c-s)/,\n                format: \"floorctrl:%s\"\n            },\n            {\n                // a=confid:1\n                name: \"bfcpConfId\",\n                reg: /^confid:(\\d+)/,\n                format: \"confid:%s\"\n            },\n            {\n                // a=userid:1\n                name: \"bfcpUserId\",\n                reg: /^userid:(\\d+)/,\n                format: \"userid:%s\"\n            },\n            {\n                // a=floorid:1\n                name: \"bfcpFloorId\",\n                reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n                names: [\n                    \"id\",\n                    \"mStream\"\n                ],\n                format: \"floorid:%s mstrm:%s\"\n            },\n            {\n                // any a= that we don't understand is kept verbatim on media.invalid\n                push: \"invalid\",\n                names: [\n                    \"value\"\n                ]\n            }\n        ]\n    };\n    // set sensible defaults to avoid polluting the grammar with boring details\n    Object.keys(grammar$1).forEach(function(key) {\n        var objs = grammar$1[key];\n        objs.forEach(function(obj) {\n            if (!obj.reg) {\n                obj.reg = /(.*)/;\n            }\n            if (!obj.format) {\n                obj.format = \"%s\";\n            }\n        });\n    });\n    return grammar.exports;\n}\nvar hasRequiredParser;\nfunction requireParser() {\n    if (hasRequiredParser) return parser;\n    hasRequiredParser = 1;\n    (function(exports) {\n        var toIntIfInt = function(v) {\n            return String(Number(v)) === v ? Number(v) : v;\n        };\n        var attachProperties = function(match, location, names, rawName) {\n            if (rawName && !names) {\n                location[rawName] = toIntIfInt(match[1]);\n            } else {\n                for(var i = 0; i < names.length; i += 1){\n                    if (match[i + 1] != null) {\n                        location[names[i]] = toIntIfInt(match[i + 1]);\n                    }\n                }\n            }\n        };\n        var parseReg = function(obj, location, content) {\n            var needsBlank = obj.name && obj.names;\n            if (obj.push && !location[obj.push]) {\n                location[obj.push] = [];\n            } else if (needsBlank && !location[obj.name]) {\n                location[obj.name] = {};\n            }\n            var keyLocation = obj.push ? {} : // blank object that will be pushed\n            needsBlank ? location[obj.name] : location; // otherwise, named location or root\n            attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n            if (obj.push) {\n                location[obj.push].push(keyLocation);\n            }\n        };\n        var grammar = requireGrammar();\n        var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n        exports.parse = function(sdp) {\n            var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n            // parse lines we understand\n            sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n                var type = l[0];\n                var content = l.slice(2);\n                if (type === \"m\") {\n                    media.push({\n                        rtp: [],\n                        fmtp: []\n                    });\n                    location = media[media.length - 1]; // point at latest media line\n                }\n                for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                    var obj = grammar[type][j];\n                    if (obj.reg.test(content)) {\n                        return parseReg(obj, location, content);\n                    }\n                }\n            });\n            session.media = media; // link it up\n            return session;\n        };\n        var paramReducer = function(acc, expr) {\n            var s = expr.split(/=(.+)/, 2);\n            if (s.length === 2) {\n                acc[s[0]] = toIntIfInt(s[1]);\n            } else if (s.length === 1 && expr.length > 1) {\n                acc[s[0]] = undefined;\n            }\n            return acc;\n        };\n        exports.parseParams = function(str) {\n            return str.split(/;\\s?/).reduce(paramReducer, {});\n        };\n        // For backward compatibility - alias will be removed in 3.0.0\n        exports.parseFmtpConfig = exports.parseParams;\n        exports.parsePayloads = function(str) {\n            return str.toString().split(\" \").map(Number);\n        };\n        exports.parseRemoteCandidates = function(str) {\n            var candidates = [];\n            var parts = str.split(\" \").map(toIntIfInt);\n            for(var i = 0; i < parts.length; i += 3){\n                candidates.push({\n                    component: parts[i],\n                    ip: parts[i + 1],\n                    port: parts[i + 2]\n                });\n            }\n            return candidates;\n        };\n        exports.parseImageAttributes = function(str) {\n            return str.split(\" \").map(function(item) {\n                return item.substring(1, item.length - 1).split(\",\").reduce(paramReducer, {});\n            });\n        };\n        exports.parseSimulcastStreamList = function(str) {\n            return str.split(\";\").map(function(stream) {\n                return stream.split(\",\").map(function(format) {\n                    var scid, paused = false;\n                    if (format[0] !== \"~\") {\n                        scid = toIntIfInt(format);\n                    } else {\n                        scid = toIntIfInt(format.substring(1, format.length));\n                        paused = true;\n                    }\n                    return {\n                        scid: scid,\n                        paused: paused\n                    };\n                });\n            });\n        };\n    })(parser);\n    return parser;\n}\nvar writer;\nvar hasRequiredWriter;\nfunction requireWriter() {\n    if (hasRequiredWriter) return writer;\n    hasRequiredWriter = 1;\n    var grammar = requireGrammar();\n    // customized util.format - discards excess arguments and can void middle ones\n    var formatRegExp = /%[sdv%]/g;\n    var format = function(formatStr) {\n        var i = 1;\n        var args = arguments;\n        var len = args.length;\n        return formatStr.replace(formatRegExp, function(x) {\n            if (i >= len) {\n                return x; // missing argument\n            }\n            var arg = args[i];\n            i += 1;\n            switch(x){\n                case \"%%\":\n                    return \"%\";\n                case \"%s\":\n                    return String(arg);\n                case \"%d\":\n                    return Number(arg);\n                case \"%v\":\n                    return \"\";\n            }\n        });\n    // NB: we discard excess arguments - they are typically undefined from makeLine\n    };\n    var makeLine = function(type, obj, location) {\n        var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n        var args = [\n            type + \"=\" + str\n        ];\n        if (obj.names) {\n            for(var i = 0; i < obj.names.length; i += 1){\n                var n = obj.names[i];\n                if (obj.name) {\n                    args.push(location[obj.name][n]);\n                } else {\n                    // for mLine and push attributes\n                    args.push(location[obj.names[i]]);\n                }\n            }\n        } else {\n            args.push(location[obj.name]);\n        }\n        return format.apply(null, args);\n    };\n    // RFC specified order\n    // TODO: extend this with all the rest\n    var defaultOuterOrder = [\n        \"v\",\n        \"o\",\n        \"s\",\n        \"i\",\n        \"u\",\n        \"e\",\n        \"p\",\n        \"c\",\n        \"b\",\n        \"t\",\n        \"r\",\n        \"z\",\n        \"a\"\n    ];\n    var defaultInnerOrder = [\n        \"i\",\n        \"c\",\n        \"b\",\n        \"a\"\n    ];\n    writer = function(session, opts) {\n        opts = opts || {};\n        // ensure certain properties exist\n        if (session.version == null) {\n            session.version = 0; // 'v=0' must be there (only defined version atm)\n        }\n        if (session.name == null) {\n            session.name = \" \"; // 's= ' must be there if no meaningful name set\n        }\n        session.media.forEach(function(mLine) {\n            if (mLine.payloads == null) {\n                mLine.payloads = \"\";\n            }\n        });\n        var outerOrder = opts.outerOrder || defaultOuterOrder;\n        var innerOrder = opts.innerOrder || defaultInnerOrder;\n        var sdp = [];\n        // loop through outerOrder for matching properties on session\n        outerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in session && session[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, session));\n                } else if (obj.push in session && session[obj.push] != null) {\n                    session[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n        // then for each media line, follow the innerOrder\n        session.media.forEach(function(mLine) {\n            sdp.push(makeLine(\"m\", grammar.m[0], mLine));\n            innerOrder.forEach(function(type) {\n                grammar[type].forEach(function(obj) {\n                    if (obj.name in mLine && mLine[obj.name] != null) {\n                        sdp.push(makeLine(type, obj, mLine));\n                    } else if (obj.push in mLine && mLine[obj.push] != null) {\n                        mLine[obj.push].forEach(function(el) {\n                            sdp.push(makeLine(type, obj, el));\n                        });\n                    }\n                });\n            });\n        });\n        return sdp.join(\"\\r\\n\") + \"\\r\\n\";\n    };\n    return writer;\n}\nvar hasRequiredLib;\nfunction requireLib() {\n    if (hasRequiredLib) return lib;\n    hasRequiredLib = 1;\n    var parser = requireParser();\n    var writer = requireWriter();\n    var grammar = requireGrammar();\n    lib.grammar = grammar;\n    lib.write = writer;\n    lib.parse = parser.parse;\n    lib.parseParams = parser.parseParams;\n    lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\n    lib.parsePayloads = parser.parsePayloads;\n    lib.parseRemoteCandidates = parser.parseRemoteCandidates;\n    lib.parseImageAttributes = parser.parseImageAttributes;\n    lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n    return lib;\n}\nvar libExports = requireLib();\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst debounceInterval = 20;\nconst PCEvents = {\n    NegotiationStarted: \"negotiationStarted\",\n    NegotiationComplete: \"negotiationComplete\",\n    RTPVideoPayloadTypes: \"rtpVideoPayloadTypes\"\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        super();\n        this.log = livekitLogger;\n        this.ddExtID = 0;\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), debounceInterval);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n        this.loggerOptions = loggerOptions;\n        this.config = config;\n        this._pc = this.createPC();\n    }\n    createPC() {\n        const pc = new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\");\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            let mungedSDP = undefined;\n            if (sd.type === \"offer\") {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === \"answer\") {\n                const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : \"\");\n                sdpParsed.media.forEach((media)=>{\n                    if (media.type === \"audio\") {\n                        // mung sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(\";\").filter((attr)=>!attr.includes(\"maxaveragebitrate\")).join(\";\");\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = libExports.write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === \"answer\") {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = libExports.parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === \"video\") {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createAndSendOffer(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (this.onOffer === undefined) {\n                return;\n            }\n            if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                this.log.debug(\"restarting ICE\", this.logContext);\n                this.restartingIce = true;\n            }\n            if (this._pc && this._pc.signalingState === \"have-local-offer\") {\n                // we're waiting for the peer to accept our offer, so we'll just wait\n                // the only exception to this is when ICE restart is needed\n                const currentSD = this._pc.remoteDescription;\n                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                    // TODO: handle when ICE restart is needed but we don't have a remote description\n                    // the best thing to do is to recreate the peerconnection\n                    yield this._pc.setRemoteDescription(currentSD);\n                } else {\n                    this.renegotiate = true;\n                    return;\n                }\n            } else if (!this._pc || this._pc.signalingState === \"closed\") {\n                this.log.warn(\"could not createOffer with closed peer connection\", this.logContext);\n                return;\n            }\n            // actually negotiate\n            this.log.debug(\"starting to negotiate\", this.logContext);\n            const offer = yield this.pc.createOffer(options);\n            this.log.debug(\"original offer\", Object.assign({\n                sdp: offer.sdp\n            }, this.logContext));\n            const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                ensureIPAddrMatchVersion(media);\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, [], []);\n                } else if (media.type === \"video\") {\n                    this.trackBitrates.some((trackbr)=>{\n                        if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                            return false;\n                        }\n                        let codecPayload = 0;\n                        media.rtp.some((rtp)=>{\n                            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                codecPayload = rtp.payload;\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (codecPayload === 0) {\n                            return true;\n                        }\n                        if (isSVCCodec(trackbr.codec)) {\n                            this.ensureVideoDDExtensionForSVC(media, sdpParsed);\n                        }\n                        // TODO: av1 slow starting issue already fixed in chrome 124, clean this after some versions\n                        // mung sdp for av1 bitrate setting that can't apply by sendEncoding\n                        if (trackbr.codec !== \"av1\") {\n                            return true;\n                        }\n                        const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);\n                        for (const fmtp of media.fmtp){\n                            if (fmtp.payload === codecPayload) {\n                                // if another track's fmtp already is set, we cannot override the bitrate\n                                // this has the unfortunate consequence of being forced to use the\n                                // initial track's bitrate for all tracks\n                                if (!fmtp.config.includes(\"x-google-start-bitrate\")) {\n                                    fmtp.config += \";x-google-start-bitrate=\".concat(startBitrate);\n                                }\n                                break;\n                            }\n                        }\n                        return true;\n                    });\n                }\n            });\n            yield this.setMungedSDP(offer, libExports.write(sdpParsed));\n            this.onOffer(offer);\n        });\n    }\n    createAndSetAnswer() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                ensureIPAddrMatchVersion(media);\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, libExports.write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot add track\");\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot configure\");\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = \"\";\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case \"transport\":\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case \"candidate-pair\":\n                        if (selectedCandidatePairId === \"\" && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case \"remote-candidate\":\n                        candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === \"\") {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    this.log.debug(\"setting munged \".concat(remote ? \"remote\" : \"local\", \" description\"), this.logContext);\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n                        error: e,\n                        sdp: munged\n                    }));\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                let msg = \"unknown error\";\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === \"string\") {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n                    fields\n                }));\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n    ensureVideoDDExtensionForSVC(media, sdp) {\n        var _a, _b;\n        const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some((ext)=>{\n            if (ext.uri === ddExtensionURI) {\n                return true;\n            }\n            return false;\n        });\n        if (!ddFound) {\n            if (this.ddExtID === 0) {\n                let maxID = 0;\n                sdp.media.forEach((m)=>{\n                    var _a;\n                    if (m.type !== \"video\") {\n                        return;\n                    }\n                    (_a = m.ext) === null || _a === void 0 ? void 0 : _a.forEach((ext)=>{\n                        if (ext.value > maxID) {\n                            maxID = ext.value;\n                        }\n                    });\n                });\n                this.ddExtID = maxID + 1;\n            }\n            (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({\n                value: this.ddExtID,\n                uri: ddExtensionURI\n            });\n        }\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === \"opus\") {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: \"nack\"\n            });\n        }\n        if (stereoMids.includes(media.mid)) {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes(\"stereo=1\")) {\n                        fmtp.config += \";stereo=1\";\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        if (media.type === \"audio\") {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === \"opus\") {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n                nackMids.push(media.mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes(\"sprop-stereo=1\")) {\n                        stereoMids.push(media.mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nfunction ensureIPAddrMatchVersion(media) {\n    // Chrome could generate sdp with c = IN IP4 <ipv6 addr>\n    // in edge case and return error when set sdp.This is not a\n    // sdk error but correct it if the issue detected.\n    if (media.connection) {\n        const isV6 = media.connection.ip.indexOf(\":\") >= 0;\n        if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {\n            // fallback to dummy address\n            media.connection.ip = \"0.0.0.0\";\n            media.connection.version = 4;\n        }\n    }\n}\nconst defaultVideoCodec = \"vp8\";\nconst publishDefaults = {\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true\n};\nconst audioDefaults = {\n    deviceId: {\n        ideal: \"default\"\n    },\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true,\n    voiceIsolation: true\n};\nconst videoDefaults = {\n    deviceId: {\n        ideal: \"default\"\n    },\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    webAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n    PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n    PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n    PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, subscriberPrimary, loggerOptions){\n        var _a;\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.log = livekitLogger;\n        this.updateState = ()=>{\n            var _a;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === \"connected\")) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === \"failed\")) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === \"connecting\")) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === \"new\")) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n        this.loggerOptions = loggerOptions;\n        this.isPublisherConnectionRequired = !subscriberPrimary;\n        this.isSubscriberConnectionRequired = subscriberPrimary;\n        this.publisher = new PCTransport(rtcConfig, loggerOptions);\n        this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.subscriber.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.subscriber.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.subscriber.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.subscriber.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n        };\n        // in subscriber primary mode, server side opens sub data channels.\n        this.subscriber.onDataChannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.subscriber.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new _();\n        this.remoteOfferLock = new _();\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    requireSubscriber() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isSubscriberConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd) {\n        return this.publisher.setRemoteDescription(sd);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.publisher && this.publisher.getSignallingState() !== \"closed\") {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn't have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not removeTrack\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                this.subscriber.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.subscriber.restartingIce = true;\n            // only restart publisher if it's needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield this.subscriber.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"received server offer\", Object.assign(Object.assign({}, this.logContext), {\n                RTCSdpType: sd.type,\n                sdp: sd.sdp,\n                signalingState: this.subscriber.getSignallingState().toString()\n            }));\n            const unlock = yield this.remoteOfferLock.lock();\n            try {\n                yield this.subscriber.setRemoteDescription(sd);\n                // answer the offer\n                const answer = yield this.subscriber.createAndSetAnswer();\n                return answer;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        this.publisher.setConfiguration(config);\n        this.subscriber.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== \"connected\" && this.publisher.getConnectionState() !== \"connecting\") {\n                    this.log.debug(\"negotiation required, start negotiating\", this.logContext);\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject(\"negotiation timed out\");\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(\"negotiation aborted\");\n                    };\n                    abortController.signal.addEventListener(\"abort\", abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport's address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport_1, abortController_1) {\n        return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {\n            var _this = this;\n            let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n            return function*() {\n                const connectionState = pcTransport.getConnectionState();\n                if (connectionState === \"connected\") {\n                    return;\n                }\n                return new Promise((resolve, reject)=>__awaiter(_this, void 0, void 0, function*() {\n                        const abortHandler = ()=>{\n                            this.log.warn(\"abort transport connection\", this.logContext);\n                            CriticalTimers.clearTimeout(connectTimeout);\n                            reject(new ConnectionError(\"room connection has been cancelled\", ConnectionErrorReason.Cancelled));\n                        };\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            abortHandler();\n                        }\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", abortHandler);\n                        const connectTimeout = CriticalTimers.setTimeout(()=>{\n                            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                            reject(new ConnectionError(\"could not establish pc connection\", ConnectionErrorReason.InternalError));\n                        }, timeout);\n                        while(this.state !== PCTransportState.CONNECTED){\n                            yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                                reject(new ConnectionError(\"room connection has been cancelled\", ConnectionErrorReason.Cancelled));\n                                return;\n                            }\n                        }\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        resolve();\n                    }));\n            }();\n        });\n    }\n}\n// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Specialized error handling for RPC methods.\n *\n * Instances of this type, when thrown in a method handler, will have their `message`\n * serialized and sent across the wire. The sender will receive an equivalent error on the other side.\n *\n * Built-in types are included but developers may use any string, with a max length of 256 bytes.\n */ class RpcError extends Error {\n    /**\n   * Creates an error object with the given code and message, plus an optional data payload.\n   *\n   * If thrown in an RPC method handler, the error will be sent back to the caller.\n   *\n   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).\n   */ constructor(code, message, data){\n        super(message);\n        this.code = code;\n        this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);\n        this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;\n    }\n    /**\n   * @internal\n   */ static fromProto(proto) {\n        return new RpcError(proto.code, proto.message, proto.data);\n    }\n    /**\n   * @internal\n   */ toProto() {\n        return new RpcError$1({\n            code: this.code,\n            message: this.message,\n            data: this.data\n        });\n    }\n    /**\n   * Creates an error object from the code, with an auto-populated message.\n   *\n   * @internal\n   */ static builtIn(key, data) {\n        return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);\n    }\n}\nRpcError.MAX_MESSAGE_BYTES = 256;\nRpcError.MAX_DATA_BYTES = 15360; // 15 KB\nRpcError.ErrorCode = {\n    APPLICATION_ERROR: 1500,\n    CONNECTION_TIMEOUT: 1501,\n    RESPONSE_TIMEOUT: 1502,\n    RECIPIENT_DISCONNECTED: 1503,\n    RESPONSE_PAYLOAD_TOO_LARGE: 1504,\n    SEND_FAILED: 1505,\n    UNSUPPORTED_METHOD: 1400,\n    RECIPIENT_NOT_FOUND: 1401,\n    REQUEST_PAYLOAD_TOO_LARGE: 1402,\n    UNSUPPORTED_SERVER: 1403,\n    UNSUPPORTED_VERSION: 1404\n};\n/**\n * @internal\n */ RpcError.ErrorMessage = {\n    APPLICATION_ERROR: \"Application error in method handler\",\n    CONNECTION_TIMEOUT: \"Connection timeout\",\n    RESPONSE_TIMEOUT: \"Response timeout\",\n    RECIPIENT_DISCONNECTED: \"Recipient disconnected\",\n    RESPONSE_PAYLOAD_TOO_LARGE: \"Response payload too large\",\n    SEND_FAILED: \"Failed to send\",\n    UNSUPPORTED_METHOD: \"Method not supported at destination\",\n    RECIPIENT_NOT_FOUND: \"Recipient not found\",\n    REQUEST_PAYLOAD_TOO_LARGE: \"Request payload too large\",\n    UNSUPPORTED_SERVER: \"RPC not supported by server\",\n    UNSUPPORTED_VERSION: \"Unsupported RPC version\"\n};\n/*\n * Maximum payload size for RPC requests and responses. If a payload exceeds this size,\n * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.\n */ const MAX_PAYLOAD_BYTES = 15360; // 15 KB\n/**\n * @internal\n */ function byteLength(str) {\n    const encoder = new TextEncoder();\n    return encoder.encode(str).length;\n}\n/**\n * @internal\n */ function truncateBytes(str, maxBytes) {\n    if (byteLength(str) <= maxBytes) {\n        return str;\n    }\n    let low = 0;\n    let high = str.length;\n    const encoder = new TextEncoder();\n    while(low < high){\n        const mid = Math.floor((low + high + 1) / 2);\n        if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {\n            low = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return str.slice(0, low);\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if (\"bytesReceived\" in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if (\"bytesSent\" in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n    /** @internal */ get sender() {\n        return this._sender;\n    }\n    /** @internal */ set sender(sender) {\n        this._sender = sender;\n    }\n    get constraints() {\n        return this._constraints;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, kind, loggerOptions);\n        this.manuallyStopped = false;\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>this.log.debug(\"track mute bounce got cancelled by an unmute event\", this.logContext));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel(\"unmute\");\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new _();\n        this.pauseUpstreamLock = new _();\n        this.processorLock = new _();\n        this.restartLock = new _();\n        this.setMediaStreamTrack(mediaTrack, true);\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    get isLocal() {\n        return true;\n    }\n    /**\n   * @internal\n   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors\n   */ getSourceTrackSettings() {\n        return this._mediaStreamTrack.getSettings();\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel(\"new-track\");\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we'll need to signal with remote that\n                // the track is \"muted\"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener(\"mute\", this.handleTrackMuteEvent);\n                newTrack.addEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack) {\n                const unlock = yield this.processorLock.lock();\n                try {\n                    this.log.debug(\"restarting processor\", this.logContext);\n                    if (this.kind === \"unknown\") {\n                        throw TypeError(\"cannot set processor on track of unknown kind\");\n                    }\n                    if (this.processorElement) {\n                        attachToElement(newTrack, this.processorElement);\n                        // ensure the processorElement itself stays muted\n                        this.processorElement.muted = true;\n                    }\n                    yield this.processor.restart({\n                        track: newTrack,\n                        kind: this.kind,\n                        element: this.processorElement\n                    });\n                    processedTrack = this.processor.processedTrack;\n                } finally{\n                    unlock();\n                }\n            }\n            if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            // if `newTrack` is different from the existing track, stop the\n            // older track just before replacing it\n            if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                this._mediaStreamTrack.stop();\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we'd want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this = this;\n            let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n            return function*() {\n                var _a;\n                if (_this.kind === Track.Kind.Audio) {\n                    throw new Error(\"cannot get dimensions for audio tracks\");\n                }\n                if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === \"iOS\") {\n                    // browsers report wrong initial resolution on iOS.\n                    // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                    yield sleep(10);\n                }\n                const started = Date.now();\n                while(Date.now() - started < timeout){\n                    const dims = _this.dimensions;\n                    if (dims) {\n                        return dims;\n                    }\n                    yield sleep(50);\n                }\n                throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n            }();\n        });\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when track is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (this.isMuted) {\n                return true;\n            }\n            yield this.restartTrack();\n            return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this2 = this;\n            let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                // screen share doesn't have a usable device id\n                if (_this2.source === Track.Source.ScreenShare) {\n                    return;\n                }\n                const { deviceId, groupId } = _this2._mediaStreamTrack.getSettings();\n                const kind = _this2.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n                return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;\n            }();\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track, userProvidedOrOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new TrackInvalidError(\"unable to replace an unpublished track\");\n            }\n            let userProvidedTrack;\n            let stopProcessor;\n            if (typeof userProvidedOrOptions === \"boolean\") {\n                userProvidedTrack = userProvidedOrOptions;\n            } else if (userProvidedOrOptions !== undefined) {\n                userProvidedTrack = userProvidedOrOptions.userProvidedTrack;\n                stopProcessor = userProvidedOrOptions.stopProcessor;\n            }\n            this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;\n            this.log.debug(\"replace MediaStreamTrack\", this.logContext);\n            yield this.setMediaStreamTrack(track);\n            // this must be synced *after* setting mediaStreamTrack above, since it relies\n            // on the previous state in order to cleanup\n            if (stopProcessor && this.processor) {\n                yield this.stopProcessor();\n            }\n            return this;\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.manuallyStopped = false;\n            const unlock = yield this.restartLock.lock();\n            try {\n                if (!constraints) {\n                    constraints = this._constraints;\n                }\n                const { deviceId, facingMode } = constraints, otherConstraints = __rest(constraints, [\n                    \"deviceId\",\n                    \"facingMode\"\n                ]);\n                this.log.debug(\"restarting track with constraints\", Object.assign(Object.assign({}, this.logContext), {\n                    constraints\n                }));\n                const streamConstraints = {\n                    audio: false,\n                    video: false\n                };\n                if (this.kind === Track.Kind.Video) {\n                    streamConstraints.video = deviceId || facingMode ? {\n                        deviceId,\n                        facingMode\n                    } : true;\n                } else {\n                    streamConstraints.audio = deviceId ? {\n                        deviceId\n                    } : true;\n                }\n                // these steps are duplicated from setMediaStreamTrack because we must stop\n                // the previous tracks before new tracks can be acquired\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this.mediaStreamTrack, el);\n                });\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                // on Safari, the old audio track must be stopped before attempting to acquire\n                // the new track, otherwise the new track will stop with\n                // 'A MediaStreamTrack ended due to a capture failure`\n                this._mediaStreamTrack.stop();\n                // create new track and attach\n                const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n                const newTrack = mediaStream.getTracks()[0];\n                yield newTrack.applyConstraints(otherConstraints);\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                this.log.debug(\"re-acquired MediaStreamTrack\", this.logContext);\n                yield this.setMediaStreamTrack(newTrack);\n                this._constraints = constraints;\n                this.emit(TrackEvent.Restarted, this);\n                if (this.manuallyStopped) {\n                    this.log.warn(\"track was stopped during a restart, stopping restarted track\", this.logContext);\n                    this.stop();\n                }\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? \"muted\" : \"unmuted\"), this.logContext);\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        this.manuallyStopped = true;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n        this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to pause upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Safari\" && compareVersions(browser.version, \"12.0\") < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError(\"pauseUpstream is not supported on Safari < 12.\");\n                }\n                if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                    yield this.sender.replaceTrack(null);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to resume upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                    // this operation is noop if mediastreamtrack is already being sent\n                    yield this.sender.replaceTrack(this.mediaStreamTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor_1) {\n        return __awaiter(this, arguments, void 0, function(processor) {\n            var _this3 = this;\n            let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a;\n                const unlock = yield _this3.processorLock.lock();\n                try {\n                    _this3.log.debug(\"setting up processor\", _this3.logContext);\n                    const processorElement = document.createElement(_this3.kind);\n                    const processorOptions = {\n                        kind: _this3.kind,\n                        track: _this3._mediaStreamTrack,\n                        element: processorElement,\n                        audioContext: _this3.audioContext\n                    };\n                    yield processor.init(processorOptions);\n                    _this3.log.debug(\"processor initialized\", _this3.logContext);\n                    if (_this3.processor) {\n                        yield _this3.stopProcessor();\n                    }\n                    if (_this3.kind === \"unknown\") {\n                        throw TypeError(\"cannot set processor on track of unknown kind\");\n                    }\n                    attachToElement(_this3._mediaStreamTrack, processorElement);\n                    processorElement.muted = true;\n                    processorElement.play().catch((error)=>_this3.log.error(\"failed to play processor element\", Object.assign(Object.assign({}, _this3.logContext), {\n                            error\n                        })));\n                    _this3.processor = processor;\n                    _this3.processorElement = processorElement;\n                    if (_this3.processor.processedTrack) {\n                        for (const el of _this3.attachedElements){\n                            if (el !== _this3.processorElement && showProcessedStreamLocally) {\n                                detachTrack(_this3._mediaStreamTrack, el);\n                                attachToElement(_this3.processor.processedTrack, el);\n                            }\n                        }\n                        yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);\n                    }\n                    _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);\n                } finally{\n                    unlock();\n                }\n            }();\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this4 = this;\n            let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                var _a, _b;\n                if (!_this4.processor) return;\n                _this4.log.debug(\"stopping processor\", _this4.logContext);\n                (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n                yield _this4.processor.destroy();\n                _this4.processor = undefined;\n                if (!keepElement) {\n                    (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n                    _this4.processorElement = undefined;\n                }\n                // apply original track constraints in case the processor changed them\n                yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);\n                // force re-setting of the mediaStreamTrack on the sender\n                yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);\n                _this4.emit(TrackEvent.TrackProcessorUpdate);\n            }();\n        });\n    }\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   * boolean indicating whether enhanced noise cancellation is currently being used on this track\n   */ get enhancedNoiseCancellation() {\n        return this.isKrispNoiseFilterEnabled;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n        /** @internal */ this.stopOnMute = false;\n        this.isKrispNoiseFilterEnabled = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.handleKrispNoiseFilterEnable = ()=>{\n            this.isKrispNoiseFilterEnabled = true;\n            this.log.debug(\"Krisp noise filter enabled\", this.logContext);\n            this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);\n        };\n        this.handleKrispNoiseFilterDisable = ()=>{\n            this.isKrispNoiseFilterEnabled = false;\n            this.log.debug(\"Krisp noise filter disabled\", this.logContext);\n            this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);\n        };\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.isMuted) {\n                    this.log.debug(\"Track already muted\", this.logContext);\n                    return this;\n                }\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    this.log.debug(\"stopping mic track\", this.logContext);\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (!this.isMuted) {\n                    this.log.debug(\"Track already unmuted\", this.logContext);\n                    return this;\n                }\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\" || deviceHasChanged) && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring mic track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== \"boolean\") {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.processorLock.lock();\n            try {\n                if (!isReactNative() && !this.audioContext) {\n                    throw Error(\"Audio context needs to be set on LocalAudioTrack in order to enable processors\");\n                }\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    // RN won't have or use AudioContext\n                    audioContext: this.audioContext\n                };\n                this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                    this.processor.processedTrack.addEventListener(\"enable-lk-krisp-noise-filter\", this.handleKrispNoiseFilterEnable);\n                    this.processor.processedTrack.addEventListener(\"disable-lk-krisp-noise-filter\", this.handleKrispNoiseFilterDisable);\n                }\n                this.emit(TrackEvent.TrackProcessorUpdate, this.processor);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === \"outbound-rtp\") {\n                    audioStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    this.log.warn(\"silence detected on local audio track\", this.logContext);\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n    switch(mediaStreamTrack.kind){\n        case \"audio\":\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n        case \"video\":\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n        default:\n            throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: fromPreset.encoding.maxFramerate\n        }\n    ];\n    return layers.map((t)=>{\n        var _a, _b;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    \"q\",\n    \"h\",\n    \"f\"\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren't simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug(\"using video encoding\", videoEncoding);\n    }\n    const sourceFramerate = videoEncoding.maxFramerate;\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n        }\n        // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated\n        // that SVC mode should be used. Safari still works this way.\n        // This is a bit confusing but is due to how libwebrtc interpreted the encodings field\n        // before M113.\n        // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1\n        const browser = getBrowser();\n        if (isSafari() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding\n        // is provided. So we'll use the legacy SVC specification for now.\n        // TODO: when we upstream libwebrtc, this will need additional verification\n        isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, \"113\") < 0) {\n            const bitratesRatio = sm.suffix == \"h\" ? 2 : 3;\n            for(let i = 0; i < sm.spatial; i += 1){\n                // in legacy SVC, scaleResolutionDownBy cannot be set\n                encodings.push({\n                    rid: videoRids[2 - i],\n                    maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),\n                    maxFramerate: original.encoding.maxFramerate\n                });\n            }\n            // legacy SVC, scalabilityMode is set only on the first encoding\n            /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        } else {\n            encodings.push({\n                maxBitrate: videoEncoding.maxBitrate,\n                maxFramerate: original.encoding.maxFramerate,\n                /* @ts-ignore */ scalabilityMode: scalabilityMode\n            });\n        }\n        if (original.encoding.priority) {\n            encodings[0].priority = original.encoding.priority;\n            encodings[0].networkPriority = original.encoding.priority;\n        }\n        livekitLogger.debug(\"using svc encoding\", {\n            encodings\n        });\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. livekit-server translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ], sourceFramerate);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ], sourceFramerate);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn(\"requested a different codec than specified as backup\", {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    // disable simulcast for screenshare backup codec since L1Tx is used by primary codec\n    if (track.source === Track.Source.ScreenShare && opts.simulcast) {\n        opts.simulcast = false;\n    }\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case \"av1\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case \"vp9\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets, sourceFramerate) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        // ensure that the sourceFramerate is the highest framerate applied across all layers so that the\n        // original encoding doesn't get bumped unintentionally by any of the other layers\n        const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;\n        if (maxFramerate) {\n            encoding.maxFramerate = maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === \"ios\") {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n                }\n                livekitLogger.info('Setting framerate of encoding \"'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\", '\" to ').concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error(\"invalid scalability mode\");\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case \"h\":\n                case \"_KEY\":\n                case \"_KEY_SHIFT\":\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : \"\");\n    }\n}\nfunction getDefaultDegradationPreference(track) {\n    // a few of reasons we have different default paths:\n    // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue\n    // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`\n    if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {\n        return \"maintain-resolution\";\n    } else {\n        return \"balanced\";\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    get sender() {\n        return this._sender;\n    }\n    set sender(sender) {\n        this._sender = sender;\n        if (this.degradationPreference) {\n            this.setDegradationPreference(this.degradationPreference);\n        }\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.degradationPreference = \"balanced\";\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new _();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_1, _b, _c;\n            var _d;\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_2, _b, _c;\n            var _d;\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.isMuted) {\n                    this.log.debug(\"Track already muted\", this.logContext);\n                    return this;\n                }\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"stopping camera track\", this.logContext);\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (!this.isMuted) {\n                    this.log.debug(\"Track already unmuted\", this.logContext);\n                    return this;\n                }\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring camera track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === \"outbound-rtp\") {\n                    const vs = {\n                        type: \"video\",\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        framesPerSecond: v.framesPerSecond,\n                        framesSent: v.framesSent,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationDurations: v.qualityLimitationDurations,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        targetBitrate: v.targetBitrate,\n                        timestamp: v.timestamp\n                    };\n                    //locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            // make sure highest res layer is always first\n            items.sort((a, b)=>{\n                var _a, _b;\n                return ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n        this.setPublishingLayers(qualities);\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_3, _b, _c;\n            var _d;\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== \"boolean\") {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== \"closed\") {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor_1) {\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        return __awaiter(this, arguments, void 0, function(processor) {\n            var _this = this;\n            let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a, e_4, _b, _c;\n                var _d, _e;\n                yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);\n                if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                    try {\n                        for(var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                            _c = _h.value;\n                            _f = false;\n                            const sc = _c;\n                            yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);\n                        }\n                    } catch (e_4_1) {\n                        e_4 = {\n                            error: e_4_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                        } finally{\n                            if (e_4) throw e_4.error;\n                        }\n                    }\n                }\n            }();\n        });\n    }\n    setDegradationPreference(preference) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.degradationPreference = preference;\n            if (this.sender) {\n                try {\n                    this.log.debug(\"setting degradationPreference to \".concat(preference), this.logContext);\n                    const params = this.sender.getParameters();\n                    params.degradationPreference = preference;\n                    this.sender.setParameters(params);\n                } catch (e) {\n                    this.log.warn(\"failed to set degradationPreference\", Object.assign({\n                        error: e\n                    }, this.logContext));\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            this.log.error(\"\".concat(codec, \" already added, skipping adding simulcast codec\"), this.logContext);\n            return;\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, codecs_1, codecs_1_1;\n            var _b, e_5, _c, _d;\n            this.log.debug(\"setting publishing codecs\", Object.assign(Object.assign({}, this.logContext), {\n                codecs,\n                currentCodec: this.codec\n            }));\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n                            simulcastCodecInfo\n                        }));\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"setting publishing layers\", Object.assign(Object.assign({}, this.logContext), {\n                qualities\n            }));\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log, logContext) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        log.debug(\"setPublishingLayersForSender\", Object.assign(Object.assign({}, logContext), {\n            sender,\n            qualities,\n            senderEncodings\n        }));\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                log.warn(\"cannot set publishing layers, encodings mismatch\", Object.assign(Object.assign({}, logContext), {\n                    encodings,\n                    senderEncodings\n                }));\n                return;\n            }\n            let hasChanged = false;\n            const browser = getBrowser();\n            const closableSpatial = (browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, \"133\") > 0;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) {\n                // svc dynacast encodings\n                const encoding = encodings[0];\n                /* @ts-ignore */ const mode = new ScalabilityMode(encoding.scalabilityMode);\n                let maxQuality = VideoQuality$1.OFF;\n                qualities.forEach((q)=>{\n                    if (q.enabled && (maxQuality === VideoQuality$1.OFF || q.quality > maxQuality)) {\n                        maxQuality = q.quality;\n                    }\n                });\n                if (maxQuality === VideoQuality$1.OFF) {\n                    if (encoding.active) {\n                        encoding.active = false;\n                        hasChanged = true;\n                    }\n                } else if (!encoding.active || mode.spatial !== maxQuality + 1) {\n                    hasChanged = true;\n                    encoding.active = true;\n                    /* @ts-ignore */ const originalMode = new ScalabilityMode(senderEncodings[0].scalabilityMode);\n                    mode.spatial = maxQuality + 1;\n                    mode.suffix = originalMode.suffix;\n                    if (mode.spatial === 1) {\n                        // no suffix for L1Tx\n                        mode.suffix = undefined;\n                    }\n                    /* @ts-ignore */ encoding.scalabilityMode = mode.toString();\n                    encoding.scaleResolutionDownBy = Math.pow(2, 2 - maxQuality);\n                    if (senderEncodings[0].maxBitrate) {\n                        encoding.maxBitrate = senderEncodings[0].maxBitrate / (encoding.scaleResolutionDownBy * encoding.scaleResolutionDownBy);\n                    }\n                }\n            } else {\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\";\n                    if (rid === \"\") {\n                        rid = \"q\";\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? \"enabled\" : \"disabled\"), logContext);\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n                    encodings: params.encodings\n                }));\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case \"f\":\n            return VideoQuality.HIGH;\n        case \"h\":\n            return VideoQuality.MEDIUM;\n        case \"q\":\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        const resRatio = sm.suffix == \"h\" ? 1.5 : 2;\n        const bitratesRatio = sm.suffix == \"h\" ? 2 : 3;\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,\n                width: Math.ceil(width / Math.pow(resRatio, i)),\n                height: Math.ceil(height / Math.pow(resRatio, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : \"\");\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nconst lossyDataChannel = \"_lossy\";\nconst reliableDataChannel = \"_reliable\";\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = \"leave-reconnect\";\nvar PCState;\n(function(PCState) {\n    PCState[PCState[\"New\"] = 0] = \"New\";\n    PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n    PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n    PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n    PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    get pendingReconnect() {\n        return !!this.reconnectTimeout;\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.log = livekitLogger;\n        this.handleDataChannel = (_a)=>__awaiter(this, [\n                _a\n            ], void 0, function(_ref) {\n                var _this = this;\n                let { channel } = _ref;\n                return function*() {\n                    if (!channel) {\n                        return;\n                    }\n                    if (channel.label === reliableDataChannel) {\n                        _this.reliableDCSub = channel;\n                    } else if (channel.label === lossyDataChannel) {\n                        _this.lossyDCSub = channel;\n                    } else {\n                        return;\n                    }\n                    _this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), _this.logContext);\n                    channel.onmessage = _this.handleDataMessage;\n                }();\n            });\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        this.log.error(\"unsupported data type\", Object.assign(Object.assign({}, this.logContext), {\n                            data: message.data\n                        }));\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === \"speaker\") {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else {\n                        if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === \"user\") {\n                            // compatibility\n                            applyUserDataCompat(dp, dp.value.value);\n                        }\n                        this.emit(EngineEvent.DataPacketReceived, dp);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n                    error\n                }));\n            } else {\n                this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n                    event\n                }));\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we'll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason).finally(()=>this.reconnectTimeout = undefined), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== \"undefined\" && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>{\n            // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n            if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n                this.clearReconnectTimeout();\n                this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n            }\n        };\n        this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n        this.loggerOptions = {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.logContext\n        };\n        this.client = new SignalClient(undefined, this.loggerOptions);\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.registerOnLineListener();\n        this.closingLock = new _();\n        this.dataProcessLock = new _();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n        this.client.onRequestResponse = (response)=>this.emit(EngineEvent.SignalRequestResponse, response);\n    }\n    /** @internal */ get logContext() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return {\n            room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n            roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n            participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,\n            pID: (_h = (_g = this.latestJoinResponse) === null || _g === void 0 ? void 0 : _g.participant) === null || _h === void 0 ? void 0 : _h.sid\n        };\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary || joinResponse.fastPublish) {\n                    this.negotiate();\n                }\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                // emit signal connected event after a short delay to allow for join response to be processed on room\n                setTimeout(()=>{\n                    this.emit(EngineEvent.SignalConnected);\n                }, 10);\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === ConnectionErrorReason.ServerUnreachable) {\n                        this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.joinAttempts = 0;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError(\"a track with the same ID has already been published\");\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError(\"publication of local track timed out, no response from server\", ConnectionErrorReason.InternalError));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error(\"Cancelled publication by calling unpublish\"));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            this.log.warn(\"failed to remove track\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer)=>{\n                this.client.sendOffer(offer);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n                    if ([\n                        \"closed\",\n                        \"disconnected\",\n                        \"failed\"\n                    ].includes(publisherState)) {\n                        // reset publisher connection promise\n                        this.publisherConnectionPromise = undefined;\n                    }\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n                        if (this.pcState === PCState.Connected) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect(\"peerconnection failed\", subscriberState === \"failed\" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                    // detect cases where both signal client and peer connection are severed and assume that user has lost network connection\n                    const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;\n                    const isPCSevered = [\n                        PCTransportState.FAILED,\n                        PCTransportState.CLOSING,\n                        PCTransportState.CLOSED\n                    ].includes(connectionState);\n                    if (isSignalSevered && isPCSevered && !this._isClosed) {\n                        this.emit(EngineEvent.Offline);\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {\n                this.createDataChannels();\n            }\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                this.log.debug(\"received server answer\", Object.assign(Object.assign({}, this.logContext), {\n                    RTCSdpType: sd.type\n                }));\n                yield this.pcManager.setPublisherAnswer(sd);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            this.log.debug(\"got ICE candidate from peer\", Object.assign(Object.assign({}, this.logContext), {\n                candidate,\n                target\n            }));\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n                this.client.sendAnswer(answer);\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            var _a;\n            this.log.debug(\"received trackPublishedResponse\", Object.assign(Object.assign({}, this.logContext), {\n                cid: res.cid,\n                track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n            }));\n            if (!this.pendingTrackResolvers[res.cid]) {\n                this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n                    cid: res.cid\n                }));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onLocalTrackUnpublished = (response)=>{\n            this.emit(EngineEvent.LocalTrackUnpublished, response);\n        };\n        this.client.onLocalTrackSubscribed = (trackSid)=>{\n            this.emit(EngineEvent.LocalTrackSubscribed, trackSid);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            this.token = token;\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            this.log.debug(\"client leave request\", Object.assign(Object.assign({}, this.logContext), {\n                reason: leave === null || leave === void 0 ? void 0 : leave.reason\n            }));\n            if (leave.regions && this.regionUrlProvider) {\n                this.log.debug(\"updating regions\", this.logContext);\n                this.regionUrlProvider.setServerReportedRegions(leave.regions);\n            }\n            switch(leave.action){\n                case LeaveRequest_Action.DISCONNECT:\n                    this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                    this.close();\n                    break;\n                case LeaveRequest_Action.RECONNECT:\n                    this.fullReconnectOnNext = true;\n                    // reconnect immediately instead of waiting for next attempt\n                    this.handleDisconnect(leaveReconnect);\n                    break;\n                case LeaveRequest_Action.RESUME:\n                    // reconnect immediately instead of waiting for next attempt\n                    this.handleDisconnect(leaveReconnect);\n            }\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            this.log.debug(\"E2EE - setting up transports with insertable streams\", this.logContext);\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = \"relay\";\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = \"unified-plan\";\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = \"gather_continually\";\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            // will drop older packets that arrive\n            ordered: true,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                this.log.warn(\"using add-track fallback\", this.logContext);\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                this.log.debug(\"using add-track fallback\", this.logContext);\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            if (isVideoTrack(track)) {\n                track.codec = opts.videoCodec;\n            }\n            const transceiverInit = {\n                direction: \"sendonly\",\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const transceiverInit = {\n                direction: \"sendonly\"\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                livekitLogger.warn(\"already attempting reconnect, returning early\", this.logContext);\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    this.log.debug(\"received unrecoverable error\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKNOWN);\n                } else {\n                    this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            this.log.warn(\"encountered error in reconnect policy\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don't attempt reconnection\n                    throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n                }\n                this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        this.log.warn(\"attempted connection restart, without signal options present\", this.logContext);\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {\n                        throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error(\"simulated failure\");\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                // re-check signal connection state before setting engine as resumed\n                if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                    throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n                }\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we're not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!this.url || !this.token) {\n                // permanent failure, don't attempt reconnection\n                throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n            }\n            this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n            this.emit(EngineEvent.Resuming);\n            let res;\n            try {\n                this.setupSignalClientCallbacks();\n                res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n            } catch (error) {\n                let message = \"\";\n                if (error instanceof Error) {\n                    message = error.message;\n                    this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\n                    throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                }\n                if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {\n                    throw error;\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (res) {\n                const rtcConfig = this.makeRTCConfiguration(res);\n                this.pcManager.updateConfiguration(rtcConfig);\n            } else {\n                this.log.warn(\"Did not receive reconnect response\", this.logContext);\n            }\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error(\"simulated failure\");\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            // re-check signal connection state before setting engine as resumed\n            if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n            }\n            this.client.setReconnected();\n            // recreate publish datachannel if it's id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\" && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"PC manager is closed\");\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            this.log.debug(\"waiting for peer connection to reconnect\", this.logContext);\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError(\"could not establish PC connection, \".concat(e.message), ConnectionErrorReason.InternalError);\n            }\n        });\n    }\n    /** @internal */ publishRpcResponse(destinationIdentity, requestId, payload, error) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcResponse\",\n                    value: new RpcResponse({\n                        requestId,\n                        value: error ? {\n                            case: \"error\",\n                            value: error.toProto()\n                        } : {\n                            case: \"payload\",\n                            value: payload !== null && payload !== void 0 ? payload : \"\"\n                        }\n                    })\n                }\n            });\n            yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /** @internal */ publishRpcAck(destinationIdentity, requestId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcAck\",\n                    value: new RpcAck({\n                        requestId\n                    })\n                }\n            });\n            yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = packet.toBinary();\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    waitForBufferStatusLow(kind) {\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                if (this.isBufferStatusLow(kind)) {\n                    resolve();\n                } else {\n                    const onClosing = ()=>reject(\"Engine closed\");\n                    this.once(EngineEvent.Closing, onClosing);\n                    while(!this.dcBufferStatus.get(kind)){\n                        yield sleep(10);\n                    }\n                    this.off(EngineEvent.Closing, onClosing);\n                    resolve();\n                }\n            }));\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind_1) {\n        return __awaiter(this, arguments, void 0, function(kind) {\n            var _this2 = this;\n            let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n            return function*() {\n                var _a;\n                if (!_this2.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;\n                const transportName = subscriber ? \"Subscriber\" : \"Publisher\";\n                if (!transport) {\n                    throw new ConnectionError(\"\".concat(transportName, \" connection not set\"), ConnectionErrorReason.InternalError);\n                }\n                let needNegotiation = false;\n                if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {\n                    _this2.createDataChannels();\n                    needNegotiation = true;\n                }\n                if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== \"checking\") {\n                    needNegotiation = true;\n                }\n                if (needNegotiation) {\n                    // start negotiation\n                    _this2.negotiate();\n                }\n                const targetChannel = _this2.dataChannelForKind(kind, subscriber);\n                if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === \"open\") {\n                    return;\n                }\n                // wait until ICE connected\n                const endTime = new Date().getTime() + _this2.peerConnectionTimeout;\n                while(new Date().getTime() < endTime){\n                    if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\") {\n                        return;\n                    }\n                    yield sleep(50);\n                }\n                throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);\n            }();\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.publisherConnectionPromise) {\n                this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);\n            }\n            yield this.publisherConnectionPromise;\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError(\"PC manager is closed\"));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed\n                    if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {\n                        this.createDataChannels();\n                    }\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        this.log.debug(\"engine disconnected while negotiation was ongoing\", this.logContext);\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject(\"cannot negotiate on closed engine\");\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b;\n        if (!this.pcManager) {\n            this.log.warn(\"sync state cannot be sent without peer connection setup\", this.logContext);\n            return;\n        }\n        const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n        const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n        const trackSids = new Array();\n        const trackSidsDisabled = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n            if (!track.isEnabled) {\n                trackSidsDisabled.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: previousAnswer ? toProtoSessionDescription({\n                sdp: previousAnswer.sdp,\n                type: previousAnswer.type\n            }) : undefined,\n            offer: previousOffer ? toProtoSessionDescription({\n                sdp: previousOffer.sdp,\n                type: previousOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo(),\n            trackSidsDisabled\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nfunction supportOptionalDatachannel(protocol) {\n    return protocol !== undefined && protocol > 13;\n}\nfunction applyUserDataCompat(newObj, oldObj) {\n    const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;\n    newObj.participantIdentity = participantIdentity;\n    oldObj.participantIdentity = participantIdentity;\n    const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;\n    newObj.destinationIdentities = destinationIdentities;\n    oldObj.destinationIdentities = destinationIdentities;\n}\nclass RegionUrlProvider {\n    constructor(url, token){\n        this.lastUpdateAt = 0;\n        this.settingsCacheTime = 3000;\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n            }\n            if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n                this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n            }\n            const regionsLeft = this.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    /* @internal */ fetchRegionSettings(signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n                headers: {\n                    authorization: \"Bearer \".concat(this.token)\n                },\n                signal\n            });\n            if (regionSettingsResponse.ok) {\n                const regionSettings = yield regionSettingsResponse.json();\n                this.lastUpdateAt = Date.now();\n                return regionSettings;\n            } else {\n                throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);\n            }\n        });\n    }\n    setServerReportedRegions(regions) {\n        this.regionSettings = regions;\n        this.lastUpdateAt = Date.now();\n    }\n}\nfunction getCloudConfigUrl(serverUrl) {\n    return \"\".concat(serverUrl.protocol.replace(\"ws\", \"http\"), \"//\").concat(serverUrl.host, \"/settings\");\n}\nclass BaseStreamReader {\n    get info() {\n        return this._info;\n    }\n    constructor(info, stream, totalByteSize){\n        this.reader = stream;\n        this.totalByteSize = totalByteSize;\n        this._info = info;\n        this.bytesReceived = 0;\n    }\n}\nclass ByteStreamReader extends BaseStreamReader {\n    handleChunkReceived(chunk) {\n        var _a;\n        this.bytesReceived += chunk.content.byteLength;\n        const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n        (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n    }\n    [Symbol.asyncIterator]() {\n        const reader = this.reader.getReader();\n        return {\n            next: ()=>__awaiter(this, void 0, void 0, function*() {\n                    try {\n                        const { done, value } = yield reader.read();\n                        if (done) {\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        } else {\n                            this.handleChunkReceived(value);\n                            return {\n                                done: false,\n                                value: value.content\n                            };\n                        }\n                    } catch (error) {\n                        // TODO handle errors\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                }),\n            return () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    reader.releaseLock();\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                });\n            }\n        };\n    }\n    readAll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_1, _b, _c;\n            let chunks = new Set();\n            try {\n                for(var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const chunk = _c;\n                    chunks.add(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            return Array.from(chunks);\n        });\n    }\n}\n/**\n * A class to read chunks from a ReadableStream and provide them in a structured format.\n */ class TextStreamReader extends BaseStreamReader {\n    /**\n   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string\n   * that has been received up to the current point in time.\n   */ constructor(info, stream, totalChunkCount){\n        super(info, stream, totalChunkCount);\n        this.receivedChunks = new Map();\n    }\n    handleChunkReceived(chunk) {\n        var _a;\n        const index = bigIntToNumber(chunk.chunkIndex);\n        const previousChunkAtIndex = this.receivedChunks.get(index);\n        if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {\n            // we have a newer version already, dropping the old one\n            return;\n        }\n        this.receivedChunks.set(index, chunk);\n        this.bytesReceived += chunk.content.byteLength;\n        const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n        (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n    }\n    /**\n   * Async iterator implementation to allow usage of `for await...of` syntax.\n   * Yields structured chunks from the stream.\n   *\n   */ [Symbol.asyncIterator]() {\n        const reader = this.reader.getReader();\n        const decoder = new TextDecoder();\n        return {\n            next: ()=>__awaiter(this, void 0, void 0, function*() {\n                    try {\n                        const { done, value } = yield reader.read();\n                        if (done) {\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        } else {\n                            this.handleChunkReceived(value);\n                            return {\n                                done: false,\n                                value: decoder.decode(value.content)\n                            };\n                        }\n                    } catch (error) {\n                        // TODO handle errors\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                }),\n            return () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    reader.releaseLock();\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                });\n            }\n        };\n    }\n    readAll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_2, _b, _c;\n            let finalString = \"\";\n            try {\n                for(var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const chunk = _c;\n                    finalString += chunk;\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n            return finalString;\n        });\n    }\n}\nclass BaseStreamWriter {\n    constructor(writableStream, info, onClose){\n        this.writableStream = writableStream;\n        this.defaultWriter = writableStream.getWriter();\n        this.onClose = onClose;\n        this.info = info;\n    }\n    write(chunk) {\n        return this.defaultWriter.write(chunk);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield this.defaultWriter.close();\n            this.defaultWriter.releaseLock();\n            (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\nclass TextStreamWriter extends BaseStreamWriter {\n}\nclass ByteStreamWriter extends BaseStreamWriter {\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver, loggerOptions){\n        super(mediaTrack, kind, loggerOptions);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener(\"removetrack\", onRemoveTrack);\n                if (this.receiver && \"playoutDelayHint\" in this.receiver) {\n                    this.receiver.playoutDelayHint = undefined;\n                }\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener(\"removetrack\", onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Allows to set a playout delay (in seconds) for this track.\n   * A higher value allows for more buffering of the track in the browser\n   * and will result in a delay of media being played back of `delayInSeconds`\n   */ setPlayoutDelay(delayInSeconds) {\n        if (this.receiver) {\n            if (\"playoutDelayHint\" in this.receiver) {\n                this.receiver.playoutDelayHint = delayInSeconds;\n            } else {\n                this.log.warn(\"Playout delay not supported in this browser\");\n            }\n        } else {\n            this.log.warn(\"Cannot set playout delay, track already ended\");\n        }\n    }\n    /**\n   * Returns the current playout delay (in seconds) of this track.\n   */ getPlayoutDelay() {\n        if (this.receiver) {\n            if (\"playoutDelayHint\" in this.receiver) {\n                return this.receiver.playoutDelayHint;\n            } else {\n                this.log.warn(\"Playout delay not supported in this browser\");\n            }\n        } else {\n            this.log.warn(\"Cannot get playout delay, track already ended\");\n        }\n        return 0;\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n        if (supportsSynchronizationSources()) {\n            this.registerTimeSyncUpdate();\n        }\n    }\n    registerTimeSyncUpdate() {\n        const loop = ()=>{\n            var _a;\n            this.timeSyncHandle = requestAnimationFrame(()=>loop());\n            const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];\n            if (sources) {\n                const { timestamp, rtpTimestamp } = sources;\n                if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {\n                    this.emit(TrackEvent.TimeSyncUpdate, {\n                        timestamp,\n                        rtpTimestamp\n                    });\n                    this.rtpTimestamp = rtpTimestamp;\n                }\n            }\n        };\n        loop();\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn't been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            /* @ts-ignore */ element.setSinkId(this.sinkId);\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            this.log.debug(\"using audio context mapping\", this.logContext);\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn't running already\n        if (context.state !== \"running\") {\n            context.resume().then(()=>{\n                if (context.state !== \"running\") {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    receiverStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It's possible attach is called multiple times on an element. When that's\n        // the case, we'd want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            this.log.warn(\"visibility resize observer not triggered\", this.logContext);\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            this.log.warn(\"stopObservingElementInfo ignored\", this.logContext);\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = \"\";\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: \"video\",\n                        streamId: v.id,\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === \"codec\") {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== \"\" && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility() {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === \"screen\") {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we'll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we'll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.isPiP = isElementInPiP(this.element);\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a, _b, _c;\n            (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener(\"pagehide\", this.onLeavePiP);\n            this.isPiP = isElementInPiP(this.element);\n            (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = isElementInPiP(this.element);\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && isElementInPiP(element);\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        var _a, _b, _c;\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = isElementInPiP(this.element);\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n        (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener(\"enter\", this.onEnterPiP);\n        (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener(\"pagehide\", this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b, _c, _d, _e;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n        (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener(\"enter\", this.onEnterPiP);\n        (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener(\"pagehide\", this.onLeavePiP);\n    }\n}\nfunction isElementInPiP(el) {\n    var _a, _b;\n    // Simple video PiP\n    if (document.pictureInPictureElement === el) return true;\n    // Document PiP\n    if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);\n    return false;\n}\n// does not account for occlusion by other elements or opacity property\nfunction isElementInViewport(el, win) {\n    const viewportWindow = win || window;\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== \"none\";\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name, loggerOptions){\n        var _a;\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.log = livekitLogger;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n        this.loggerContextCb = this.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (isAudioTrack(this.track)) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (isVideoTrack(this.track)) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        this.log.debug(\"update publication info\", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus[\"Desired\"] = \"desired\";\n        SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n        SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus[\"Allowed\"] = \"allowed\";\n        PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    get isLocal() {\n        return true;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n    getTrackFeatures() {\n        var _a;\n        if (isAudioTrack(this.track)) {\n            const settings = this.track.getSourceTrackSettings();\n            const features = new Set();\n            if (settings.autoGainControl) {\n                features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\n            }\n            if (settings.echoCancellation) {\n                features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);\n            }\n            if (settings.noiseSuppression) {\n                features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);\n            }\n            if (settings.channelCount && settings.channelCount > 1) {\n                features.add(AudioTrackFeature.TF_STEREO);\n            }\n            if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {\n                features.add(AudioTrackFeature.TF_NO_DTX);\n            }\n            if (this.track.enhancedNoiseCancellation) {\n                features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);\n            }\n            return Array.from(features.values());\n        } else return [];\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options, loggerOptions) {\n    return __awaiter(this, void 0, void 0, function*() {\n        // set default options to true\n        const internalOptions = Object.assign({}, options !== null && options !== void 0 ? options : {});\n        let attemptExactMatch = false;\n        let retryAudioOptions = options === null || options === void 0 ? void 0 : options.audio;\n        let retryVideoOptions = options === null || options === void 0 ? void 0 : options.video;\n        // if the user passes a device id as a string, we default to exact match\n        if (internalOptions.audio && typeof internalOptions.audio === \"object\" && typeof internalOptions.audio.deviceId === \"string\") {\n            const deviceId = internalOptions.audio.deviceId;\n            internalOptions.audio.deviceId = {\n                exact: deviceId\n            };\n            attemptExactMatch = true;\n            retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {\n                deviceId: {\n                    ideal: deviceId\n                }\n            });\n        }\n        if (internalOptions.video && typeof internalOptions.video === \"object\" && typeof internalOptions.video.deviceId === \"string\") {\n            const deviceId = internalOptions.video.deviceId;\n            internalOptions.video.deviceId = {\n                exact: deviceId\n            };\n            attemptExactMatch = true;\n            retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {\n                deviceId: {\n                    ideal: deviceId\n                }\n            });\n        }\n        // TODO if internal options don't have device Id specified, set it to 'default'\n        if (internalOptions.audio === true || typeof internalOptions.audio === \"object\" && !internalOptions.audio.deviceId) {\n            internalOptions.audio = {\n                deviceId: \"default\"\n            };\n        }\n        if (internalOptions.video === true || typeof internalOptions.video === \"object\" && !internalOptions.video.deviceId) {\n            internalOptions.video = {\n                deviceId: \"default\"\n            };\n        }\n        const { audioProcessor, videoProcessor } = extractProcessorsFromOptions(internalOptions);\n        const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (internalOptions.audio) {\n            DeviceManager.userMediaPromiseMap.set(\"audioinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"audioinput\"));\n        }\n        if (internalOptions.video) {\n            DeviceManager.userMediaPromiseMap.set(\"videoinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"videoinput\"));\n        }\n        try {\n            const stream = yield mediaPromise;\n            return yield Promise.all(stream.getTracks().map((mediaStreamTrack)=>__awaiter(this, void 0, void 0, function*() {\n                    const isAudio = mediaStreamTrack.kind === \"audio\";\n                    let trackOptions = isAudio ? opts.audio : opts.video;\n                    if (typeof trackOptions === \"boolean\" || !trackOptions) {\n                        trackOptions = {};\n                    }\n                    let trackConstraints;\n                    const conOrBool = isAudio ? constraints.audio : constraints.video;\n                    if (typeof conOrBool !== \"boolean\") {\n                        trackConstraints = conOrBool;\n                    }\n                    // update the constraints with the device id the user gave permissions to in the permission prompt\n                    // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n                    const newDeviceId = mediaStreamTrack.getSettings().deviceId;\n                    if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {\n                        trackConstraints.deviceId = newDeviceId;\n                    } else if (!trackConstraints) {\n                        trackConstraints = {\n                            deviceId: newDeviceId\n                        };\n                    }\n                    const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);\n                    if (track.kind === Track.Kind.Video) {\n                        track.source = Track.Source.Camera;\n                    } else if (track.kind === Track.Kind.Audio) {\n                        track.source = Track.Source.Microphone;\n                    }\n                    track.mediaStream = stream;\n                    if (isAudioTrack(track) && audioProcessor) {\n                        yield track.setProcessor(audioProcessor);\n                    } else if (isVideoTrack(track) && videoProcessor) {\n                        yield track.setProcessor(videoProcessor);\n                    }\n                    return track;\n                })));\n        } catch (e) {\n            if (!attemptExactMatch) {\n                throw e;\n            }\n            return createLocalTracks(Object.assign(Object.assign({}, options), {\n                audio: retryAudioOptions,\n                video: retryVideoOptions\n            }), loggerOptions);\n        }\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options !== null && options !== void 0 ? options : true\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options !== null && options !== void 0 ? options : true,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined && !isSafari17()) {\n            options.resolution = ScreenSharePresets.h1080fps30.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError(\"no video track found\");\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality[\"Excellent\"] = \"excellent\";\n    ConnectionQuality[\"Good\"] = \"good\";\n    ConnectionQuality[\"Poor\"] = \"poor\";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality[\"Lost\"] = \"lost\";\n    ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isEncrypted() {\n        return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a;\n        return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;\n    }\n    get kind() {\n        return this._kind;\n    }\n    /** participant attributes, similar to metadata, but as a key/value map */ get attributes() {\n        return Object.freeze(Object.assign({}, this._attributes));\n    }\n    /** @internal */ constructor(sid, identity, name, metadata, attributes, loggerOptions){\n        let kind = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ParticipantInfo_Kind.STANDARD;\n        var _a;\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.log = livekitLogger;\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n        this.loggerOptions = loggerOptions;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.trackPublications = new Map();\n        this._kind = kind;\n        this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};\n    }\n    getTrackPublications() {\n        return Array.from(this.trackPublications.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   */ getTrackPublication(source) {\n        for (const [, pub] of this.trackPublications){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track's name.\n   */ getTrackPublicationByName(name) {\n        for (const [, pub] of this.trackPublications){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrackPublication(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrackPublication(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrackPublication(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        // it's possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it's possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        this._setAttributes(info.attributes);\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        this.log.trace(\"update participant info\", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /**\n   * Updates metadata from server\n   **/ _setAttributes(attributes) {\n        const diff = diffAttributes(this.attributes, attributes);\n        this._attributes = attributes;\n        if (Object.keys(diff).length > 0) {\n            this.emit(ParticipantEvent.AttributesChanged, diff);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e, _f;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTrackPublications.forEach((track)=>isAudioTrack(track.track) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.trackPublications.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTrackPublications.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTrackPublications.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : \"\",\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : \"\",\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nconst STREAM_CHUNK_SIZE = 15000;\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options, roomRpcHandlers){\n        super(sid, identity, undefined, undefined, undefined, {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.engine.logContext\n        });\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.enabledPublishVideoCodecs = [];\n        this.pendingAcks = new Map();\n        this.pendingResponses = new Map();\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleDisconnected = ()=>{\n            var _a, _b;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>this.log.warn(e.message, this.logContext));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, \"Got disconnected during reconnection attempt\");\n                this.reconnectFuture = undefined;\n            }\n        };\n        this.handleSignalRequestResponse = (response)=>{\n            const { requestId, reason, message } = response;\n            const targetRequest = this.pendingSignalRequests.get(requestId);\n            if (targetRequest) {\n                if (reason !== RequestResponse_Reason.OK) {\n                    targetRequest.reject(new SignalRequestError(message, reason));\n                }\n                this.pendingSignalRequests.delete(requestId);\n            }\n        };\n        this.handleDataPacket = (packet)=>{\n            switch(packet.value.case){\n                case \"rpcResponse\":\n                    let rpcResponse = packet.value.value;\n                    let payload = null;\n                    let error = null;\n                    if (rpcResponse.value.case === \"payload\") {\n                        payload = rpcResponse.value.value;\n                    } else if (rpcResponse.value.case === \"error\") {\n                        error = RpcError.fromProto(rpcResponse.value.value);\n                    }\n                    this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);\n                    break;\n                case \"rpcAck\":\n                    let rpcAck = packet.value.value;\n                    this.handleIncomingRpcAck(rpcAck.requestId);\n                    break;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            this.log.debug(\"updating track subscription permissions\", Object.assign(Object.assign({}, this.logContext), {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            }));\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we'll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                this.log.error(\"could not update mute status for unpublished track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            this.log.debug(\"upstream paused\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            this.log.debug(\"upstream resumed\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.onTrackFeatureUpdate = (track)=>{\n            const pub = this.audioTrackPublications.get(track.sid);\n            if (!pub) {\n                this.log.warn(\"Could not update local audio track settings, missing publication for track \".concat(track.sid), this.logContext);\n                return;\n            }\n            this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTrackPublications.get(update.trackSid);\n                if (!pub) {\n                    this.log.warn(\"received subscribed quality update for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                        trackSid: update.trackSid\n                    }));\n                    return;\n                }\n                if (update.subscribedCodecs.length > 0) {\n                    if (!pub.videoTrack) {\n                        return;\n                    }\n                    const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                    try {\n                        for(var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true){\n                            _c = newCodecs_1_1.value;\n                            _f = false;\n                            const codec = _c;\n                            if (isBackupCodec(codec)) {\n                                this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n                                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                } else if (update.subscribedQualities.length > 0) {\n                    yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.trackPublications.get(unpublished.trackSid);\n            if (!track) {\n                this.log.warn(\"received unpublished event for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: unpublished.trackSid\n                }));\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    this.log.debug(\"unpublishing local track due to TrackEnded\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n                                });\n                                if (currentPermissions && currentPermissions.state === \"denied\") {\n                                    this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== \"denied\") {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error(\"GetUserMedia Permission denied\");\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            this.log.debug(\"track ended, attempting to use a different device\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            if (isLocalAudioTrack(track)) {\n                                // fall back to default device if available\n                                yield track.restartTrack({\n                                    deviceId: \"default\"\n                                });\n                            } else {\n                                yield track.restartTrack();\n                            }\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.trackPublications = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map([\n            [\n                \"audioinput\",\n                \"default\"\n            ],\n            [\n                \"videoinput\",\n                \"default\"\n            ],\n            [\n                \"audiooutput\",\n                \"default\"\n            ]\n        ]);\n        this.pendingSignalRequests = new Map();\n        this.rpcHandlers = roomRpcHandlers;\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrackPublication(source) {\n        const track = super.getTrackPublication(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackPublicationByName(name) {\n        const track = super.getTrackPublicationByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.trackPublications.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */ setMetadata(metadata) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                metadata\n            });\n        });\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */ setName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                name\n            });\n        });\n    }\n    /**\n   * Set or update participant attributes. It will make updates only to keys that\n   * are present in `attributes`, and will not override others.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param attributes attributes to update\n   */ setAttributes(attributes) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                attributes\n            });\n        });\n    }\n    requestMetadataUpdate(_a) {\n        return __awaiter(this, arguments, void 0, function(_ref) {\n            var _this = this;\n            let { metadata, name, attributes } = _ref;\n            return function*() {\n                return new Promise((resolve, reject)=>__awaiter(_this, void 0, void 0, function*() {\n                        var _a, _b;\n                        try {\n                            let isRejected = false;\n                            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a !== void 0 ? _a : \"\", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : \"\", attributes);\n                            const startTime = performance.now();\n                            this.pendingSignalRequests.set(requestId, {\n                                resolve,\n                                reject: (error)=>{\n                                    reject(error);\n                                    isRejected = true;\n                                },\n                                values: {\n                                    name,\n                                    metadata,\n                                    attributes\n                                }\n                            });\n                            while(performance.now() - startTime < 5000 && !isRejected){\n                                if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every((_ref2)=>{\n                                    let [key, value] = _ref2;\n                                    return this.attributes[key] === value || value === \"\" && !this.attributes[key];\n                                }))) {\n                                    this.pendingSignalRequests.delete(requestId);\n                                    resolve();\n                                    return;\n                                }\n                                yield sleep(50);\n                            }\n                            reject(new SignalRequestError(\"Request to update local metadata timed out\", \"TimeoutError\"));\n                        } catch (e) {\n                            if (e instanceof Error) reject(e);\n                        }\n                    }));\n            }();\n        });\n    }\n    /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setPermissions(permissions) {\n        const prevPermissions = this.permissions;\n        const changed = super.setPermissions(permissions);\n        if (changed && prevPermissions) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            this.log.debug(\"setTrackEnabled\", Object.assign(Object.assign({}, this.logContext), {\n                source,\n                enabled\n            }));\n            if (this.republishPromise) {\n                yield this.republishPromise;\n            }\n            let track = this.getTrackPublication(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        const pendingTrack = yield this.waitForPendingPublicationOfSource(source);\n                        if (!pendingTrack) {\n                            this.log.info(\"waiting for pending publication promise timed out\", Object.assign(Object.assign({}, this.logContext), {\n                                source\n                            }));\n                        }\n                        yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();\n                        return pendingTrack;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e);\n                        }\n                        this.pendingPublishing.delete(source);\n                        throw e;\n                    }\n                    try {\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            this.log.info(\"publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else {\n                if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {\n                    // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available\n                    track = yield this.waitForPendingPublicationOfSource(source);\n                    if (!track) {\n                        this.log.info(\"waiting for pending publication promise timed out\", Object.assign(Object.assign({}, this.logContext), {\n                            source\n                        }));\n                    }\n                }\n                if (track && track.track) {\n                    // screenshare cannot be muted, unpublish instead\n                    if (source === Track.Source.ScreenShare) {\n                        track = yield this.unpublishTrack(track.track);\n                        const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);\n                        if (screenAudioTrack && screenAudioTrack.track) {\n                            this.unpublishTrack(screenAudioTrack.track);\n                        }\n                    } else {\n                        yield track.mute();\n                    }\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it's already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            options !== null && options !== void 0 ? options : options = {};\n            const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            try {\n                const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                const localTracks = tracks.map((track)=>{\n                    if (isAudioTrack(track)) {\n                        this.microphoneError = undefined;\n                        track.setAudioContext(this.audioContext);\n                        track.source = Track.Source.Microphone;\n                        this.emit(ParticipantEvent.AudioStreamAcquired);\n                    }\n                    if (isVideoTrack(track)) {\n                        this.cameraError = undefined;\n                        track.source = Track.Source.Camera;\n                    }\n                    return track;\n                });\n                return localTracks;\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (options.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (options.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n            }\n            if (options.resolution === undefined && !isSafari17()) {\n                // we need to constrain the dimensions, otherwise it could lead to low bitrate\n                // due to encoding a huge video. Encoding such large surfaces is really expensive\n                // unfortunately Safari 17 has a but and cannot be constrained by default\n                options.resolution = ScreenSharePresets.h1080fps30.resolution;\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError(\"no video track found\");\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            screenVideo.source = Track.Source.ScreenShare;\n            if (options.contentHint) {\n                screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n            }\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.publishOrRepublishTrack(track, options);\n        });\n    }\n    publishOrRepublishTrack(track_1, options_1) {\n        return __awaiter(this, arguments, void 0, function(track, options) {\n            var _this2 = this;\n            let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            return function*() {\n                var _a, _b, _c, _d;\n                if (isLocalAudioTrack(track)) {\n                    track.setAudioContext(_this2.audioContext);\n                }\n                yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n                if (_this2.republishPromise && !isRepublish) {\n                    yield _this2.republishPromise;\n                }\n                if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {\n                    yield _this2.pendingPublishPromises.get(track);\n                }\n                let defaultConstraints;\n                if (track instanceof MediaStreamTrack) {\n                    defaultConstraints = track.getConstraints();\n                } else {\n                    // we want to access constraints directly as `track.mediaStreamTrack`\n                    // might be pointing to a non-device track (e.g. processed track) already\n                    defaultConstraints = track.constraints;\n                    let deviceKind = undefined;\n                    switch(track.source){\n                        case Track.Source.Microphone:\n                            deviceKind = \"audioinput\";\n                            break;\n                        case Track.Source.Camera:\n                            deviceKind = \"videoinput\";\n                    }\n                    if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {\n                        defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                            deviceId: _this2.activeDeviceMap.get(deviceKind)\n                        });\n                    }\n                }\n                // convert raw media track into audio or video track\n                if (track instanceof MediaStreamTrack) {\n                    switch(track.kind){\n                        case \"audio\":\n                            track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {\n                                loggerName: _this2.roomOptions.loggerName,\n                                loggerContextCb: ()=>_this2.logContext\n                            });\n                            break;\n                        case \"video\":\n                            track = new LocalVideoTrack(track, defaultConstraints, true, {\n                                loggerName: _this2.roomOptions.loggerName,\n                                loggerContextCb: ()=>_this2.logContext\n                            });\n                            break;\n                        default:\n                            throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n                    }\n                } else {\n                    track.updateLoggerOptions({\n                        loggerName: _this2.roomOptions.loggerName,\n                        loggerContextCb: ()=>_this2.logContext\n                    });\n                }\n                // is it already published? if so skip\n                let existingPublication;\n                _this2.trackPublications.forEach((publication)=>{\n                    if (!publication.track) {\n                        return;\n                    }\n                    if (publication.track === track) {\n                        existingPublication = publication;\n                    }\n                });\n                if (existingPublication) {\n                    _this2.log.warn(\"track has already been published, skipping\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));\n                    return existingPublication;\n                }\n                const isStereoInput = \"channelCount\" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n                track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n                const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n                // disable dtx for stereo track if not enabled explicitly\n                if (isStereo) {\n                    if (!options) {\n                        options = {};\n                    }\n                    if (options.dtx === undefined) {\n                        _this2.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));\n                    }\n                    if (options.red === undefined) {\n                        _this2.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                    }\n                    (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n                    (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n                }\n                const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);\n                if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {\n                    _this2.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2\", Object.assign({}, _this2.logContext));\n                    opts.simulcast = false;\n                }\n                if (opts.source) {\n                    track.source = opts.source;\n                }\n                const publishPromise = new Promise((resolve, reject)=>__awaiter(_this2, void 0, void 0, function*() {\n                        try {\n                            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {\n                                this.log.debug(\"deferring track publication until signal is connected\", Object.assign(Object.assign({}, this.logContext), {\n                                    track: getLogContextFromTrack(track)\n                                }));\n                                const onSignalConnected = ()=>__awaiter(this, void 0, void 0, function*() {\n                                        try {\n                                            const publication = yield this.publish(track, opts, isStereo);\n                                            resolve(publication);\n                                        } catch (e) {\n                                            reject(e);\n                                        }\n                                    });\n                                setTimeout(()=>{\n                                    this.engine.off(EngineEvent.SignalConnected, onSignalConnected);\n                                    reject(new PublishTrackError(\"publishing rejected as engine not connected within timeout\", 408));\n                                }, 15000);\n                                this.engine.once(EngineEvent.SignalConnected, onSignalConnected);\n                                this.engine.on(EngineEvent.Closing, ()=>{\n                                    this.engine.off(EngineEvent.SignalConnected, onSignalConnected);\n                                    reject(new PublishTrackError(\"publishing rejected as engine closed\", 499));\n                                });\n                            } else {\n                                try {\n                                    const publication = yield this.publish(track, opts, isStereo);\n                                    resolve(publication);\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            }\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }));\n                _this2.pendingPublishPromises.set(track, publishPromise);\n                try {\n                    const publication = yield publishPromise;\n                    return publication;\n                } catch (e) {\n                    throw e;\n                } finally{\n                    _this2.pendingPublishPromises.delete(track);\n                }\n            }();\n        });\n    }\n    hasPermissionsToPublish(track) {\n        if (!this.permissions) {\n            this.log.warn(\"no permissions present for publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            return false;\n        }\n        const { canPublish, canPublishSources } = this.permissions;\n        if (canPublish && (canPublishSources.length === 0 || canPublishSources.map((source)=>getTrackSourceFromProto(source)).includes(track.source))) {\n            return true;\n        }\n        this.log.warn(\"insufficient permissions to publish\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        return false;\n    }\n    publish(track, opts, isStereo) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n            if (!this.hasPermissionsToPublish(track)) {\n                throw new PublishTrackError(\"failed to publish track, insufficient permissions\", 403);\n            }\n            const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack)=>isLocalTrack(track) && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            }\n            if (opts.stopMicTrackOnMute && isAudioTrack(track)) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === \"av1\" && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === \"vp9\" && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            if (this.enabledPublishVideoCodecs.length > 0) {\n                // fallback to a supported codec if it is not supported\n                if (!this.enabledPublishVideoCodecs.some((c)=>opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {\n                    opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);\n                }\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream,\n                backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it's quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    this.log.error(\"could not determine track dimensions, using defaults\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        dims\n                    }));\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (isLocalVideoTrack(track)) {\n                    if (isSVCCodec(videoCodec)) {\n                        if (track.source === Track.Source.ScreenShare) {\n                            // vp9 svc with screenshare cannot encode multiple spatial layers\n                            // doing so reduces publish resolution to minimal resolution\n                            opts.scalabilityMode = \"L1T3\";\n                            // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3\n                            // It has a different path for screenshare handling and it seems to be untested/buggy\n                            // As a workaround, we are setting contentHint to force it to go through the same\n                            // path as regular camera video. While this is not optimal, it delivers the performance\n                            // that we need\n                            if (\"contentHint\" in track.mediaStreamTrack) {\n                                track.mediaStreamTrack.contentHint = \"motion\";\n                                this.log.info(\"forcing contentHint to motion for screenshare with SVC codecs\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            }\n                        }\n                        // set scalabilityMode to 'L3T3_KEY' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : \"L3T3_KEY\";\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: \"\"\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,\n                        priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : \"high\",\n                        networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : \"high\"\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const negotiate = ()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b, _c;\n                    if (!this.engine.pcManager) {\n                        throw new UnexpectedConnectionState(\"pcManager is not ready\");\n                    }\n                    track.sender = yield this.engine.createSender(track, opts, encodings);\n                    if (isLocalVideoTrack(track)) {\n                        (_a = opts.degradationPreference) !== null && _a !== void 0 ? _a : opts.degradationPreference = getDefaultDegradationPreference(track);\n                        track.setDegradationPreference(opts.degradationPreference);\n                    }\n                    if (encodings) {\n                        if (isFireFox() && track.kind === Track.Kind.Audio) {\n                            /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n               publish high quality audio track. But firefox always uses this value as the actual\n               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n               So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n               fix the issue.\n             */ let trackTransceiver = undefined;\n                            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                                if (transceiver.sender === track.sender) {\n                                    trackTransceiver = transceiver;\n                                    break;\n                                }\n                            }\n                            if (trackTransceiver) {\n                                this.engine.pcManager.publisher.setTrackCodecBitrate({\n                                    transceiver: trackTransceiver,\n                                    codec: \"opus\",\n                                    maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                                });\n                            }\n                        } else if (track.codec && isSVCCodec(track.codec) && ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)) {\n                            this.engine.pcManager.publisher.setTrackCodecBitrate({\n                                cid: req.cid,\n                                codec: track.codec,\n                                maxbr: encodings[0].maxBitrate / 1000\n                            });\n                        }\n                    }\n                    yield this.engine.negotiate();\n                });\n            let ti;\n            if (this.enabledPublishVideoCodecs.length > 0) {\n                const rets = yield Promise.all([\n                    this.engine.addTrack(req),\n                    negotiate()\n                ]);\n                ti = rets[0];\n            } else {\n                ti = yield this.engine.addTrack(req);\n                // server might not support the codec the client has requested, in that case, fallback\n                // to a supported codec\n                let primaryCodecMime;\n                ti.codecs.forEach((codec)=>{\n                    if (primaryCodecMime === undefined) {\n                        primaryCodecMime = codec.mimeType;\n                    }\n                });\n                if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                    const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                    if (updatedCodec !== videoCodec) {\n                        this.log.debug(\"falling back to server selected codec\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                            codec: updatedCodec\n                        }));\n                        opts.videoCodec = updatedCodec;\n                        // recompute encodings since bitrates/etc could have changed\n                        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                    }\n                }\n                yield negotiate();\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n            if (isLocalVideoTrack(track)) {\n                track.startMonitor(this.engine.client);\n            } else if (isLocalAudioTrack(track)) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.trackPublications.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError(\"track is not published\");\n            }\n            if (!isLocalVideoTrack(track)) {\n                throw new TrackInvalidError(\"track is not a video track\");\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            if (!simulcastTrack) {\n                return;\n            }\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const negotiate = ()=>__awaiter(this, void 0, void 0, function*() {\n                    yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n                    yield this.engine.negotiate();\n                });\n            const rets = yield Promise.all([\n                this.engine.addTrack(req),\n                negotiate()\n            ]);\n            const ti = rets[0];\n            this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            if (isLocalTrack(track)) {\n                const publishPromise = this.pendingPublishPromises.get(track);\n                if (publishPromise) {\n                    this.log.info(\"awaiting publish promise before attempting to unpublish\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    yield publishPromise;\n                }\n            }\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n            this.log.debug(\"unpublishing track\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n            if (!publication || !publication.track) {\n                this.log.warn(\"track was not unpublished because no publication was found\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            } else {\n                track.stopMonitor();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = \"inactive\";\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (isLocalVideoTrack(track)) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    this.log.warn(\"failed to unpublish track\", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n                        error: e\n                    }));\n                }\n            }\n            // remove from our maps\n            this.trackPublications.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTrackPublications.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTrackPublications.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>!!track);\n        });\n    }\n    republishAllTracks(options_1) {\n        return __awaiter(this, arguments, void 0, function(options) {\n            var _this3 = this;\n            let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                if (_this3.republishPromise) {\n                    yield _this3.republishPromise;\n                }\n                _this3.republishPromise = new Promise((resolve, reject)=>__awaiter(_this3, void 0, void 0, function*() {\n                        try {\n                            const localPubs = [];\n                            this.trackPublications.forEach((pub)=>{\n                                if (pub.track) {\n                                    if (options) {\n                                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                                    }\n                                    localPubs.push(pub);\n                                }\n                            });\n                            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                                    const track = pub.track;\n                                    yield this.unpublishTrack(track, false);\n                                    if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {\n                                        // generally we need to restart the track before publishing, often a full reconnect\n                                        // is necessary because computer had gone to sleep.\n                                        this.log.debug(\"restarting existing track\", Object.assign(Object.assign({}, this.logContext), {\n                                            track: pub.trackSid\n                                        }));\n                                        yield track.restartTrack();\n                                    }\n                                    yield this.publishOrRepublishTrack(track, pub.options, true);\n                                })));\n                            resolve();\n                        } catch (error) {\n                            reject(error);\n                        } finally{\n                            this.republishPromise = undefined;\n                        }\n                    }));\n                yield _this3.republishPromise;\n            }();\n        });\n    }\n    /**\n   * Publish a new data payload to the room. Data will be forwarded to each\n   * participant in the room if the destination field in publishOptions is empty\n   *\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\n   * @param options optionally specify a `reliable`, `topic` and `destination`\n   */ publishData(data_1) {\n        return __awaiter(this, arguments, void 0, function(data) {\n            var _this4 = this;\n            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return function*() {\n                const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;\n                const destinationIdentities = options.destinationIdentities;\n                const topic = options.topic;\n                const packet = new DataPacket({\n                    kind: kind,\n                    value: {\n                        case: \"user\",\n                        value: new UserPacket({\n                            participantIdentity: _this4.identity,\n                            payload: data,\n                            destinationIdentities,\n                            topic\n                        })\n                    }\n                });\n                yield _this4.engine.sendDataPacket(packet, kind);\n            }();\n        });\n    }\n    /**\n   * Publish SIP DTMF message to the room.\n   *\n   * @param code DTMF code\n   * @param digit DTMF digit\n   */ publishDtmf(code, digit) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"sipDtmf\",\n                    value: new SipDTMF({\n                        code: code,\n                        digit: digit\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    sendChatMessage(text, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = {\n                id: crypto.randomUUID(),\n                message: text,\n                timestamp: Date.now(),\n                attachedFiles: options === null || options === void 0 ? void 0 : options.attachments\n            };\n            const packet = new DataPacket({\n                value: {\n                    case: \"chatMessage\",\n                    value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n                        timestamp: protoInt64.parse(msg.timestamp)\n                    }))\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            this.emit(ParticipantEvent.ChatMessage, msg);\n            return msg;\n        });\n    }\n    editChatMessage(editText, originalMessage) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = Object.assign(Object.assign({}, originalMessage), {\n                message: editText,\n                editTimestamp: Date.now()\n            });\n            const packet = new DataPacket({\n                value: {\n                    case: \"chatMessage\",\n                    value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n                        timestamp: protoInt64.parse(msg.timestamp),\n                        editTimestamp: protoInt64.parse(msg.editTimestamp)\n                    }))\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            this.emit(ParticipantEvent.ChatMessage, msg);\n            return msg;\n        });\n    }\n    sendText(text, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const streamId = crypto.randomUUID();\n            const textInBytes = new TextEncoder().encode(text);\n            const totalTextLength = textInBytes.byteLength;\n            const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(()=>crypto.randomUUID());\n            const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);\n            const handleProgress = (progress, idx)=>{\n                var _a;\n                progresses[idx] = progress;\n                const totalProgress = progresses.reduce((acc, val)=>acc + val, 0);\n                (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, totalProgress);\n            };\n            const writer = yield this.streamText({\n                streamId,\n                totalSize: totalTextLength,\n                destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,\n                topic: options === null || options === void 0 ? void 0 : options.topic,\n                attachedStreamIds: fileIds,\n                attributes: options === null || options === void 0 ? void 0 : options.attributes\n            });\n            yield writer.write(text);\n            // set text part of progress to 1\n            handleProgress(1, 0);\n            yield writer.close();\n            if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {\n                yield Promise.all(options.attachments.map((file, idx)=>__awaiter(this, void 0, void 0, function*() {\n                        return this._sendFile(fileIds[idx], file, {\n                            topic: options.topic,\n                            mimeType: file.type,\n                            onProgress: (progress)=>{\n                                handleProgress(progress, idx + 1);\n                            }\n                        });\n                    })));\n            }\n            return writer.info;\n        });\n    }\n    /**\n   * @internal\n   * @experimental CAUTION, might get removed in a minor release\n   */ streamText(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            const info = {\n                id: streamId,\n                mimeType: \"text/plain\",\n                timestamp: Date.now(),\n                topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : \"\",\n                size: options === null || options === void 0 ? void 0 : options.totalSize,\n                attributes: options === null || options === void 0 ? void 0 : options.attributes\n            };\n            const header = new DataStream_Header({\n                streamId,\n                mimeType: info.mimeType,\n                topic: info.topic,\n                timestamp: numberToBigInt(info.timestamp),\n                totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),\n                attributes: info.attributes,\n                contentHeader: {\n                    case: \"textHeader\",\n                    value: new DataStream_TextHeader({\n                        version: options === null || options === void 0 ? void 0 : options.version,\n                        attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,\n                        replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,\n                        operationType: (options === null || options === void 0 ? void 0 : options.type) === \"update\" ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE\n                    })\n                }\n            });\n            const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n            const packet = new DataPacket({\n                destinationIdentities,\n                value: {\n                    case: \"streamHeader\",\n                    value: header\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            let chunkId = 0;\n            const localP = this;\n            const writableStream = new WritableStream({\n                // Implement the sink\n                write (text) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)){\n                            yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\n                            const chunk = new DataStream_Chunk({\n                                content: textByteChunk,\n                                streamId,\n                                chunkIndex: numberToBigInt(chunkId)\n                            });\n                            const chunkPacket = new DataPacket({\n                                destinationIdentities,\n                                value: {\n                                    case: \"streamChunk\",\n                                    value: chunk\n                                }\n                            });\n                            yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                            chunkId += 1;\n                        }\n                    });\n                },\n                close () {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const trailer = new DataStream_Trailer({\n                            streamId\n                        });\n                        const trailerPacket = new DataPacket({\n                            destinationIdentities,\n                            value: {\n                                case: \"streamTrailer\",\n                                value: trailer\n                            }\n                        });\n                        yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n                    });\n                },\n                abort (err) {\n                    console.log(\"Sink error:\", err);\n                // TODO handle aborts to signal something to receiver side\n                }\n            });\n            let onEngineClose = ()=>__awaiter(this, void 0, void 0, function*() {\n                    yield writer.close();\n                });\n            localP.engine.once(EngineEvent.Closing, onEngineClose);\n            const writer = new TextStreamWriter(writableStream, info, ()=>this.engine.off(EngineEvent.Closing, onEngineClose));\n            return writer;\n        });\n    }\n    sendFile(file, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const streamId = crypto.randomUUID();\n            yield this._sendFile(streamId, file, options);\n            return {\n                id: streamId\n            };\n        });\n    }\n    _sendFile(streamId, file, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const writer = yield this.streamBytes({\n                streamId,\n                totalSize: file.size,\n                name: file.name,\n                mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,\n                topic: options === null || options === void 0 ? void 0 : options.topic,\n                destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities\n            });\n            const reader = file.stream().getReader();\n            while(true){\n                const { done, value } = yield reader.read();\n                if (done) {\n                    break;\n                }\n                yield writer.write(value);\n            }\n            yield writer.close();\n            return writer.info;\n        });\n    }\n    streamBytes(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c, _d, _e;\n            const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n            const info = {\n                id: streamId,\n                mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : \"application/octet-stream\",\n                topic: (_c = options === null || options === void 0 ? void 0 : options.topic) !== null && _c !== void 0 ? _c : \"\",\n                timestamp: Date.now(),\n                attributes: options === null || options === void 0 ? void 0 : options.attributes,\n                size: options === null || options === void 0 ? void 0 : options.totalSize,\n                name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : \"unknown\"\n            };\n            const header = new DataStream_Header({\n                totalLength: numberToBigInt((_e = info.size) !== null && _e !== void 0 ? _e : 0),\n                mimeType: info.mimeType,\n                streamId,\n                topic: info.topic,\n                timestamp: numberToBigInt(Date.now()),\n                contentHeader: {\n                    case: \"byteHeader\",\n                    value: new DataStream_ByteHeader({\n                        name: info.name\n                    })\n                }\n            });\n            const packet = new DataPacket({\n                destinationIdentities,\n                value: {\n                    case: \"streamHeader\",\n                    value: header\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            let chunkId = 0;\n            const writeMutex = new _();\n            const engine = this.engine;\n            const log = this.log;\n            const writableStream = new WritableStream({\n                write (chunk) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const unlock = yield writeMutex.lock();\n                        let byteOffset = 0;\n                        try {\n                            while(byteOffset < chunk.byteLength){\n                                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);\n                                yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\n                                const chunkPacket = new DataPacket({\n                                    destinationIdentities,\n                                    value: {\n                                        case: \"streamChunk\",\n                                        value: new DataStream_Chunk({\n                                            content: subChunk,\n                                            streamId,\n                                            chunkIndex: numberToBigInt(chunkId)\n                                        })\n                                    }\n                                });\n                                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                                chunkId += 1;\n                                byteOffset += subChunk.byteLength;\n                            }\n                        } finally{\n                            unlock();\n                        }\n                    });\n                },\n                close () {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const trailer = new DataStream_Trailer({\n                            streamId\n                        });\n                        const trailerPacket = new DataPacket({\n                            destinationIdentities,\n                            value: {\n                                case: \"streamTrailer\",\n                                value: trailer\n                            }\n                        });\n                        yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n                    });\n                },\n                abort (err) {\n                    log.error(\"Sink error:\", err);\n                }\n            });\n            const byteWriter = new ByteStreamWriter(writableStream, info);\n            return byteWriter;\n        });\n    }\n    /**\n   * Initiate an RPC call to a remote participant\n   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}\n   * @returns A promise that resolves with the response payload or rejects with an error.\n   * @throws Error on failure. Details in `message`.\n   */ performRpc(_a) {\n        return __awaiter(this, arguments, void 0, function(_ref3) {\n            var _this5 = this;\n            let { destinationIdentity, method, payload, responseTimeout = 10000 } = _ref3;\n            return function*() {\n                const maxRoundTripLatency = 2000;\n                return new Promise((resolve, reject)=>__awaiter(_this5, void 0, void 0, function*() {\n                        var _a, _b, _c, _d;\n                        if (byteLength(payload) > MAX_PAYLOAD_BYTES) {\n                            reject(RpcError.builtIn(\"REQUEST_PAYLOAD_TOO_LARGE\"));\n                            return;\n                        }\n                        if (((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, \"1.8.0\") < 0) {\n                            reject(RpcError.builtIn(\"UNSUPPORTED_SERVER\"));\n                            return;\n                        }\n                        const id = crypto.randomUUID();\n                        yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);\n                        const ackTimeoutId = setTimeout(()=>{\n                            this.pendingAcks.delete(id);\n                            reject(RpcError.builtIn(\"CONNECTION_TIMEOUT\"));\n                            this.pendingResponses.delete(id);\n                            clearTimeout(responseTimeoutId);\n                        }, maxRoundTripLatency);\n                        this.pendingAcks.set(id, {\n                            resolve: ()=>{\n                                clearTimeout(ackTimeoutId);\n                            },\n                            participantIdentity: destinationIdentity\n                        });\n                        const responseTimeoutId = setTimeout(()=>{\n                            this.pendingResponses.delete(id);\n                            reject(RpcError.builtIn(\"RESPONSE_TIMEOUT\"));\n                        }, responseTimeout);\n                        this.pendingResponses.set(id, {\n                            resolve: (responsePayload, responseError)=>{\n                                clearTimeout(responseTimeoutId);\n                                if (this.pendingAcks.has(id)) {\n                                    console.warn(\"RPC response received before ack\", id);\n                                    this.pendingAcks.delete(id);\n                                    clearTimeout(ackTimeoutId);\n                                }\n                                if (responseError) {\n                                    reject(responseError);\n                                } else {\n                                    resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : \"\");\n                                }\n                            },\n                            participantIdentity: destinationIdentity\n                        });\n                    }));\n            }();\n        });\n    }\n    /**\n   * @deprecated use `room.registerRpcMethod` instead\n   */ registerRpcMethod(method, handler) {\n        if (this.rpcHandlers.has(method)) {\n            this.log.warn(\"you're overriding the RPC handler for method \".concat(method, \", in the future this will throw an error\"));\n        }\n        this.rpcHandlers.set(method, handler);\n    }\n    /**\n   * @deprecated use `room.unregisterRpcMethod` instead\n   */ unregisterRpcMethod(method) {\n        this.rpcHandlers.delete(method);\n    }\n    /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    handleIncomingRpcAck(requestId) {\n        const handler = this.pendingAcks.get(requestId);\n        if (handler) {\n            handler.resolve();\n            this.pendingAcks.delete(requestId);\n        } else {\n            console.error(\"Ack received for unexpected RPC request\", requestId);\n        }\n    }\n    handleIncomingRpcResponse(requestId, payload, error) {\n        const handler = this.pendingResponses.get(requestId);\n        if (handler) {\n            handler.resolve(payload, error);\n            this.pendingResponses.delete(requestId);\n        } else {\n            console.error(\"Response received for unexpected RPC request\", requestId);\n        }\n    }\n    /** @internal */ publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcRequest\",\n                    value: new RpcRequest({\n                        id: requestId,\n                        method,\n                        payload,\n                        responseTimeoutMs: responseTimeout,\n                        version: 1\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /** @internal */ handleParticipantDisconnected(participantIdentity) {\n        for (const [id, { participantIdentity: pendingIdentity }] of this.pendingAcks){\n            if (pendingIdentity === participantIdentity) {\n                this.pendingAcks.delete(id);\n            }\n        }\n        for (const [id, { participantIdentity: pendingIdentity, resolve }] of this.pendingResponses){\n            if (pendingIdentity === participantIdentity) {\n                resolve(null, RpcError.builtIn(\"RECIPIENT_DISCONNECTED\"));\n                this.pendingResponses.delete(id);\n            }\n        }\n    }\n    /** @internal */ setEnabledPublishCodecs(codecs) {\n        this.enabledPublishVideoCodecs = codecs.filter((c)=>c.mime.split(\"/\")[0].toLowerCase() === \"video\");\n    }\n    /** @internal */ updateInfo(info) {\n        if (info.sid !== this.sid) {\n            // drop updates that specify a wrong sid.\n            // the sid for local participant is only explicitly set on join and full reconnect\n            return false;\n        }\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server's track mute status doesn't match actual, we'll have to update\n        // the server's copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.trackPublications.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    this.log.debug(\"updating server mute state after reconcile\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n                        mutedOnServer\n                    }));\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.trackPublications.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n    waitForPendingPublicationOfSource(source) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const waitForPendingTimeout = 10000;\n            const startTime = Date.now();\n            while(Date.now() < startTime + waitForPendingTimeout){\n                const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find((_ref4)=>{\n                    let [pendingTrack] = _ref4;\n                    return pendingTrack.source === source;\n                });\n                if (publishPromiseEntry) {\n                    return publishPromiseEntry[1];\n                }\n                yield sleep(20);\n            }\n        });\n    }\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.disabled = false;\n        this.currentVideoQuality = VideoQuality.HIGH;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n            this.disabled = !visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n            this.videoDimensions = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it's not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn't keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: \"\",\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return !this.disabled;\n    }\n    get isLocal() {\n        return false;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n            return;\n        }\n        this.disabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n            return;\n        }\n        this.currentVideoQuality = quality;\n        this.videoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (isRemoteVideoTrack(this.track)) {\n            this.videoDimensions = dimensions;\n        }\n        this.currentVideoQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!isRemoteVideoTrack(this.track)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        return this.currentVideoQuality;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n            this.log.warn(\"adaptive stream is enabled, cannot change video track settings\", this.logContext);\n            return false;\n        }\n        if (!this.isDesired) {\n            this.log.warn(\"cannot update track settings when not subscribed\", this.logContext);\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: this.disabled,\n            fps: this.fps\n        });\n        if (this.videoDimensions) {\n            settings.width = Math.ceil(this.videoDimensions.width);\n            settings.height = Math.ceil(this.videoDimensions.height);\n        } else if (this.currentVideoQuality !== undefined) {\n            settings.quality = this.currentVideoQuality;\n        } else {\n            // defaults to high quality\n            settings.quality = VideoQuality.HIGH;\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi, loggerOptions) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);\n    }\n    get logContext() {\n        return Object.assign(Object.assign({}, super.logContext), {\n            rpID: this.sid,\n            remoteParticipant: this.identity\n        });\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions){\n        let kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : ParticipantInfo_Kind.STANDARD;\n        super(sid, identity || \"\", name, metadata, attributes, loggerOptions, kind);\n        this.signalClient = signalClient;\n        this.trackPublications = new Map();\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            this.log.debug(\"send update settings\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrackPublication(source) {\n        const track = super.getTrackPublication(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackPublicationByName(name) {\n        const track = super.getTrackPublicationByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrackPublication(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant's microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrackPublication(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it's possible for the media track to arrive before participant info\n        let publication = this.getTrackPublicationBySid(sid);\n        // it's also possible that the browser didn't honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith(\"TR\")) {\n                // find the first track that matches type\n                this.trackPublications.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn't locate the track, it's possible that the metadata hasn't\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                this.log.error(\"could not find published track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: sid\n                }));\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            this.log.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === \"video\";\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication's muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    /**\n   * @internal\n   */ getTrackPublicationBySid(sid) {\n        return this.trackPublications.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            let publication = this.getTrackPublicationBySid(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n                    loggerContextCb: ()=>this.logContext,\n                    loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n                });\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n                        oldTrack: getLogContextFromTrack(existingTrackOfSource),\n                        newTrack: getLogContextFromTrack(publication)\n                    }));\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.trackPublications.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                this.log.trace(\"detected removed track on remote participant, unpublishing\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it's ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.trackPublications.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.trackPublications.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTrackPublications.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTrackPublications.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTrackPublications.forEach((pub)=>{\n                var _a;\n                if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : \"default\"));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        this.log.trace(\"participant event\", Object.assign(Object.assign({}, this.logContext), {\n            event,\n            args\n        }));\n        return super.emit(event, ...args);\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Disconnected\"] = \"disconnected\";\n    ConnectionState[\"Connecting\"] = \"connecting\";\n    ConnectionState[\"Connected\"] = \"connected\";\n    ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n    ConnectionState[\"SignalReconnecting\"] = \"signalReconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 4 * 1000;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a, _b, _c;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.log = livekitLogger;\n        this.bufferedEvents = [];\n        this.isResuming = false;\n        this.byteStreamControllers = new Map();\n        this.textStreamControllers = new Map();\n        this.byteStreamHandlers = new Map();\n        this.textStreamHandlers = new Map();\n        this.rpcHandlers = new Map();\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _a;\n                if (!isBrowserSupported()) {\n                    if (isReactNative()) {\n                        throw Error(\"WebRTC isn't detected, have you called registerGlobals?\");\n                    } else {\n                        throw Error(\"LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.\");\n                    }\n                }\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().then((settings)=>{\n                        var _a;\n                        (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.setServerReportedRegions(settings);\n                    }).catch((e)=>{\n                        this.log.warn(\"could not fetch region settings\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _a, _b;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (e) {\n                            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== ConnectionErrorReason.Cancelled && e.reason !== ConnectionErrorReason.NotAllowed) {\n                                let nextUrl = null;\n                                try {\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\n                                } catch (error) {\n                                    if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(error);\n                                        return;\n                                    }\n                                }\n                                if (nextUrl && !((_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.aborted)) {\n                                    this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n                                    this.recreateEngine();\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e));\n                                    reject(e);\n                                }\n                            } else {\n                                let disconnectReason = DisconnectReason.UNKNOWN_REASON;\n                                if (e instanceof ConnectionError) {\n                                    disconnectReason = getDisconnectReasonFromConnectionError(e);\n                                }\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);\n                                reject(e);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c;\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === \"object\" ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                this.serverInfo = serverInfo;\n                this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return \"\".concat(key, \": \").concat(value);\n                }).join(\", \")), {\n                    room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,\n                    roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,\n                    identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity\n                });\n                if (!serverInfo.version) {\n                    throw new UnsupportedServer(\"unknown server version\");\n                }\n                if (serverInfo.version === \"0.15.1\" && this.options.dynacast) {\n                    this.log.debug(\"disabling dynacast due to server version\", this.logContext);\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);\n            if (this.options.e2ee && this.e2eeManager) {\n                try {\n                    this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n                } catch (e) {\n                    this.log.error(e instanceof Error ? e.message : \"Could not set SifTrailer\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)) {\n                    this.log.info(\"Reconnection attempt replaced by new connection attempt\", this.logContext);\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError(\"could not establish signal connection\", ConnectionErrorReason.ServerUnreachable);\n                    if (err instanceof Error) {\n                        resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n                        error: err\n                    }));\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError(\"Connection attempt aborted\", ConnectionErrorReason.Cancelled);\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n                    window.addEventListener(\"pagehide\", this.onPageLeave);\n                    window.addEventListener(\"beforeunload\", this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener(\"freeze\", this.onPageLeave);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                this.registerConnectionReconcile();\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            for(var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++){\n                args_1[_key] = arguments[_key];\n            }\n            return __awaiter(_this, [\n                ...args_1\n            ], void 0, function() {\n                var _this2 = this;\n                let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                return function*() {\n                    var _a, _b, _c, _d;\n                    const unlock = yield _this2.disconnectLock.lock();\n                    try {\n                        if (_this2.state === ConnectionState.Disconnected) {\n                            _this2.log.debug(\"already disconnected\", _this2.logContext);\n                            return;\n                        }\n                        _this2.log.info(\"disconnect from room\", Object.assign({}, _this2.logContext));\n                        if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {\n                            // try aborting pending connection attempt\n                            _this2.log.warn(\"abort connection attempt\", _this2.logContext);\n                            (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n                            // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n                            (_c = (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, new ConnectionError(\"Client initiated disconnect\", ConnectionErrorReason.Cancelled));\n                            _this2.connectFuture = undefined;\n                        }\n                        // send leave\n                        if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {\n                            yield _this2.engine.client.sendLeave();\n                        }\n                        // close engine (also closes client)\n                        if (_this2.engine) {\n                            yield _this2.engine.close();\n                        }\n                        _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                        /* @ts-ignore */ _this2.engine = undefined;\n                    } finally{\n                        unlock();\n                    }\n                }();\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.log.info(\"Page leave detected, disconnecting\", this.logContext);\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === \"iOS\") {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = \"livekit-dummy-audio-el\";\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement(\"audio\");\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener(\"visibilitychange\", ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                            if (!document.hidden) {\n                                this.log.debug(\"page visible again, triggering startAudio to resume playback and update playback status\", this.logContext);\n                                this.startAudio();\n                            }\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                            dummyAudioEl = null;\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.remoteParticipants.forEach((p)=>{\n                    p.audioTrackPublications.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.remoteParticipants.values()){\n                    p.videoTrackPublications.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === \"NotAllowedError\") {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        this.log.warn(\"Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler\", this.logContext);\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag\n            this.isResuming = false;\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.remoteParticipants.values()){\n                this.handleParticipantDisconnected(p.identity, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n                    region: joinResponse.serverRegion\n                }));\n                this.bufferedEvents = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    yield this.localParticipant.republishAllTracks(undefined, true);\n                } catch (error) {\n                    this.log.error(\"error trying to re-publish tracks after reconnection\", Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n                        region: joinResponse.serverRegion\n                    }));\n                } catch (_a) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                this.emitBufferedEvents();\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                var _a;\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates\n                // so we try to map an empty identity to an already known sID manually\n                if (info.identity === \"\") {\n                    info.identity = (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : \"\";\n                }\n                let remoteParticipant = this.remoteParticipants.get(info.identity);\n                // when it's disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.identity, remoteParticipant);\n                } else {\n                    // create participant if doesn't exist\n                    remoteParticipant = this.getOrCreateParticipant(info.identity, info);\n                }\n            });\n        };\n        // updates are sent only when there's a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.getRemoteParticipantBySid(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.remoteParticipants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                const remoteParticipant = this.remoteParticipants.get(p.identity);\n                if (remoteParticipant && remoteParticipant.sid !== p.sid) {\n                    return;\n                }\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.getRemoteParticipantBySid(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.getRemoteParticipantBySid(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublicationBySid(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                const newStreamState = Track.streamStateFromProto(streamState.state);\n                if (newStreamState !== pub.track.streamState) {\n                    pub.track.streamState = newStreamState;\n                    participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                    this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n                }\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.getRemoteParticipantBySid(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublicationBySid(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.remoteParticipants.values()).find((p)=>p.trackPublications.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublicationBySid(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (packet)=>{\n            // find the participant\n            const participant = this.remoteParticipants.get(packet.participantIdentity);\n            if (packet.value.case === \"user\") {\n                this.handleUserPacket(participant, packet.value.value, packet.kind);\n            } else if (packet.value.case === \"transcription\") {\n                this.handleTranscription(participant, packet.value.value);\n            } else if (packet.value.case === \"sipDtmf\") {\n                this.handleSipDtmf(participant, packet.value.value);\n            } else if (packet.value.case === \"chatMessage\") {\n                this.handleChatMessage(participant, packet.value.value);\n            } else if (packet.value.case === \"metrics\") {\n                this.handleMetrics(packet.value.value, participant);\n            } else if (packet.value.case === \"streamHeader\") {\n                this.handleStreamHeader(packet.value.value, packet.participantIdentity);\n            } else if (packet.value.case === \"streamChunk\") {\n                this.handleStreamChunk(packet.value.value);\n            } else if (packet.value.case === \"streamTrailer\") {\n                this.handleStreamTrailer(packet.value.value);\n            } else if (packet.value.case === \"rpcRequest\") {\n                const rpc = packet.value.value;\n                this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);\n            }\n        };\n        this.handleUserPacket = (participant, userPacket, kind)=>{\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n        };\n        this.handleSipDtmf = (participant, dtmf)=>{\n            this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);\n        };\n        this.bufferedSegments = new Map();\n        this.handleTranscription = (_remoteParticipant, transcription)=>{\n            // find the participant\n            const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);\n            const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);\n            const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);\n            publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);\n            this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);\n        };\n        this.handleChatMessage = (participant, chatMessage)=>{\n            const msg = extractChatMessage(chatMessage);\n            this.emit(RoomEvent.ChatMessage, msg, participant);\n        };\n        this.handleMetrics = (metrics, participant)=>{\n            this.emit(RoomEvent.MetricsReceived, metrics, participant);\n        };\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            this.log.warn(\"could not playback audio\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                const previousDevices = DeviceManager.getInstance().previousDevices;\n                // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before\n                const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && browser.os !== \"iOS\") {\n                    for (let availableDevice of availableDevices){\n                        const previousDevice = previousDevices.find((info)=>info.deviceId === availableDevice.deviceId);\n                        if (previousDevice && previousDevice.label !== \"\" && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {\n                            // label has changed on device the same deviceId, indicating that the default device has changed on the OS level\n                            if (this.getActiveDevice(availableDevice.kind) === \"default\") {\n                                // emit an active device change event only if the selected output device is actually on `default`\n                                this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);\n                            }\n                        }\n                    }\n                }\n                // inputs are automatically handled via TrackEvent.Ended causing a TrackEvent.Restarted. Here we only need to worry about audiooutputs changing\n                const kinds = [\n                    \"audiooutput\",\n                    \"audioinput\",\n                    \"videoinput\"\n                ];\n                for (let kind of kinds){\n                    const devicesOfKind = availableDevices.filter((d)=>d.kind === kind);\n                    const activeDevice = this.getActiveDevice(kind);\n                    if (activeDevice === ((_a = previousDevices.filter((info)=>info.kind === kind)[0]) === null || _a === void 0 ? void 0 : _a.deviceId)) {\n                        // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes\n                        // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array\n                        if (devicesOfKind.length > 0 && ((_b = devicesOfKind[0]) === null || _b === void 0 ? void 0 : _b.deviceId) !== activeDevice) {\n                            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n                            continue;\n                        }\n                    }\n                    if (kind === \"audioinput\" && !isSafari() || kind === \"videoinput\") {\n                        continue;\n                    }\n                    // switch to first available device if previously active device is not available any more\n                    if (devicesOfKind.length > 0 && !devicesOfKind.find((deviceInfo)=>deviceInfo.deviceId === this.getActiveDevice(kind))) {\n                        yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n                    }\n                }\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.getRemoteParticipantBySid(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalAttributesChanged = (changedAttributes)=>{\n            this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onTrackProcessorUpdate = (processor)=>{\n            var _a;\n            (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a === void 0 ? void 0 : _a.call(processor, this);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c, _d, _e, _f;\n                (_a = pub.track) === null || _a === void 0 ? void 0 : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n                (_b = pub.track) === null || _b === void 0 ? void 0 : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);\n                (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (isLocalAudioTrack(pub.track)) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            var _a, _b;\n            (_a = pub.track) === null || _a === void 0 ? void 0 : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalTrackRestarted = (track)=>__awaiter(this, void 0, void 0, function*() {\n                const deviceId = yield track.getDeviceId(false);\n                const deviceKind = sourceToKind(track.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.log.debug(\"local track restarted, setting \".concat(deviceKind, \" \").concat(deviceId, \" active\"), this.logContext);\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e)=>{\n            this.emit(RoomEvent.MediaDevicesError, e);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.onLocalChatMessageSent = (msg)=>{\n            this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.remoteParticipants = new Map();\n        this.sidToIdentity = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n        this.transcriptionReceivedTimes = new Map();\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.disconnectLock = new _();\n        this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options, this.rpcHandlers);\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"videoinput\", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"audioinput\", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n            this.switchActiveDevice(\"audiooutput\", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        if (this.options.e2ee) {\n            this.setupE2EE();\n        }\n        if (isWeb()) {\n            const abortController = new AbortController();\n            // in order to catch device changes prior to room connection we need to register the event in the constructor\n            (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener(\"devicechange\", this.handleDeviceChange, {\n                signal: abortController.signal\n            });\n            if (Room.cleanupRegistry) {\n                Room.cleanupRegistry.register(this, ()=>{\n                    abortController.abort();\n                });\n            }\n        }\n    }\n    registerTextStreamHandler(topic, callback) {\n        if (this.textStreamHandlers.has(topic)) {\n            throw new TypeError('A text stream handler for topic \"'.concat(topic, '\" has already been set.'));\n        }\n        this.textStreamHandlers.set(topic, callback);\n    }\n    unregisterTextStreamHandler(topic) {\n        this.textStreamHandlers.delete(topic);\n    }\n    registerByteStreamHandler(topic, callback) {\n        if (this.byteStreamHandlers.has(topic)) {\n            throw new TypeError('A byte stream handler for topic \"'.concat(topic, '\" has already been set.'));\n        }\n        this.byteStreamHandlers.set(topic, callback);\n    }\n    unregisterByteStreamHandler(topic) {\n        this.byteStreamHandlers.delete(topic);\n    }\n    /**\n   * Establishes the participant as a receiver for calls of the specified RPC method.\n   *\n   * @param method - The name of the indicated RPC method\n   * @param handler - Will be invoked when an RPC request for this method is received\n   * @returns A promise that resolves when the method is successfully registered\n   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)\n   *\n   * @example\n   * ```typescript\n   * room.localParticipant?.registerRpcMethod(\n   *   'greet',\n   *   async (data: RpcInvocationData) => {\n   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);\n   *     return `Hello, ${data.callerIdentity}!`;\n   *   }\n   * );\n   * ```\n   *\n   * The handler should return a Promise that resolves to a string.\n   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.\n   *\n   * You may throw errors of type `RpcError` with a string `message` in the handler,\n   * and they will be received on the caller's side with the message intact.\n   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` (\"Application Error\").\n   */ registerRpcMethod(method, handler) {\n        if (this.rpcHandlers.has(method)) {\n            throw Error(\"RPC handler already registered for method \".concat(method, \", unregisterRpcMethod before trying to register again\"));\n        }\n        this.rpcHandlers.set(method, handler);\n    }\n    /**\n   * Unregisters a previously registered RPC method.\n   *\n   * @param method - The name of the RPC method to unregister\n   */ unregisterRpcMethod(method) {\n        this.rpcHandlers.delete(method);\n    }\n    handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.engine.publishRpcAck(callerIdentity, requestId);\n            if (version !== 1) {\n                yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn(\"UNSUPPORTED_VERSION\"));\n                return;\n            }\n            const handler = this.rpcHandlers.get(method);\n            if (!handler) {\n                yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn(\"UNSUPPORTED_METHOD\"));\n                return;\n            }\n            let responseError = null;\n            let responsePayload = null;\n            try {\n                const response = yield handler({\n                    requestId,\n                    callerIdentity,\n                    payload,\n                    responseTimeout\n                });\n                if (byteLength(response) > MAX_PAYLOAD_BYTES) {\n                    responseError = RpcError.builtIn(\"RESPONSE_PAYLOAD_TOO_LARGE\");\n                    console.warn(\"RPC Response payload too large for \".concat(method));\n                } else {\n                    responsePayload = response;\n                }\n            } catch (error) {\n                if (error instanceof RpcError) {\n                    responseError = error;\n                } else {\n                    console.warn(\"Uncaught error returned by RPC handler for \".concat(method, \". Returning APPLICATION_ERROR instead.\"), error);\n                    responseError = RpcError.builtIn(\"APPLICATION_ERROR\");\n                }\n            }\n            yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);\n        });\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== \"\") {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error(\"e2ee not configured, please set e2ee settings within the room options\");\n            }\n        });\n    }\n    setupE2EE() {\n        var _a;\n        if (this.options.e2ee) {\n            if (\"e2eeManager\" in this.options.e2ee) {\n                this.e2eeManager = this.options.e2ee.e2eeManager;\n            } else {\n                this.e2eeManager = new E2EEManager(this.options.e2ee);\n            }\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (isLocalParticipant(participant)) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error)=>this.emit(RoomEvent.EncryptionError, error));\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    get logContext() {\n        var _a;\n        return {\n            room: this.name,\n            roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,\n            participant: this.localParticipant.identity,\n            pID: this.localParticipant.sid\n        };\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n   * server assigned unique room id.\n   * returns once a sid has been issued by the server.\n   */ getSid() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === ConnectionState.Disconnected) {\n                return \"\";\n            }\n            if (this.roomInfo && this.roomInfo.sid !== \"\") {\n                return this.roomInfo.sid;\n            }\n            return new Promise((resolve, reject)=>{\n                const handleRoomUpdate = (roomInfo)=>{\n                    if (roomInfo.sid !== \"\") {\n                        this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n                        resolve(roomInfo.sid);\n                    }\n                };\n                this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);\n                this.once(RoomEvent.Disconnected, ()=>{\n                    this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n                    reject(\"Room disconnected before room server id was available\");\n                });\n            });\n        });\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            this.isResuming = true;\n            this.log.info(\"Resuming signal connection\", this.logContext);\n            if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {\n                this.emit(RoomEvent.SignalReconnecting);\n            }\n        }).on(EngineEvent.Resumed, ()=>{\n            this.registerConnectionReconcile();\n            this.isResuming = false;\n            this.log.info(\"Resumed signal connection\", this.logContext);\n            this.updateSubscriptions();\n            this.emitBufferedEvents();\n            if (this.setAndEmitConnectionState(ConnectionState.Connected)) {\n                this.emit(RoomEvent.Reconnected);\n            }\n        }).on(EngineEvent.SignalResumed, ()=>{\n            this.bufferedEvents = [];\n            if (this.state === ConnectionState.Reconnecting || this.isResuming) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, ()=>{\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        }).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        }).on(EngineEvent.LocalTrackSubscribed, (subscribedSid)=>{\n            const trackPublication = this.localParticipant.getTrackPublications().find((_ref2)=>{\n                let { trackSid } = _ref2;\n                return trackSid === subscribedSid;\n            });\n            if (!trackPublication) {\n                this.log.warn(\"could not find local track subscription for subscribed event\", this.logContext);\n                return;\n            }\n            this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);\n            this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it requests device permissions by default if needed\n   * and makes sure the returned device does not consist of dummy devices\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: \"HEAD\"\n                        });\n                        this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: \"HEAD\"\n                    });\n                }\n            } catch (e) {\n                this.log.warn(\"could not prepare connection\", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        return this.remoteParticipants.get(identity);\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>{};\n            let req;\n            switch(scenario){\n                case \"signal-reconnect\":\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate disconnect\");\n                    break;\n                case \"speaker\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"speakerUpdate\",\n                            value: 3\n                        }\n                    });\n                    break;\n                case \"node-failure\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"nodeFailure\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"server-leave\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"serverLeave\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"migration\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"migration\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"resume-reconnect\":\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                    break;\n                case \"disconnect-signal-on-resume\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResume\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"disconnect-signal-on-resume-no-messages\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResumeNoMessages\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"full-reconnect\":\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate full-reconnect\");\n                    break;\n                case \"force-tcp\":\n                case \"force-tls\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"switchCandidateProtocol\",\n                            value: scenario === \"force-tls\" ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    action: LeaveRequest_Action.RECONNECT\n                                }));\n                            }\n                        });\n                    break;\n                case \"subscriber-bandwidth\":\n                    if (arg === undefined || typeof arg !== \"number\") {\n                        throw new Error(\"subscriber-bandwidth requires a number as argument\");\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"subscriberBandwidth\",\n                            value: numberToBigInt(arg)\n                        }\n                    });\n                    break;\n                case \"leave-full-reconnect\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"leaveRequestFullReconnect\",\n                            value: true\n                        }\n                    });\n            }\n            if (req) {\n                yield this.engine.client.sendSimulateScenario(req);\n                yield postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind_1, deviceId_1) {\n        return __awaiter(this, arguments, void 0, function(kind, deviceId) {\n            var _this3 = this;\n            let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            return function*() {\n                var _a, _b, _c, _d, _e, _f, _g;\n                var _h;\n                let success = true;\n                let needsUpdateWithoutTracks = false;\n                const deviceConstraint = exact ? {\n                    exact: deviceId\n                } : deviceId;\n                if (kind === \"audioinput\") {\n                    needsUpdateWithoutTracks = _this3.localParticipant.audioTrackPublications.size === 0;\n                    const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;\n                    _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                    const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter((track)=>track.source === Track.Source.Microphone);\n                    try {\n                        success = (yield Promise.all(tracks.map((t)=>{\n                            var _a;\n                            return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                        }))).every((val)=>val === true);\n                    } catch (e) {\n                        _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                } else if (kind === \"videoinput\") {\n                    needsUpdateWithoutTracks = _this3.localParticipant.videoTrackPublications.size === 0;\n                    const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;\n                    _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                    const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter((track)=>track.source === Track.Source.Camera);\n                    try {\n                        success = (yield Promise.all(tracks.map((t)=>{\n                            var _a;\n                            return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                        }))).every((val)=>val === true);\n                    } catch (e) {\n                        _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                } else if (kind === \"audiooutput\") {\n                    if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !(\"setSinkId\" in _this3.audioContext)) {\n                        throw new Error(\"cannot switch audio output, setSinkId not supported\");\n                    }\n                    if (_this3.options.webAudioMix) {\n                        // setting `default` for web audio output doesn't work, so we need to normalize the id before\n                        deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId(\"audiooutput\", deviceId)) !== null && _c !== void 0 ? _c : \"\";\n                    }\n                    (_d = (_h = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};\n                    const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;\n                    _this3.options.audioOutput.deviceId = deviceId;\n                    try {\n                        if (_this3.options.webAudioMix) {\n                            // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                            (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);\n                        }\n                        // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices\n                        // see https://issues.chromium.org/issues/40252911#comment7\n                        yield Promise.all(Array.from(_this3.remoteParticipants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    } catch (e) {\n                        _this3.options.audioOutput.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                }\n                if (needsUpdateWithoutTracks || kind === \"audiooutput\") {\n                    // if there are not active tracks yet or we're switching audiooutput, we need to manually update the active device map here as changing audio output won't result in a track restart\n                    _this3.localParticipant.activeDeviceMap.set(kind, kind === \"audiooutput\" && ((_g = _this3.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);\n                    _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n                }\n                return success;\n            }();\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        this.isResuming = false;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.remoteParticipants.clear();\n        this.sidToIdentity.clear();\n        this.bufferedEvents = [];\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don't fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We'll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            this.log.warn(\"skipping incoming track after Room disconnected\", this.logContext);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            this.log.info(\"skipping incoming track as it already ended\", this.logContext);\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantSid = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith(\"TR\")) trackId = streamId;\n        if (participantSid === this.localParticipant.sid) {\n            this.log.warn(\"tried to create RemoteParticipant for local participant\", this.logContext);\n            return;\n        }\n        const participant = Array.from(this.remoteParticipants.values()).find((p)=>p.sid === participantSid);\n        if (!participant) {\n            this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\n            return;\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === \"object\") {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        this.isResuming = false;\n        this.bufferedEvents = [];\n        this.transcriptionReceivedTimes.clear();\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        try {\n            this.remoteParticipants.forEach((p)=>{\n                p.trackPublications.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.trackPublications.forEach((pub)=>{\n                var _a, _b, _c;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                } else {\n                    (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.trackPublications.clear();\n            this.localParticipant.videoTrackPublications.clear();\n            this.localParticipant.audioTrackPublications.clear();\n            this.remoteParticipants.clear();\n            this.sidToIdentity.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.webAudioMix === \"boolean\") {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener(\"beforeunload\", this.onPageLeave);\n                window.removeEventListener(\"pagehide\", this.onPageLeave);\n                window.removeEventListener(\"freeze\", this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"devicechange\", this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(identity, participant) {\n        var _a;\n        // remove and send event\n        this.remoteParticipants.delete(identity);\n        if (!participant) {\n            return;\n        }\n        participant.trackPublications.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n        (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);\n    }\n    handleStreamHeader(streamHeader, participantIdentity) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (streamHeader.contentHeader.case === \"byteHeader\") {\n                const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);\n                if (!streamHandlerCallback) {\n                    this.log.debug(\"ignoring incoming byte stream due to no handler for topic\", streamHeader.topic);\n                    return;\n                }\n                let streamController;\n                const info = {\n                    id: streamHeader.streamId,\n                    name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : \"unknown\",\n                    mimeType: streamHeader.mimeType,\n                    size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n                    topic: streamHeader.topic,\n                    timestamp: bigIntToNumber(streamHeader.timestamp),\n                    attributes: streamHeader.attributes\n                };\n                const stream = new ReadableStream({\n                    start: (controller)=>{\n                        streamController = controller;\n                        this.byteStreamControllers.set(streamHeader.streamId, {\n                            info,\n                            controller: streamController,\n                            startTime: Date.now()\n                        });\n                    }\n                });\n                streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\n                    identity: participantIdentity\n                });\n            } else if (streamHeader.contentHeader.case === \"textHeader\") {\n                const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);\n                if (!streamHandlerCallback) {\n                    this.log.debug(\"ignoring incoming text stream due to no handler for topic\", streamHeader.topic);\n                    return;\n                }\n                let streamController;\n                const info = {\n                    id: streamHeader.streamId,\n                    mimeType: streamHeader.mimeType,\n                    size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n                    topic: streamHeader.topic,\n                    timestamp: Number(streamHeader.timestamp),\n                    attributes: streamHeader.attributes\n                };\n                const stream = new ReadableStream({\n                    start: (controller)=>{\n                        streamController = controller;\n                        this.textStreamControllers.set(streamHeader.streamId, {\n                            info,\n                            controller: streamController,\n                            startTime: Date.now()\n                        });\n                    }\n                });\n                streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\n                    identity: participantIdentity\n                });\n            }\n        });\n    }\n    handleStreamChunk(chunk) {\n        const fileBuffer = this.byteStreamControllers.get(chunk.streamId);\n        if (fileBuffer) {\n            if (chunk.content.length > 0) {\n                fileBuffer.controller.enqueue(chunk);\n            }\n        }\n        const textBuffer = this.textStreamControllers.get(chunk.streamId);\n        if (textBuffer) {\n            if (chunk.content.length > 0) {\n                textBuffer.controller.enqueue(chunk);\n            }\n        }\n    }\n    handleStreamTrailer(trailer) {\n        const textBuffer = this.textStreamControllers.get(trailer.streamId);\n        if (textBuffer) {\n            textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);\n            textBuffer.controller.close();\n            this.textStreamControllers.delete(trailer.streamId);\n        }\n        const fileBuffer = this.byteStreamControllers.get(trailer.streamId);\n        if (fileBuffer) {\n            {\n                fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);\n                fileBuffer.controller.close();\n                this.byteStreamControllers.delete(trailer.streamId);\n            }\n        }\n    }\n    acquireAudioContext() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            if (typeof this.options.webAudioMix !== \"boolean\" && this.options.webAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.webAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === \"closed\") {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.options.webAudioMix) {\n                this.remoteParticipants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            if (this.audioContext && this.audioContext.state === \"suspended\") {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n                try {\n                    yield Promise.race([\n                        this.audioContext.resume(),\n                        sleep(200)\n                    ]);\n                } catch (e) {\n                    this.log.warn(\"Could not resume audio context\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === \"running\";\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(identity, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        } else {\n            participant = new RemoteParticipant(this.engine.client, \"\", identity, undefined, undefined, undefined, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        }\n        if (this.options.webAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(identity, info) {\n        if (this.remoteParticipants.has(identity)) {\n            const existingParticipant = this.remoteParticipants.get(identity);\n            if (info) {\n                const wasUpdated = existingParticipant.updateInfo(info);\n                if (wasUpdated) {\n                    this.sidToIdentity.set(info.sid, info.identity);\n                }\n            }\n            return existingParticipant;\n        }\n        const participant = this.createParticipant(identity, info);\n        this.remoteParticipants.set(identity, participant);\n        this.sidToIdentity.set(info.sid, info.identity);\n        // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.AttributesChanged, (changedAttributes)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.remoteParticipants.values()){\n            for (const pub of p.videoTrackPublications.values()){\n                if (pub.isSubscribed && isRemotePub(pub)) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    getRemoteParticipantBySid(sid) {\n        const identity = this.sidToIdentity.get(sid);\n        if (identity) {\n            return this.remoteParticipants.get(identity);\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn't tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                this.log.warn(\"detected connection state mismatch\", Object.assign(Object.assign({}, this.logContext), {\n                    numFailures: consecutiveFailures,\n                    engine: this.engine ? {\n                        closed: this.engine.isClosed,\n                        transportsConnected: this.engine.verifyTransport()\n                    } : undefined\n                }));\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, connectionReconcileFrequency);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitBufferedEvents() {\n        this.bufferedEvents.forEach((_ref3)=>{\n            let [ev, args] = _ref3;\n            this.emit(ev, ...args);\n        });\n        this.bufferedEvents = [];\n    }\n    emitWhenConnected(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {\n            // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\n            this.bufferedEvents.push([\n                event,\n                args\n            ]);\n        } else if (this.state === ConnectionState.Connected) {\n            return this.emit(event, ...args);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: \"RM_SIMULATED\",\n                name: \"simulated-room\",\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: \"\",\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: \"\",\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: \"simulated-local\",\n                name: \"local-name\"\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: \"video-dummy\"\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: \"simulated-\".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]), new RTCRtpReceiver());\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]), new RTCRtpReceiver());\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){\n            args[_key3 - 1] = arguments[_key3];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {\n            // only extract logContext from arguments in order to avoid logging the whole object tree\n            const minimizedArgs = mapArgs(args).filter((arg)=>arg !== undefined);\n            this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                event,\n                args: minimizedArgs\n            }));\n        }\n        return super.emit(event, ...args);\n    }\n}\nRoom.cleanupRegistry = typeof FinalizationRegistry !== \"undefined\" && new FinalizationRegistry((cleanup)=>{\n    cleanup();\n});\nfunction mapArgs(args) {\n    return args.map((arg)=>{\n        if (!arg) {\n            return;\n        }\n        if (Array.isArray(arg)) {\n            return mapArgs(arg);\n        }\n        if (typeof arg === \"object\") {\n            return \"logContext\" in arg ? arg.logContext : undefined;\n        }\n        return arg;\n    });\n}\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n    CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n    CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.options = {};\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        this.options = options;\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error(\"check is running already\");\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.options.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === \"error\");\n    }\n    connect(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            if (!url) {\n                url = this.url;\n            }\n            yield this.room.connect(url, this.token, this.connectOptions);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    switchProtocol(protocol) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasReconnecting = false;\n            let hasReconnected = false;\n            this.room.on(RoomEvent.Reconnecting, ()=>{\n                hasReconnecting = true;\n            });\n            this.room.once(RoomEvent.Reconnected, ()=>{\n                hasReconnected = true;\n            });\n            this.room.simulateScenario(\"force-\".concat(protocol));\n            yield new Promise((resolve)=>setTimeout(resolve, 1000));\n            if (!hasReconnecting) {\n                // no need to wait for reconnection\n                return;\n            }\n            // wait for 10 seconds for reconnection\n            const timeout = Date.now() + 10000;\n            while(Date.now() < timeout){\n                if (hasReconnected) {\n                    return;\n                }\n                yield sleep(100);\n            }\n            throw new Error(\"Could not reconnect using \".concat(protocol, \" protocol after 10 seconds\"));\n        });\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: \"info\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: \"warning\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: \"error\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit(\"update\", this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Checks for connections quality to closests Cloud regions and determining the best quality\n */ class CloudRegionCheck extends Checker {\n    get description() {\n        return \"Cloud regions\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionProvider = new RegionUrlProvider(this.url, this.token);\n            if (!regionProvider.isCloud()) {\n                this.skip();\n                return;\n            }\n            const regionStats = [];\n            const seenUrls = new Set();\n            for(let i = 0; i < 3; i++){\n                const regionUrl = yield regionProvider.getNextBestRegionUrl();\n                if (!regionUrl) {\n                    break;\n                }\n                if (seenUrls.has(regionUrl)) {\n                    continue;\n                }\n                seenUrls.add(regionUrl);\n                const stats = yield this.checkCloudRegion(regionUrl);\n                this.appendMessage(\"\".concat(stats.region, \" RTT: \").concat(stats.rtt, \"ms, duration: \").concat(stats.duration, \"ms\"));\n                regionStats.push(stats);\n            }\n            regionStats.sort((a, b)=>{\n                return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;\n            });\n            const bestRegion = regionStats[0];\n            this.bestStats = bestRegion;\n            this.appendMessage(\"best Cloud region: \".concat(bestRegion.region));\n        });\n    }\n    getInfo() {\n        const info = super.getInfo();\n        info.data = this.bestStats;\n        return info;\n    }\n    checkCloudRegion(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            yield this.connect(url);\n            if (this.options.protocol === \"tcp\") {\n                yield this.switchProtocol(\"tcp\");\n            }\n            const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;\n            if (!region) {\n                throw new Error(\"Region not found\");\n            }\n            const writer = yield this.room.localParticipant.streamText({\n                topic: \"test\"\n            });\n            const chunkSize = 1000; // each chunk is about 1000 bytes\n            const totalSize = 1000000; // approximately 1MB of data\n            const numChunks = totalSize / chunkSize; // will yield 1000 chunks\n            const chunkData = \"A\".repeat(chunkSize); // create a string of 1000 'A' characters\n            const startTime = Date.now();\n            for(let i = 0; i < numChunks; i++){\n                yield writer.write(chunkData);\n            }\n            yield writer.close();\n            const endTime = Date.now();\n            const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();\n            const regionStats = {\n                region: region,\n                rtt: 10000,\n                duration: endTime - startTime\n            };\n            stats === null || stats === void 0 ? void 0 : stats.forEach((stat)=>{\n                if (stat.type === \"candidate-pair\" && stat.nominated) {\n                    regionStats.rtt = stat.currentRoundTripTime * 1000;\n                }\n            });\n            yield this.disconnect();\n            return regionStats;\n        });\n    }\n}\nconst TEST_DURATION = 10000;\nclass ConnectionProtocolCheck extends Checker {\n    get description() {\n        return \"Connection via UDP vs TCP\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const udpStats = yield this.checkConnectionProtocol(\"udp\");\n            const tcpStats = yield this.checkConnectionProtocol(\"tcp\");\n            this.bestStats = udpStats;\n            // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:\n            // 1. the bandwidth limitation is worse on UDP by 500ms\n            // 2. the packet loss is higher on UDP by 1%\n            if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {\n                this.appendMessage(\"best connection quality via tcp\");\n                this.bestStats = tcpStats;\n            } else {\n                this.appendMessage(\"best connection quality via udp\");\n            }\n            const stats = this.bestStats;\n            this.appendMessage(\"upstream bitrate: \".concat((stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2), \" mbps\"));\n            this.appendMessage(\"RTT: \".concat((stats.rttTotal / stats.count * 1000).toFixed(2), \" ms\"));\n            this.appendMessage(\"jitter: \".concat((stats.jitterTotal / stats.count * 1000).toFixed(2), \" ms\"));\n            if (stats.packetsLost > 0) {\n                this.appendWarning(\"packets lost: \".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), \"%\"));\n            }\n            if (stats.qualityLimitationDurations.bandwidth > 1) {\n                this.appendWarning(\"bandwidth limited \".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n            }\n            if (stats.qualityLimitationDurations.cpu > 0) {\n                this.appendWarning(\"cpu limited \".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n            }\n        });\n    }\n    getInfo() {\n        const info = super.getInfo();\n        info.data = this.bestStats;\n        return info;\n    }\n    checkConnectionProtocol(protocol) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.connect();\n            if (protocol === \"tcp\") {\n                yield this.switchProtocol(\"tcp\");\n            } else {\n                yield this.switchProtocol(\"udp\");\n            }\n            // create a canvas with animated content\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = 1280;\n            canvas.height = 720;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                throw new Error(\"Could not get canvas context\");\n            }\n            let hue = 0;\n            const animate = ()=>{\n                hue = (hue + 1) % 360;\n                ctx.fillStyle = \"hsl(\".concat(hue, \", 100%, 50%)\");\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                requestAnimationFrame(animate);\n            };\n            animate();\n            // create video track from canvas\n            const stream = canvas.captureStream(30); // 30fps\n            const videoTrack = stream.getVideoTracks()[0];\n            // publish to room\n            const pub = yield this.room.localParticipant.publishTrack(videoTrack, {\n                simulcast: false,\n                degradationPreference: \"maintain-resolution\",\n                videoEncoding: {\n                    maxBitrate: 2000000\n                }\n            });\n            const track = pub.track;\n            const protocolStats = {\n                protocol,\n                packetsLost: 0,\n                packetsSent: 0,\n                qualityLimitationDurations: {},\n                rttTotal: 0,\n                jitterTotal: 0,\n                bitrateTotal: 0,\n                count: 0\n            };\n            // gather stats once a second\n            const interval = setInterval(()=>__awaiter(this, void 0, void 0, function*() {\n                    const stats = yield track.getRTCStatsReport();\n                    stats === null || stats === void 0 ? void 0 : stats.forEach((stat)=>{\n                        if (stat.type === \"outbound-rtp\") {\n                            protocolStats.packetsSent = stat.packetsSent;\n                            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;\n                            protocolStats.bitrateTotal += stat.targetBitrate;\n                            protocolStats.count++;\n                        } else if (stat.type === \"remote-inbound-rtp\") {\n                            protocolStats.packetsLost = stat.packetsLost;\n                            protocolStats.rttTotal += stat.roundTripTime;\n                            protocolStats.jitterTotal += stat.jitter;\n                        }\n                    });\n                }), 1000);\n            // wait a bit to gather stats\n            yield new Promise((resolve)=>setTimeout(resolve, TEST_DURATION));\n            clearInterval(interval);\n            videoTrack.stop();\n            canvas.remove();\n            yield this.disconnect();\n            return protocolStats;\n        });\n    }\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return \"Can publish audio\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            const trackIsSilent = yield detectSilence(track, 1000);\n            if (trackIsSilent) {\n                throw new Error(\"unable to detect audio from microphone\");\n            }\n            this.appendMessage(\"detected audio from microphone\");\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && (stat.kind === \"audio\" || !stat.kind && stat.mediaType === \"audio\")) {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return \"Can publish video\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            // check if we have video from camera\n            yield this.checkForVideo(track.mediaStreamTrack);\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 5000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && (stat.kind === \"video\" || !stat.kind && stat.mediaType === \"video\")) {\n                    numPackets += stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n        });\n    }\n    checkForVideo(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const stream = new MediaStream();\n            stream.addTrack(track.clone());\n            // Create video element to check frames\n            const video = document.createElement(\"video\");\n            video.srcObject = stream;\n            video.muted = true;\n            yield new Promise((resolve)=>{\n                video.onplay = ()=>{\n                    setTimeout(()=>{\n                        var _a, _b, _c, _d;\n                        const canvas = document.createElement(\"canvas\");\n                        const settings = track.getSettings();\n                        const width = (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;\n                        const height = (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !== null && _d !== void 0 ? _d : 720;\n                        canvas.width = width;\n                        canvas.height = height;\n                        const ctx = canvas.getContext(\"2d\");\n                        // Draw video frame to canvas\n                        ctx.drawImage(video, 0, 0);\n                        // Get image data and check if all pixels are black\n                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        const data = imageData.data;\n                        let isAllBlack = true;\n                        for(let i = 0; i < data.length; i += 4){\n                            if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {\n                                isAllBlack = false;\n                                break;\n                            }\n                        }\n                        if (isAllBlack) {\n                            this.appendError(\"camera appears to be producing only black frames\");\n                        } else {\n                            this.appendMessage(\"received video frames\");\n                        }\n                        resolve();\n                    }, 1000);\n                };\n                video.play();\n            });\n            video.remove();\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return \"Resuming connection after interruption\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            const handleReconnecting = ()=>{\n                reconnectingTriggered = true;\n            };\n            room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose(\"\");\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error(\"Did not attempt to reconnect\");\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning(\"reconnection is only possible in Redis-based configurations\");\n                throw new Error(\"Not able to reconnect\");\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return \"Can connect via TURN\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith(\"turn:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith(\"turns:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith(\"stun:\")) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning(\"No STUN servers configured on server side.\");\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\");\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: \"relay\"\n                    }\n                });\n            } else {\n                this.appendWarning(\"No TURN servers configured.\");\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return \"Establishing WebRTC connection\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += \" (private)\";\n                            } else {\n                                if (candidate.protocol === \"tcp\" && candidate.tcpType === \"passive\") {\n                                    hasTcp = true;\n                                    str += \" (passive)\";\n                                } else if (candidate.protocol === \"udp\") {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if (this.room.engine.pcManager) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info(\"now the room is connected\");\n            } catch (err) {\n                this.appendWarning(\"ports need to be open on firewall in order to connect.\");\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning(\"Server is not configured for ICE/TCP\");\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning(\"No public IPv4 UDP candidates were found. Your server is likely not configured correctly\");\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split(\".\");\n    if (parts.length === 4) {\n        if (parts[0] === \"10\") {\n            return true;\n        } else if (parts[0] === \"192\" && parts[1] === \"168\") {\n            return true;\n        } else if (parts[0] === \"172\") {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return \"Connecting to signal connection via WebSocket\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            if (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) {\n                this.appendWarning(\"Server is insecure, clients may block connections to it\");\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.options = {};\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n        this.options = options;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: \"\",\n            description: \"\"\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit(\"checkUpdate\", checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token, this.options);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on(\"update\", handleUpdate);\n            const result = yield test.run();\n            test.off(\"update\", handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n    checkConnectionProtocol() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const info = yield this.createAndRunCheck(ConnectionProtocolCheck);\n            if (info.data && \"protocol\" in info.data) {\n                const stats = info.data;\n                this.options.protocol = stats.protocol;\n            }\n            return info;\n        });\n    }\n    checkCloudRegion() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(CloudRegionCheck);\n        });\n    }\n}\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : \"user\",\n        confidence: \"low\"\n    };\n    // 1. Try to get facingMode from track settings.\n    if (\"facingMode\" in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.trace(\"rawFacingMode\", {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === \"string\" && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: \"high\"\n            };\n        }\n    }\n    // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n    if ([\n        \"low\",\n        \"medium\"\n    ].includes(result.confidence)) {\n        livekitLogger.trace(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        \"obs virtual camera\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        \"iphone\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ],\n    [\n        \"ipad\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can't infer anything from it.\n    if (label === \"\") {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        \"user\",\n        \"environment\",\n        \"left\",\n        \"right\"\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2xpdmVraXQtY2xpZW50LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU8sTUFBTUE7SUFLWEMsYUFBYztRQUpOQyxFQUFBO1FBRUFBLEVBQUE7UUFHRCxJQUFBQyxDQUFBQSxRQUFBLEdBQVdDLFFBQVFDLE9BQUEsSUFDeEIsS0FBS0MsTUFBQSxHQUFTO0lBQ2hCO0lBRUFDLFdBQVc7UUFDVCxPQUFPLEtBQUtELE1BQUEsR0FBUztJQUN2QjtJQUVBRSxPQUFPO1FBQ0wsS0FBS0YsTUFBQSxJQUFVO1FBRVgsSUFBQUc7UUFFSixNQUFNQyxJQUFXLElBQUlOLFFBQ2xCTyxDQUFBQSxJQUNFRixJQUFhRztnQkFDWixJQUFLTixDQUFBQSxNQUFBLElBQVUsR0FDUEs7WUFDVixJQUdFRSxJQUFhLElBQUtWLENBQUFBLFFBQUEsQ0FBU1csSUFBQSxDQUFLLElBQU1MO1FBRTVDLE9BQUtOLElBQUFBLENBQUFBLFFBQUEsR0FBVyxLQUFLQSxRQUFBLENBQVNXLElBQUEsQ0FBSyxJQUFNSixJQUVsQ0c7SUFDVDtBQUNGO0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0NBRUEsR0FDTyxTQUFTRSxPQUFPQyxTQUFTLEVBQUVDLEdBQUc7SUFDakM7SUFDQSxJQUFJLENBQUNELFdBQVc7UUFDWixNQUFNLElBQUlFLE1BQU1EO0lBQ3BCO0FBQ0o7QUFDQSxNQUFNRSxjQUFjLHVCQUF1QkMsY0FBYyx1QkFBd0JDLGFBQWEs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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUNIQSxTQUFBO0lBRUE7O0dBRUcsR0FDSEEsU0FBQTtJQUVBOzs7Ozs7R0FNRyxHQUNIQSxTQUFBO0lBRUE7Ozs7O0dBS0csR0FDSEEsU0FBQTtJQUVBOzs7Ozs7OztHQVFHLEdBQ0hBLFNBQUE7SUFFQTs7Ozs7R0FLRyxHQUNIQSxTQUFBO0lBRUE7Ozs7R0FJRyxHQUNIQSxTQUFBO0lBRUE7Ozs7R0FJRyxHQUNIQSxTQUFBO0lBRUE7Ozs7O0dBS0csR0FDSEEsU0FBQTtJQUVBOzs7O0dBSUcsR0FDSEEsU0FBQTtJQUVBOzs7O0dBSUcsR0FDSEEsU0FBQTtJQUVBOzs7OztHQUtHLEdBQ0hBLFNBQUE7SUFFQTs7Ozs7Ozs7R0FRRyxHQUNIQSxTQUFBO0lBRUE7Ozs7O0dBS0csR0FDSEEsU0FBQTtJQUVBOzs7Ozs7O0dBT0csR0FDSEEsU0FBQTtJQUVBOzs7Ozs7OztHQVFHLEdBQ0hBLFNBQUE7SUFFQTs7Ozs7R0FLRyxHQUNIQSxTQUFBO0lBRUE7Ozs7O0dBS0csR0FDSEEsU0FBQTtJQUVBOzs7Ozs7O0dBT0csR0FDSEEsU0FBQTtJQUVBOzs7Ozs7R0FNRyxHQUNIQSxTQUFBO0lBRUE7Ozs7R0FJRyxHQUNIQSxTQUFBO0lBRUE7OztHQUdHLEdBQ0hBLFNBQUE7SUFFQTs7Ozs7O0dBTUcsR0FDSEEsU0FBQTtJQUVBOzs7Ozs7Ozs7R0FTRyxHQUNIQSxTQUFBO0lBRUE7Ozs7Ozs7OztHQVNHLEdBQ0hBLFNBQUE7SUFFQTs7Ozs7OztHQU9HLEdBQ0hBLFNBQUE7SUFFQTs7OztHQUlHLEdBQ0hBLFNBQUE7SUFFQTs7OztHQUlHLEdBQ0hBLFNBQUE7SUFFQTs7Ozs7Ozs7R0FRRyxHQUNIQSxTQUFBO0lBRUE7OztHQUdHLEdBQ0hBLFNBQUE7SUFFQTs7R0FFRyxHQUNIQSxTQUFBO0lBRUE7OztHQUdHLEdBQ0hBLFNBQUE7SUFFQUEsU0FBQTtJQUVBQSxTQUFBO0lBQ0E7OztHQUdHLEdBQ0hBLFNBQUE7SUFFQTs7O0dBR0csR0FDSEEsU0FBQTtJQUVBQSxTQUFBO0lBQ0E7O0dBRUcsR0FDSEEsU0FBQTtJQUVB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QUM7UUFBc0I7WUFBRTBhLFlBQVk7WUFBZTRtRixZQUFZO1FBQVE7S0FBRztDQUM1RTtBQUNELE1BQU1NLDJCQUEyQixJQUFJNWhHLElBQWlEO0lBQ3BGO1FBQUM7UUFBVTtZQUFFMGEsWUFBWTtZQUFlNG1GLFlBQVk7UUFBUTtLQUFHO0lBQy9EO1FBQUM7UUFBUTtZQUFFNW1GLFlBQVk7WUFBZTRtRixZQUFZO1FBQVE7S0FBRztDQUM5RDtBQUNEOzs7O0NBSUcsR0FDRyxTQUFVSSwwQkFDZEcsV0FBbUI7O0lBRW5CLE1BQU0zbUYsUUFBUTJtRixZQUFZeC9GLElBQUksR0FBRzBDLFdBQVc7SUFDNUM7SUFDQSxJQUFJbVcsVUFBVSxJQUFJO1FBQ2hCLE9BQU96Z0I7SUFDVDtJQUVBO0lBQ0EsSUFBSWtuRyxrQkFBa0JoNkYsR0FBRyxDQUFDdVQsUUFBUTtRQUNoQyxPQUFPeW1GLGtCQUFrQnBrRyxHQUFHLENBQUMyZDtJQUMvQjtJQUVBO0lBQ0EsT0FBTyxDQUFBbnJCLEtBQUE2UCxNQUFNMjZCLElBQUksQ0FBQ3FuRSx5QkFBeUJ4aEcsT0FBTyxJQUFJakMsSUFBSSxDQUFDKytCLENBQUFBO1FBQUEsSUFBQyxDQUFDNGtFLFFBQVEsR0FBQTVrRTtRQUFBLE9BQ25FaGlCLE1BQU1DLFFBQVEsQ0FBQzJtRjtJQUFRLFFBQ3JCLFFBQUEveEcsT0FBQSxrQkFBQUEsRUFBQSxHQUFFO0FBQ1I7QUFFQSxTQUFTeXhHLGtCQUFrQmg5RixJQUFZO0lBQ3JDLE1BQU11OUYsZ0JBQThCO1FBQUM7UUFBUTtRQUFlO1FBQVE7S0FBUTtJQUM1RSxPQUFPdjlGLFNBQVMvSixhQUFhc25HLGNBQWM1bUYsUUFBUSxDQUFDM1c7QUFDdEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGxpdmVraXQrbXV0ZXhAMS4xLjEvbm9kZV9tb2R1bGVzL0BsaXZla2l0L211dGV4L2Rpc3QvaW5kZXgubWpzPzQzZDUiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2Fzc2VydC5qcz9jMmU0Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9lbnVtLmpzPzYxY2YiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9tZXNzYWdlLmpzP2Q4YTgiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL21lc3NhZ2UtdHlwZS5qcz9iNDliIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vZ29vZ2xlL3ZhcmludC5qcz9jZTk3Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8taW50NjQuanM/MmYwNCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3NjYWxhci5qcz84YWUxIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9zY2FsYXJzLmpzP2RhMjciLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9iaW5hcnktZW5jb2RpbmcuanM/MDAzYyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvZXh0ZW5zaW9ucy5qcz8wZmFhIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8tYmFzZTY0LmpzPzg0OTciLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9leHRlbnNpb24tYWNjZXNzb3IuanM/YWY0NSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvcmVmbGVjdC5qcz8xMWFmIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vaXMtbWVzc2FnZS5qcz9lM2UwIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC13cmFwcGVyLmpzPzk0YjEiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2pzb24tZm9ybWF0LmpzPzUxYTYiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2JpbmFyeS1mb3JtYXQuanM/ZmVmNiIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvdXRpbC1jb21tb24uanM/OWUwMSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vQGJ1ZmJ1aWxkK3Byb3RvYnVmQDEuMTAuMC9ub2RlX21vZHVsZXMvQGJ1ZmJ1aWxkL3Byb3RvYnVmL2Rpc3QvZXNtL3ByaXZhdGUvcHJvdG8tcnVudGltZS5qcz9lMjI5Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJpdmF0ZS9maWVsZC1saXN0LmpzPzNjNjEiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL25hbWVzLmpzPzFjNzYiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2ZpZWxkLmpzPzFhOTMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9wcml2YXRlL2ZpZWxkLW5vcm1hbGl6ZS5qcz9jYzc5Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AYnVmYnVpbGQrcHJvdG9idWZAMS4xMC4wL25vZGVfbW9kdWxlcy9AYnVmYnVpbGQvcHJvdG9idWYvZGlzdC9lc20vcHJvdG8zLmpzP2E0NWIiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BidWZidWlsZCtwcm90b2J1ZkAxLjEwLjAvbm9kZV9tb2R1bGVzL0BidWZidWlsZC9wcm90b2J1Zi9kaXN0L2VzbS9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wX3BiLmpzPzBiOWEiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0BsaXZla2l0K3Byb3RvY29sQDEuMzYuMS9ub2RlX21vZHVsZXMvQGxpdmVraXQvcHJvdG9jb2wvZGlzdC9pbmRleC5tanM/ZDkwMSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vbG9nbGV2ZWxAMS45LjIvbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcz82ZmQzIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9sb2dnZXIudHM/ODk1ZCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS9EZWZhdWx0UmVjb25uZWN0UG9saWN5LnRzP2ZiMTciLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL2V2ZW50c0AzLjMuMC9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz85MWYzIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA5LjAuMS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL3V0aWxzLmpzP2I4YTkiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL3dlYnJ0Yy1hZGFwdGVyQDkuMC4xL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvY2hyb21lL2dldHVzZXJtZWRpYS5qcz84ZTUwIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA5LjAuMS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2Nocm9tZS9jaHJvbWVfc2hpbS5qcz85MDEwIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA5LjAuMS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2ZpcmVmb3gvZ2V0dXNlcm1lZGlhLmpzPzM4NjkiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL3dlYnJ0Yy1hZGFwdGVyQDkuMC4xL25vZGVfbW9kdWxlcy93ZWJydGMtYWRhcHRlci9zcmMvanMvZmlyZWZveC9nZXRkaXNwbGF5bWVkaWEuanM/NDM4NyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vd2VicnRjLWFkYXB0ZXJAOS4wLjEvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9maXJlZm94L2ZpcmVmb3hfc2hpbS5qcz8wNDlkIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA5LjAuMS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL3NhZmFyaS9zYWZhcmlfc2hpbS5qcz84OWQwIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9zZHBAMy4yLjAvbm9kZV9tb2R1bGVzL3NkcC9zZHAuanM/NWExMyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vd2VicnRjLWFkYXB0ZXJAOS4wLjEvbm9kZV9tb2R1bGVzL3dlYnJ0Yy1hZGFwdGVyL3NyYy9qcy9jb21tb25fc2hpbS5qcz9mYTQ3Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA5LjAuMS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2FkYXB0ZXJfZmFjdG9yeS5qcz9iZTE1Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS93ZWJydGMtYWRhcHRlckA5LjAuMS9ub2RlX21vZHVsZXMvd2VicnRjLWFkYXB0ZXIvc3JjL2pzL2FkYXB0ZXJfY29yZS5qcz9kNjNmIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL2NvbnN0YW50cy50cz84Nzg5Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL2V2ZW50cy50cz9kMWIxIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL3V0aWxzLnRzP2RlYmEiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2UyZWUvS2V5UHJvdmlkZXIudHM/YjE1YyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS9lcnJvcnMudHM/ODVhZCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvZTJlZS9lcnJvcnMudHM/NGU3ZSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS9ldmVudHMudHM/MTg0OSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvdXRpbHMvY2xvbmVEZWVwLnRzP2UxMjgiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3V0aWxzL2Jyb3dzZXJQYXJzZXIudHM/Y2E4NCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvdmVyc2lvbi50cz9mMjg0Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3RpbWVycy50cz9lNGJhIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3RyYWNrL1RyYWNrLnRzPzg3YTAiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vdHJhY2svb3B0aW9ucy50cz81YjVlIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3V0aWxzLnRzPzY2NmQiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vdHJhY2svdXRpbHMudHM/M2U4ZCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvZTJlZS9FMmVlTWFuYWdlci50cz85Y2I0Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL0RldmljZU1hbmFnZXIudHM/ZWIzNyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvdXRpbHMvQXN5bmNRdWV1ZS50cz8zMzY5Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9hcGkvdXRpbHMudHM/MzE0OSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvYXBpL1NpZ25hbENsaWVudC50cz82MDYzIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9zZHAtdHJhbnNmb3JtQDIuMTUuMC9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvZ3JhbW1hci5qcz84Y2FjIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9zZHAtdHJhbnNmb3JtQDIuMTUuMC9ub2RlX21vZHVsZXMvc2RwLXRyYW5zZm9ybS9saWIvcGFyc2VyLmpzPzVjMmQiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL3NkcC10cmFuc2Zvcm1AMi4xNS4wL25vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanM/YWJjMiIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vc2RwLXRyYW5zZm9ybUAyLjE1LjAvbm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2luZGV4LmpzPzgxOWIiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWRlYm91bmNlQDQuMC4wL25vZGVfbW9kdWxlcy90cy1kZWJvdW5jZS9kaXN0L3NyYy9pbmRleC5lc20uanM/YzI0YyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS9QQ1RyYW5zcG9ydC50cz8zYzI0Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL2RlZmF1bHRzLnRzP2Q3MTQiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vUENUcmFuc3BvcnRNYW5hZ2VyLnRzPzZmMDEiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vcnBjLnRzPzE0MjMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vc3RhdHMudHM/NDM5NCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS90cmFjay9Mb2NhbFRyYWNrLnRzPzdmMWUiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vdHJhY2svTG9jYWxBdWRpb1RyYWNrLnRzP2M3NWYiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vcGFydGljaXBhbnQvcHVibGlzaFV0aWxzLnRzPzQxYmMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vdHJhY2svTG9jYWxWaWRlb1RyYWNrLnRzPzJlNjAiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vUlRDRW5naW5lLnRzPzkxNTUiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vUmVnaW9uVXJsUHJvdmlkZXIudHM/NjNhMSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS9TdHJlYW1SZWFkZXIudHM/MTZkYSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS9TdHJlYW1Xcml0ZXIudHM/OGVhOCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS90cmFjay9SZW1vdGVUcmFjay50cz83NThkIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3RyYWNrL1JlbW90ZUF1ZGlvVHJhY2sudHM/MTdiMCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS90cmFjay9SZW1vdGVWaWRlb1RyYWNrLnRzPzI4ZjAiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vdHJhY2svVHJhY2tQdWJsaWNhdGlvbi50cz9mYzUxIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbi50cz8yYWJjIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3RyYWNrL2NyZWF0ZS50cz9lMmUyIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3BhcnRpY2lwYW50L1BhcnRpY2lwYW50LnRzPzg5OTIiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vcGFydGljaXBhbnQvUGFydGljaXBhbnRUcmFja1Blcm1pc3Npb24udHM/MDhiNyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS9wYXJ0aWNpcGFudC9Mb2NhbFBhcnRpY2lwYW50LnRzP2NlOTgiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbi50cz8zZTEyIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3BhcnRpY2lwYW50L1JlbW90ZVBhcnRpY2lwYW50LnRzP2Q0MjAiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vUm9vbS50cz8yMDQ1Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9jb25uZWN0aW9uSGVscGVyL2NoZWNrcy9DaGVja2VyLnRzPzBhNTkiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2Nvbm5lY3Rpb25IZWxwZXIvY2hlY2tzL2Nsb3VkUmVnaW9uLnRzPzJhYWIiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2Nvbm5lY3Rpb25IZWxwZXIvY2hlY2tzL2Nvbm5lY3Rpb25Qcm90b2NvbC50cz8yYThlIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9jb25uZWN0aW9uSGVscGVyL2NoZWNrcy9wdWJsaXNoQXVkaW8udHM/YjFiNyIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvY29ubmVjdGlvbkhlbHBlci9jaGVja3MvcHVibGlzaFZpZGVvLnRzPzUzMjgiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2Nvbm5lY3Rpb25IZWxwZXIvY2hlY2tzL3JlY29ubmVjdC50cz81Njg5Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9jb25uZWN0aW9uSGVscGVyL2NoZWNrcy90dXJuLnRzPzYyNDQiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL2Nvbm5lY3Rpb25IZWxwZXIvY2hlY2tzL3dlYnJ0Yy50cz8zNTE2Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9jb25uZWN0aW9uSGVscGVyL2NoZWNrcy93ZWJzb2NrZXQudHM/Mzk1YSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvY29ubmVjdGlvbkhlbHBlci9Db25uZWN0aW9uQ2hlY2sudHM/M2YzMCIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvcm9vbS90cmFjay9mYWNpbmdNb2RlLnRzP2UyYTMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzPzliODkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgaCA9IChpLCBzLCB0KSA9PiBzIGluIGkgPyBlKGksIHMsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBpW3NdID0gdDtcbnZhciBvID0gKGksIHMsIHQpID0+IGgoaSwgdHlwZW9mIHMgIT0gXCJzeW1ib2xcIiA/IHMgKyBcIlwiIDogcywgdCk7XG5jbGFzcyBfIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbyh0aGlzLCBcIl9sb2NraW5nXCIpO1xuICAgIG8odGhpcywgXCJfbG9ja3NcIik7XG4gICAgdGhpcy5fbG9ja2luZyA9IFByb21pc2UucmVzb2x2ZSgpLCB0aGlzLl9sb2NrcyA9IDA7XG4gIH1cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tzID4gMDtcbiAgfVxuICBsb2NrKCkge1xuICAgIHRoaXMuX2xvY2tzICs9IDE7XG4gICAgbGV0IHM7XG4gICAgY29uc3QgdCA9IG5ldyBQcm9taXNlKFxuICAgICAgKGwpID0+IHMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvY2tzIC09IDEsIGwoKTtcbiAgICAgIH1cbiAgICApLCBjID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHMpO1xuICAgIHJldHVybiB0aGlzLl9sb2NraW5nID0gdGhpcy5fbG9ja2luZy50aGVuKCgpID0+IHQpLCBjO1xuICB9XG59XG5jbGFzcyBuIHtcbiAgY29uc3RydWN0b3Iocykge1xuICAgIG8odGhpcywgXCJfcXVldWVcIik7XG4gICAgbyh0aGlzLCBcIl9saW1pdFwiKTtcbiAgICBvKHRoaXMsIFwiX2xvY2tzXCIpO1xuICAgIHRoaXMuX3F1ZXVlID0gW10sIHRoaXMuX2xpbWl0ID0gcywgdGhpcy5fbG9ja3MgPSAwO1xuICB9XG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrcyA+PSB0aGlzLl9saW1pdDtcbiAgfVxuICBhc3luYyBsb2NrKCkge1xuICAgIHJldHVybiB0aGlzLmlzTG9ja2VkKCkgPyBuZXcgUHJvbWlzZSgocykgPT4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2xvY2tzKyssIHModGhpcy5fdW5sb2NrLmJpbmQodGhpcykpO1xuICAgICAgfSk7XG4gICAgfSkgOiAodGhpcy5fbG9ja3MrKywgdGhpcy5fdW5sb2NrLmJpbmQodGhpcykpO1xuICB9XG4gIF91bmxvY2soKSB7XG4gICAgaWYgKHRoaXMuX2xvY2tzLS0sIHRoaXMuX3F1ZXVlLmxlbmd0aCAmJiAhdGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgIHMgPT0gbnVsbCB8fCBzKCk7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBuIGFzIE11bHRpTXV0ZXgsXG4gIF8gYXMgTXV0ZXhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBBc3NlcnQgdGhhdCBjb25kaXRpb24gaXMgdHJ1dGh5IG9yIHRocm93IGVycm9yICh3aXRoIG1lc3NhZ2UpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gYm9vbGVhblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmNvbnN0IEZMT0FUMzJfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZTM4LCBGTE9BVDMyX01JTiA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgsIFVJTlQzMl9NQVggPSAweGZmZmZmZmZmLCBJTlQzMl9NQVggPSAweDdmZmZmZmZmLCBJTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgc2lnbmVkIHByb3RvYnVmIDMyLWJpdCBpbnRlZ2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihhcmcpIHx8IGFyZyA+IElOVDMyX01BWCB8fCBhcmcgPCBJTlQzMl9NSU4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW50IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbi8qKlxuICogQXNzZXJ0IGEgdmFsaWQgdW5zaWduZWQgcHJvdG9idWYgMzItYml0IGludGVnZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVSW50MzIoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBVSU5UMzJfTUFYIHx8IGFyZyA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHByb3RvYnVmIGZsb2F0IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RmxvYXQzMihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhcmcpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGFyZyA+IEZMT0FUMzJfTUFYIHx8IGFyZyA8IEZMT0FUMzJfTUlOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZsb2F0IDMyOiBcIiArIGFyZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXBsdXMtb3BlcmFuZHMgLS0gd2Ugd2FudCB0aGUgaW1wbGljaXQgY29udmVyc2lvbiB0byBzdHJpbmdcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiLi9hc3NlcnQuanNcIjtcbmNvbnN0IGVudW1UeXBlU3ltYm9sID0gU3ltYm9sKFwiQGJ1ZmJ1aWxkL3Byb3RvYnVmL2VudW0tdHlwZVwiKTtcbi8qKlxuICogR2V0IHJlZmxlY3Rpb24gaW5mb3JtYXRpb24gZnJvbSBhIGdlbmVyYXRlZCBlbnVtLlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gc29tZXRoaW5nIG90aGVyIHRoYW4gYSBnZW5lcmF0ZWRcbiAqIGVudW0sIGl0IHJhaXNlcyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVudW1UeXBlKGVudW1PYmplY3QpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgdCA9IGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdO1xuICAgIGFzc2VydCh0LCBcIm1pc3NpbmcgZW51bSB0eXBlIG9uIGVudW0gb2JqZWN0XCIpO1xuICAgIHJldHVybiB0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG59XG4vKipcbiAqIFNldHMgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBvbiBhIGdlbmVyYXRlZCBlbnVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcywgb3B0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdID0gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMubWFwKCh2KSA9PiAoe1xuICAgICAgICBubzogdi5ubyxcbiAgICAgICAgbmFtZTogdi5uYW1lLFxuICAgICAgICBsb2NhbE5hbWU6IGVudW1PYmplY3Rbdi5ub10sXG4gICAgfSkpLCBvcHQpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRW51bVR5cGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuX29wdCkge1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBudW1iZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBub3JtYWxWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgICAgICAvLyBjb25zdCB2YWx1ZTogRW51bVZhbHVlSW5mbyA9IHsuLi52LCBvcHRpb25zOiB2Lm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdH07XG4gICAgICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgICAgICBub3JtYWxWYWx1ZXMucHVzaChuKTtcbiAgICAgICAgbmFtZXNbdmFsdWUubmFtZV0gPSBuO1xuICAgICAgICBudW1iZXJzW3ZhbHVlLm5vXSA9IG47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVOYW1lLFxuICAgICAgICB2YWx1ZXM6IG5vcm1hbFZhbHVlcyxcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAgICAgLy8gb3B0aW9uczogb3B0Py5vcHRpb25zID8/IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGZpbmROYW1lKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc1tuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZE51bWJlcihubykge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcnNbbm9dO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbnVtIG9iamVjdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKiBTZXRzIHJlZmxlY3Rpb24gaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRW51bSh0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgICBjb25zdCBlbnVtT2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgbiA9IG5vcm1hbGl6ZUVudW1WYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGVudW1PYmplY3Rbbi5sb2NhbE5hbWVdID0gbi5ubztcbiAgICAgICAgZW51bU9iamVjdFtuLm5vXSA9IG4ubG9jYWxOYW1lO1xuICAgIH1cbiAgICBzZXRFbnVtVHlwZShlbnVtT2JqZWN0LCB0eXBlTmFtZSwgdmFsdWVzLCBvcHQpO1xuICAgIHJldHVybiBlbnVtT2JqZWN0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKFwibG9jYWxOYW1lXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSksIHsgbG9jYWxOYW1lOiB2YWx1ZS5uYW1lIH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogTWVzc2FnZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBldmVyeSBtZXNzYWdlLCBnZW5lcmF0ZWQsIG9yIGNyZWF0ZWQgYXRcbiAqIHJ1bnRpbWUuXG4gKlxuICogSXQgaXMgX25vdF8gc2FmZSB0byBleHRlbmQgdGhpcyBjbGFzcy4gSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbWVzc2FnZSBhdFxuICogcnVuIHRpbWUsIHVzZSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHdpdGggYSBtZXNzYWdlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGlzcmVnYXJkcyBleHRlbnNpb25zIGFuZCB1bmtub3duIGZpZWxkcy5cbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5lcXVhbHModGhpcy5nZXRUeXBlKCksIHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5LlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlKCkucnVudGltZS51dGlsLmNsb25lKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBmcm9tIGJpbmFyeSBkYXRhLCBtZXJnaW5nIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICAgKiBleGlzdGluZyBrZXlzLlxuICAgICAqXG4gICAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICAgKiBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmJpbiwgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgZm9ybWF0LnJlYWRNZXNzYWdlKHRoaXMsIG9wdC5yZWFkZXJGYWN0b3J5KGJ5dGVzKSwgYnl0ZXMuYnl0ZUxlbmd0aCwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiB2YWx1ZS5cbiAgICAgKi9cbiAgICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBmb3JtYXQgPSB0eXBlLnJ1bnRpbWUuanNvbiwgb3B0ID0gZm9ybWF0Lm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgZm9ybWF0LnJlYWRNZXNzYWdlKHR5cGUsIGpzb25WYWx1ZSwgb3B0LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiBzdHJpbmcuXG4gICAgICovXG4gICAgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICBsZXQganNvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgJHt0aGlzLmdldFR5cGUoKS50eXBlTmFtZX0gZnJvbSBKU09OOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSnNvbihqc29uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGJpbmFyeSBkYXRhLlxuICAgICAqL1xuICAgIHRvQmluYXJ5KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLCBiaW4gPSB0eXBlLnJ1bnRpbWUuYmluLCBvcHQgPSBiaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSwgd3JpdGVyID0gb3B0LndyaXRlckZhY3RvcnkoKTtcbiAgICAgICAgYmluLndyaXRlTWVzc2FnZSh0aGlzLCB3cml0ZXIsIG9wdCk7XG4gICAgICAgIHJldHVybiB3cml0ZXIuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byBhIEpTT04gdmFsdWUsIGEgSmF2YVNjcmlwdCB2YWx1ZSB0aGF0IGNhbiBiZVxuICAgICAqIHBhc3NlZCB0byBKU09OLnN0cmluZ2lmeSgpLlxuICAgICAqL1xuICAgIHRvSnNvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSwganNvbiA9IHR5cGUucnVudGltZS5qc29uLCBvcHQgPSBqc29uLm1ha2VXcml0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBqc29uLndyaXRlTWVzc2FnZSh0aGlzLCBvcHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHN0cmluZy5cbiAgICAgKi9cbiAgICB0b0pzb25TdHJpbmcob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXR0eVNwYWNlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZvciBzZXJpYWxpemF0aW9uIGJlaGF2aW9yLiBUaGlzIHdpbGwgYmUgaW52b2tlZCB3aGVuIGNhbGxpbmdcbiAgICAgKiBKU09OLnN0cmluZ2lmeSBvbiB0aGlzIG1lc3NhZ2UgKGkuZS4gSlNPTi5zdHJpbmdpZnkobXNnKSkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBzZXJpYWxpemUgZ29vZ2xlLnByb3RvYnVmLkFueSB3aXRoIGEgcGFja2VkXG4gICAgICogbWVzc2FnZSBiZWNhdXNlIHRoZSBwcm90b2J1ZiBKU09OIGZvcm1hdCBzcGVjaWZpZXMgdGhhdCBpdCBuZWVkcyB0byBiZVxuICAgICAqIHVucGFja2VkLCBhbmQgdGhpcyBpcyBvbmx5IHBvc3NpYmxlIHdpdGggYSB0eXBlIHJlZ2lzdHJ5IHRvIGxvb2sgdXAgdGhlXG4gICAgICogbWVzc2FnZSB0eXBlLiAgQXMgYSByZXN1bHQsIGF0dGVtcHRpbmcgdG8gc2VyaWFsaXplIGEgbWVzc2FnZSB3aXRoIHRoaXNcbiAgICAgKiB0eXBlIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwcm90ZWN0ZWQgYmVjYXVzZSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIGludm9rZSBpdFxuICAgICAqIGRpcmVjdGx5IC0tIGluc3RlYWQgdXNlIEpTT04uc3RyaW5naWZ5IG9yIHRvSnNvblN0cmluZyBmb3JcbiAgICAgKiBzdHJpbmdpZmllZCBKU09OLiAgQWx0ZXJuYXRpdmVseSwgaWYgYWN0dWFsIEpTT04gaXMgZGVzaXJlZCwgeW91IHNob3VsZFxuICAgICAqIHVzZSB0b0pzb24uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pzb24oe1xuICAgICAgICAgICAgZW1pdERlZmF1bHRWYWx1ZXM6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgTWVzc2FnZVR5cGUgb2YgdGhpcyBtZXNzYWdlIC0gYSBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzXG4gICAgICogdGhlIHByb3RvYnVmIG1lc3NhZ2UgZGVjbGFyYXRpb24gYW5kIHByb3ZpZGVzIG1ldGFkYXRhIGZvciByZWZsZWN0aW9uLVxuICAgICAqIGJhc2VkIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgLy8gQW55IGNsYXNzIHRoYXQgZXh0ZW5kcyBNZXNzYWdlIF9tdXN0XyBwcm92aWRlIGEgY29tcGxldGUgc3RhdGljXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIE1lc3NhZ2VUeXBlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWVzc2FnZSB0eXBlIHVzaW5nIHRoZSBnaXZlbiBydW50aW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1lc3NhZ2VUeXBlKHJ1bnRpbWUsIHR5cGVOYW1lLCBmaWVsZHMsIG9wdCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2NhbE5hbWUgPSAoX2EgPSBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQubG9jYWxOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlTmFtZS5zdWJzdHJpbmcodHlwZU5hbWUubGFzdEluZGV4T2YoXCIuXCIpICsgMSk7XG4gICAgY29uc3QgdHlwZSA9IHtcbiAgICAgICAgW2xvY2FsTmFtZV06IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBydW50aW1lLnV0aWwuaW5pdEZpZWxkcyh0aGlzKTtcbiAgICAgICAgICAgIHJ1bnRpbWUudXRpbC5pbml0UGFydGlhbChkYXRhLCB0aGlzKTtcbiAgICAgICAgfSxcbiAgICB9W2xvY2FsTmFtZV07XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHR5cGUucHJvdG90eXBlLCBuZXcgTWVzc2FnZSgpKTtcbiAgICBPYmplY3QuYXNzaWduKHR5cGUsIHtcbiAgICAgICAgcnVudGltZSxcbiAgICAgICAgdHlwZU5hbWUsXG4gICAgICAgIGZpZWxkczogcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChmaWVsZHMpLFxuICAgICAgICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBydW50aW1lLnV0aWwuZXF1YWxzKHR5cGUsIGEsIGIpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB0eXBlO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzFdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDY0cmVhZCgpIHtcbiAgICBsZXQgbG93Qml0cyA9IDA7XG4gICAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgICBmb3IgKGxldCBzaGlmdCA9IDA7IHNoaWZ0IDwgMjg7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgbG93Qml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgICAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAvLyBsYXN0IGZvdXIgYml0cyBvZiB0aGUgZmlyc3QgMzIgYml0IG51bWJlclxuICAgIGxvd0JpdHMgfD0gKG1pZGRsZUJ5dGUgJiAweDBmKSA8PCAyODtcbiAgICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICAgIGhpZ2hCaXRzID0gKG1pZGRsZUJ5dGUgJiAweDcwKSA+PiA0O1xuICAgIGlmICgobWlkZGxlQnl0ZSAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICAgIGZvciAobGV0IHNoaWZ0ID0gMzsgc2hpZnQgPD0gMzE7IHNoaWZ0ICs9IDcpIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICAgICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICAgICAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBbbG93Qml0cywgaGlnaEJpdHNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFyaW50NjR3cml0ZShsbywgaGksIGJ5dGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gbG8gPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDAgJiYgaGkgPT0gMCk7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgICAgIGlmICghaGFzTmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0Qml0cyA9ICgobG8gPj4+IDI4KSAmIDB4MGYpIHwgKChoaSAmIDB4MDcpIDw8IDQpO1xuICAgIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICAgIGJ5dGVzLnB1c2goKGhhc01vcmVCaXRzID8gc3BsaXRCaXRzIHwgMHg4MCA6IHNwbGl0Qml0cykgJiAweGZmKTtcbiAgICBpZiAoIWhhc01vcmVCaXRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gaGkgPj4+IGk7XG4gICAgICAgIGNvbnN0IGhhc05leHQgPSAhKHNoaWZ0ID4+PiA3ID09IDApO1xuICAgICAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGUpO1xuICAgICAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBieXRlcy5wdXNoKChoaSA+Pj4gMzEpICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludDY0RnJvbVN0cmluZyhkZWMpIHtcbiAgICAvLyBDaGVjayBmb3IgbWludXMgc2lnbi5cbiAgICBjb25zdCBtaW51cyA9IGRlY1swXSA9PT0gXCItXCI7XG4gICAgaWYgKG1pbnVzKSB7XG4gICAgICAgIGRlYyA9IGRlYy5zbGljZSgxKTtcbiAgICB9XG4gICAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAgIC8vIGRpZ2l0cyB0byBiaW5hcnkuIFRoaXMgaXMgc2FmZSB0byBkbyB3aXRoIGZsb2F0aW5nIHBvaW50IG1hdGggYmVjYXVzZVxuICAgIC8vIE51bWJlci5pc1NhZmVJbnRlZ2VyKEFMTF8zMl9CSVRTICogMWU2KSA9PSB0cnVlLlxuICAgIGNvbnN0IGJhc2UgPSAxZTY7XG4gICAgbGV0IGxvd0JpdHMgPSAwO1xuICAgIGxldCBoaWdoQml0cyA9IDA7XG4gICAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgICAgICAvLyBOb3RlOiBOdW1iZXIoJycpIGlzIDAuXG4gICAgICAgIGNvbnN0IGRpZ2l0MWU2ID0gTnVtYmVyKGRlYy5zbGljZShiZWdpbiwgZW5kKSk7XG4gICAgICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICogYmFzZSArIGRpZ2l0MWU2O1xuICAgICAgICAvLyBDYXJyeSBiaXRzIGZyb20gbG93Qml0cyB0b1xuICAgICAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArICgobG93Qml0cyAvIFRXT19QV1JfMzJfREJMKSB8IDApO1xuICAgICAgICAgICAgbG93Qml0cyA9IGxvd0JpdHMgJSBUV09fUFdSXzMyX0RCTDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQxZTZkaWdpdCgtMjQsIC0xOCk7XG4gICAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICAgIGFkZDFlNmRpZ2l0KC0xMiwgLTYpO1xuICAgIGFkZDFlNmRpZ2l0KC02KTtcbiAgICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludDY0VG9TdHJpbmcobG8sIGhpKSB7XG4gICAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gICAgLy8gSWYgd2UncmUgdHJlYXRpbmcgdGhlIGlucHV0IGFzIGEgc2lnbmVkIHZhbHVlIGFuZCB0aGUgaGlnaCBiaXQgaXMgc2V0LCBkb1xuICAgIC8vIGEgbWFudWFsIHR3bydzIGNvbXBsZW1lbnQgY29udmVyc2lvbiBiZWZvcmUgdGhlIGRlY2ltYWwgY29udmVyc2lvbi5cbiAgICBjb25zdCBuZWdhdGl2ZSA9IChiaXRzLmhpICYgMHg4MDAwMDAwMCk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIGJpdHMgPSBuZWdhdGUoYml0cy5sbywgYml0cy5oaSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xuICAgIHJldHVybiBuZWdhdGl2ZSA/IFwiLVwiICsgcmVzdWx0IDogcmVzdWx0O1xufVxuLyoqXG4gKiBMb3NzbGVzc2x5IGNvbnZlcnRzIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAgICh7IGxvLCBoaSB9ID0gdG9VbnNpZ25lZChsbywgaGkpKTtcbiAgICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gICAgLy8gYnVpbHQtaW4gY29udmVyc2lvbnMuXG4gICAgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPSAweDAwMUZGRkZGIEZGRkZGRkZGLCB0aHVzIGFueSBudW1iZXIgd2l0aFxuICAgIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAgIC8vIGludGVnZXIgcHJlY2lzaW9uLlxuICAgIC8vIFByb3ZlbiBieTogTnVtYmVyLmlzU2FmZUludGVnZXIoMHgxRkZGRkYgKiAyKiozMiArIDB4RkZGRkZGRkYpID09IHRydWUuXG4gICAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoVFdPX1BXUl8zMl9EQkwgKiBoaSArIGxvKTtcbiAgICB9XG4gICAgLy8gV2hhdCB0aGlzIGNvZGUgaXMgZG9pbmcgaXMgZXNzZW50aWFsbHkgY29udmVydGluZyB0aGUgaW5wdXQgbnVtYmVyIGZyb21cbiAgICAvLyBiYXNlLTIgdG8gYmFzZS0xZTcsIHdoaWNoIGFsbG93cyB1cyB0byByZXByZXNlbnQgdGhlIDY0LWJpdCByYW5nZSB3aXRoXG4gICAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIGJhc2UtMTAgc3RyaW5nLlxuICAgIC8vIFRoZSBtYWdpYyBudW1iZXJzIHVzZWQgaGVyZSBhcmUgLVxuICAgIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIDJeNDggPSAyODE0NzQ5NzY3MTA2NTYgPSAoMiw4MTQ3NDk3LDY3MTA2NTYpIGluIGJhc2UtMWU3LlxuICAgIC8vIFNwbGl0IDMyOjMyIHJlcHJlc2VudGF0aW9uIGludG8gMTY6MjQ6MjQgcmVwcmVzZW50YXRpb24gc28gb3VyXG4gICAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgICBjb25zdCBsb3cgPSBsbyAmIDB4RkZGRkZGO1xuICAgIGNvbnN0IG1pZCA9ICgobG8gPj4+IDI0KSB8IChoaSA8PCA4KSkgJiAweEZGRkZGRjtcbiAgICBjb25zdCBoaWdoID0gKGhpID4+IDE2KSAmIDB4RkZGRjtcbiAgICAvLyBBc3NlbWJsZSBvdXIgdGhyZWUgYmFzZS0xZTcgZGlnaXRzLCBpZ25vcmluZyBjYXJyaWVzLiBUaGUgbWF4aW11bVxuICAgIC8vIHZhbHVlIGluIGEgZGlnaXQgYXQgdGhpcyBzdGVwIGlzIHJlcHJlc2VudGFibGUgYXMgYSA0OC1iaXQgaW50ZWdlciwgd2hpY2hcbiAgICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICBsZXQgZGlnaXRBID0gbG93ICsgKG1pZCAqIDY3NzcyMTYpICsgKGhpZ2ggKiA2NzEwNjU2KTtcbiAgICBsZXQgZGlnaXRCID0gbWlkICsgKGhpZ2ggKiA4MTQ3NDk3KTtcbiAgICBsZXQgZGlnaXRDID0gKGhpZ2ggKiAyKTtcbiAgICAvLyBBcHBseSBjYXJyaWVzIGZyb20gQSB0byBCIGFuZCBmcm9tIEIgdG8gQy5cbiAgICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gICAgaWYgKGRpZ2l0QSA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgICAgICBkaWdpdEEgJT0gYmFzZTtcbiAgICB9XG4gICAgaWYgKGRpZ2l0QiA+PSBiYXNlKSB7XG4gICAgICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgICAgICBkaWdpdEIgJT0gYmFzZTtcbiAgICB9XG4gICAgLy8gSWYgZGlnaXRDIGlzIDAsIHRoZW4gd2Ugc2hvdWxkIGhhdmUgcmV0dXJuZWQgaW4gdGhlIHRyaXZpYWwgY29kZSBwYXRoXG4gICAgLy8gYXQgdGhlIHRvcCBmb3Igbm9uLXNhZmUgaW50ZWdlcnMuIEdpdmVuIHRoaXMsIHdlIGNhbiBhc3N1bWUgYm90aCBkaWdpdEJcbiAgICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgICByZXR1cm4gZGlnaXRDLnRvU3RyaW5nKCkgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRCKSArXG4gICAgICAgIGRlY2ltYWxGcm9tMWU3V2l0aExlYWRpbmdaZXJvcyhkaWdpdEEpO1xufVxuZnVuY3Rpb24gdG9VbnNpZ25lZChsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gPj4+IDAsIGhpOiBoaSA+Pj4gMCB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgICByZXR1cm4geyBsbzogbG8gfCAwLCBoaTogaGkgfCAwIH07XG59XG4vKipcbiAqIFJldHVybnMgdHdvJ3MgY29tcGxpbWVudCBuZWdhdGlvbiBvZiBpbnB1dC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzI1NpZ25lZF8zMi1iaXRfaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gICAgaWYgKGxvd0JpdHMpIHtcbiAgICAgICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIGxvd0JpdHMgaXMgMCwgdGhlbiBiaXR3aXNlLW5vdCBpcyAweEZGRkZGRkZGLFxuICAgICAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAgICAgLy8gdGhlIGxvdyBiaXRzIDB4MCBhbmQgc2ltcGx5IGFkZHMgb25lIHRvIHRoZSBoaWdoIGJpdHMuXG4gICAgICAgIGhpZ2hCaXRzICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gKGRpZ2l0MWU3KSA9PiB7XG4gICAgY29uc3QgcGFydGlhbCA9IFN0cmluZyhkaWdpdDFlNyk7XG4gICAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpbnQzMndyaXRlKHZhbHVlLCBieXRlcykge1xuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgIC8vIHdyaXRlIHZhbHVlIGFzIHZhcmludCAzMlxuICAgICAgICB3aGlsZSAodmFsdWUgPiAweDdmKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKCh2YWx1ZSAmIDB4N2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goKHZhbHVlICYgMTI3KSB8IDEyOCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgxKTtcbiAgICB9XG59XG4vKipcbiAqIFJlYWQgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wyMjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgICBsZXQgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIGxldCByZXN1bHQgPSBiICYgMHg3ZjtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgICByZXN1bHQgfD0gKGIgJiAweDdmKSA8PCA3O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDIxO1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gICAgYiA9IHRoaXMuYnVmW3RoaXMucG9zKytdO1xuICAgIHJlc3VsdCB8PSAoYiAmIDB4MGYpIDw8IDI4O1xuICAgIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKVxuICAgICAgICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaWYgKChiICYgMHg4MCkgIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB2YXJpbnRcIik7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICAgIHJldHVybiByZXN1bHQgPj4+IDA7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vcHJpdmF0ZS9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGludDY0RnJvbVN0cmluZywgaW50NjRUb1N0cmluZywgdUludDY0VG9TdHJpbmcsIH0gZnJvbSBcIi4vZ29vZ2xlL3ZhcmludC5qc1wiO1xuZnVuY3Rpb24gbWFrZUludDY0U3VwcG9ydCgpIHtcbiAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoOCkpO1xuICAgIC8vIG5vdGUgdGhhdCBTYWZhcmkgMTQgaW1wbGVtZW50cyBCaWdJbnQsIGJ1dCBub3QgdGhlIERhdGFWaWV3IG1ldGhvZHNcbiAgICBjb25zdCBvayA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICh0eXBlb2YgcHJvY2VzcyAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5lbnYgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQlVGX0JJR0lOVF9ESVNBQkxFICE9PSBcIjFcIik7XG4gICAgaWYgKG9rKSB7XG4gICAgICAgIGNvbnN0IE1JTiA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCBNQVggPSBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLCBVTUlOID0gQmlnSW50KFwiMFwiKSwgVU1BWCA9IEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgemVybzogQmlnSW50KDApLFxuICAgICAgICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IE1BWCB8fCBiaSA8IE1JTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1UGFyc2UodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChiaSA+IFVNQVggfHwgYmkgPCBVTUlOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdWludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiaTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnBhcnNlKHZhbHVlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbG86IGR2LmdldEludDMyKDAsIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RW5jKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZHYuc2V0QmlnSW50NjQoMCwgdGhpcy51UGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGhpOiBkdi5nZXRJbnQzMig0LCB0cnVlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYyhsbywgaGkpIHtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMigwLCBsbywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkdi5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR2LmdldEJpZ1VpbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGFzc2VydEludDY0U3RyaW5nID0gKHZhbHVlKSA9PiBhc3NlcnQoL14tP1swLTldKyQvLnRlc3QodmFsdWUpLCBgaW50NjQgaW52YWxpZDogJHt2YWx1ZX1gKTtcbiAgICBjb25zdCBhc3NlcnRVSW50NjRTdHJpbmcgPSAodmFsdWUpID0+IGFzc2VydCgvXlswLTldKyQvLnRlc3QodmFsdWUpLCBgdWludDY0IGludmFsaWQ6ICR7dmFsdWV9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgemVybzogXCIwXCIsXG4gICAgICAgIHN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdUVuYyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50NjRUb1N0cmluZyhsbywgaGkpO1xuICAgICAgICB9LFxuICAgICAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCBwcm90b0ludDY0ID0gbWFrZUludDY0U3VwcG9ydCgpO1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogU2NhbGFyIHZhbHVlIHR5cGVzLiBUaGlzIGlzIGEgc3Vic2V0IG9mIGZpZWxkIHR5cGVzIGRlY2xhcmVkIGJ5IHByb3RvYnVmXG4gKiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90by5UeXBlIFRoZSB0eXBlcyBHUk9VUCBhbmQgTUVTU0FHRVxuICogYXJlIG9taXR0ZWQsIGJ1dCB0aGUgbnVtZXJpY2FsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICovXG5leHBvcnQgdmFyIFNjYWxhclR5cGU7XG4oZnVuY3Rpb24gKFNjYWxhclR5cGUpIHtcbiAgICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnMuXG4gICAgLy8gT3JkZXIgaXMgd2VpcmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJET1VCTEVcIl0gPSAxXSA9IFwiRE9VQkxFXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRkxPQVRcIl0gPSAyXSA9IFwiRkxPQVRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UNjQgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQ2NFwiXSA9IDNdID0gXCJJTlQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQ2NFwiXSA9IDRdID0gXCJVSU5UNjRcIjtcbiAgICAvLyBOb3QgWmlnWmFnIGVuY29kZWQuICBOZWdhdGl2ZSBudW1iZXJzIHRha2UgMTAgYnl0ZXMuICBVc2UgVFlQRV9TSU5UMzIgaWZcbiAgICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQzMlwiXSA9IDVdID0gXCJJTlQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVENjRcIl0gPSA2XSA9IFwiRklYRUQ2NFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJPT0xcIl0gPSA4XSA9IFwiQk9PTFwiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNUUklOR1wiXSA9IDldID0gXCJTVFJJTkdcIjtcbiAgICAvLyBUYWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBHcm91cCB0eXBlIGlzIGRlcHJlY2F0ZWQgYW5kIG5vdCBzdXBwb3J0ZWQgaW4gcHJvdG8zLiBIb3dldmVyLCBQcm90bzNcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHN0aWxsIGJlIGFibGUgdG8gcGFyc2UgdGhlIGdyb3VwIHdpcmUgZm9ybWF0IGFuZFxuICAgIC8vIHRyZWF0IGdyb3VwIGZpZWxkcyBhcyB1bmtub3duIGZpZWxkcy5cbiAgICAvLyBUWVBFX0dST1VQID0gMTAsXG4gICAgLy8gVFlQRV9NRVNTQUdFID0gMTEsICAvLyBMZW5ndGgtZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICAvLyBOZXcgaW4gdmVyc2lvbiAyLlxuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkJZVEVTXCJdID0gMTJdID0gXCJCWVRFU1wiO1xuICAgIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlVJTlQzMlwiXSA9IDEzXSA9IFwiVUlOVDMyXCI7XG4gICAgLy8gVFlQRV9FTlVNID0gMTQsXG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVEMzJcIl0gPSAxNV0gPSBcIlNGSVhFRDMyXCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0ZJWEVENjRcIl0gPSAxNl0gPSBcIlNGSVhFRDY0XCI7XG4gICAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcbiAgICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTSU5UNjRcIl0gPSAxOF0gPSBcIlNJTlQ2NFwiO1xufSkoU2NhbGFyVHlwZSB8fCAoU2NhbGFyVHlwZSA9IHt9KSk7XG4vKipcbiAqIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgZmllbGRzIHdpdGggNjQgYml0IGludGVncmFsIHR5cGVzIChpbnQ2NCwgdWludDY0LFxuICogc2ludDY0LCBmaXhlZDY0LCBzZml4ZWQ2NCkuXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiBnb29nbGUucHJvdG9idWYuRmllbGRPcHRpb25zLkpTVHlwZSwgd2hpY2ggZGVmaW5lcyBKU19OT1JNQUwsXG4gKiBKU19TVFJJTkcsIGFuZCBKU19OVU1CRVIuIFByb3RvYnVmLUVTIHVzZXMgQmlnSW50IGJ5IGRlZmF1bHQsIGJ1dCB3aWxsIHVzZVxuICogU3RyaW5nIGlmIGBbanN0eXBlID0gSlNfU1RSSU5HXWAgaXMgc3BlY2lmaWVkLlxuICpcbiAqIGBgYHByb3RvYnVmXG4gKiB1aW50NjQgZmllbGRfYSA9IDE7IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19OT1JNQUxdOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTlVNQkVSXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX1NUUklOR107IC8vIFN0cmluZ1xuICogYGBgXG4gKi9cbmV4cG9ydCB2YXIgTG9uZ1R5cGU7XG4oZnVuY3Rpb24gKExvbmdUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVXNlIEphdmFTY3JpcHQgQmlnSW50LlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiQklHSU5UXCJdID0gMF0gPSBcIkJJR0lOVFwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBKYXZhU2NyaXB0IFN0cmluZy5cbiAgICAgKlxuICAgICAqIEZpZWxkIG9wdGlvbiBgW2pzdHlwZSA9IEpTX1NUUklOR11gLlxuICAgICAqL1xuICAgIExvbmdUeXBlW0xvbmdUeXBlW1wiU1RSSU5HXCJdID0gMV0gPSBcIlNUUklOR1wiO1xufSkoTG9uZ1R5cGUgfHwgKExvbmdUeXBlID0ge30pKTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4uL3Byb3RvLWludDY0LmpzXCI7XG5pbXBvcnQgeyBMb25nVHlwZSwgU2NhbGFyVHlwZSB9IGZyb20gXCIuLi9zY2FsYXIuanNcIjtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJvdGggc2NhbGFyIHZhbHVlcyBhcmUgZXF1YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIFRoaXMgY29ycmVjdGx5IG1hdGNoZXMgZXF1YWwgdmFsdWVzIGV4Y2VwdCBCWVRFUyBhbmQgKHBvc3NpYmx5KSA2NC1iaXQgaW50ZWdlcnMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIGNhc2UgQllURVMgLSB3ZSBuZWVkIHRvIGNvbXBhcmUgZWFjaCBieXRlIGluZGl2aWR1YWxseVxuICAgIGlmICh0eXBlID09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgaWYgKCEoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFNwZWNpYWwgY2FzZSA2NC1iaXQgaW50ZWdlcnMgLSB3ZSBzdXBwb3J0IG51bWJlciwgc3RyaW5nIGFuZCBiaWdpbnQgcmVwcmVzZW50YXRpb24uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgLy8gTG9vc2UgY29tcGFyaXNvbiB3aWxsIG1hdGNoIGJldHdlZW4gMG4sIDAgYW5kIFwiMFwiLlxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYjtcbiAgICB9XG4gICAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxuICAgIC8vIEJZVEVTIGFuZCA2NC1iaXQgaW50ZWdlcnMgaXMgbm90IGVxdWFsLlxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgemVybyB2YWx1ZSBmb3IgdGhlIGdpdmVuIHNjYWxhciB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgICAgICAgIHJldHVybiAobG9uZ1R5cGUgPT0gMCA/IHByb3RvSW50NjQuemVybyA6IFwiMFwiKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBIYW5kbGVzIElOVDMyLCBVSU5UMzIsIFNJTlQzMiwgRklYRUQzMiwgU0ZJWEVEMzIuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGluZGl2aWR1YWwgY2FzZXMgdG8gc2F2ZSBhIGZldyBieXRlcyBjb2RlIHNpemUuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBmb3IgYSB6ZXJvLXZhbHVlLiBGb3IgZXhhbXBsZSwgYW4gaW50ZWdlciBoYXMgdGhlIHplcm8tdmFsdWUgYDBgLFxuICogYSBib29sZWFuIGlzIGBmYWxzZWAsIGEgc3RyaW5nIGlzIGBcIlwiYCwgYW5kIGJ5dGVzIGlzIGFuIGVtcHR5IFVpbnQ4QXJyYXkuXG4gKlxuICogSW4gcHJvdG8zLCB6ZXJvLXZhbHVlcyBhcmUgbm90IHdyaXR0ZW4gdG8gdGhlIHdpcmUsIHVubGVzcyB0aGUgZmllbGQgaXNcbiAqIG9wdGlvbmFsIG9yIHJlcGVhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTY2FsYXJaZXJvVmFsdWUodHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBcIlwiO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICF2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IDA7IC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgdmFyaW50MzJyZWFkLCB2YXJpbnQzMndyaXRlLCB2YXJpbnQ2NHJlYWQsIHZhcmludDY0d3JpdGUsIH0gZnJvbSBcIi4vZ29vZ2xlL3ZhcmludC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0RmxvYXQzMiwgYXNzZXJ0SW50MzIsIGFzc2VydFVJbnQzMiB9IGZyb20gXCIuL3ByaXZhdGUvYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4vcHJvdG8taW50NjQuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBQcm90b2J1ZiBiaW5hcnkgZm9ybWF0IHdpcmUgdHlwZXMuXG4gKlxuICogQSB3aXJlIHR5cGUgcHJvdmlkZXMganVzdCBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZmluZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogZm9sbG93aW5nIHZhbHVlLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvZW5jb2Rpbmcjc3RydWN0dXJlXG4gKi9cbmV4cG9ydCB2YXIgV2lyZVR5cGU7XG4oZnVuY3Rpb24gKFdpcmVUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlZhcmludFwiXSA9IDBdID0gXCJWYXJpbnRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBmaXhlZDY0LCBzZml4ZWQ2NCwgZG91YmxlLlxuICAgICAqIEFsd2F5cyA4IGJ5dGVzIHdpdGggbGl0dGxlLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiQml0NjRcIl0gPSAxXSA9IFwiQml0NjRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuICAgICAqXG4gICAgICogT25seSByZXBlYXRlZCBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LFxuICAgICAqIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgcGFja2VkLiBJbiBwcm90bzMsIHN1Y2ggZmllbGRzIGFyZVxuICAgICAqIHBhY2tlZCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiTGVuZ3RoRGVsaW1pdGVkXCJdID0gMl0gPSBcIkxlbmd0aERlbGltaXRlZFwiO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IG9mIGEgdGFnLWRlbGltaXRlZCBhZ2dyZWdhdGUsIHN1Y2ggYXMgYSBwcm90bzIgZ3JvdXAsIG9yIGEgbWVzc2FnZVxuICAgICAqIGluIGVkaXRpb25zIHdpdGggbWVzc2FnZV9lbmNvZGluZyA9IERFTElNSVRFRC5cbiAgICAgKi9cbiAgICBXaXJlVHlwZVtXaXJlVHlwZVtcIlN0YXJ0R3JvdXBcIl0gPSAzXSA9IFwiU3RhcnRHcm91cFwiO1xuICAgIC8qKlxuICAgICAqIEVuZCBvZiBhIHRhZy1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAgICAqL1xuICAgIFdpcmVUeXBlW1dpcmVUeXBlW1wiRW5kR3JvdXBcIl0gPSA0XSA9IFwiRW5kR3JvdXBcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBmaXhlZDMyLCBzZml4ZWQzMiwgZmxvYXQuXG4gICAgICogQWx3YXlzIDQgYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAgICovXG4gICAgV2lyZVR5cGVbV2lyZVR5cGVbXCJCaXQzMlwiXSA9IDVdID0gXCJCaXQzMlwiO1xufSkoV2lyZVR5cGUgfHwgKFdpcmVUeXBlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBCaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRleHRFbmNvZGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2aW91cyBmb3JrIHN0YXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy50ZXh0RW5jb2RlciA9IHRleHRFbmNvZGVyICE9PSBudWxsICYmIHRleHRFbmNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RW5jb2RlciA6IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGJ5dGVzIHdyaXR0ZW4gYW5kIHJlc2V0IHRoaXMgd3JpdGVyLlxuICAgICAqL1xuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgVWludDhBcnJheSh0aGlzLmJ1ZikpOyAvLyBmbHVzaCB0aGUgYnVmZmVyXG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbGVuICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnNldCh0aGlzLmNodW5rc1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmNodW5rc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIG5ldyBmb3JrIGZvciBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgbGlrZSBhIG1lc3NhZ2VcbiAgICAgKiBvciBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZC5cbiAgICAgKlxuICAgICAqIE11c3QgYmUgam9pbmVkIGxhdGVyIHdpdGggYGpvaW4oKWAuXG4gICAgICovXG4gICAgZm9yaygpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHsgY2h1bmtzOiB0aGlzLmNodW5rcywgYnVmOiB0aGlzLmJ1ZiB9KTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW4gdGhlIGxhc3QgZm9yay4gV3JpdGUgaXRzIGxlbmd0aCBhbmQgYnl0ZXMsIHRoZW5cbiAgICAgKiByZXR1cm4gdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAqL1xuICAgIGpvaW4oKSB7XG4gICAgICAgIC8vIGdldCBjaHVuayBvZiBmb3JrXG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMuZmluaXNoKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgcHJldmlvdXMgc3RhdGVcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIXByZXYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlLCBmb3JrIHN0YWNrIGVtcHR5XCIpO1xuICAgICAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xuICAgICAgICB0aGlzLmJ1ZiA9IHByZXYuYnVmO1xuICAgICAgICAvLyB3cml0ZSBsZW5ndGggb2YgY2h1bmsgYXMgdmFyaW50XG4gICAgICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSB0YWcgKGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlKS5cbiAgICAgKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYHVpbnQzMiggKGZpZWxkTm8gPDwgMyB8IHR5cGUpID4+PiAwIClgLlxuICAgICAqXG4gICAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXG4gICAgICovXG4gICAgdGFnKGZpZWxkTm8sIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludDMyKCgoZmllbGRObyA8PCAzKSB8IHR5cGUpID4+PiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBjaHVuayBvZiByYXcgYnl0ZXMuXG4gICAgICovXG4gICAgcmF3KGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGB1aW50MzJgIHZhbHVlLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQzMih2YWx1ZSkge1xuICAgICAgICBhc3NlcnRVSW50MzIodmFsdWUpO1xuICAgICAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzIsIGlubGluZWQgZm9yIHNwZWVkXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDB4N2YpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goKHZhbHVlICYgMHg3ZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBpbnQzMmAgdmFsdWUsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBib29sYCB2YWx1ZSwgYSB2YXJpYW50LlxuICAgICAqL1xuICAgIGJvb2wodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGJ5dGVzYCB2YWx1ZSwgbGVuZ3RoLWRlbGltaXRlZCBhcmJpdHJhcnkgZGF0YS5cbiAgICAgKi9cbiAgICBieXRlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVpbnQzMih2YWx1ZS5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgICAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzdHJpbmdgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGRhdGEgY29udmVydGVkIHRvIFVURi04IHRleHQuXG4gICAgICovXG4gICAgc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgdGhpcy51aW50MzIoY2h1bmsuYnl0ZUxlbmd0aCk7IC8vIHdyaXRlIGxlbmd0aCBvZiBjaHVuayBhcyB2YXJpbnRcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgZmxvYXRgIHZhbHVlLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZsb2F0KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEZsb2F0MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYGRvdWJsZWAgdmFsdWUsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEZsb2F0NjQoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDMyYCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDMyKHZhbHVlKSB7XG4gICAgICAgIGFzc2VydFVJbnQzMih2YWx1ZSk7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRVaW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzZml4ZWQzMmAgdmFsdWUsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgc2ZpeGVkMzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0SW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBzaW50MzJgIHZhbHVlLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHZhbHVlID0gKCh2YWx1ZSA8PCAxKSBeICh2YWx1ZSA+PiAzMSkpID4+PiAwO1xuICAgICAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBzZml4ZWQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSwgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBmaXhlZDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQsIGZpeGVkLWxlbmd0aCA2NCBiaXQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBmaXhlZDY0KHZhbHVlKSB7XG4gICAgICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLCB2aWV3ID0gbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlciksIHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0Yy5sbywgdHJ1ZSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGBpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkIDY0LWJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKHRjLmxvLCB0Yy5oaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgc2ludDY0YCB2YWx1ZSwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHNpbnQ2NCh2YWx1ZSkge1xuICAgICAgICBsZXQgdGMgPSBwcm90b0ludDY0LmVuYyh2YWx1ZSksIFxuICAgICAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgICAgIHNpZ24gPSB0Yy5oaSA+PiAzMSwgbG8gPSAodGMubG8gPDwgMSkgXiBzaWduLCBoaSA9ICgodGMuaGkgPDwgMSkgfCAodGMubG8gPj4+IDMxKSkgXiBzaWduO1xuICAgICAgICB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgdGhpcy5idWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSBgdWludDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB1aW50NjQodmFsdWUpIHtcbiAgICAgICAgbGV0IHRjID0gcHJvdG9JbnQ2NC51RW5jKHZhbHVlKTtcbiAgICAgICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpbmFyeVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmLCB0ZXh0RGVjb2Rlcikge1xuICAgICAgICB0aGlzLnZhcmludDY0ID0gdmFyaW50NjRyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2BcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWQgYSBgdWludDMyYCBmaWVsZCwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudWludDMyID0gdmFyaW50MzJyZWFkOyAvLyBkaXJ0eSBjYXN0IGZvciBgdGhpc2AgYW5kIGFjY2VzcyB0byBwcm90ZWN0ZWQgYGJ1ZmBcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgIHRoaXMubGVuID0gYnVmLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IHRleHREZWNvZGVyICE9PSBudWxsICYmIHRleHREZWNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RGVjb2RlciA6IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHRhZyAtIGZpZWxkIG51bWJlciBhbmQgd2lyZSB0eXBlLlxuICAgICAqL1xuICAgIHRhZygpIHtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMudWludDMyKCksIGZpZWxkTm8gPSB0YWcgPj4+IDMsIHdpcmVUeXBlID0gdGFnICYgNztcbiAgICAgICAgaWYgKGZpZWxkTm8gPD0gMCB8fCB3aXJlVHlwZSA8IDAgfHwgd2lyZVR5cGUgPiA1KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICAgICAgcmV0dXJuIFtmaWVsZE5vLCB3aXJlVHlwZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXAgb25lIGVsZW1lbnQgYW5kIHJldHVybiB0aGUgc2tpcHBlZCBkYXRhLlxuICAgICAqXG4gICAgICogV2hlbiBza2lwcGluZyBTdGFydEdyb3VwLCBwcm92aWRlIHRoZSB0YWdzIGZpZWxkIG51bWJlciB0byBjaGVjayBmb3JcbiAgICAgKiBtYXRjaGluZyBmaWVsZCBudW1iZXIgaW4gdGhlIEVuZEdyb3VwIHRhZy5cbiAgICAgKi9cbiAgICBza2lwKHdpcmVUeXBlLCBmaWVsZE5vKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLlZhcmludDpcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgICBjYXNlIFdpcmVUeXBlLkJpdDY0OlxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5CaXQzMjpcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQ6XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXaXJlVHlwZS5TdGFydEdyb3VwOlxuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2ZuLCB3dF0gPSB0aGlzLnRhZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3QgPT09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRObyAhPT0gdW5kZWZpbmVkICYmIGZuICE9PSBmaWVsZE5vKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmQgZ3JvdXAgdGFnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKHd0LCBmbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW50IHNraXAgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgdGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaHJvd3MgZXJyb3IgaWYgcG9zaXRpb24gaW4gYnl0ZSBhcnJheSBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgICovXG4gICAgYXNzZXJ0Qm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwicHJlbWF0dXJlIEVPRlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBpbnQzMmAgZmllbGQsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAgICovXG4gICAgaW50MzIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBzaW50MzJgIGZpZWxkLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50MzIoKSB7XG4gICAgICAgIGxldCB6emUgPSB0aGlzLnVpbnQzMigpO1xuICAgICAgICAvLyBkZWNvZGUgemlnemFnXG4gICAgICAgIHJldHVybiAoenplID4+PiAxKSBeIC0oenplICYgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgaW50NjRgIGZpZWxkLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIGludDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMoLi4udGhpcy52YXJpbnQ2NCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGB1aW50NjRgIGZpZWxkLCBhbiB1bnNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgICAqL1xuICAgIHVpbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvSW50NjQudURlYyguLi50aGlzLnZhcmludDY0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHNpbnQ2NGAgZmllbGQsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICAgKi9cbiAgICBzaW50NjQoKSB7XG4gICAgICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAgICAgLy8gZGVjb2RlIHppZyB6YWdcbiAgICAgICAgbGV0IHMgPSAtKGxvICYgMSk7XG4gICAgICAgIGxvID0gKChsbyA+Pj4gMSkgfCAoKGhpICYgMSkgPDwgMzEpKSBeIHM7XG4gICAgICAgIGhpID0gKGhpID4+PiAxKSBeIHM7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LmRlYyhsbywgaGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGJvb2xgIGZpZWxkLCBhIHZhcmlhbnQuXG4gICAgICovXG4gICAgYm9vbCgpIHtcbiAgICAgICAgbGV0IFtsbywgaGldID0gdGhpcy52YXJpbnQ2NCgpO1xuICAgICAgICByZXR1cm4gbG8gIT09IDAgfHwgaGkgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgZml4ZWQzMmAgZmllbGQsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAgICovXG4gICAgZml4ZWQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRVaW50MzIoKHRoaXMucG9zICs9IDQpIC0gNCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgc2ZpeGVkMzJgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIGZpeGVkNjQoKSB7XG4gICAgICAgIHJldHVybiBwcm90b0ludDY0LnVEZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHNmaXhlZDY0KCkge1xuICAgICAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWModGhpcy5zZml4ZWQzMigpLCB0aGlzLnNmaXhlZDMyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGZsb2F0YCBmaWVsZCwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBmbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICAgKi9cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCgodGhpcy5wb3MgKz0gOCkgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGBieXRlc2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgYXJiaXRyYXJ5IGRhdGEuXG4gICAgICovXG4gICAgYnl0ZXMoKSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLnVpbnQzMigpLCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW47XG4gICAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgYHN0cmluZ2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICAgKi9cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ5dGVzKCkpO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBzY2FsYXJaZXJvVmFsdWUgfSBmcm9tIFwiLi9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBXaXJlVHlwZSB9IGZyb20gXCIuLi9iaW5hcnktZW5jb2RpbmcuanNcIjtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV4dGVuc2lvbiB1c2luZyB0aGUgZ2l2ZW4gcnVudGltZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFeHRlbnNpb24ocnVudGltZSwgdHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCkge1xuICAgIGxldCBmaTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlTmFtZSxcbiAgICAgICAgZXh0ZW5kZWUsXG4gICAgICAgIGdldCBmaWVsZCgpIHtcbiAgICAgICAgICAgIGlmICghZmkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gKHR5cGVvZiBmaWVsZCA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZCgpIDogZmllbGQpO1xuICAgICAgICAgICAgICAgIGkubmFtZSA9IHR5cGVOYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpLmpzb25OYW1lID0gYFske3R5cGVOYW1lfV1gO1xuICAgICAgICAgICAgICAgIGZpID0gcnVudGltZS51dGlsLm5ld0ZpZWxkTGlzdChbaV0pLmxpc3QoKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVudGltZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBjb250YWluZXIgdGhhdCBhbGxvd3MgdXMgdG8gcmVhZCBleHRlbnNpb24gZmllbGRzIGludG8gaXQgd2l0aCB0aGVcbiAqIHNhbWUgbG9naWMgYXMgcmVndWxhciBmaWVsZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgbG9jYWxOYW1lID0gZXh0ZW5zaW9uLmZpZWxkLmxvY2FsTmFtZTtcbiAgICBjb25zdCBjb250YWluZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnRhaW5lcltsb2NhbE5hbWVdID0gaW5pdEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbik7XG4gICAgcmV0dXJuIFtjb250YWluZXIsICgpID0+IGNvbnRhaW5lcltsb2NhbE5hbWVdXTtcbn1cbmZ1bmN0aW9uIGluaXRFeHRlbnNpb25GaWVsZChleHQpIHtcbiAgICBjb25zdCBmaWVsZCA9IGV4dC5maWVsZDtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoZmllbGQuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5kZWZhdWx0O1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5ULnZhbHVlc1swXS5ubztcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhclplcm9WYWx1ZShmaWVsZC5ULCBmaWVsZC5MKTtcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgY29uc3QgVCA9IGZpZWxkLlQsIHZhbHVlID0gbmV3IFQoKTtcbiAgICAgICAgICAgIHJldHVybiBULmZpZWxkV3JhcHBlciA/IFQuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICB0aHJvdyBcIm1hcCBmaWVsZHMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIGV4dGVuc2lvbnNcIjtcbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBmaWx0ZXIgdW5rbm93biBmaWVsZHMsIG9wdGltaXplZCBiYXNlZCBvbiBmaWVsZCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVW5rbm93bkZpZWxkcyh1bmtub3duRmllbGRzLCBmaWVsZCkge1xuICAgIGlmICghZmllbGQucmVwZWF0ZWQgJiYgKGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgfHwgZmllbGQua2luZCA9PSBcInNjYWxhclwiKSkge1xuICAgICAgICAvLyBzaW5ndWxhciBzY2FsYXIgZmllbGRzIGRvIG5vdCBtZXJnZSwgd2UgcGljayB0aGUgbGFzdFxuICAgICAgICBmb3IgKGxldCBpID0gdW5rbm93bkZpZWxkcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKHVua25vd25GaWVsZHNbaV0ubm8gPT0gZmllbGQubm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3Vua25vd25GaWVsZHNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHVua25vd25GaWVsZHMuZmlsdGVyKCh1ZikgPT4gdWYubm8gPT09IGZpZWxkLm5vKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb24sIHByZWZlci1jb25zdCAqL1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciB0byBieXRlXG5sZXQgZW5jVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcbi8vIGxvb2t1cCB0YWJsZSBmcm9tIGJhc2U2NCBjaGFyYWN0ZXIgKmNvZGUqIHRvIGJ5dGUgYmVjYXVzZSBsb29rdXAgYnkgbnVtYmVyIGlzIGZhc3RcbmxldCBkZWNUYWJsZSA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNUYWJsZS5sZW5ndGg7IGkrKylcbiAgICBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG5leHBvcnQgY29uc3QgcHJvdG9CYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGJhc2U2NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5LlxuICAgICAqXG4gICAgICogLSBpZ25vcmVzIHdoaXRlLXNwYWNlLCBpbmNsdWRpbmcgbGluZSBicmVha3MgYW5kIHRhYnNcbiAgICAgKiAtIGFsbG93cyBpbm5lciBwYWRkaW5nIChjYW4gZGVjb2RlIGNvbmNhdGVuYXRlZCBiYXNlNjQgc3RyaW5ncylcbiAgICAgKiAtIGRvZXMgbm90IHJlcXVpcmUgcGFkZGluZ1xuICAgICAqIC0gdW5kZXJzdGFuZHMgYmFzZTY0dXJsIGVuY29kaW5nOlxuICAgICAqICAgXCItXCIgaW5zdGVhZCBvZiBcIitcIixcbiAgICAgKiAgIFwiX1wiIGluc3RlYWQgb2YgXCIvXCIsXG4gICAgICogICBubyBwYWRkaW5nXG4gICAgICovXG4gICAgZGVjKGJhc2U2NFN0cikge1xuICAgICAgICAvLyBlc3RpbWF0ZSBieXRlIHNpemUsIG5vdCBhY2NvdW50aW5nIGZvciBpbm5lciBwYWRkaW5nIGFuZCB3aGl0ZXNwYWNlXG4gICAgICAgIGxldCBlcyA9IChiYXNlNjRTdHIubGVuZ3RoICogMykgLyA0O1xuICAgICAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSBcIj1cIilcbiAgICAgICAgICAgIGVzIC09IDI7XG4gICAgICAgIGVsc2UgaWYgKGJhc2U2NFN0cltiYXNlNjRTdHIubGVuZ3RoIC0gMV0gPT0gXCI9XCIpXG4gICAgICAgICAgICBlcyAtPSAxO1xuICAgICAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheShlcyksIGJ5dGVQb3MgPSAwLCAvLyBwb3NpdGlvbiBpbiBieXRlIGFycmF5XG4gICAgICAgIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICAgIGIsIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgICBwID0gMDsgLy8gcHJldmlvdXMgYnl0ZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYiA9IGRlY1RhYmxlW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRTNzAyOTogRmFsbHRocm91Z2ggY2FzZSBpbiBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDsgLy8gcmVzZXQgc3RhdGUgd2hlbiBwYWRkaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlxcdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgd2hpdGUtc3BhY2UsIGFuZCBwYWRkaW5nXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYmFzZTY0IHN0cmluZy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKHAgPDwgMikgfCAoKGIgJiA0OCkgPj4gNCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9ICgocCAmIDE1KSA8PCA0KSB8ICgoYiAmIDYwKSA+PiAyKTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBieXRlc1tieXRlUG9zKytdID0gKChwICYgMykgPDwgNikgfCBiO1xuICAgICAgICAgICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cFBvcyA9PSAxKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NCBzdHJpbmcuXCIpO1xuICAgICAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgYnl0ZVBvcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBFbmNvZGUgYSBieXRlIGFycmF5IHRvIGEgYmFzZTY0IHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmMoYnl0ZXMpIHtcbiAgICAgICAgbGV0IGJhc2U2NCA9IFwiXCIsIGdyb3VwUG9zID0gMCwgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICAgIGIsIC8vIGN1cnJlbnQgYnl0ZVxuICAgICAgICBwID0gMDsgLy8gY2Fycnkgb3ZlciBmcm9tIHByZXZpb3VzIGJ5dGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgPj4gMl07XG4gICAgICAgICAgICAgICAgICAgIHAgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IChiID4+IDQpXTtcbiAgICAgICAgICAgICAgICAgICAgcCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IChiID4+IDYpXTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgJiA2M107XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIG91dHB1dCBwYWRkaW5nXG4gICAgICAgIGlmIChncm91cFBvcykge1xuICAgICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW3BdO1xuICAgICAgICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgICAgICAgaWYgKGdyb3VwUG9zID09IDEpXG4gICAgICAgICAgICAgICAgYmFzZTY0ICs9IFwiPVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfSxcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vcHJpdmF0ZS9hc3NlcnQuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lciwgZmlsdGVyVW5rbm93bkZpZWxkcywgfSBmcm9tIFwiLi9wcml2YXRlL2V4dGVuc2lvbnMuanNcIjtcbi8qKlxuICogUmV0cmlldmUgYW4gZXh0ZW5zaW9uIHZhbHVlIGZyb20gYSBtZXNzYWdlLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBuZXZlciByZXR1cm5zIHVuZGVmaW5lZC4gVXNlIGhhc0V4dGVuc2lvbigpIHRvIGNoZWNrIHdoZXRoZXIgYW5cbiAqIGV4dGVuc2lvbiBpcyBzZXQuIElmIHRoZSBleHRlbnNpb24gaXMgbm90IHNldCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICogZGVmYXVsdCB2YWx1ZSAoaWYgb25lIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHByb3RvYnVmIHNvdXJjZSksIG9yIHRoZSB6ZXJvIHZhbHVlXG4gKiAoZm9yIGV4YW1wbGUgYDBgIGZvciBudW1lcmljIHR5cGVzLCBgW11gIGZvciByZXBlYXRlZCBleHRlbnNpb24gZmllbGRzLCBhbmRcbiAqIGFuIGVtcHR5IG1lc3NhZ2UgaW5zdGFuY2UgZm9yIG1lc3NhZ2UgZmllbGRzKS5cbiAqXG4gKiBFeHRlbnNpb25zIGFyZSBzdG9yZWQgYXMgdW5rbm93biBmaWVsZHMgb24gYSBtZXNzYWdlLiBUbyBtdXRhdGUgYW4gZXh0ZW5zaW9uXG4gKiB2YWx1ZSwgbWFrZSBzdXJlIHRvIHN0b3JlIHRoZSBuZXcgdmFsdWUgd2l0aCBzZXRFeHRlbnNpb24oKSBhZnRlciBtdXRhdGluZy5cbiAqXG4gKiBJZiB0aGUgZXh0ZW5zaW9uIGRvZXMgbm90IGV4dGVuZCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW4gZXJyb3IgaXMgcmFpc2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbiwgb3B0aW9ucykge1xuICAgIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gICAgY29uc3Qgb3B0ID0gZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLm1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB1ZnMgPSBmaWx0ZXJVbmtub3duRmllbGRzKG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpLCBleHRlbnNpb24uZmllbGQpO1xuICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0ZW5zaW9uKTtcbiAgICBmb3IgKGNvbnN0IHVmIG9mIHVmcykge1xuICAgICAgICBleHRlbnNpb24ucnVudGltZS5iaW4ucmVhZEZpZWxkKGNvbnRhaW5lciwgb3B0LnJlYWRlckZhY3RvcnkodWYuZGF0YSksIGV4dGVuc2lvbi5maWVsZCwgdWYud2lyZVR5cGUsIG9wdCk7XG4gICAgfVxuICAgIHJldHVybiBnZXQoKTtcbn1cbi8qKlxuICogU2V0IGFuIGV4dGVuc2lvbiB2YWx1ZSBvbiBhIG1lc3NhZ2UuIElmIHRoZSBtZXNzYWdlIGFscmVhZHkgaGFzIGEgdmFsdWUgZm9yXG4gKiB0aGlzIGV4dGVuc2lvbiwgdGhlIHZhbHVlIGlzIHJlcGxhY2VkLlxuICpcbiAqIElmIHRoZSBleHRlbnNpb24gZG9lcyBub3QgZXh0ZW5kIHRoZSBnaXZlbiBtZXNzYWdlLCBhbiBlcnJvciBpcyByYWlzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gICAgY29uc3QgcmVhZE9wdCA9IGV4dGVuc2lvbi5ydW50aW1lLmJpbi5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3Qgd3JpdGVPcHQgPSBleHRlbnNpb24ucnVudGltZS5iaW4ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAoaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikpIHtcbiAgICAgICAgY29uc3QgdWZzID0gbWVzc2FnZVxuICAgICAgICAgICAgLmdldFR5cGUoKVxuICAgICAgICAgICAgLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpXG4gICAgICAgICAgICAuZmlsdGVyKCh1ZikgPT4gdWYubm8gIT0gZXh0ZW5zaW9uLmZpZWxkLm5vKTtcbiAgICAgICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4uZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSk7XG4gICAgICAgIGZvciAoY29uc3QgdWYgb2YgdWZzKSB7XG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICAgICAgLmdldFR5cGUoKVxuICAgICAgICAgICAgICAgIC5ydW50aW1lLmJpbi5vblVua25vd25GaWVsZChtZXNzYWdlLCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdyaXRlciA9IHdyaXRlT3B0LndyaXRlckZhY3RvcnkoKTtcbiAgICBsZXQgZiA9IGV4dGVuc2lvbi5maWVsZDtcbiAgICAvLyBJbXBsaWNpdCBwcmVzZW5jZSBkb2VzIG5vdCBhcHBseSB0byBleHRlbnNpb25zLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9pc3N1ZXMvODIzNFxuICAgIC8vIFdlIHBhdGNoIHRoZSBmaWVsZCBpbmZvIHRvIHVzZSBleHBsaWNpdCBwcmVzZW5jZTpcbiAgICBpZiAoIWYub3B0ICYmICFmLnJlcGVhdGVkICYmIChmLmtpbmQgPT0gXCJlbnVtXCIgfHwgZi5raW5kID09IFwic2NhbGFyXCIpKSB7XG4gICAgICAgIGYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dGVuc2lvbi5maWVsZCksIHsgb3B0OiB0cnVlIH0pO1xuICAgIH1cbiAgICBleHRlbnNpb24ucnVudGltZS5iaW4ud3JpdGVGaWVsZChmLCB2YWx1ZSwgd3JpdGVyLCB3cml0ZU9wdCk7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZE9wdC5yZWFkZXJGYWN0b3J5KHdyaXRlci5maW5pc2goKSk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCByZWFkZXIubGVuKSB7XG4gICAgICAgIGNvbnN0IFtubywgd2lyZVR5cGVdID0gcmVhZGVyLnRhZygpO1xuICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnNraXAod2lyZVR5cGUsIG5vKTtcbiAgICAgICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQobWVzc2FnZSwgbm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZSBhbiBleHRlbnNpb24gdmFsdWUgZnJvbSBhIG1lc3NhZ2UuXG4gKlxuICogSWYgdGhlIGV4dGVuc2lvbiBkb2VzIG5vdCBleHRlbmQgdGhlIGdpdmVuIG1lc3NhZ2UsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikge1xuICAgIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gICAgaWYgKGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24pKSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluO1xuICAgICAgICBjb25zdCB1ZnMgPSBiaW5cbiAgICAgICAgICAgIC5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKVxuICAgICAgICAgICAgLmZpbHRlcigodWYpID0+IHVmLm5vICE9IGV4dGVuc2lvbi5maWVsZC5ubyk7XG4gICAgICAgIGJpbi5kaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKTtcbiAgICAgICAgZm9yIChjb25zdCB1ZiBvZiB1ZnMpIHtcbiAgICAgICAgICAgIGJpbi5vblVua25vd25GaWVsZChtZXNzYWdlLCB1Zi5ubywgdWYud2lyZVR5cGUsIHVmLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIGV4dGVuc2lvbiBpcyBzZXQgb24gYSBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikge1xuICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgcmV0dXJuIChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT09IG1lc3NhZ2VUeXBlLnR5cGVOYW1lICYmXG4gICAgICAgICEhbWVzc2FnZVR5cGUucnVudGltZS5iaW5cbiAgICAgICAgICAgIC5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKVxuICAgICAgICAgICAgLmZpbmQoKHVmKSA9PiB1Zi5ubyA9PSBleHRlbnNpb24uZmllbGQubm8pKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSkge1xuICAgIGFzc2VydChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT0gbWVzc2FnZS5nZXRUeXBlKCkudHlwZU5hbWUsIGBleHRlbnNpb24gJHtleHRlbnNpb24udHlwZU5hbWV9IGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gbWVzc2FnZSAke2V4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZX1gKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBpc1NjYWxhclplcm9WYWx1ZSwgc2NhbGFyWmVyb1ZhbHVlIH0gZnJvbSBcIi4vc2NhbGFycy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpZWxkIGlzIHNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmllbGRTZXQoZmllbGQsIHRhcmdldCkge1xuICAgIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0uY2FzZSA9PT0gbG9jYWxOYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgaWYgKGZpZWxkLm9wdCB8fCBmaWVsZC5yZXEpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCBwcmVzZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW1wbGljaXQgcHJlc2VuY2VcbiAgICAgICAgICAgIGlmIChmaWVsZC5raW5kID09IFwiZW51bVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdICE9PSBmaWVsZC5ULnZhbHVlc1swXS5ubztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaXNTY2FsYXJaZXJvVmFsdWUoZmllbGQuVCwgdGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXRbbG9jYWxOYW1lXSkubGVuZ3RoID4gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgfVxufVxuLyoqXG4gKiBSZXNldHMgdGhlIGZpZWxkLCBzbyB0aGF0IGlzRmllbGRTZXQoKSB3aWxsIHJldHVybiBmYWxzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCkge1xuICAgIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICBjb25zdCBpbXBsaWNpdFByZXNlbmNlID0gIWZpZWxkLm9wdCAmJiAhZmllbGQucmVxO1xuICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IFtdO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaWVsZC5vbmVvZikge1xuICAgICAgICB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2UgPyBmaWVsZC5ULnZhbHVlc1swXS5ubyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGltcGxpY2l0UHJlc2VuY2VcbiAgICAgICAgICAgICAgICAgICAgPyBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVCwgZmllbGQuTClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi9tZXNzYWdlLmpzXCI7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhbnkgc3VidHlwZSBvZiBNZXNzYWdlIG9yIGlzIGEgc3BlY2lmaWNcbiAqIE1lc3NhZ2UgYnkgcGFzc2luZyB0aGUgdHlwZS5cbiAqXG4gKiBKdXN0IGxpa2UgYGluc3RhbmNlb2ZgLCBgaXNNZXNzYWdlYCBuYXJyb3dzIHRoZSB0eXBlLiBUaGUgYWR2YW50YWdlIG9mXG4gKiBgaXNNZXNzYWdlYCBpcyB0aGF0IGl0IGNvbXBhcmVzIGlkZW50aXR5IGJ5IHRoZSBtZXNzYWdlIHR5cGUgbmFtZSwgbm90IGJ5XG4gKiBjbGFzcyBpZGVudGl0eS4gVGhpcyBtYWtlcyBpdCByb2J1c3QgYWdhaW5zdCB0aGUgZHVhbCBwYWNrYWdlIGhhemFyZCBhbmRcbiAqIHNpbWlsYXIgc2l0dWF0aW9ucywgd2hlcmUgdGhlIHNhbWUgbWVzc2FnZSBpcyBkdXBsaWNhdGVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgX21vc3RseV8gZXF1aXZhbGVudCB0byB0aGUgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLiBGb3JcbiAqIGV4YW1wbGUsIGBpc01lc3NhZ2UoZm9vLCBNeU1lc3NhZ2UpYCBpcyB0aGUgc2FtZSBhcyBgZm9vIGluc3RhbmNlb2YgTXlNZXNzYWdlYCxcbiAqIGFuZCBgaXNNZXNzYWdlKGZvbylgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNZXNzYWdlYC4gSW4gbW9zdCBjYXNlcyxcbiAqIGBpc01lc3NhZ2VgIHNob3VsZCBiZSBwcmVmZXJyZWQgb3ZlciBgaW5zdGFuY2VvZmAuXG4gKlxuICogSG93ZXZlciwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgYGlzTWVzc2FnZWAgZG9lcyBub3QgdXNlIGNsYXNzIGlkZW50aXR5LCB0aGVyZVxuICogYXJlIHN1YnRsZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgZnVuY3Rpb24gYW5kIGBpbnN0YW5jZW9mYC4gTm90YWJseSxcbiAqIGNhbGxpbmcgYGlzTWVzc2FnZWAgb24gYW4gZXhwbGljaXQgdHlwZSBvZiBNZXNzYWdlIHdpbGwgcmV0dXJuIGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXNzYWdlKGFyZywgdHlwZSkge1xuICAgIGlmIChhcmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZyAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNZXNzYWdlLnByb3RvdHlwZSkuZXZlcnkoKG0pID0+IG0gaW4gYXJnICYmIHR5cGVvZiBhcmdbbV0gPT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbFR5cGUgPSBhcmcuZ2V0VHlwZSgpO1xuICAgIGlmIChhY3R1YWxUeXBlID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBhY3R1YWxUeXBlICE9IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAhKFwidHlwZU5hbWVcIiBpbiBhY3R1YWxUeXBlKSB8fFxuICAgICAgICB0eXBlb2YgYWN0dWFsVHlwZS50eXBlTmFtZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhY3R1YWxUeXBlLnR5cGVOYW1lID09IHR5cGUudHlwZU5hbWU7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL3NjYWxhci5qc1wiO1xuaW1wb3J0IHsgaXNNZXNzYWdlIH0gZnJvbSBcIi4uL2lzLW1lc3NhZ2UuanNcIjtcbi8qKlxuICogV3JhcCBhIHByaW1pdGl2ZSBtZXNzYWdlIGZpZWxkIHZhbHVlIGluIGl0cyBjb3JyZXNwb25kaW5nIHdyYXBwZXJcbiAqIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbXBvdGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmIChpc01lc3NhZ2UodmFsdWUpIHx8ICF0eXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLmZpZWxkV3JhcHBlci53cmFwRmllbGQodmFsdWUpO1xufVxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZmllbGQgdXNlcyBvbmUgb2YgdGhlIHdlbGwta25vd24gd3JhcHBlciB0eXBlcywgcmV0dXJuXG4gKiB0aGUgcHJpbWl0aXZlIHR5cGUgaXQgd3JhcHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbndyYXBwZWRGaWVsZFR5cGUoZmllbGQpIHtcbiAgICBpZiAoZmllbGQuZmllbGRLaW5kICE9PSBcIm1lc3NhZ2VcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGZpZWxkLm9uZW9mICE9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gd2t0V3JhcHBlclRvU2NhbGFyVHlwZVtmaWVsZC5tZXNzYWdlLnR5cGVOYW1lXTtcbn1cbmNvbnN0IHdrdFdyYXBwZXJUb1NjYWxhclR5cGUgPSB7XG4gICAgXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjogU2NhbGFyVHlwZS5ET1VCTEUsXG4gICAgXCJnb29nbGUucHJvdG9idWYuRmxvYXRWYWx1ZVwiOiBTY2FsYXJUeXBlLkZMT0FULFxuICAgIFwiZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWVcIjogU2NhbGFyVHlwZS5JTlQ2NCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQ2NCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCI6IFNjYWxhclR5cGUuSU5UMzIsXG4gICAgXCJnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWVcIjogU2NhbGFyVHlwZS5VSU5UMzIsXG4gICAgXCJnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlXCI6IFNjYWxhclR5cGUuQk9PTCxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZVwiOiBTY2FsYXJUeXBlLlNUUklORyxcbiAgICBcImdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlXCI6IFNjYWxhclR5cGUuQllURVMsXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZS5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0LCBhc3NlcnRGbG9hdDMyLCBhc3NlcnRJbnQzMiwgYXNzZXJ0VUludDMyIH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0ludDY0IH0gZnJvbSBcIi4uL3Byb3RvLWludDY0LmpzXCI7XG5pbXBvcnQgeyBwcm90b0Jhc2U2NCB9IGZyb20gXCIuLi9wcm90by1iYXNlNjQuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lciB9IGZyb20gXCIuL2V4dGVuc2lvbnMuanNcIjtcbmltcG9ydCB7IGdldEV4dGVuc2lvbiwgaGFzRXh0ZW5zaW9uLCBzZXRFeHRlbnNpb24sIH0gZnJvbSBcIi4uL2V4dGVuc2lvbi1hY2Nlc3Nvci5qc1wiO1xuaW1wb3J0IHsgY2xlYXJGaWVsZCwgaXNGaWVsZFNldCB9IGZyb20gXCIuL3JlZmxlY3QuanNcIjtcbmltcG9ydCB7IHdyYXBGaWVsZCB9IGZyb20gXCIuL2ZpZWxkLXdyYXBwZXIuanNcIjtcbmltcG9ydCB7IHNjYWxhclplcm9WYWx1ZSB9IGZyb20gXCIuL3NjYWxhcnMuanNcIjtcbmltcG9ydCB7IGlzU2NhbGFyWmVyb1ZhbHVlIH0gZnJvbSBcIi4vc2NhbGFycy5qc1wiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vc2NhbGFyLmpzXCI7XG5pbXBvcnQgeyBpc01lc3NhZ2UgfSBmcm9tIFwiLi4vaXMtbWVzc2FnZS5qc1wiO1xuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCAqL1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBwYXJzaW5nIEpTT04uXG5jb25zdCBqc29uUmVhZERlZmF1bHRzID0ge1xuICAgIGlnbm9yZVVua25vd25GaWVsZHM6IGZhbHNlLFxufTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3Igc2VyaWFsaXppbmcgdG8gSlNPTi5cbmNvbnN0IGpzb25Xcml0ZURlZmF1bHRzID0ge1xuICAgIGVtaXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgICBlbnVtQXNJbnRlZ2VyOiBmYWxzZSxcbiAgICB1c2VQcm90b0ZpZWxkTmFtZTogZmFsc2UsXG4gICAgcHJldHR5U3BhY2VzOiAwLFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGpzb25SZWFkRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25SZWFkRGVmYXVsdHM7XG59XG5mdW5jdGlvbiBtYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvbldyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IGpzb25Xcml0ZURlZmF1bHRzO1xufVxuY29uc3QgdG9rZW5OdWxsID0gU3ltYm9sKCk7XG5jb25zdCB0b2tlbklnbm9yZWRVbmtub3duRW51bSA9IFN5bWJvbCgpO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VKc29uRm9ybWF0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1ha2VSZWFkT3B0aW9ucyxcbiAgICAgICAgbWFrZVdyaXRlT3B0aW9ucyxcbiAgICAgICAgcmVhZE1lc3NhZ2UodHlwZSwganNvbiwgb3B0aW9ucywgbWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGpzb24gPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGpzb24pIHx8IHR5cGVvZiBqc29uICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjogJHtkZWJ1Z0pzb25WYWx1ZShqc29uKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgY29uc3Qgb25lb2ZTZWVuID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2pzb25LZXksIGpzb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmRKc29uTmFtZShqc29uS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBjb25mb3JtYW5jZSB0ZXN0IFJlcXVpcmVkLlByb3RvMy5Kc29uSW5wdXQuT25lb2ZGaWVsZE51bGx7Rmlyc3QsU2Vjb25kfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG9uZW9mU2Vlbi5nZXQoZmllbGQub25lb2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBtZXNzYWdlICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiBtdWx0aXBsZSBrZXlzIGZvciBvbmVvZiBcIiR7ZmllbGQub25lb2YubmFtZX1cIiBwcmVzZW50OiBcIiR7c2Vlbn1cIiwgXCIke2pzb25LZXl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mU2Vlbi5zZXQoZmllbGQub25lb2YsIGpzb25LZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlYWRGaWVsZChtZXNzYWdlLCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbktleS5zdGFydHNXaXRoKFwiW1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbktleS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IHJlZ2lzdHJ5LmZpbmRFeHRlbnNpb24oanNvbktleS5zdWJzdHJpbmcoMSwganNvbktleS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ICYmIGV4dC5leHRlbmRlZS50eXBlTmFtZSA9PSB0eXBlLnR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjb250YWluZXIsIGdldF0gPSBjcmVhdGVFeHRlbnNpb25Db250YWluZXIoZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkRmllbGQoY29udGFpbmVyLCBqc29uVmFsdWUsIGV4dC5maWVsZCwgb3B0aW9ucywgZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBwYXNzIG9uIHRoZSBvcHRpb25zIGFzIEJpbmFyeVJlYWRPcHRpb25zL0JpbmFyeVdyaXRlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHVzZXJzIGNhbiBicmluZyB0aGVpciBvd24gYmluYXJ5IHJlYWRlciBhbmQgd3JpdGVyIGZhY3Rvcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0LCBnZXQoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiAhb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgbWVzc2FnZSAke3R5cGUudHlwZU5hbWV9IGZyb20gSlNPTjoga2V5IFwiJHtqc29uS2V5fVwiIGlzIHVua25vd25gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHt9O1xuICAgICAgICAgICAgbGV0IGZpZWxkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZpZWxkU2V0KGZpZWxkLCBtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGByZXF1aXJlZCBmaWVsZCBub3Qgc2V0YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5vbmVvZlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uVmFsdWUgPSB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gb3B0aW9ucy50eXBlUmVnaXN0cnk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uRm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdWYgb2YgdHlwZS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0ID0gcmVnaXN0cnkuZmluZEV4dGVuc2lvbkZvcih0eXBlLnR5cGVOYW1lLCB1Zi5ubyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ICYmIGhhc0V4dGVuc2lvbihtZXNzYWdlLCBleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgcGFzcyBvbiB0aGUgb3B0aW9ucyBhcyBCaW5hcnlSZWFkT3B0aW9ucywgc28gdGhhdCB1c2VycyBjYW4gYnJpbmcgdGhlaXIgb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmluYXJ5IHJlYWRlciBmYWN0b3J5IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEV4dGVuc2lvbihtZXNzYWdlLCBleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHdyaXRlRmllbGQoZXh0LmZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25bZXh0LmZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICA/IGBjYW5ub3QgZW5jb2RlIGZpZWxkICR7dHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSB0byBKU09OYFxuICAgICAgICAgICAgICAgICAgICA6IGBjYW5ub3QgZW5jb2RlIG1lc3NhZ2UgJHt0eXBlLnR5cGVOYW1lfSB0byBKU09OYDtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtICsgKHIubGVuZ3RoID4gMCA/IGA6ICR7cn1gIDogXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLiBGb3IgYmFja3dhcmRzLVxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAgICAgICAvLyB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgSnNvbkZvcm1hdC5cbiAgICAgICAgICAgIHJldHVybiByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlICE9PSBudWxsICYmIGxvbmdUeXBlICE9PSB2b2lkIDAgPyBsb25nVHlwZSA6IExvbmdUeXBlLkJJR0lOVCwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlU2NhbGFyKHR5cGUsIHZhbHVlLCBlbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiBvdXIgaW50ZXJuYWwgZnVuY3Rpb24gaGFzIGNoYW5nZWQuIEZvciBiYWNrd2FyZHMtXG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2YgdGhlIHB1YmxpYyBBUElcbiAgICAgICAgICAgIC8vIHRocm91Z2ggdGhlIGludGVyZmFjZSBKc29uRm9ybWF0LlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVtaXREZWZhdWx0VmFsdWVzIHx8IGlzU2NhbGFyWmVyb1ZhbHVlKHR5cGUsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBkZWJ1ZzogZGVidWdKc29uVmFsdWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlYnVnSnNvblZhbHVlKGpzb24pIHtcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoanNvbikgPyBcImFycmF5XCIgOiBcIm9iamVjdFwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4ganNvbi5sZW5ndGggPiAxMDAgPyBcInN0cmluZ1wiIDogYFwiJHtqc29uLnNwbGl0KCdcIicpLmpvaW4oJ1xcXFxcIicpfVwiYDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoanNvbik7XG4gICAgfVxufVxuLy8gUmVhZCBhIEpTT04gdmFsdWUgZm9yIGEgZmllbGQuXG4vLyBUaGUgXCJwYXJlbnRUeXBlXCIgYXJndW1lbnQgaXMgb25seSB1c2VkIHRvIHByb3ZpZGUgY29udGV4dCBpbiBlcnJvcnMuXG5mdW5jdGlvbiByZWFkRmllbGQodGFyZ2V0LCBqc29uVmFsdWUsIGZpZWxkLCBvcHRpb25zLCBwYXJlbnRUeXBlKSB7XG4gICAgbGV0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmtpbmQgIT0gXCJtYXBcIik7XG4gICAgICAgIGlmIChqc29uVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvblZhbHVlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRBcnJheSA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICBmb3IgKGNvbnN0IGpzb25JdGVtIG9mIGpzb25WYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGpzb25JdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChmaWVsZC5ULmZyb21Kc29uKGpzb25JdGVtLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25JdGVtLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW51bVZhbHVlICE9PSB0b2tlbklnbm9yZWRVbmtub3duRW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkucHVzaChlbnVtVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2gocmVhZFNjYWxhcihmaWVsZC5ULCBqc29uSXRlbSwgZmllbGQuTCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IGBjYW5ub3QgZGVjb2RlIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvbkl0ZW0pfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpZWxkLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBqc29uVmFsdWUgIT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGpzb25WYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0TWFwID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgIGZvciAoY29uc3QgW2pzb25NYXBLZXksIGpzb25NYXBWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoanNvblZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGpzb25NYXBWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiBtYXAgdmFsdWUgbnVsbGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcmVhZE1hcEtleShmaWVsZC5LLCBqc29uTWFwS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtYXAga2V5IGZvciBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IGZpZWxkLlYuVC5mcm9tSnNvbihqc29uTWFwVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgb3B0aW9ucy5pZ25vcmVVbmtub3duRmllbGRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdG9rZW5JZ25vcmVkVW5rbm93bkVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gZW51bVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gcmVhZFNjYWxhcihmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgTG9uZ1R5cGUuQklHSU5ULCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBtYXAgdmFsdWUgZm9yIGZpZWxkICR7cGFyZW50VHlwZS50eXBlTmFtZX0uJHtmaWVsZC5uYW1lfSBmcm9tIEpTT046ICR7ZGVidWdKc29uVmFsdWUoanNvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gKz0gYDogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbZmllbGQub25lb2YubG9jYWxOYW1lXSA9IHsgY2FzZTogbG9jYWxOYW1lIH07XG4gICAgICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlLnR5cGVOYW1lICE9IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGlzTWVzc2FnZShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBjdXJyZW50VmFsdWUgPSBtZXNzYWdlVHlwZS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlci51bndyYXBGaWVsZChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSByZWFkRW51bShmaWVsZC5ULCBqc29uVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZW51bVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJGaWVsZChmaWVsZCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRva2VuSWdub3JlZFVua25vd25FbnVtOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGVudW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJWYWx1ZSA9IHJlYWRTY2FsYXIoZmllbGQuVCwganNvblZhbHVlLCBmaWVsZC5MLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NhbGFyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdG9rZW5OdWxsOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gc2NhbGFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBgY2Fubm90IGRlY29kZSBmaWVsZCAke3BhcmVudFR5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbSArPSBgOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZWFkTWFwS2V5KHR5cGUsIGpzb24pIHtcbiAgICBpZiAodHlwZSA9PT0gU2NhbGFyVHlwZS5CT09MKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gICAgICAgIHN3aXRjaCAoanNvbikge1xuICAgICAgICAgICAgY2FzZSBcInRydWVcIjpcbiAgICAgICAgICAgICAgICBqc29uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgICAgICAgICAgIGpzb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVhZFNjYWxhcih0eXBlLCBqc29uLCBMb25nVHlwZS5CSUdJTlQsIHRydWUpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiByZWFkU2NhbGFyKHR5cGUsIGpzb24sIGxvbmdUeXBlLCBudWxsQXNaZXJvVmFsdWUpIHtcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobnVsbEFzWmVyb1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyWmVyb1ZhbHVlKHR5cGUsIGxvbmdUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5OdWxsO1xuICAgIH1cbiAgICAvLyBldmVyeSB2YWxpZCBjYXNlIGluIHRoZSBzd2l0Y2ggYmVsb3cgcmV0dXJucywgYW5kIGV2ZXJ5IGZhbGxcbiAgICAvLyB0aHJvdWdoIGlzIHJlZ2FyZGVkIGFzIGEgZmFpbHVyZS5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJOYU5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIkluZmluaXR5XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIi1JbmZpbml0eVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICBpZiAoanNvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBub3QgYSBudW1iZXJcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24udHJpbSgpLmxlbmd0aCAhPT0ganNvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YganNvbiAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmbG9hdCA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZmxvYXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmbG9hdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmZpbml0eSBhbmQgLWluZmluaXR5IGFyZSBoYW5kbGVkIGJ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBhYm92ZSwgc28gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVClcbiAgICAgICAgICAgICAgICBhc3NlcnRGbG9hdDMyKGZsb2F0KTtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdDtcbiAgICAgICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICAgICAgICBsZXQgaW50MzI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBpbnQzMiA9IGpzb247XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnRyaW0oKS5sZW5ndGggPT09IGpzb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBpbnQzMiA9IE51bWJlcihqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnQzMiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5VSU5UMzIgfHwgdHlwZSA9PSBTY2FsYXJUeXBlLkZJWEVEMzIpXG4gICAgICAgICAgICAgICAgYXNzZXJ0VUludDMyKGludDMyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhc3NlcnRJbnQzMihpbnQzMik7XG4gICAgICAgICAgICByZXR1cm4gaW50MzI7XG4gICAgICAgIC8vIGludDY0LCBmaXhlZDY0LCB1aW50NjQ6IEpTT04gdmFsdWUgd2lsbCBiZSBhIGRlY2ltYWwgc3RyaW5nLiBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIiAmJiB0eXBlb2YganNvbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgbG9uZyA9IHByb3RvSW50NjQucGFyc2UoanNvbik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICByZXR1cm4gbG9uZ1R5cGUgPyBsb25nLnRvU3RyaW5nKCkgOiBsb25nO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCB1TG9uZyA9IHByb3RvSW50NjQudVBhcnNlKGpzb24pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdUeXBlID8gdUxvbmcudG9TdHJpbmcoKSA6IHVMb25nO1xuICAgICAgICAvLyBib29sOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgLy8gc3RyaW5nOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBIHN0cmluZyBtdXN0IGFsd2F5cyBjb250YWluIFVURi04IGVuY29kZWQgb3IgNy1iaXQgQVNDSUkuXG4gICAgICAgICAgICAvLyBXZSB2YWxpZGF0ZSB3aXRoIGVuY29kZVVSSUNvbXBvbmVudCwgd2hpY2ggYXBwZWFycyB0byBiZSB0aGUgZmFzdGVzdCB3aWRlbHkgYXZhaWxhYmxlIG9wdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFVURjhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgLy8gYnl0ZXM6IEpTT04gdmFsdWUgd2lsbCBiZSB0aGUgZGF0YSBlbmNvZGVkIGFzIGEgc3RyaW5nIHVzaW5nIHN0YW5kYXJkIGJhc2U2NCBlbmNvZGluZyB3aXRoIHBhZGRpbmdzLlxuICAgICAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgICAgICAgIGlmIChqc29uID09PSBcIlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5kZWMoanNvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gcmVhZEVudW0odHlwZSwganNvbiwgaWdub3JlVW5rbm93bkZpZWxkcywgbnVsbEFzWmVyb1ZhbHVlKSB7XG4gICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlLk5VTExfVkFMVUUgPSAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxBc1plcm9WYWx1ZSA/IHR5cGUudmFsdWVzWzBdLm5vIDogdG9rZW5OdWxsO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICAgIHN3aXRjaCAodHlwZW9mIGpzb24pIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoanNvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGUuZmluZE5hbWUoanNvbik7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5ubztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZ25vcmVVbmtub3duRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuSWdub3JlZFVua25vd25FbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGRlY29kZSBlbnVtICR7dHlwZS50eXBlTmFtZX0gZnJvbSBKU09OOiAke2RlYnVnSnNvblZhbHVlKGpzb24pfWApO1xufVxuLy8gRGVjaWRlIHdoZXRoZXIgYW4gdW5zZXQgZmllbGQgc2hvdWxkIGJlIGVtaXR0ZWQgd2l0aCBKU09OIHdyaXRlIG9wdGlvbiBgZW1pdERlZmF1bHRWYWx1ZXNgXG5mdW5jdGlvbiBjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUoZmllbGQpIHtcbiAgICBpZiAoZmllbGQucmVwZWF0ZWQgfHwgZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgIC8vIG1hcHMgYXJlIHt9LCByZXBlYXRlZCBmaWVsZHMgYXJlIFtdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgICAgLy8gb25lb2YgZmllbGRzIGFyZSBuZXZlciBlbWl0dGVkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgLy8gc2luZ3VsYXIgbWVzc2FnZSBmaWVsZCBhcmUgYWxsb3dlZCB0byBlbWl0IEpTT04gbnVsbCwgYnV0IHdlIGRvIG5vdFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICBpZiAoZmllbGQub3B0IHx8IGZpZWxkLnJlcSkge1xuICAgICAgICAvLyB0aGUgZmllbGQgdXNlcyBleHBsaWNpdCBwcmVzZW5jZSwgc28gd2UgY2Fubm90IGVtaXQgYSB6ZXJvIHZhbHVlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9IG51bGwpO1xuICAgICAgICBjb25zdCBqc29uT2JqID0ge307XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlU2NhbGFyKGZpZWxkLlYuVCwgZW50cnlWYWx1ZSk7IC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VudHJ5S2V5LCBlbnRyeVZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICAgICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IGVudHJ5VmFsdWUudG9Kc29uKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgZW51bVR5cGUgPSBmaWVsZC5WLlQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSlNPTiBzdGFuZGFyZCBhbGxvd3Mgb25seSAoZG91YmxlIHF1b3RlZCkgc3RyaW5nIGFzIHByb3BlcnR5IGtleVxuICAgICAgICAgICAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gd3JpdGVFbnVtKGVudW1UeXBlLCBlbnRyeVZhbHVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5lbWl0RGVmYXVsdFZhbHVlcyB8fCBlbnRyaWVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8ganNvbk9ialxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICBjb25zdCBqc29uQXJyID0gW107XG4gICAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZUVudW0oZmllbGQuVCwgdmFsdWVbaV0sIG9wdGlvbnMuZW51bUFzSW50ZWdlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBqc29uQXJyLnB1c2godmFsdWVbaV0udG9Kc29uKG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwganNvbkFyci5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IGpzb25BcnJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyKGZpZWxkLlQsIHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUVudW0oZmllbGQuVCwgdmFsdWUsIG9wdGlvbnMuZW51bUFzSW50ZWdlcik7XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICByZXR1cm4gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKS50b0pzb24ob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVFbnVtKHR5cGUsIHZhbHVlLCBlbnVtQXNJbnRlZ2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgaWYgKHR5cGUudHlwZU5hbWUgPT0gXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChlbnVtQXNJbnRlZ2VyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gdHlwZS5maW5kTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gKF9hID0gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlOyAvLyBpZiB3ZSBkb24ndCBrbm93IHRoZSBlbnVtIHZhbHVlLCBqdXN0IHJldHVybiB0aGUgbnVtYmVyXG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgICAgICAvLyBFaXRoZXIgbnVtYmVycyBvciBzdHJpbmdzIGFyZSBhY2NlcHRlZC4gRXhwb25lbnQgbm90YXRpb24gaXMgYWxzbyBhY2NlcHRlZC5cbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5hTlwiO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAvLyBzdHJpbmc6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAvLyBib29sOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJib29sZWFuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAvLyBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAgICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBwcm90b0Jhc2U2NC5lbmModmFsdWUpO1xuICAgIH1cbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBCaW5hcnlSZWFkZXIsIEJpbmFyeVdyaXRlciwgV2lyZVR5cGUgfSBmcm9tIFwiLi4vYmluYXJ5LWVuY29kaW5nLmpzXCI7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IHdyYXBGaWVsZCB9IGZyb20gXCIuL2ZpZWxkLXdyYXBwZXIuanNcIjtcbmltcG9ydCB7IHNjYWxhclplcm9WYWx1ZSB9IGZyb20gXCIuL3NjYWxhcnMuanNcIjtcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gXCIuL2Fzc2VydC5qc1wiO1xuaW1wb3J0IHsgaXNGaWVsZFNldCB9IGZyb20gXCIuL3JlZmxlY3QuanNcIjtcbmltcG9ydCB7IExvbmdUeXBlLCBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL3NjYWxhci5qc1wiO1xuaW1wb3J0IHsgaXNNZXNzYWdlIH0gZnJvbSBcIi4uL2lzLW1lc3NhZ2UuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGwsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm4gKi9cbmNvbnN0IHVua25vd25GaWVsZHNTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvdW5rbm93bi1maWVsZHNcIik7XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgYmluYXJ5IGRhdGEuXG5jb25zdCByZWFkRGVmYXVsdHMgPSB7XG4gICAgcmVhZFVua25vd25GaWVsZHM6IHRydWUsXG4gICAgcmVhZGVyRmFjdG9yeTogKGJ5dGVzKSA9PiBuZXcgQmluYXJ5UmVhZGVyKGJ5dGVzKSxcbn07XG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nIGJpbmFyeSBkYXRhLlxuY29uc3Qgd3JpdGVEZWZhdWx0cyA9IHtcbiAgICB3cml0ZVVua25vd25GaWVsZHM6IHRydWUsXG4gICAgd3JpdGVyRmFjdG9yeTogKCkgPT4gbmV3IEJpbmFyeVdyaXRlcigpLFxufTtcbmZ1bmN0aW9uIG1ha2VSZWFkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDogcmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyaXRlRGVmYXVsdHMpLCBvcHRpb25zKSA6IHdyaXRlRGVmYXVsdHM7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYWtlUmVhZE9wdGlvbnMsXG4gICAgICAgIG1ha2VXcml0ZU9wdGlvbnMsXG4gICAgICAgIGxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBtZXNzYWdlW3Vua25vd25GaWVsZHNTeW1ib2xdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY2FyZFVua25vd25GaWVsZHMobWVzc2FnZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1lc3NhZ2VbdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBjKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblVua25vd25GaWVsZChtZXNzYWdlLCBubywgd2lyZVR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1bdW5rbm93bkZpZWxkc1N5bWJvbF0pKSB7XG4gICAgICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHsgbm8sIHdpcmVUeXBlLCBkYXRhIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGxlbmd0aE9yRW5kVGFnRmllbGRObywgb3B0aW9ucywgZGVsaW1pdGVkTWVzc2FnZUVuY29kaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmdcbiAgICAgICAgICAgICAgICA/IHJlYWRlci5sZW5cbiAgICAgICAgICAgICAgICA6IHJlYWRlci5wb3MgKyBsZW5ndGhPckVuZFRhZ0ZpZWxkTm87XG4gICAgICAgICAgICBsZXQgZmllbGRObywgd2lyZVR5cGU7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIFtmaWVsZE5vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0eXBlLmZpZWxkcy5maW5kKGZpZWxkTm8pO1xuICAgICAgICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWRlci5za2lwKHdpcmVUeXBlLCBmaWVsZE5vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVhZFVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Vbmtub3duRmllbGQobWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkRmllbGQobWVzc2FnZSwgcmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICh3aXJlVHlwZSAhPSBXaXJlVHlwZS5FbmRHcm91cCB8fCBmaWVsZE5vICE9PSBsZW5ndGhPckVuZFRhZ0ZpZWxkTm8pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGVuZCBncm91cCB0YWdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZEZpZWxkLFxuICAgICAgICB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmllbGRTZXQoZmllbGQsIG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGVuY29kZSBmaWVsZCAke3R5cGUudHlwZU5hbWV9LiR7ZmllbGQubmFtZX0gdG8gYmluYXJ5OiByZXF1aXJlZCBmaWVsZCBub3Qgc2V0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQub25lb2ZcbiAgICAgICAgICAgICAgICAgICAgPyBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53cml0ZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gVGhlIGJlaGF2aW9yIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZCwgaXQgZG9lcyBubyBsb25nZXJcbiAgICAgICAgICAgIC8vIGFjY2VwdCBgdW5kZWZpbmVkYCB2YWx1ZXMgZm9yIHNpbmd1bGFyIHNjYWxhciBhbmQgbWFwLlxuICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBwdWJsaWMgQVBJIHRocm91Z2ggdGhlIGludGVyZmFjZSBCaW5hcnlGb3JtYXQuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZEZpZWxkKHRhcmdldCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55IC0tIGBhbnlgIGlzIHRoZSBiZXN0IGNob2ljZSBmb3IgZHluYW1pYyBhY2Nlc3NcbnJlYWRlciwgZmllbGQsIHdpcmVUeXBlLCBvcHRpb25zKSB7XG4gICAgbGV0IHsgcmVwZWF0ZWQsIGxvY2FsTmFtZSB9ID0gZmllbGQ7XG4gICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgICAgICBpZiAodGFyZ2V0LmNhc2UgIT0gbG9jYWxOYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xuICAgICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgfVxuICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICBjb25zdCBzY2FsYXJUeXBlID0gZmllbGQua2luZCA9PSBcImVudW1cIiA/IFNjYWxhclR5cGUuSU5UMzIgOiBmaWVsZC5UO1xuICAgICAgICAgICAgbGV0IHJlYWQgPSByZWFkU2NhbGFyO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uIC0tIGFjY2VwdGFibGUgc2luY2UgaXQncyBjb3ZlcmVkIGJ5IHRlc3RzXG4gICAgICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmIGZpZWxkLkwgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVhZCA9IHJlYWRTY2FsYXJMVFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGxldCBhcnIgPSB0YXJnZXRbbG9jYWxOYW1lXTsgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUGFja2VkID0gd2lyZVR5cGUgPT0gV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNjYWxhclR5cGUgIT0gU2NhbGFyVHlwZS5TVFJJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLkJZVEVTO1xuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2gocmVhZChyZWFkZXIsIHNjYWxhclR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2FmZSB0byBhc3N1bWUgcHJlc2VuY2Ugb2YgYXJyYXksIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLnB1c2gocmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zLCBmaWVsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWVzc2FnZSh0YXJnZXRbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIHRhcmdldFtsb2NhbE5hbWVdLCBvcHRpb25zLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyICYmICFmaWVsZC5vbmVvZiAmJiAhZmllbGQucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICBsZXQgW21hcEtleSwgbWFwVmFsXSA9IHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIG1hcCBvYmplY3QsIG9uZW9mIGNhbm5vdCBjb250YWluIHJlcGVhdGVkIHZhbHVlc1xuICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV1bbWFwS2V5XSA9IG1hcFZhbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbi8vIFJlYWQgYSBtZXNzYWdlLCBhdm9pZGluZyBNZXNzYWdlVHlwZS5mcm9tQmluYXJ5KCkgdG8gcmUtdXNlIHRoZVxuLy8gQmluYXJ5UmVhZE9wdGlvbnMgYW5kIHRoZSBJQmluYXJ5UmVhZGVyLlxuZnVuY3Rpb24gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMsIGZpZWxkKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW47XG4gICAgY29uc3QgZGVsaW1pdGVkID0gZmllbGQgPT09IG51bGwgfHwgZmllbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpZWxkLmRlbGltaXRlZDtcbiAgICBmb3JtYXQucmVhZE1lc3NhZ2UobWVzc2FnZSwgcmVhZGVyLCBkZWxpbWl0ZWQgPyBmaWVsZC5ubyA6IHJlYWRlci51aW50MzIoKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICBvcHRpb25zLCBkZWxpbWl0ZWQpO1xuICAgIHJldHVybiBtZXNzYWdlO1xufVxuLy8gUmVhZCBhIG1hcCBmaWVsZCwgZXhwZWN0aW5nIGtleSBmaWVsZCA9IDEsIHZhbHVlIGZpZWxkID0gMlxuZnVuY3Rpb24gcmVhZE1hcEVudHJ5KGZpZWxkLCByZWFkZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZW5ndGggPSByZWFkZXIudWludDMyKCksIGVuZCA9IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgbGV0IGtleSwgdmFsO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IFtmaWVsZE5vXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZE5vKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAga2V5ID0gcmVhZFNjYWxhcihyZWFkZXIsIGZpZWxkLkspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBmaWVsZC5WLlQoKSwgb3B0aW9ucywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5ID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLkssIExvbmdUeXBlLkJJR0lOVCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVi5ULCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBmaWVsZC5WLlQudmFsdWVzWzBdLm5vO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXcgZmllbGQuVi5UKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtrZXksIHZhbF07XG59XG4vLyBSZWFkIGEgc2NhbGFyIHZhbHVlLCBidXQgcmV0dXJuIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcbiAgICBjb25zdCB2ID0gcmVhZFNjYWxhcihyZWFkZXIsIHR5cGUpO1xuICAgIHJldHVybiB0eXBlb2YgdiA9PSBcImJpZ2ludFwiID8gdi50b1N0cmluZygpIDogdjtcbn1cbi8vIERvZXMgbm90IHVzZSBzY2FsYXJUeXBlSW5mbygpIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5mdW5jdGlvbiByZWFkU2NhbGFyKHJlYWRlciwgdHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkJPT0w6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5pbnQzMigpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmludDY0KCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuZml4ZWQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5maXhlZDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIuc2ZpeGVkMzIoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQ2NCgpO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5zaW50NjQoKTtcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQzMjpcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIudWludDMyKCk7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnNpbnQzMigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZDtcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgbGV0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICAgICAgICBpZiAocmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5wYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVQYWNrZWQod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgc2NhbGFyVHlwZSwgZmllbGQubm8sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPSBudWxsKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZU1hcEVudHJ5KHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGtleSwgdmFsdWUpIHtcbiAgICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xuICAgIHdyaXRlci5mb3JrKCk7XG4gICAgLy8gamF2YXNjcmlwdCBvbmx5IGFsbG93cyBudW1iZXIgb3Igc3RyaW5nIGZvciBvYmplY3QgcHJvcGVydGllc1xuICAgIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgICBsZXQga2V5VmFsdWUgPSBrZXk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gd2UgZGVsaWJlcmF0ZWx5IGhhbmRsZSBqdXN0IHRoZSBzcGVjaWFsIGNhc2VzIGZvciBtYXAga2V5c1xuICAgIHN3aXRjaCAoZmllbGQuSykge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICAgICAgICBrZXlWYWx1ZSA9IE51bWJlci5wYXJzZUludChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgICAgICAgYXNzZXJ0KGtleSA9PSBcInRydWVcIiB8fCBrZXkgPT0gXCJmYWxzZVwiKTtcbiAgICAgICAgICAgIGtleVZhbHVlID0ga2V5ID09IFwidHJ1ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHdyaXRlIGtleSwgZXhwZWN0aW5nIGtleSBmaWVsZCBudW1iZXIgPSAxXG4gICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSk7XG4gICAgLy8gd3JpdGUgdmFsdWUsIGV4cGVjdGluZyB2YWx1ZSBmaWVsZCBudW1iZXIgPSAyXG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5WLlQsIDIsIHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHdyaXRlci50YWcoMiwgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5ieXRlcyh2YWx1ZS50b0JpbmFyeShvcHRpb25zKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgd3JpdGVyLmpvaW4oKTtcbn1cbi8vIFZhbHVlIG11c3Qgbm90IGJlIHVuZGVmaW5lZFxuZnVuY3Rpb24gd3JpdGVNZXNzYWdlRmllbGQod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgaWYgKGZpZWxkLmRlbGltaXRlZClcbiAgICAgICAgd3JpdGVyXG4gICAgICAgICAgICAudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5TdGFydEdyb3VwKVxuICAgICAgICAgICAgLnJhdyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKVxuICAgICAgICAgICAgLnRhZyhmaWVsZC5ubywgV2lyZVR5cGUuRW5kR3JvdXApO1xuICAgIGVsc2VcbiAgICAgICAgd3JpdGVyXG4gICAgICAgICAgICAudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpXG4gICAgICAgICAgICAuYnl0ZXMobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSk7XG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgIGxldCBbd2lyZVR5cGUsIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgICB3cml0ZXIudGFnKGZpZWxkTm8sIHdpcmVUeXBlKVttZXRob2RdKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdyaXRlci50YWcoZmllbGRObywgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkKS5mb3JrKCk7XG4gICAgbGV0IFssIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcbiAgICB9XG4gICAgd3JpdGVyLmpvaW4oKTtcbn1cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGZvciB3cml0aW5nIGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIFJldHVybnMgdHVwbGU6XG4gKiBbMF06IGFwcHJvcHJpYXRlIFdpcmVUeXBlXG4gKiBbMV06IG5hbWUgb2YgdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBvZiBJQmluYXJ5V3JpdGVyXG4gKiBbMl06IHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvdG8zIHNlbWFudGljc1xuICpcbiAqIElmIGFyZ3VtZW50IGB2YWx1ZWAgaXMgb21pdHRlZCwgWzJdIGlzIGFsd2F5cyBmYWxzZS5cbiAqL1xuLy8gVE9ETyByZXBsYWNlIGNhbGwtc2l0ZXMgd3JpdGVTY2FsYXIoKSBhbmQgd3JpdGVQYWNrZWQoKSwgdGhlbiByZW1vdmVcbmZ1bmN0aW9uIHNjYWxhclR5cGVJbmZvKHR5cGUpIHtcbiAgICBsZXQgd2lyZVR5cGUgPSBXaXJlVHlwZS5WYXJpbnQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gSU5UMzIsIFVJTlQzMiwgU0lOVDMyIGFyZSBjb3ZlcmVkIGJ5IHRoZSBkZWZhdWx0c1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQ2NDpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICAgICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDMyOlxuICAgICAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICAgICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IFNjYWxhclR5cGVbdHlwZV0udG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gW3dpcmVUeXBlLCBtZXRob2RdO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmltcG9ydCB7IHNldEVudW1UeXBlIH0gZnJvbSBcIi4vZW51bS5qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlLmpzXCI7XG5pbXBvcnQgeyBzY2FsYXJFcXVhbHMgfSBmcm9tIFwiLi9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBTY2FsYXJUeXBlIH0gZnJvbSBcIi4uL3NjYWxhci5qc1wiO1xuaW1wb3J0IHsgaXNNZXNzYWdlIH0gZnJvbSBcIi4uL2lzLW1lc3NhZ2UuanNcIjtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybixAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVV0aWxDb21tb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0RW51bVR5cGUsXG4gICAgICAgIGluaXRQYXJ0aWFsKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LmdldFR5cGUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSBtZW1iZXIubG9jYWxOYW1lLCB0ID0gdGFyZ2V0LCBzID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGlmIChzW2xvY2FsTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGlmIHNvdXJjZSBpcyBhIE1lc3NhZ2UgaW5zdGFuY2UsIHdlIHNob3VsZCB1c2UgaXNGaWVsZFNldCgpIGhlcmUgdG8gc3VwcG9ydCBmdXR1cmUgZmllbGQgcHJlc2VuY2VcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzayA9IHNbbG9jYWxOYW1lXS5jYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUZpZWxkID0gbWVtYmVyLmZpbmRGaWVsZChzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gc1tsb2NhbE5hbWVdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUZpZWxkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlRmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc01lc3NhZ2UodmFsLCBzb3VyY2VGaWVsZC5UKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG5ldyBzb3VyY2VGaWVsZC5UKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VGaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpZWxkLmtpbmQgPT09IFwic2NhbGFyXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWVsZC5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0geyBjYXNlOiBzaywgdmFsdWU6IHZhbCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gc1tsb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlci5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IG1lbWJlci5yZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNvcHkubWFwKHRvVThBcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdG9VOEFycihjb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZW1iZXIuVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuVi5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdW2tdID0gdG9VOEFycih2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odFtsb2NhbE5hbWVdLCBzW2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVtYmVyLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV1ba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdGFrZSBwYXJ0aWFsIGlucHV0IGZvciBtZXNzYWdlcyB0aGF0IGFyZSBub3QgYSB3cmFwcGVyIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRob3NlIG1lc3NhZ2VzLCB3ZSByZWN1cnNpdmVseSBub3JtYWxpemUgdGhlIHBhcnRpYWwgaW5wdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IG1lc3NhZ2VUeXBlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG10ID0gbWVtYmVyLlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gc1tsb2NhbE5hbWVdLm1hcCgodmFsKSA9PiBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG10LmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IHVzZSBCeXRlc1ZhbHVlLnR5cGVOYW1lIGFzIHRoYXQgd2lsbCBjcmVhdGUgYSBjaXJjdWxhciBpbXBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQudHlwZU5hbWUgPT09IFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSBpc01lc3NhZ2UodmFsLCBtdCkgPyB2YWwgOiBuZXcgbXQodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgICAgIGVxdWFscyh0eXBlLCBhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8ICFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkuZXZlcnkoKG0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YSA9IGFbbS5sb2NhbE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZiID0gYlttLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhLmxlbmd0aCAhPT0gdmIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2sgLS0gcmVwZWF0ZWQgZmllbGRzIGFyZSBuZXZlciBcIm1hcFwiXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobS5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gbS5ULmVxdWFscyhhLCB2YltpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YS5ldmVyeSgoYSwgaSkgPT4gc2NhbGFyRXF1YWxzKG0uVCwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgYSwgdmJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcGVhdGVkIGNhbm5vdCBjb250YWluICR7bS5raW5kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG0ua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0uVC5lcXVhbHModmEsIHZiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEsIHZiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxhckVxdWFscyhtLlQsIHZhLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhLmNhc2UgIT09IHZiLmNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gbS5maW5kRmllbGQodmEuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocy5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMuVC5lcXVhbHModmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKHMuVCwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25lb2YgY2Fubm90IGNvbnRhaW4gJHtzLmtpbmR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YSkuY29uY2F0KE9iamVjdC5rZXlzKHZiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG0uVi5raW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBtLlYuVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoKGspID0+IG1lc3NhZ2VUeXBlLmVxdWFscyh2YVtrXSwgdmJba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyVHlwZSA9IG0uVi5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5ldmVyeSgoaykgPT4gc2NhbGFyRXF1YWxzKHNjYWxhclR5cGUsIHZhW2tdLCB2YltrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE8gdXNlIGlzRmllbGRTZXQoKSBoZXJlIHRvIHN1cHBvcnQgZnV0dXJlIGZpZWxkIHByZXNlbmNlXG4gICAgICAgIGNsb25lKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKSwgdGFyZ2V0ID0gbmV3IHR5cGUoKSwgYW55ID0gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IG1lc3NhZ2VbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgICAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc291cmNlLm1hcChjbG9uZVNpbmd1bGFyRmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZW1iZXIua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBhbnlbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdl0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVTaW5ndWxhckZpZWxkKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gbWVtYmVyLmZpbmRGaWVsZChzb3VyY2UuY2FzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBmXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgY2FzZTogc291cmNlLmNhc2UsIHZhbHVlOiBjbG9uZVNpbmd1bGFyRmllbGQoc291cmNlLnZhbHVlKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gY2xvbmVTaW5ndWxhckZpZWxkKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVttZW1iZXIubG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVmIG9mIHR5cGUucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlLnJ1bnRpbWUuYmluLm9uVW5rbm93bkZpZWxkKGFueSwgdWYubm8sIHVmLndpcmVUeXBlLCB1Zi5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIGNsb25lIGEgc2luZ2xlIGZpZWxkIHZhbHVlIC0gaS5lLiB0aGUgZWxlbWVudCB0eXBlIG9mIHJlcGVhdGVkIGZpZWxkcywgdGhlIHZhbHVlIHR5cGUgb2YgbWFwc1xuZnVuY3Rpb24gY2xvbmVTaW5ndWxhckZpZWxkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNNZXNzYWdlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuY2xvbmUoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGMuc2V0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIGNvbnZlcnRzIGFueSBBcnJheUxpa2U8bnVtYmVyPiB0byBVaW50OEFycmF5IGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIHRvVThBcnIoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gaW5wdXQgOiBuZXcgVWludDhBcnJheShpbnB1dCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgZ2V0RW51bVR5cGUsIG1ha2VFbnVtLCBtYWtlRW51bVR5cGUgfSBmcm9tIFwiLi9lbnVtLmpzXCI7XG5pbXBvcnQgeyBtYWtlTWVzc2FnZVR5cGUgfSBmcm9tIFwiLi9tZXNzYWdlLXR5cGUuanNcIjtcbmltcG9ydCB7IG1ha2VFeHRlbnNpb24gfSBmcm9tIFwiLi9leHRlbnNpb25zLmpzXCI7XG5pbXBvcnQgeyBtYWtlSnNvbkZvcm1hdCB9IGZyb20gXCIuL2pzb24tZm9ybWF0LmpzXCI7XG5pbXBvcnQgeyBtYWtlQmluYXJ5Rm9ybWF0IH0gZnJvbSBcIi4vYmluYXJ5LWZvcm1hdC5qc1wiO1xuaW1wb3J0IHsgbWFrZVV0aWxDb21tb24gfSBmcm9tIFwiLi91dGlsLWNvbW1vbi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQcm90b1J1bnRpbWUoc3ludGF4LCBuZXdGaWVsZExpc3QsIGluaXRGaWVsZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzeW50YXgsXG4gICAgICAgIGpzb246IG1ha2VKc29uRm9ybWF0KCksXG4gICAgICAgIGJpbjogbWFrZUJpbmFyeUZvcm1hdCgpLFxuICAgICAgICB1dGlsOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1ha2VVdGlsQ29tbW9uKCkpLCB7IG5ld0ZpZWxkTGlzdCxcbiAgICAgICAgICAgIGluaXRGaWVsZHMgfSksXG4gICAgICAgIG1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlTWVzc2FnZVR5cGUodGhpcywgdHlwZU5hbWUsIGZpZWxkcywgb3B0KTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZUVudW0sXG4gICAgICAgIG1ha2VFbnVtVHlwZSxcbiAgICAgICAgZ2V0RW51bVR5cGUsXG4gICAgICAgIG1ha2VFeHRlbnNpb24odHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VFeHRlbnNpb24odGhpcywgdHlwZU5hbWUsIGV4dGVuZGVlLCBmaWVsZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxGaWVsZExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLl9maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICAgIH1cbiAgICBmaW5kSnNvbk5hbWUoanNvbk5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpzb25OYW1lcykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgdFtmLmpzb25OYW1lXSA9IHRbZi5uYW1lXSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmpzb25OYW1lcyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgICB9XG4gICAgZmluZChmaWVsZE5vKSB7XG4gICAgICAgIGlmICghdGhpcy5udW1iZXJzKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgICAgICB0W2Yubm9dID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubnVtYmVycyA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgICB9XG4gICAgbGlzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbCkge1xuICAgICAgICAgICAgdGhpcy5hbGwgPSB0aGlzLl9ub3JtYWxpemVyKHRoaXMuX2ZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsO1xuICAgIH1cbiAgICBieU51bWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJzQXNjO1xuICAgIH1cbiAgICBieU1lbWJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMubWVtYmVycztcbiAgICAgICAgICAgIGxldCBvO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYub25lb2YgIT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBmLm9uZW9mO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lbWJlcnM7XG4gICAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIHByb3RvYnVmIGVsZW1lbnQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogRmllbGQgbmFtZXMgLSBpbmNsdWRpbmcgb25lb2ZzIC0gYXJlIGNvbnZlcnRlZCB0byBsb3dlckNhbWVsQ2FzZS4gRm9yXG4gKiBtZXNzYWdlcywgZW51bWVyYXRpb25zIGFuZCBzZXJ2aWNlcywgdGhlIHBhY2thZ2UgbmFtZSBpcyBzdHJpcHBlZCBmcm9tXG4gKiB0aGUgdHlwZSBuYW1lLiBGb3IgbmVzdGVkIG1lc3NhZ2VzIGFuZCBlbnVtZXJhdGlvbnMsIHRoZSBuYW1lcyBhcmUgam9pbmVkXG4gKiB3aXRoIGFuIHVuZGVyc2NvcmUuIEZvciBtZXRob2RzLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG1hZGUgbG93ZXJjYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxOYW1lKGRlc2MpIHtcbiAgICBzd2l0Y2ggKGRlc2Mua2luZCkge1xuICAgICAgICBjYXNlIFwiZmllbGRcIjpcbiAgICAgICAgICAgIHJldHVybiBsb2NhbEZpZWxkTmFtZShkZXNjLm5hbWUsIGRlc2Mub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsT25lb2ZOYW1lKGRlc2MubmFtZSk7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIGNhc2UgXCJzZXJ2aWNlXCI6XG4gICAgICAgIGNhc2UgXCJleHRlbnNpb25cIjoge1xuICAgICAgICAgICAgY29uc3QgcGtnID0gZGVzYy5maWxlLnByb3RvLnBhY2thZ2U7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwa2cgPT09IHVuZGVmaW5lZCA/IDAgOiBwa2cubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZXNjLnR5cGVOYW1lLnN1YnN0cmluZyhvZmZzZXQpLnJlcGxhY2UoL1xcLi9nLCBcIl9cIik7XG4gICAgICAgICAgICAvLyBGb3Igc2VydmljZXMsIHdlIG9ubHkgY2FyZSBhYm91dCBzYWZlIGlkZW50aWZpZXJzLCBub3Qgc2FmZSBvYmplY3QgcHJvcGVydGllcyxcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHNoaXBwZWQgdjEgd2l0aCBhIGJ1ZyB0aGF0IHJlc3BlY3RlZCBvYmplY3QgcHJvcGVydGllcywgYW5kIHdlXG4gICAgICAgICAgICAvLyBkbyBub3Qgd2FudCB0byBpbnRyb2R1Y2UgYSBicmVha2luZyBjaGFuZ2UsIHNvIHdlIGNvbnRpbnVlIHRvIGVzY2FwZSBmb3JcbiAgICAgICAgICAgIC8vIHNhZmUgb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2J1ZmJ1aWxkL3Byb3RvYnVmLWVzL3B1bGwvMzkxXG4gICAgICAgICAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVJZGVudGlmaWVyKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZW51bV92YWx1ZVwiOiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGRlc2MubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFByZWZpeCA9IGRlc2MucGFyZW50LnNoYXJlZFByZWZpeDtcbiAgICAgICAgICAgIGlmIChzaGFyZWRQcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhzaGFyZWRQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYWZlT2JqZWN0UHJvcGVydHkobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJwY1wiOiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGRlc2MubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXS50b0xvd2VyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZmllbGQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbEZpZWxkTmFtZShwcm90b05hbWUsIGluT25lb2YpIHtcbiAgICBjb25zdCBuYW1lID0gcHJvdG9DYW1lbENhc2UocHJvdG9OYW1lKTtcbiAgICBpZiAoaW5PbmVvZikge1xuICAgICAgICAvLyBvbmVvZiBtZW1iZXIgbmFtZXMgYXJlIG5vdCBwcm9wZXJ0aWVzLCBidXQgdmFsdWVzIG9mIHRoZSBgY2FzZWAgcHJvcGVydHkuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gc2FmZU9iamVjdFByb3BlcnR5KHNhZmVNZXNzYWdlUHJvcGVydHkobmFtZSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgb25lb2YgZ3JvdXAgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcbiAgICByZXR1cm4gbG9jYWxGaWVsZE5hbWUocHJvdG9OYW1lLCBmYWxzZSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gbmFtZSBmb3IgYSBwcm90b2J1ZiBmaWVsZCwgZXhhY3RseSBsaWtlIHByb3RvYyBkb2VzLlxuICovXG5leHBvcnQgY29uc3QgZmllbGRKc29uTmFtZSA9IHByb3RvQ2FtZWxDYXNlO1xuLyoqXG4gKiBGaW5kcyBhIHByZWZpeCBzaGFyZWQgYnkgZW51bSB2YWx1ZXMsIGZvciBleGFtcGxlIGBNWV9FTlVNX2AgZm9yXG4gKiBgZW51bSBNeUVudW0ge01ZX0VOVU1fQT0wOyBNWV9FTlVNX0I9MTt9YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbnVtU2hhcmVkUHJlZml4KGVudW1OYW1lLCB2YWx1ZU5hbWVzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gY2FtZWxUb1NuYWtlQ2FzZShlbnVtTmFtZSkgKyBcIl9cIjtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdmFsdWVOYW1lcykge1xuICAgICAgICBpZiAoIW5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvcnROYW1lID0gbmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIGlmIChzaG9ydE5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eXFxkLy50ZXN0KHNob3J0TmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGlkZW50aWZpZXJzIG11c3Qgbm90IHN0YXJ0IHdpdGggbnVtYmVyc1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlZml4O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBsb3dlckNhbWVsQ2FzZSBvciBVcHBlckNhbWVsQ2FzZSBpbnRvIGxvd2VyX3NuYWtlX2Nhc2UuXG4gKiBUaGlzIGlzIHVzZWQgdG8gZmluZCBzaGFyZWQgcHJlZml4ZXMgaW4gYW4gZW51bS5cbiAqL1xuZnVuY3Rpb24gY2FtZWxUb1NuYWtlQ2FzZShjYW1lbCkge1xuICAgIHJldHVybiAoY2FtZWwuc3Vic3RyaW5nKDAsIDEpICsgY2FtZWwuc3Vic3RyaW5nKDEpLnJlcGxhY2UoL1tBLVpdL2csIChjKSA9PiBcIl9cIiArIGMpKS50b0xvd2VyQ2FzZSgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIHByb3RvQ2FtZWxDYXNlIGFjY29yZGluZyB0byB0aGUgY29udmVudGlvblxuICogdXNlZCBieSBwcm90b2MgdG8gY29udmVydCBhIGZpZWxkIG5hbWUgdG8gYSBKU09OIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHByb3RvQ2FtZWxDYXNlKHNuYWtlQ2FzZSkge1xuICAgIGxldCBjYXBOZXh0ID0gZmFsc2U7XG4gICAgY29uc3QgYiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc25ha2VDYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gc25ha2VDYXNlLmNoYXJBdChpKTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiX1wiOlxuICAgICAgICAgICAgICAgIGNhcE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgY2FwTmV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2FwTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIucHVzaChjKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBpZGVudGlmaWVycywgc3VjaCBhcyBjbGFzcyBuYW1lcyxcbiAqIGJ1dCBfY2FuXyBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgcmVzZXJ2ZWRJZGVudGlmaWVycyA9IG5ldyBTZXQoW1xuICAgIC8vIEVDTUFTY3JpcHQgMjAxNSBrZXl3b3Jkc1xuICAgIFwiYnJlYWtcIixcbiAgICBcImNhc2VcIixcbiAgICBcImNhdGNoXCIsXG4gICAgXCJjbGFzc1wiLFxuICAgIFwiY29uc3RcIixcbiAgICBcImNvbnRpbnVlXCIsXG4gICAgXCJkZWJ1Z2dlclwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCJkb1wiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiZXhwb3J0XCIsXG4gICAgXCJleHRlbmRzXCIsXG4gICAgXCJmYWxzZVwiLFxuICAgIFwiZmluYWxseVwiLFxuICAgIFwiZm9yXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwiaWZcIixcbiAgICBcImltcG9ydFwiLFxuICAgIFwiaW5cIixcbiAgICBcImluc3RhbmNlb2ZcIixcbiAgICBcIm5ld1wiLFxuICAgIFwibnVsbFwiLFxuICAgIFwicmV0dXJuXCIsXG4gICAgXCJzdXBlclwiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJ0aGlzXCIsXG4gICAgXCJ0aHJvd1wiLFxuICAgIFwidHJ1ZVwiLFxuICAgIFwidHJ5XCIsXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZhclwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwid2hpbGVcIixcbiAgICBcIndpdGhcIixcbiAgICBcInlpZWxkXCIsXG4gICAgLy8gRUNNQVNjcmlwdCAyMDE1IGZ1dHVyZSByZXNlcnZlZCBrZXl3b3Jkc1xuICAgIFwiZW51bVwiLFxuICAgIFwiaW1wbGVtZW50c1wiLFxuICAgIFwiaW50ZXJmYWNlXCIsXG4gICAgXCJsZXRcIixcbiAgICBcInBhY2thZ2VcIixcbiAgICBcInByaXZhdGVcIixcbiAgICBcInByb3RlY3RlZFwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJzdGF0aWNcIixcbiAgICAvLyBDbGFzcyBuYW1lIGNhbm5vdCBiZSAnT2JqZWN0JyB3aGVuIHRhcmdldGluZyBFUzUgd2l0aCBtb2R1bGUgQ29tbW9uSlNcbiAgICBcIk9iamVjdFwiLFxuICAgIC8vIFR5cGVTY3JpcHQga2V5d29yZHMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3IgdHlwZXMgKGFzIG9wcG9zZWQgdG8gdmFyaWFibGVzKVxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcInN0cmluZ1wiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgLy8gSWRlbnRpZmllcnMgcmVzZXJ2ZWQgZm9yIHRoZSBydW50aW1lLCBzbyB3ZSBjYW4gZ2VuZXJhdGUgbGVnaWJsZSBjb2RlXG4gICAgXCJnbG9iYWxUaGlzXCIsXG4gICAgXCJVaW50OEFycmF5XCIsXG4gICAgXCJQYXJ0aWFsXCIsXG5dKTtcbi8qKlxuICogTmFtZXMgdGhhdCBjYW5ub3QgYmUgdXNlZCBmb3Igb2JqZWN0IHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGFyZSByZXNlcnZlZFxuICogYnkgYnVpbHQtaW4gSmF2YVNjcmlwdCBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCByZXNlcnZlZE9iamVjdFByb3BlcnRpZXMgPSBuZXcgU2V0KFtcbiAgICAvLyBuYW1lcyByZXNlcnZlZCBieSBKYXZhU2NyaXB0XG4gICAgXCJjb25zdHJ1Y3RvclwiLFxuICAgIFwidG9TdHJpbmdcIixcbiAgICBcInRvSlNPTlwiLFxuICAgIFwidmFsdWVPZlwiLFxuXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IHRoZSBydW50aW1lLlxuICovXG5jb25zdCByZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWVcbiAgICBcImdldFR5cGVcIixcbiAgICBcImNsb25lXCIsXG4gICAgXCJlcXVhbHNcIixcbiAgICBcImZyb21CaW5hcnlcIixcbiAgICBcImZyb21Kc29uXCIsXG4gICAgXCJmcm9tSnNvblN0cmluZ1wiLFxuICAgIFwidG9CaW5hcnlcIixcbiAgICBcInRvSnNvblwiLFxuICAgIFwidG9Kc29uU3RyaW5nXCIsXG4gICAgLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgdGhlIHJ1bnRpbWUgZm9yIHRoZSBmdXR1cmVcbiAgICBcInRvT2JqZWN0XCIsXG5dKTtcbmNvbnN0IGZhbGxiYWNrID0gKG5hbWUpID0+IGAke25hbWV9JGA7XG4vKipcbiAqIFdpbGwgd3JhcCBuYW1lcyB0aGF0IGFyZSBPYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXMgb3IgbmFtZXMgcmVzZXJ2ZWRcbiAqIGZvciBgTWVzc2FnZWBzLlxuICovXG5jb25zdCBzYWZlTWVzc2FnZVByb3BlcnR5ID0gKG5hbWUpID0+IHtcbiAgICBpZiAocmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IGJ1aWx0LWluIEphdmFTY3JpcHQgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKHJlc2VydmVkT2JqZWN0UHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4vKipcbiAqIE5hbWVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGlkZW50aWZpZXJzIG9yIGNsYXNzIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHNhZmVJZGVudGlmaWVyID0gKG5hbWUpID0+IHtcbiAgICBpZiAocmVzZXJ2ZWRJZGVudGlmaWVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgbG9jYWxPbmVvZk5hbWUgfSBmcm9tIFwiLi9uYW1lcy5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSBcIi4vYXNzZXJ0LmpzXCI7XG5leHBvcnQgY2xhc3MgSW50ZXJuYWxPbmVvZkluZm8ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5raW5kID0gXCJvbmVvZlwiO1xuICAgICAgICB0aGlzLnJlcGVhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVxID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE9uZW9mTmFtZShuYW1lKTtcbiAgICB9XG4gICAgYWRkRmllbGQoZmllbGQpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLm9uZW9mID09PSB0aGlzLCBgZmllbGQgJHtmaWVsZC5uYW1lfSBub3Qgb25lIG9mICR7dGhpcy5uYW1lfWApO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICB9XG4gICAgZmluZEZpZWxkKGxvY2FsTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvb2t1cCkge1xuICAgICAgICAgICAgdGhpcy5fbG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb29rdXBbdGhpcy5maWVsZHNbaV0ubG9jYWxOYW1lXSA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBbbG9jYWxOYW1lXTtcbiAgICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuaW1wb3J0IHsgSW50ZXJuYWxPbmVvZkluZm8gfSBmcm9tIFwiLi9maWVsZC5qc1wiO1xuaW1wb3J0IHsgZmllbGRKc29uTmFtZSwgbG9jYWxGaWVsZE5hbWUgfSBmcm9tIFwiLi9uYW1lcy5qc1wiO1xuaW1wb3J0IHsgTG9uZ1R5cGUsIFNjYWxhclR5cGUgfSBmcm9tIFwiLi4vc2NhbGFyLmpzXCI7XG4vKipcbiAqIENvbnZlcnQgYSBjb2xsZWN0aW9uIG9mIGZpZWxkIGluZm8gdG8gYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCBGaWVsZEluZm8uXG4gKlxuICogVGhlIGFyZ3VtZW50IGBwYWNrZWRCeURlZmF1bHRgIHNwZWNpZmllcyB3aGV0aGVyIGZpZWxkcyB0aGF0IGRvIG5vdCBzcGVjaWZ5XG4gKiBgcGFja2VkYCBzaG91bGQgYmUgcGFja2VkIChwcm90bzMpIG9yIHVucGFja2VkIChwcm90bzIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRmllbGRJbmZvcyhmaWVsZEluZm9zLCBwYWNrZWRCeURlZmF1bHQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCByID0gW107XG4gICAgbGV0IG87XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBmaWVsZEluZm9zKClcbiAgICAgICAgOiBmaWVsZEluZm9zKSB7XG4gICAgICAgIGNvbnN0IGYgPSBmaWVsZDtcbiAgICAgICAgZi5sb2NhbE5hbWUgPSBsb2NhbEZpZWxkTmFtZShmaWVsZC5uYW1lLCBmaWVsZC5vbmVvZiAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xuICAgICAgICBmLnJlcGVhdGVkID0gKF9iID0gZmllbGQucmVwZWF0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICBpZiAoZmllbGQua2luZCA9PSBcInNjYWxhclwiKSB7XG4gICAgICAgICAgICBmLkwgPSAoX2MgPSBmaWVsZC5MKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBMb25nVHlwZS5CSUdJTlQ7XG4gICAgICAgIH1cbiAgICAgICAgZi5kZWxpbWl0ZWQgPSAoX2QgPSBmaWVsZC5kZWxpbWl0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICBmLnJlcSA9IChfZSA9IGZpZWxkLnJlcSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZmFsc2U7XG4gICAgICAgIGYub3B0ID0gKF9mID0gZmllbGQub3B0KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZTtcbiAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocGFja2VkQnlEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgZi5wYWNrZWQgPVxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5raW5kID09IFwiZW51bVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZmllbGQua2luZCA9PSBcInNjYWxhclwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuVCAhPSBTY2FsYXJUeXBlLkJZVEVTICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuVCAhPSBTY2FsYXJUeXBlLlNUUklORyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmLnBhY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvIG5vdCBzdXJmYWNlIG9wdGlvbnMgYXQgdGhpcyB0aW1lXG4gICAgICAgIC8vIGYub3B0aW9ucyA9IGZpZWxkLm9wdGlvbnMgPz8gZW1wdHlSZWFkb25seU9iamVjdDtcbiAgICAgICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgICAgICAgICBvID0gbmV3IEludGVybmFsT25lb2ZJbmZvKG9vbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmLm9uZW9mID0gbztcbiAgICAgICAgICAgIG8uYWRkRmllbGQoZik7XG4gICAgICAgIH1cbiAgICAgICAgci5wdXNoKGYpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBtYWtlUHJvdG9SdW50aW1lIH0gZnJvbSBcIi4vcHJpdmF0ZS9wcm90by1ydW50aW1lLmpzXCI7XG5pbXBvcnQgeyBJbnRlcm5hbEZpZWxkTGlzdCB9IGZyb20gXCIuL3ByaXZhdGUvZmllbGQtbGlzdC5qc1wiO1xuaW1wb3J0IHsgc2NhbGFyWmVyb1ZhbHVlIH0gZnJvbSBcIi4vcHJpdmF0ZS9zY2FsYXJzLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVGaWVsZEluZm9zIH0gZnJvbSBcIi4vcHJpdmF0ZS9maWVsZC1ub3JtYWxpemUuanNcIjtcbi8qKlxuICogUHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgbWVzc2FnZXMgZGVmaW5lZCB3aXRoIHRoZSBwcm90bzMgc3ludGF4LlxuICovXG5leHBvcnQgY29uc3QgcHJvdG8zID0gbWFrZVByb3RvUnVudGltZShcInByb3RvM1wiLCAoZmllbGRzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBJbnRlcm5hbEZpZWxkTGlzdChmaWVsZHMsIChzb3VyY2UpID0+IG5vcm1hbGl6ZUZpZWxkSW5mb3Moc291cmNlLCB0cnVlKSk7XG59LCBcbi8vIFRPRE8gbWVyZ2Ugd2l0aCBwcm90bzIgYW5kIGluaXRFeHRlbnNpb25GaWVsZCwgYWxzbyBzZWUgaW5pdFBhcnRpYWwsIGVxdWFscywgY2xvbmVcbih0YXJnZXQpID0+IHtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0YXJnZXQuZ2V0VHlwZSgpLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgIGlmIChtZW1iZXIub3B0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gbWVtYmVyLmxvY2FsTmFtZSwgdCA9IHRhcmdldDtcbiAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgICAgdFtuYW1lXSA9IFtdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgdFtuYW1lXSA9IHsgY2FzZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHRbbmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgIHRbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICB0W25hbWVdID0gc2NhbGFyWmVyb1ZhbHVlKG1lbWJlci5ULCBtZW1iZXIuTCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UgZmllbGRzIGFyZSBhbHdheXMgb3B0aW9uYWwgaW4gcHJvdG8zXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSBcIi4uLy4uL21lc3NhZ2UuanNcIjtcbmltcG9ydCB7IHByb3RvSW50NjQgfSBmcm9tIFwiLi4vLi4vcHJvdG8taW50NjQuanNcIjtcbmltcG9ydCB7IHByb3RvMyB9IGZyb20gXCIuLi8uLi9wcm90bzMuanNcIjtcbi8qKlxuICogQSBUaW1lc3RhbXAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvciBsb2NhbFxuICogY2FsZW5kYXIsIGVuY29kZWQgYXMgYSBjb3VudCBvZiBzZWNvbmRzIGFuZCBmcmFjdGlvbnMgb2Ygc2Vjb25kcyBhdFxuICogbmFub3NlY29uZCByZXNvbHV0aW9uLiBUaGUgY291bnQgaXMgcmVsYXRpdmUgdG8gYW4gZXBvY2ggYXQgVVRDIG1pZG5pZ2h0IG9uXG4gKiBKYW51YXJ5IDEsIDE5NzAsIGluIHRoZSBwcm9sZXB0aWMgR3JlZ29yaWFuIGNhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLlxuICpcbiAqIEFsbCBtaW51dGVzIGFyZSA2MCBzZWNvbmRzIGxvbmcuIExlYXAgc2Vjb25kcyBhcmUgXCJzbWVhcmVkXCIgc28gdGhhdCBubyBsZWFwXG4gKiBzZWNvbmQgdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbiwgdXNpbmcgYSBbMjQtaG91ciBsaW5lYXJcbiAqIHNtZWFyXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS90aW1lL3NtZWFyKS5cbiAqXG4gKiBUaGUgcmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouIEJ5XG4gKiByZXN0cmljdGluZyB0byB0aGF0IHJhbmdlLCB3ZSBlbnN1cmUgdGhhdCB3ZSBjYW4gY29udmVydCB0byBhbmQgZnJvbSBbUkZDXG4gKiAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGRhdGUgc3RyaW5ncy5cbiAqXG4gKiAjIEV4YW1wbGVzXG4gKlxuICogRXhhbXBsZSAxOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFBPU0lYIGB0aW1lKClgLlxuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcyh0aW1lKE5VTEwpKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKDApO1xuICpcbiAqIEV4YW1wbGUgMjogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgZ2V0dGltZW9mZGF5KClgLlxuICpcbiAqICAgICBzdHJ1Y3QgdGltZXZhbCB0djtcbiAqICAgICBnZXR0aW1lb2ZkYXkoJnR2LCBOVUxMKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModHYudHZfc2VjKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKHR2LnR2X3VzZWMgKiAxMDAwKTtcbiAqXG4gKiBFeGFtcGxlIDM6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gV2luMzIgYEdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lKClgLlxuICpcbiAqICAgICBGSUxFVElNRSBmdDtcbiAqICAgICBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgmZnQpO1xuICogICAgIFVJTlQ2NCB0aWNrcyA9ICgoKFVJTlQ2NClmdC5kd0hpZ2hEYXRlVGltZSkgPDwgMzIpIHwgZnQuZHdMb3dEYXRlVGltZTtcbiAqXG4gKiAgICAgLy8gQSBXaW5kb3dzIHRpY2sgaXMgMTAwIG5hbm9zZWNvbmRzLiBXaW5kb3dzIGVwb2NoIDE2MDEtMDEtMDFUMDA6MDA6MDBaXG4gKiAgICAgLy8gaXMgMTE2NDQ0NzM2MDAgc2Vjb25kcyBiZWZvcmUgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcygoSU5UNjQpICgodGlja3MgLyAxMDAwMDAwMCkgLSAxMTY0NDQ3MzYwMExMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygoSU5UMzIpICgodGlja3MgJSAxMDAwMDAwMCkgKiAxMDApKTtcbiAqXG4gKiBFeGFtcGxlIDQ6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKClgLlxuICpcbiAqICAgICBsb25nIG1pbGxpcyA9IFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID0gVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG1pbGxpcyAvIDEwMDApXG4gKiAgICAgICAgIC5zZXROYW5vcygoaW50KSAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA1OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYEluc3RhbnQubm93KClgLlxuICpcbiAqICAgICBJbnN0YW50IG5vdyA9IEluc3RhbnQubm93KCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXAgPVxuICogICAgICAgICBUaW1lc3RhbXAubmV3QnVpbGRlcigpLnNldFNlY29uZHMobm93LmdldEVwb2NoU2Vjb25kKCkpXG4gKiAgICAgICAgICAgICAuc2V0TmFub3Mobm93LmdldE5hbm8oKSkuYnVpbGQoKTtcbiAqXG4gKiBFeGFtcGxlIDY6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gY3VycmVudCB0aW1lIGluIFB5dGhvbi5cbiAqXG4gKiAgICAgdGltZXN0YW1wID0gVGltZXN0YW1wKClcbiAqICAgICB0aW1lc3RhbXAuR2V0Q3VycmVudFRpbWUoKVxuICpcbiAqICMgSlNPTiBNYXBwaW5nXG4gKlxuICogSW4gSlNPTiBmb3JtYXQsIHRoZSBUaW1lc3RhbXAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nIGluIHRoZVxuICogW1JGQyAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGZvcm1hdC4gVGhhdCBpcywgdGhlXG4gKiBmb3JtYXQgaXMgXCJ7eWVhcn0te21vbnRofS17ZGF5fVR7aG91cn06e21pbn06e3NlY31bLntmcmFjX3NlY31dWlwiXG4gKiB3aGVyZSB7eWVhcn0gaXMgYWx3YXlzIGV4cHJlc3NlZCB1c2luZyBmb3VyIGRpZ2l0cyB3aGlsZSB7bW9udGh9LCB7ZGF5fSxcbiAqIHtob3VyfSwge21pbn0sIGFuZCB7c2VjfSBhcmUgemVyby1wYWRkZWQgdG8gdHdvIGRpZ2l0cyBlYWNoLiBUaGUgZnJhY3Rpb25hbFxuICogc2Vjb25kcywgd2hpY2ggY2FuIGdvIHVwIHRvIDkgZGlnaXRzIChpLmUuIHVwIHRvIDEgbmFub3NlY29uZCByZXNvbHV0aW9uKSxcbiAqIGFyZSBvcHRpb25hbC4gVGhlIFwiWlwiIHN1ZmZpeCBpbmRpY2F0ZXMgdGhlIHRpbWV6b25lIChcIlVUQ1wiKTsgdGhlIHRpbWV6b25lXG4gKiBpcyByZXF1aXJlZC4gQSBwcm90bzMgSlNPTiBzZXJpYWxpemVyIHNob3VsZCBhbHdheXMgdXNlIFVUQyAoYXMgaW5kaWNhdGVkIGJ5XG4gKiBcIlpcIikgd2hlbiBwcmludGluZyB0aGUgVGltZXN0YW1wIHR5cGUgYW5kIGEgcHJvdG8zIEpTT04gcGFyc2VyIHNob3VsZCBiZVxuICogYWJsZSB0byBhY2NlcHQgYm90aCBVVEMgYW5kIG90aGVyIHRpbWV6b25lcyAoYXMgaW5kaWNhdGVkIGJ5IGFuIG9mZnNldCkuXG4gKlxuICogRm9yIGV4YW1wbGUsIFwiMjAxNy0wMS0xNVQwMTozMDoxNS4wMVpcIiBlbmNvZGVzIDE1LjAxIHNlY29uZHMgcGFzdFxuICogMDE6MzAgVVRDIG9uIEphbnVhcnkgMTUsIDIwMTcuXG4gKlxuICogSW4gSmF2YVNjcmlwdCwgb25lIGNhbiBjb252ZXJ0IGEgRGF0ZSBvYmplY3QgdG8gdGhpcyBmb3JtYXQgdXNpbmcgdGhlXG4gKiBzdGFuZGFyZFxuICogW3RvSVNPU3RyaW5nKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmcpXG4gKiBtZXRob2QuIEluIFB5dGhvbiwgYSBzdGFuZGFyZCBgZGF0ZXRpbWUuZGF0ZXRpbWVgIG9iamVjdCBjYW4gYmUgY29udmVydGVkXG4gKiB0byB0aGlzIGZvcm1hdCB1c2luZ1xuICogW2BzdHJmdGltZWBdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIvbGlicmFyeS90aW1lLmh0bWwjdGltZS5zdHJmdGltZSkgd2l0aFxuICogdGhlIHRpbWUgZm9ybWF0IHNwZWMgJyVZLSVtLSVkVCVIOiVNOiVTLiVmWicuIExpa2V3aXNlLCBpbiBKYXZhLCBvbmUgY2FuIHVzZVxuICogdGhlIEpvZGEgVGltZSdzIFtgSVNPRGF0ZVRpbWVGb3JtYXQuZGF0ZVRpbWUoKWBdKFxuICogaHR0cDovL2pvZGEtdGltZS5zb3VyY2Vmb3JnZS5uZXQvYXBpZG9jcy9vcmcvam9kYS90aW1lL2Zvcm1hdC9JU09EYXRlVGltZUZvcm1hdC5odG1sI2RhdGVUaW1lKClcbiAqICkgdG8gb2J0YWluIGEgZm9ybWF0dGVyIGNhcGFibGUgb2YgZ2VuZXJhdGluZyB0aW1lc3RhbXBzIGluIHRoaXMgZm9ybWF0LlxuICpcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lc3RhbXAgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxuICAgICAgICAgKiAxOTcwLTAxLTAxVDAwOjAwOjAwWi4gTXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvXG4gICAgICAgICAqIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQ2NCBzZWNvbmRzID0gMTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQuemVybztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1uZWdhdGl2ZSBmcmFjdGlvbnMgb2YgYSBzZWNvbmQgYXQgbmFub3NlY29uZCByZXNvbHV0aW9uLiBOZWdhdGl2ZVxuICAgICAgICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXG4gICAgICAgICAqIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlIGZyb20gMCB0byA5OTksOTk5LDk5OVxuICAgICAgICAgKiBpbmNsdXNpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBnZW5lcmF0ZWQgZnJvbSBmaWVsZDogaW50MzIgbmFub3MgPSAyO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW5vcyA9IDA7XG4gICAgICAgIHByb3RvMy51dGlsLmluaXRQYXJ0aWFsKGRhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBmcm9tSnNvbihqc29uLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiAke3Byb3RvMy5qc29uLmRlYnVnKGpzb24pfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBqc29uLm1hdGNoKC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSlUKFswLTldezJ9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoPzpafFxcLihbMC05XXszLDl9KVp8KFsrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IGludmFsaWQgUkZDIDMzMzkgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKG1hdGNoZXNbMV0gKyBcIi1cIiArIG1hdGNoZXNbMl0gKyBcIi1cIiArIG1hdGNoZXNbM10gKyBcIlRcIiArIG1hdGNoZXNbNF0gKyBcIjpcIiArIG1hdGNoZXNbNV0gKyBcIjpcIiArIG1hdGNoZXNbNl0gKyAobWF0Y2hlc1s4XSA/IG1hdGNoZXNbOF0gOiBcIlpcIikpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG1zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgZnJvbSBKU09OOiBpbnZhbGlkIFJGQyAzMzM5IHN0cmluZ2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyA8IERhdGUucGFyc2UoXCIwMDAxLTAxLTAxVDAwOjAwOjAwWlwiKSB8fCBtcyA+IERhdGUucGFyc2UoXCI5OTk5LTEyLTMxVDIzOjU5OjU5WlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IG11c3QgYmUgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlY29uZHMgPSBwcm90b0ludDY0LnBhcnNlKG1zIC8gMTAwMCk7XG4gICAgICAgIHRoaXMubmFub3MgPSAwO1xuICAgICAgICBpZiAobWF0Y2hlc1s3XSkge1xuICAgICAgICAgICAgdGhpcy5uYW5vcyA9IChwYXJzZUludChcIjFcIiArIG1hdGNoZXNbN10gKyBcIjBcIi5yZXBlYXQoOSAtIG1hdGNoZXNbN10ubGVuZ3RoKSkgLSAxMDAwMDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbXMgPSBOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDA7XG4gICAgICAgIGlmIChtcyA8IERhdGUucGFyc2UoXCIwMDAxLTAxLTAxVDAwOjAwOjAwWlwiKSB8fCBtcyA+IERhdGUucGFyc2UoXCI5OTk5LTEyLTMxVDIzOjU5OjU5WlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbm9zIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZW5jb2RlIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgdG8gSlNPTjogbmFub3MgbXVzdCBub3QgYmUgbmVnYXRpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeiA9IFwiWlwiO1xuICAgICAgICBpZiAodGhpcy5uYW5vcyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbm9zU3RyID0gKHRoaXMubmFub3MgKyAxMDAwMDAwMDAwKS50b1N0cmluZygpLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoMykgPT09IFwiMDAwMDAwXCIpIHtcbiAgICAgICAgICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgMykgKyBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbm9zU3RyLnN1YnN0cmluZyg2KSA9PT0gXCIwMDBcIikge1xuICAgICAgICAgICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyLnN1YnN0cmluZygwLCA2KSArIFwiWlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIgKyBcIlpcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobXMpLnRvSVNPU3RyaW5nKCkucmVwbGFjZShcIi4wMDBaXCIsIHopO1xuICAgIH1cbiAgICB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDAgKyBNYXRoLmNlaWwodGhpcy5uYW5vcyAvIDEwMDAwMDApKTtcbiAgICB9XG4gICAgc3RhdGljIG5vdygpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcC5mcm9tRGF0ZShuZXcgRGF0ZSgpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcbiAgICAgICAgY29uc3QgbXMgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoe1xuICAgICAgICAgICAgc2Vjb25kczogcHJvdG9JbnQ2NC5wYXJzZShNYXRoLmZsb29yKG1zIC8gMTAwMCkpLFxuICAgICAgICAgICAgbmFub3M6IChtcyAlIDEwMDApICogMTAwMDAwMCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoKS5mcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpzb25TdHJpbmcoanNvblN0cmluZywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvMy51dGlsLmVxdWFscyhUaW1lc3RhbXAsIGEsIGIpO1xuICAgIH1cbn1cblRpbWVzdGFtcC5ydW50aW1lID0gcHJvdG8zO1xuVGltZXN0YW1wLnR5cGVOYW1lID0gXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCI7XG5UaW1lc3RhbXAuZmllbGRzID0gcHJvdG8zLnV0aWwubmV3RmllbGRMaXN0KCgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNlY29uZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMyAvKiBTY2FsYXJUeXBlLklOVDY0ICovIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJuYW5vc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1IC8qIFNjYWxhclR5cGUuSU5UMzIgKi8gfSxcbl0pO1xuIiwiaW1wb3J0IHsgcHJvdG8zLCBUaW1lc3RhbXAsIER1cmF0aW9uIH0gZnJvbSAnQGJ1ZmJ1aWxkL3Byb3RvYnVmJztcbmV4cG9ydCB7IHByb3RvSW50NjQgfSBmcm9tICdAYnVmYnVpbGQvcHJvdG9idWYnO1xuXG5jb25zdCBNZXRyaWNMYWJlbCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5NZXRyaWNMYWJlbFwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJBR0VOVFNfTExNX1RURlRcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiQUdFTlRTX1NUVF9UVEZUXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkFHRU5UU19UVFNfVFRGQlwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJDTElFTlRfVklERU9fU1VCU0NSSUJFUl9GUkVFWkVfQ09VTlRcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiQ0xJRU5UX1ZJREVPX1NVQlNDUklCRVJfVE9UQUxfRlJFRVpFX0RVUkFUSU9OXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIkNMSUVOVF9WSURFT19TVUJTQ1JJQkVSX1BBVVNFX0NPVU5UXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcIkNMSUVOVF9WSURFT19TVUJTQ1JJQkVSX1RPVEFMX1BBVVNFU19EVVJBVElPTlwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJDTElFTlRfQVVESU9fU1VCU0NSSUJFUl9DT05DRUFMRURfU0FNUExFU1wiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJDTElFTlRfQVVESU9fU1VCU0NSSUJFUl9TSUxFTlRfQ09OQ0VBTEVEX1NBTVBMRVNcIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiQ0xJRU5UX0FVRElPX1NVQlNDUklCRVJfQ09OQ0VBTE1FTlRfRVZFTlRTXCIgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJDTElFTlRfQVVESU9fU1VCU0NSSUJFUl9JTlRFUlJVUFRJT05fQ09VTlRcIiB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcIkNMSUVOVF9BVURJT19TVUJTQ1JJQkVSX1RPVEFMX0lOVEVSUlVQVElPTl9EVVJBVElPTlwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiQ0xJRU5UX1NVQlNDUklCRVJfSklUVEVSX0JVRkZFUl9ERUxBWVwiIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiQ0xJRU5UX1NVQlNDUklCRVJfSklUVEVSX0JVRkZFUl9FTUlUVEVEX0NPVU5UXCIgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJDTElFTlRfVklERU9fUFVCTElTSEVSX1FVQUxJVFlfTElNSVRBVElPTl9EVVJBVElPTl9CQU5EV0lEVEhcIiB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcIkNMSUVOVF9WSURFT19QVUJMSVNIRVJfUVVBTElUWV9MSU1JVEFUSU9OX0RVUkFUSU9OX0NQVVwiIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwiQ0xJRU5UX1ZJREVPX1BVQkxJU0hFUl9RVUFMSVRZX0xJTUlUQVRJT05fRFVSQVRJT05fT1RIRVJcIiB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcIlBVQkxJU0hFUl9SVFRcIiB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcIlNFUlZFUl9NRVNIX1JUVFwiIH0sXG4gICAgeyBubzogMTksIG5hbWU6IFwiU1VCU0NSSUJFUl9SVFRcIiB9LFxuICAgIHsgbm86IDQwOTYsIG5hbWU6IFwiTUVUUklDX0xBQkVMX1BSRURFRklORURfTUFYX1ZBTFVFXCIgfVxuICBdXG4pO1xuY29uc3QgTWV0cmljc0JhdGNoID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5NZXRyaWNzQmF0Y2hcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ0aW1lc3RhbXBfbXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm5vcm1hbGl6ZWRfdGltZXN0YW1wXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInN0cl9kYXRhXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ0aW1lX3Nlcmllc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZVNlcmllc01ldHJpYywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImV2ZW50c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRXZlbnRNZXRyaWMsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFRpbWVTZXJpZXNNZXRyaWMgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlRpbWVTZXJpZXNNZXRyaWNcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJsYWJlbFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInNhbXBsZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE1ldHJpY1NhbXBsZSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwicmlkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgTWV0cmljU2FtcGxlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5NZXRyaWNTYW1wbGVcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ0aW1lc3RhbXBfbXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm5vcm1hbGl6ZWRfdGltZXN0YW1wXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwidmFsdWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAyXG4gICAgICAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgRXZlbnRNZXRyaWMgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkV2ZW50TWV0cmljXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwibGFiZWxcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInN0YXJ0X3RpbWVzdGFtcF9tc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZW5kX3RpbWVzdGFtcF9tc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcIm5vcm1hbGl6ZWRfc3RhcnRfdGltZXN0YW1wXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcIm5vcm1hbGl6ZWRfZW5kX3RpbWVzdGFtcFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wLCBvcHQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogOCxcbiAgICAgIG5hbWU6IFwibWV0YWRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcInJpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH1cbiAgXVxuKTtcblxuY29uc3QgQXVkaW9Db2RlYyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5BdWRpb0NvZGVjXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIkRFRkFVTFRfQUNcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiT1BVU1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJBQUNcIiB9XG4gIF1cbik7XG5jb25zdCBWaWRlb0NvZGVjID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlZpZGVvQ29kZWNcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiREVGQVVMVF9WQ1wiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJIMjY0X0JBU0VMSU5FXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkgyNjRfTUFJTlwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJIMjY0X0hJR0hcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiVlA4XCIgfVxuICBdXG4pO1xuY29uc3QgSW1hZ2VDb2RlYyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5JbWFnZUNvZGVjXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIklDX0RFRkFVTFRcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiSUNfSlBFR1wiIH1cbiAgXVxuKTtcbmNvbnN0IEJhY2t1cENvZGVjUG9saWN5ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkJhY2t1cENvZGVjUG9saWN5XCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlBSRUZFUl9SRUdSRVNTSU9OXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlNJTVVMQ0FTVFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJSRUdSRVNTSU9OXCIgfVxuICBdXG4pO1xuY29uc3QgVHJhY2tUeXBlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlRyYWNrVHlwZVwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJBVURJT1wiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJWSURFT1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJEQVRBXCIgfVxuICBdXG4pO1xuY29uc3QgVHJhY2tTb3VyY2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuVHJhY2tTb3VyY2VcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJDQU1FUkFcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiTUlDUk9QSE9ORVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJTQ1JFRU5fU0hBUkVcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiU0NSRUVOX1NIQVJFX0FVRElPXCIgfVxuICBdXG4pO1xuY29uc3QgVmlkZW9RdWFsaXR5ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlZpZGVvUXVhbGl0eVwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJMT1dcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiTUVESVVNXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkhJR0hcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiT0ZGXCIgfVxuICBdXG4pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHkgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiUE9PUlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJHT09EXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkVYQ0VMTEVOVFwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJMT1NUXCIgfVxuICBdXG4pO1xuY29uc3QgQ2xpZW50Q29uZmlnU2V0dGluZyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5DbGllbnRDb25maWdTZXR0aW5nXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlVOU0VUXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIkRJU0FCTEVEXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkVOQUJMRURcIiB9XG4gIF1cbik7XG5jb25zdCBEaXNjb25uZWN0UmVhc29uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkRpc2Nvbm5lY3RSZWFzb25cIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiVU5LTk9XTl9SRUFTT05cIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiQ0xJRU5UX0lOSVRJQVRFRFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJEVVBMSUNBVEVfSURFTlRJVFlcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiU0VSVkVSX1NIVVRET1dOXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIlBBUlRJQ0lQQU5UX1JFTU9WRURcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiUk9PTV9ERUxFVEVEXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcIlNUQVRFX01JU01BVENIXCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcIkpPSU5fRkFJTFVSRVwiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJNSUdSQVRJT05cIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiU0lHTkFMX0NMT1NFXCIgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJST09NX0NMT1NFRFwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwiVVNFUl9VTkFWQUlMQUJMRVwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiVVNFUl9SRUpFQ1RFRFwiIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiU0lQX1RSVU5LX0ZBSUxVUkVcIiB9XG4gIF1cbik7XG5jb25zdCBSZWNvbm5lY3RSZWFzb24gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuUmVjb25uZWN0UmVhc29uXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlJSX1VOS05PV05cIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJSUl9QVUJMSVNIRVJfRkFJTEVEXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIlJSX1NVQlNDUklCRVJfRkFJTEVEXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIlJSX1NXSVRDSF9DQU5ESURBVEVcIiB9XG4gIF1cbik7XG5jb25zdCBTdWJzY3JpcHRpb25FcnJvciA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TdWJzY3JpcHRpb25FcnJvclwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJTRV9VTktOT1dOXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlNFX0NPREVDX1VOU1VQUE9SVEVEXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIlNFX1RSQUNLX05PVEZPVU5EXCIgfVxuICBdXG4pO1xuY29uc3QgQXVkaW9UcmFja0ZlYXR1cmUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuQXVkaW9UcmFja0ZlYXR1cmVcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiVEZfU1RFUkVPXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlRGX05PX0RUWFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJURl9BVVRPX0dBSU5fQ09OVFJPTFwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJURl9FQ0hPX0NBTkNFTExBVElPTlwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJURl9OT0lTRV9TVVBQUkVTU0lPTlwiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJURl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT05cIiB9XG4gIF1cbik7XG5jb25zdCBQYWdpbmF0aW9uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5QYWdpbmF0aW9uXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiYWZ0ZXJfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImxpbWl0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IExpc3RVcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lkxpc3RVcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic2V0XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFJvb20gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJvb21cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJzaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImVtcHR5X3RpbWVvdXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxNCxcbiAgICAgIG5hbWU6IFwiZGVwYXJ0dXJlX3RpbWVvdXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJtYXhfcGFydGljaXBhbnRzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwiY3JlYXRpb25fdGltZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxNSxcbiAgICAgIG5hbWU6IFwiY3JlYXRpb25fdGltZV9tc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA2LFxuICAgICAgbmFtZTogXCJ0dXJuX3Bhc3N3b3JkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZW5hYmxlZF9jb2RlY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOSxcbiAgICAgIG5hbWU6IFwibnVtX3BhcnRpY2lwYW50c1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDExLFxuICAgICAgbmFtZTogXCJudW1fcHVibGlzaGVyc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEwLFxuICAgICAgbmFtZTogXCJhY3RpdmVfcmVjb3JkaW5nXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJ2ZXJzaW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lZFZlcnNpb24gfVxuICBdXG4pO1xuY29uc3QgQ29kZWMgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNvZGVjXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwibWltZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiZm10cF9saW5lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBQbGF5b3V0RGVsYXkgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlBsYXlvdXREZWxheVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImVuYWJsZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJtaW5cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJtYXhcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBQYXJ0aWNpcGFudFBlcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlBhcnRpY2lwYW50UGVybWlzc2lvblwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImNhbl9zdWJzY3JpYmVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJjYW5fcHVibGlzaFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImNhbl9wdWJsaXNoX2RhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiY2FuX3B1Ymxpc2hfc291cmNlc1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwiaGlkZGVuXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOCxcbiAgICAgIG5hbWU6IFwicmVjb3JkZXJcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwiY2FuX3VwZGF0ZV9tZXRhZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDExLFxuICAgICAgbmFtZTogXCJhZ2VudFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEyLFxuICAgICAgbmFtZTogXCJjYW5fc3Vic2NyaWJlX21ldHJpY3NcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBQYXJ0aWNpcGFudEluZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzdGF0ZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19TdGF0ZSkgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInRyYWNrc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiam9pbmVkX2F0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDE3LFxuICAgICAgbmFtZTogXCJqb2luZWRfYXRfbXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOSxcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTAsXG4gICAgICBuYW1lOiBcInZlcnNpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcInBlcm1pc3Npb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50UGVybWlzc2lvbiB9LFxuICAgIHtcbiAgICAgIG5vOiAxMixcbiAgICAgIG5hbWU6IFwicmVnaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMyxcbiAgICAgIG5hbWU6IFwiaXNfcHVibGlzaGVyXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJraW5kXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoUGFydGljaXBhbnRJbmZvX0tpbmQpIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwiYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwiZGlzY29ubmVjdF9yZWFzb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKSB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcImtpbmRfZGV0YWlsc1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19LaW5kRGV0YWlsKSwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvX1N0YXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5TdGF0ZVwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJKT0lOSU5HXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIkpPSU5FRFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJBQ1RJVkVcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiRElTQ09OTkVDVEVEXCIgfVxuICBdXG4pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvX0tpbmQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLktpbmRcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiU1RBTkRBUkRcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiSU5HUkVTU1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJFR1JFU1NcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiU0lQXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIkFHRU5UXCIgfVxuICBdXG4pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvX0tpbmREZXRhaWwgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLktpbmREZXRhaWxcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiQ0xPVURfQUdFTlRcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiRk9SV0FSREVEXCIgfVxuICBdXG4pO1xuY29uc3QgRW5jcnlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRW5jcnlwdGlvblwiLFxuICBbXVxuKTtcbmNvbnN0IEVuY3J5cHRpb25fVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5FbmNyeXB0aW9uLlR5cGVcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiTk9ORVwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJHQ01cIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiQ1VTVE9NXCIgfVxuICBdXG4pO1xuY29uc3QgU2ltdWxjYXN0Q29kZWNJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TaW11bGNhc3RDb2RlY0luZm9cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIm1pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiY2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwibGF5ZXJzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBWaWRlb0xheWVyLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBUcmFja0luZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlRyYWNrSW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInR5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1R5cGUpIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcIm11dGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwid2lkdGhcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA2LFxuICAgICAgbmFtZTogXCJoZWlnaHRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJzaW11bGNhc3RcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJkaXNhYmxlX2R0eFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJzb3VyY2VcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSkgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDExLFxuICAgICAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEyLFxuICAgICAgbmFtZTogXCJtaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTaW11bGNhc3RDb2RlY0luZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDE0LFxuICAgICAgbmFtZTogXCJzdGVyZW9cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxNSxcbiAgICAgIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDE2LCBuYW1lOiBcImVuY3J5cHRpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpIH0sXG4gICAge1xuICAgICAgbm86IDE3LFxuICAgICAgbmFtZTogXCJzdHJlYW1cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMTgsIG5hbWU6IFwidmVyc2lvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZWRWZXJzaW9uIH0sXG4gICAgeyBubzogMTksIG5hbWU6IFwiYXVkaW9fZmVhdHVyZXNcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShBdWRpb1RyYWNrRmVhdHVyZSksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMjAsIG5hbWU6IFwiYmFja3VwX2NvZGVjX3BvbGljeVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEJhY2t1cENvZGVjUG9saWN5KSB9XG4gIF1cbik7XG5jb25zdCBWaWRlb0xheWVyID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5WaWRlb0xheWVyXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInF1YWxpdHlcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShWaWRlb1F1YWxpdHkpIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIndpZHRoXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiaGVpZ2h0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiYml0cmF0ZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcInNzcmNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBEYXRhUGFja2V0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EYXRhUGFja2V0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImtpbmRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEYXRhUGFja2V0X0tpbmQpIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZGVzdGluYXRpb25faWRlbnRpdGllc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidXNlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXNlclBhY2tldCwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic3BlYWtlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWN0aXZlU3BlYWtlclVwZGF0ZSwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwic2lwX2R0bWZcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNpcERUTUYsIG9uZW9mOiBcInZhbHVlXCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInRyYW5zY3JpcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYW5zY3JpcHRpb24sIG9uZW9mOiBcInZhbHVlXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcIm1ldHJpY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE1ldHJpY3NCYXRjaCwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiY2hhdF9tZXNzYWdlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDaGF0TWVzc2FnZSwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInJwY19yZXF1ZXN0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBScGNSZXF1ZXN0LCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicnBjX2Fja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUnBjQWNrLCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwicnBjX3Jlc3BvbnNlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBScGNSZXNwb25zZSwgb25lb2Y6IFwidmFsdWVcIiB9LFxuICAgIHsgbm86IDEzLCBuYW1lOiBcInN0cmVhbV9oZWFkZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IERhdGFTdHJlYW1fSGVhZGVyLCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwic3RyZWFtX2NodW5rXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEYXRhU3RyZWFtX0NodW5rLCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwic3RyZWFtX3RyYWlsZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IERhdGFTdHJlYW1fVHJhaWxlciwgb25lb2Y6IFwidmFsdWVcIiB9XG4gIF1cbik7XG5jb25zdCBEYXRhUGFja2V0X0tpbmQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuRGF0YVBhY2tldC5LaW5kXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlJFTElBQkxFXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIkxPU1NZXCIgfVxuICBdXG4pO1xuY29uc3QgQWN0aXZlU3BlYWtlclVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzcGVha2Vyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3BlYWtlckluZm8sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFNwZWFrZXJJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TcGVha2VySW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwibGV2ZWxcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAyXG4gICAgICAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiYWN0aXZlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgVXNlclBhY2tldCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXNlclBhY2tldFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInBheWxvYWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxMlxuICAgICAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xuICAgIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJkZXN0aW5hdGlvbl9zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ0b3BpY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImlkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwic3RhcnRfdGltZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJlbmRfdGltZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA0LCBvcHQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogMTEsXG4gICAgICBuYW1lOiBcIm5vbmNlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTJcbiAgICAgIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTaXBEVE1GID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TaXBEVE1GXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiY29kZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcImRpZ2l0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBUcmFuc2NyaXB0aW9uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5UcmFuc2NyaXB0aW9uXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwidHJhbnNjcmliZWRfcGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInRyYWNrX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic2VnbWVudHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYW5zY3JpcHRpb25TZWdtZW50LCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBUcmFuc2NyaXB0aW9uU2VnbWVudCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhbnNjcmlwdGlvblNlZ21lbnRcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwidGV4dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwic3RhcnRfdGltZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiZW5kX3RpbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA0XG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcImZpbmFsXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwibGFuZ3VhZ2VcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IENoYXRNZXNzYWdlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5DaGF0TWVzc2FnZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImlkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImVkaXRfdGltZXN0YW1wXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDMsIG9wdDogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJtZXNzYWdlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJkZWxldGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiZ2VuZXJhdGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgUnBjUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUnBjUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImlkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJtZXRob2RcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInBheWxvYWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInJlc3BvbnNlX3RpbWVvdXRfbXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgUnBjQWNrID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5ScGNBY2tcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBScGNSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUnBjUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGF5bG9hZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvbmVvZjogXCJ2YWx1ZVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJlcnJvclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUnBjRXJyb3IsIG9uZW9mOiBcInZhbHVlXCIgfVxuICBdXG4pO1xuY29uc3QgUnBjRXJyb3IgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJwY0Vycm9yXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiY29kZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFBhcnRpY2lwYW50VHJhY2tzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5QYXJ0aWNpcGFudFRyYWNrc1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRyYWNrX3NpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgU2VydmVySW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU2VydmVySW5mb1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJlZGl0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2VydmVySW5mb19FZGl0aW9uKSB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJwcm90b2NvbFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJyZWdpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcIm5vZGVfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcImRlYnVnX2luZm9cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDcsXG4gICAgICBuYW1lOiBcImFnZW50X3Byb3RvY29sXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFNlcnZlckluZm9fRWRpdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TZXJ2ZXJJbmZvLkVkaXRpb25cIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiU3RhbmRhcmRcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiQ2xvdWRcIiB9XG4gIF1cbik7XG5jb25zdCBDbGllbnRJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5DbGllbnRJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInNka1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudEluZm9fU0RLKSB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJwcm90b2NvbFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJvc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwib3NfdmVyc2lvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiZGV2aWNlX21vZGVsXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJicm93c2VyXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJicm93c2VyX3ZlcnNpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcImFkZHJlc3NcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEwLFxuICAgICAgbmFtZTogXCJuZXR3b3JrXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwib3RoZXJfc2Rrc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgQ2xpZW50SW5mb19TREsgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuQ2xpZW50SW5mby5TREtcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJKU1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJTV0lGVFwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJBTkRST0lEXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIkZMVVRURVJcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiR09cIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiVU5JVFlcIiB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiUkVBQ1RfTkFUSVZFXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcIlJVU1RcIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiUFlUSE9OXCIgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJDUFBcIiB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcIlVOSVRZX1dFQlwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiTk9ERVwiIH1cbiAgXVxuKTtcbmNvbnN0IENsaWVudENvbmZpZ3VyYXRpb24gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidmlkZW9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvQ29uZmlndXJhdGlvbiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwic2NyZWVuXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBWaWRlb0NvbmZpZ3VyYXRpb24gfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInJlc3VtZV9jb25uZWN0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImRpc2FibGVkX2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRGlzYWJsZWRDb2RlY3MgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImZvcmNlX3JlbGF5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2xpZW50Q29uZmlnU2V0dGluZykgfVxuICBdXG4pO1xuY29uc3QgVmlkZW9Db25maWd1cmF0aW9uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5WaWRlb0NvbmZpZ3VyYXRpb25cIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaGFyZHdhcmVfZW5jb2RlclwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpIH1cbiAgXVxuKTtcbmNvbnN0IERpc2FibGVkQ29kZWNzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EaXNhYmxlZENvZGVjc1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJjb2RlY3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvZGVjLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicHVibGlzaFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQ29kZWMsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFJUUERyaWZ0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5SVFBEcmlmdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzdGFydF90aW1lXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImVuZF90aW1lXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiZHVyYXRpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxXG4gICAgICAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInN0YXJ0X3RpbWVzdGFtcFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwiZW5kX3RpbWVzdGFtcFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwicnRwX2Nsb2NrX3RpY2tzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJkcmlmdF9zYW1wbGVzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcImRyaWZ0X21zXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA5LFxuICAgICAgbmFtZTogXCJjbG9ja19yYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBSVFBTdGF0cyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUlRQU3RhdHNcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwic3RhcnRfdGltZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJlbmRfdGltZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImR1cmF0aW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJwYWNrZXRzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwicGFja2V0X3JhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxXG4gICAgICAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcImJ5dGVzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzOSxcbiAgICAgIG5hbWU6IFwiaGVhZGVyX2J5dGVzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJiaXRyYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJwYWNrZXRzX2xvc3RcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA5LFxuICAgICAgbmFtZTogXCJwYWNrZXRfbG9zc19yYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwicGFja2V0X2xvc3NfcGVyY2VudGFnZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDJcbiAgICAgIC8qIFNjYWxhclR5cGUuRkxPQVQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwicGFja2V0c19kdXBsaWNhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMixcbiAgICAgIG5hbWU6IFwicGFja2V0X2R1cGxpY2F0ZV9yYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMyxcbiAgICAgIG5hbWU6IFwiYnl0ZXNfZHVwbGljYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0MCxcbiAgICAgIG5hbWU6IFwiaGVhZGVyX2J5dGVzX2R1cGxpY2F0ZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTQsXG4gICAgICBuYW1lOiBcImJpdHJhdGVfZHVwbGljYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxNSxcbiAgICAgIG5hbWU6IFwicGFja2V0c19wYWRkaW5nXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTYsXG4gICAgICBuYW1lOiBcInBhY2tldF9wYWRkaW5nX3JhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxXG4gICAgICAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDE3LFxuICAgICAgbmFtZTogXCJieXRlc19wYWRkaW5nXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0MSxcbiAgICAgIG5hbWU6IFwiaGVhZGVyX2J5dGVzX3BhZGRpbmdcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA0XG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDE4LFxuICAgICAgbmFtZTogXCJiaXRyYXRlX3BhZGRpbmdcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxXG4gICAgICAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDE5LFxuICAgICAgbmFtZTogXCJwYWNrZXRzX291dF9vZl9vcmRlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIwLFxuICAgICAgbmFtZTogXCJmcmFtZXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyMSxcbiAgICAgIG5hbWU6IFwiZnJhbWVfcmF0ZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDFcbiAgICAgIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMjIsXG4gICAgICBuYW1lOiBcImppdHRlcl9jdXJyZW50XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMVxuICAgICAgLyogU2NhbGFyVHlwZS5ET1VCTEUgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyMyxcbiAgICAgIG5hbWU6IFwiaml0dGVyX21heFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDFcbiAgICAgIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG4gICAgfSxcbiAgICB7IG5vOiAyNCwgbmFtZTogXCJnYXBfaGlzdG9ncmFtXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDUsIFY6IHtcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9IH0sXG4gICAge1xuICAgICAgbm86IDI1LFxuICAgICAgbmFtZTogXCJuYWNrc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDM3LFxuICAgICAgbmFtZTogXCJuYWNrX2Fja3NcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyNixcbiAgICAgIG5hbWU6IFwibmFja19taXNzZXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzOCxcbiAgICAgIG5hbWU6IFwibmFja19yZXBlYXRlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDI3LFxuICAgICAgbmFtZTogXCJwbGlzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7IG5vOiAyOCwgbmFtZTogXCJsYXN0X3BsaVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAge1xuICAgICAgbm86IDI5LFxuICAgICAgbmFtZTogXCJmaXJzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7IG5vOiAzMCwgbmFtZTogXCJsYXN0X2ZpclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAge1xuICAgICAgbm86IDMxLFxuICAgICAgbmFtZTogXCJydHRfY3VycmVudFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMyLFxuICAgICAgbmFtZTogXCJydHRfbWF4XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMzMsXG4gICAgICBuYW1lOiBcImtleV9mcmFtZXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHsgbm86IDM0LCBuYW1lOiBcImxhc3Rfa2V5X2ZyYW1lXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUaW1lc3RhbXAgfSxcbiAgICB7XG4gICAgICBubzogMzUsXG4gICAgICBuYW1lOiBcImxheWVyX2xvY2tfcGxpc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAgeyBubzogMzYsIG5hbWU6IFwibGFzdF9sYXllcl9sb2NrX3BsaVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVGltZXN0YW1wIH0sXG4gICAgeyBubzogNDQsIG5hbWU6IFwicGFja2V0X2RyaWZ0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSVFBEcmlmdCB9LFxuICAgIHsgbm86IDQ1LCBuYW1lOiBcIm50cF9yZXBvcnRfZHJpZnRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJUUERyaWZ0IH0sXG4gICAgeyBubzogNDYsIG5hbWU6IFwicmViYXNlZF9yZXBvcnRfZHJpZnRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJUUERyaWZ0IH0sXG4gICAgeyBubzogNDcsIG5hbWU6IFwicmVjZWl2ZWRfcmVwb3J0X2RyaWZ0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSVFBEcmlmdCB9XG4gIF1cbik7XG5jb25zdCBSVENQU2VuZGVyUmVwb3J0U3RhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJUQ1BTZW5kZXJSZXBvcnRTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInJ0cF90aW1lc3RhbXBcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJydHBfdGltZXN0YW1wX2V4dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwibnRwX3RpbWVzdGFtcFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwiYXRfYWRqdXN0ZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwicGFja2V0c1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDcsXG4gICAgICBuYW1lOiBcIm9jdGV0c1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgUlRQRm9yd2FyZGVyU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJUUEZvcndhcmRlclN0YXRlXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwic3RhcnRlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInJlZmVyZW5jZV9sYXllcl9zcGF0aWFsXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInByZV9zdGFydF90aW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcImV4dF9maXJzdF90aW1lc3RhbXBcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA0XG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcImR1bW15X3N0YXJ0X3RpbWVzdGFtcF9vZmZzZXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA0XG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xuICAgIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJydHBfbXVuZ2VyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSVFBNdW5nZXJTdGF0ZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwidnA4X211bmdlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVlA4TXVuZ2VyU3RhdGUsIG9uZW9mOiBcImNvZGVjX211bmdlclwiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJzZW5kZXJfcmVwb3J0X3N0YXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSVENQU2VuZGVyUmVwb3J0U3RhdGUsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFJUUE11bmdlclN0YXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5SVFBNdW5nZXJTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImV4dF9sYXN0X3NlcXVlbmNlX251bWJlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiZXh0X3NlY29uZF9sYXN0X3NlcXVlbmNlX251bWJlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDRcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiZXh0X2xhc3RfdGltZXN0YW1wXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJleHRfc2Vjb25kX2xhc3RfdGltZXN0YW1wXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJsYXN0X21hcmtlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcInNlY29uZF9sYXN0X21hcmtlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFZQOE11bmdlclN0YXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5WUDhNdW5nZXJTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImV4dF9sYXN0X3BpY3R1cmVfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwicGljdHVyZV9pZF91c2VkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwibGFzdF90bDBfcGljX2lkeFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInRsMF9waWNfaWR4X3VzZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJ0aWRfdXNlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcImxhc3Rfa2V5X2lkeFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDcsXG4gICAgICBuYW1lOiBcImtleV9pZHhfdXNlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFRpbWVkVmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVGltZWRWZXJzaW9uXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwidW5peF9taWNyb1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJ0aWNrc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBEYXRhU3RyZWFtID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EYXRhU3RyZWFtXCIsXG4gIFtdXG4pO1xuY29uc3QgRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkRhdGFTdHJlYW0uT3BlcmF0aW9uVHlwZVwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJDUkVBVEVcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiVVBEQVRFXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkRFTEVURVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJSRUFDVElPTlwiIH1cbiAgXVxuKTtcbmNvbnN0IERhdGFTdHJlYW1fVGV4dEhlYWRlciA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGF0YVN0cmVhbS5UZXh0SGVhZGVyXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIm9wZXJhdGlvbl90eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlKSB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInJlcGx5X3RvX3N0cmVhbV9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImF0dGFjaGVkX3N0cmVhbV9pZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwiZ2VuZXJhdGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfVxuICBdLFxuICB7IGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX1RleHRIZWFkZXJcIiB9XG4pO1xuY29uc3QgRGF0YVN0cmVhbV9CeXRlSGVhZGVyID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EYXRhU3RyZWFtLkJ5dGVIZWFkZXJcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF0sXG4gIHsgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fQnl0ZUhlYWRlclwiIH1cbik7XG5jb25zdCBEYXRhU3RyZWFtX0hlYWRlciA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGF0YVN0cmVhbS5IZWFkZXJcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJzdHJlYW1faWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJ0b3BpY1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwibWltZV90eXBlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwidG90YWxfbGVuZ3RoXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDQsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiZW5jcnlwdGlvbl90eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jcnlwdGlvbl9UeXBlKSB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJ0ZXh0X2hlYWRlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRGF0YVN0cmVhbV9UZXh0SGVhZGVyLCBvbmVvZjogXCJjb250ZW50X2hlYWRlclwiIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwiYnl0ZV9oZWFkZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IERhdGFTdHJlYW1fQnl0ZUhlYWRlciwgb25lb2Y6IFwiY29udGVudF9oZWFkZXJcIiB9XG4gIF0sXG4gIHsgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fSGVhZGVyXCIgfVxuKTtcbmNvbnN0IERhdGFTdHJlYW1fQ2h1bmsgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkRhdGFTdHJlYW0uQ2h1bmtcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJzdHJlYW1faWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImNodW5rX2luZGV4XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNFxuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJjb250ZW50XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTJcbiAgICAgIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJpdlwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAxMiwgb3B0OiB0cnVlIH1cbiAgXSxcbiAgeyBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9DaHVua1wiIH1cbik7XG5jb25zdCBEYXRhU3RyZWFtX1RyYWlsZXIgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkRhdGFTdHJlYW0uVHJhaWxlclwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInN0cmVhbV9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwicmVhc29uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH1cbiAgXSxcbiAgeyBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9UcmFpbGVyXCIgfVxuKTtcblxuY29uc3QgSm9iVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5Kb2JUeXBlXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIkpUX1JPT01cIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiSlRfUFVCTElTSEVSXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkpUX1BBUlRJQ0lQQU5UXCIgfVxuICBdXG4pO1xuY29uc3QgV29ya2VyU3RhdHVzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LldvcmtlclN0YXR1c1wiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJXU19BVkFJTEFCTEVcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiV1NfRlVMTFwiIH1cbiAgXVxuKTtcbmNvbnN0IEpvYlN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5Kb2JTdGF0dXNcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiSlNfUEVORElOR1wiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJKU19SVU5OSU5HXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkpTX1NVQ0NFU1NcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiSlNfRkFJTEVEXCIgfVxuICBdXG4pO1xuY29uc3QgSm9iID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Kb2JcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOSxcbiAgICAgIG5hbWU6IFwiZGlzcGF0Y2hfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoSm9iVHlwZSkgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInJvb21cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb20gfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInBhcnRpY2lwYW50XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEluZm8sIG9wdDogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJuYW1lc3BhY2VcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJhZ2VudF9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwic3RhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpvYlN0YXRlIH1cbiAgXVxuKTtcbmNvbnN0IEpvYlN0YXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Kb2JTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzdGF0dXNcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShKb2JTdGF0dXMpIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJzdGFydGVkX2F0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcImVuZGVkX2F0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcInVwZGF0ZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFdvcmtlck1lc3NhZ2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lldvcmtlck1lc3NhZ2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicmVnaXN0ZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlZ2lzdGVyV29ya2VyUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJhdmFpbGFiaWxpdHlcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEF2YWlsYWJpbGl0eVJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInVwZGF0ZV93b3JrZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVwZGF0ZVdvcmtlclN0YXR1cywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJ1cGRhdGVfam9iXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVKb2JTdGF0dXMsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwicGluZ1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogV29ya2VyUGluZywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJzaW11bGF0ZV9qb2JcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNpbXVsYXRlSm9iUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJtaWdyYXRlX2pvYlwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTWlncmF0ZUpvYlJlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9XG4gIF1cbik7XG5jb25zdCBTZXJ2ZXJNZXNzYWdlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TZXJ2ZXJNZXNzYWdlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJlZ2lzdGVyXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSZWdpc3RlcldvcmtlclJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImF2YWlsYWJpbGl0eVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQXZhaWxhYmlsaXR5UmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJhc3NpZ25tZW50XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKb2JBc3NpZ25tZW50LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInRlcm1pbmF0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKb2JUZXJtaW5hdGlvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJwb25nXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBXb3JrZXJQb25nLCBvbmVvZjogXCJtZXNzYWdlXCIgfVxuICBdXG4pO1xuY29uc3QgU2ltdWxhdGVKb2JSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TaW11bGF0ZUpvYlJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHlwZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEpvYlR5cGUpIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJyb29tXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSb29tIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwYXJ0aWNpcGFudFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRJbmZvIH1cbiAgXVxuKTtcbmNvbnN0IFdvcmtlclBpbmcgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LldvcmtlclBpbmdcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgV29ya2VyUG9uZyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuV29ya2VyUG9uZ1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImxhc3RfdGltZXN0YW1wXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBSZWdpc3RlcldvcmtlclJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJlZ2lzdGVyV29ya2VyUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoSm9iVHlwZSkgfSxcbiAgICB7XG4gICAgICBubzogOCxcbiAgICAgIG5hbWU6IFwiYWdlbnRfbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwidmVyc2lvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwicGluZ19pbnRlcnZhbFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJuYW1lc3BhY2VcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJhbGxvd2VkX3Blcm1pc3Npb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24gfVxuICBdXG4pO1xuY29uc3QgUmVnaXN0ZXJXb3JrZXJSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUmVnaXN0ZXJXb3JrZXJSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcIndvcmtlcl9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInNlcnZlcl9pbmZvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXJ2ZXJJbmZvIH1cbiAgXVxuKTtcbmNvbnN0IE1pZ3JhdGVKb2JSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5NaWdyYXRlSm9iUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMiwgbmFtZTogXCJqb2JfaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IEF2YWlsYWJpbGl0eVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkF2YWlsYWJpbGl0eVJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiam9iXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKb2IgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwicmVzdW1pbmdcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBBdmFpbGFiaWxpdHlSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQXZhaWxhYmlsaXR5UmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJqb2JfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImF2YWlsYWJsZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInN1cHBvcnRzX3Jlc3VtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA2LFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9tZXRhZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInBhcnRpY2lwYW50X2F0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSwgVjoge1xuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSB9XG4gIF1cbik7XG5jb25zdCBVcGRhdGVKb2JTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZUpvYlN0YXR1c1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImpvYl9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInN0YXR1c1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEpvYlN0YXR1cykgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFVwZGF0ZVdvcmtlclN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlV29ya2VyU3RhdHVzXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInN0YXR1c1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFdvcmtlclN0YXR1cyksIG9wdDogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJsb2FkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMlxuICAgICAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcImpvYl9jb3VudFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IEpvYkFzc2lnbm1lbnQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkpvYkFzc2lnbm1lbnRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiam9iXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBKb2IgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInVybFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvcHQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwidG9rZW5cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IEpvYlRlcm1pbmF0aW9uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Kb2JUZXJtaW5hdGlvblwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImpvYl9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuXG5jb25zdCBDcmVhdGVBZ2VudERpc3BhdGNoUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQ3JlYXRlQWdlbnREaXNwYXRjaFJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJhZ2VudF9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJyb29tXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgUm9vbUFnZW50RGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJvb21BZ2VudERpc3BhdGNoXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiYWdlbnRfbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwibWV0YWRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IERlbGV0ZUFnZW50RGlzcGF0Y2hSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EZWxldGVBZ2VudERpc3BhdGNoUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImRpc3BhdGNoX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJyb29tXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBMaXN0QWdlbnREaXNwYXRjaFJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lkxpc3RBZ2VudERpc3BhdGNoUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImRpc3BhdGNoX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJyb29tXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBMaXN0QWdlbnREaXNwYXRjaFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5MaXN0QWdlbnREaXNwYXRjaFJlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImFnZW50X2Rpc3BhdGNoZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEFnZW50RGlzcGF0Y2gsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IEFnZW50RGlzcGF0Y2ggPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkFnZW50RGlzcGF0Y2hcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiYWdlbnRfbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwicm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwibWV0YWRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzdGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWdlbnREaXNwYXRjaFN0YXRlIH1cbiAgXVxuKTtcbmNvbnN0IEFnZW50RGlzcGF0Y2hTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQWdlbnREaXNwYXRjaFN0YXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImpvYnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpvYiwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiY3JlYXRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJkZWxldGVkX2F0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH1cbiAgXVxuKTtcblxuY29uc3QgRW5jb2RlZEZpbGVUeXBlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkVuY29kZWRGaWxlVHlwZVwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJERUZBVUxUX0ZJTEVUWVBFXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIk1QNFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJPR0dcIiB9XG4gIF1cbik7XG5jb25zdCBTZWdtZW50ZWRGaWxlUHJvdG9jb2wgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuU2VnbWVudGVkRmlsZVByb3RvY29sXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIkRFRkFVTFRfU0VHTUVOVEVEX0ZJTEVfUFJPVE9DT0xcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiSExTX1BST1RPQ09MXCIgfVxuICBdXG4pO1xuY29uc3QgU2VnbWVudGVkRmlsZVN1ZmZpeCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TZWdtZW50ZWRGaWxlU3VmZml4XCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIklOREVYXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlRJTUVTVEFNUFwiIH1cbiAgXVxuKTtcbmNvbnN0IEltYWdlRmlsZVN1ZmZpeCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5JbWFnZUZpbGVTdWZmaXhcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiSU1BR0VfU1VGRklYX0lOREVYXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIklNQUdFX1NVRkZJWF9USU1FU1RBTVBcIiB9XG4gIF1cbik7XG5jb25zdCBTdHJlYW1Qcm90b2NvbCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TdHJlYW1Qcm90b2NvbFwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJERUZBVUxUX1BST1RPQ09MXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlJUTVBcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiU1JUXCIgfVxuICBdXG4pO1xuY29uc3QgQXVkaW9NaXhpbmcgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuQXVkaW9NaXhpbmdcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiREVGQVVMVF9NSVhJTkdcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiRFVBTF9DSEFOTkVMX0FHRU5UXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkRVQUxfQ0hBTk5FTF9BTFRFUk5BVEVcIiB9XG4gIF1cbik7XG5jb25zdCBFbmNvZGluZ09wdGlvbnNQcmVzZXQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuRW5jb2RpbmdPcHRpb25zUHJlc2V0XCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIkgyNjRfNzIwUF8zMFwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJIMjY0XzcyMFBfNjBcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiSDI2NF8xMDgwUF8zMFwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJIMjY0XzEwODBQXzYwXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIlBPUlRSQUlUX0gyNjRfNzIwUF8zMFwiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJQT1JUUkFJVF9IMjY0XzcyMFBfNjBcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiUE9SVFJBSVRfSDI2NF8xMDgwUF8zMFwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJQT1JUUkFJVF9IMjY0XzEwODBQXzYwXCIgfVxuICBdXG4pO1xuY29uc3QgRWdyZXNzU3RhdHVzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkVncmVzc1N0YXR1c1wiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJFR1JFU1NfU1RBUlRJTkdcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiRUdSRVNTX0FDVElWRVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJFR1JFU1NfRU5ESU5HXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIkVHUkVTU19DT01QTEVURVwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJFR1JFU1NfRkFJTEVEXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIkVHUkVTU19BQk9SVEVEXCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcIkVHUkVTU19MSU1JVF9SRUFDSEVEXCIgfVxuICBdXG4pO1xuY29uc3QgRWdyZXNzU291cmNlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5FZ3Jlc3NTb3VyY2VUeXBlXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIkVHUkVTU19TT1VSQ0VfVFlQRV9XRUJcIiwgbG9jYWxOYW1lOiBcIldFQlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJFR1JFU1NfU09VUkNFX1RZUEVfU0RLXCIsIGxvY2FsTmFtZTogXCJTREtcIiB9XG4gIF1cbik7XG5jb25zdCBSb29tQ29tcG9zaXRlRWdyZXNzUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUm9vbUNvbXBvc2l0ZUVncmVzc1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJyb29tX25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImxheW91dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiYXVkaW9fb25seVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwiYXVkaW9fbWl4aW5nXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9NaXhpbmcpIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInZpZGVvX29ubHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJjdXN0b21fYmFzZV91cmxcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJmaWxlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBFbmNvZGVkRmlsZU91dHB1dCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInN0cmVhbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3RyZWFtT3V0cHV0LCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInNlZ21lbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwicHJlc2V0XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jb2RpbmdPcHRpb25zUHJlc2V0KSwgb25lb2Y6IFwib3B0aW9uc1wiIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJhZHZhbmNlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW5jb2RpbmdPcHRpb25zLCBvbmVvZjogXCJvcHRpb25zXCIgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJmaWxlX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVuY29kZWRGaWxlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInN0cmVhbV9vdXRwdXRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJlYW1PdXRwdXQsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwic2VnbWVudF9vdXRwdXRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcImltYWdlX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEltYWdlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBXZWJFZ3Jlc3NSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5XZWJFZ3Jlc3NSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwidXJsXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJhdWRpb19vbmx5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwidmlkZW9fb25seVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEyLFxuICAgICAgbmFtZTogXCJhd2FpdF9zdGFydF9zaWduYWxcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiZmlsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW5jb2RlZEZpbGVPdXRwdXQsIG9uZW9mOiBcIm91dHB1dFwiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzdHJlYW1cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN0cmVhbU91dHB1dCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInNlZ21lbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwicHJlc2V0XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jb2RpbmdPcHRpb25zUHJlc2V0KSwgb25lb2Y6IFwib3B0aW9uc1wiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJhZHZhbmNlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW5jb2RpbmdPcHRpb25zLCBvbmVvZjogXCJvcHRpb25zXCIgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImZpbGVfb3V0cHV0c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW5jb2RlZEZpbGVPdXRwdXQsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwic3RyZWFtX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN0cmVhbU91dHB1dCwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJzZWdtZW50X291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlZ21lbnRlZEZpbGVPdXRwdXQsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwiaW1hZ2Vfb3V0cHV0c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSW1hZ2VPdXRwdXQsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFBhcnRpY2lwYW50RWdyZXNzUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUGFydGljaXBhbnRFZ3Jlc3NSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbV9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJpZGVudGl0eVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwic2NyZWVuX3NoYXJlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInByZXNldFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY29kaW5nT3B0aW9uc1ByZXNldCksIG9uZW9mOiBcIm9wdGlvbnNcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiYWR2YW5jZWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVuY29kaW5nT3B0aW9ucywgb25lb2Y6IFwib3B0aW9uc1wiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJmaWxlX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVuY29kZWRGaWxlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwic3RyZWFtX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN0cmVhbU91dHB1dCwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInNlZ21lbnRfb3V0cHV0c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2VnbWVudGVkRmlsZU91dHB1dCwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImltYWdlX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEltYWdlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBUcmFja0NvbXBvc2l0ZUVncmVzc1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlRyYWNrQ29tcG9zaXRlRWdyZXNzUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInJvb21fbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiYXVkaW9fdHJhY2tfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInZpZGVvX3RyYWNrX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiZmlsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW5jb2RlZEZpbGVPdXRwdXQsIG9uZW9mOiBcIm91dHB1dFwiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzdHJlYW1cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN0cmVhbU91dHB1dCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInNlZ21lbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwicHJlc2V0XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jb2RpbmdPcHRpb25zUHJlc2V0KSwgb25lb2Y6IFwib3B0aW9uc1wiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJhZHZhbmNlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRW5jb2RpbmdPcHRpb25zLCBvbmVvZjogXCJvcHRpb25zXCIgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJmaWxlX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVuY29kZWRGaWxlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInN0cmVhbV9vdXRwdXRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJlYW1PdXRwdXQsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwic2VnbWVudF9vdXRwdXRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcImltYWdlX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEltYWdlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBUcmFja0VncmVzc1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlRyYWNrRWdyZXNzUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInJvb21fbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwidHJhY2tfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJmaWxlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEaXJlY3RGaWxlT3V0cHV0LCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwid2Vic29ja2V0X3VybFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvbmVvZjogXCJvdXRwdXRcIiB9XG4gIF1cbik7XG5jb25zdCBFbmNvZGVkRmlsZU91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRW5jb2RlZEZpbGVPdXRwdXRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiZmlsZV90eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRW5jb2RlZEZpbGVUeXBlKSB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJmaWxlcGF0aFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiZGlzYWJsZV9tYW5pZmVzdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJzM1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUzNVcGxvYWQsIG9uZW9mOiBcIm91dHB1dFwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJnY3BcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEdDUFVwbG9hZCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImF6dXJlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBBenVyZUJsb2JVcGxvYWQsIG9uZW9mOiBcIm91dHB1dFwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJhbGlPU1NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEFsaU9TU1VwbG9hZCwgb25lb2Y6IFwib3V0cHV0XCIgfVxuICBdXG4pO1xuY29uc3QgU2VnbWVudGVkRmlsZU91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU2VnbWVudGVkRmlsZU91dHB1dFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwcm90b2NvbFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlZ21lbnRlZEZpbGVQcm90b2NvbCkgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiZmlsZW5hbWVfcHJlZml4XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJwbGF5bGlzdF9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwibGl2ZV9wbGF5bGlzdF9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJzZWdtZW50X2R1cmF0aW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJmaWxlbmFtZV9zdWZmaXhcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTZWdtZW50ZWRGaWxlU3VmZml4KSB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJkaXNhYmxlX21hbmlmZXN0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInMzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTM1VwbG9hZCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImdjcFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogR0NQVXBsb2FkLCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiYXp1cmVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEF6dXJlQmxvYlVwbG9hZCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImFsaU9TU1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWxpT1NTVXBsb2FkLCBvbmVvZjogXCJvdXRwdXRcIiB9XG4gIF1cbik7XG5jb25zdCBEaXJlY3RGaWxlT3V0cHV0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EaXJlY3RGaWxlT3V0cHV0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiZmlsZXBhdGhcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcImRpc2FibGVfbWFuaWZlc3RcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiczNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFMzVXBsb2FkLCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiZ2NwXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBHQ1BVcGxvYWQsIG9uZW9mOiBcIm91dHB1dFwiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJhenVyZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQXp1cmVCbG9iVXBsb2FkLCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiYWxpT1NTXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBBbGlPU1NVcGxvYWQsIG9uZW9mOiBcIm91dHB1dFwiIH1cbiAgXVxuKTtcbmNvbnN0IEltYWdlT3V0cHV0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5JbWFnZU91dHB1dFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImNhcHR1cmVfaW50ZXJ2YWxcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJ3aWR0aFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJoZWlnaHRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiZmlsZW5hbWVfcHJlZml4XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZmlsZW5hbWVfc3VmZml4XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoSW1hZ2VGaWxlU3VmZml4KSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiaW1hZ2VfY29kZWNcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShJbWFnZUNvZGVjKSB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJkaXNhYmxlX21hbmlmZXN0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInMzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTM1VwbG9hZCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImdjcFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogR0NQVXBsb2FkLCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImF6dXJlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBBenVyZUJsb2JVcGxvYWQsIG9uZW9mOiBcIm91dHB1dFwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwiYWxpT1NTXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBBbGlPU1NVcGxvYWQsIG9uZW9mOiBcIm91dHB1dFwiIH1cbiAgXVxuKTtcbmNvbnN0IFMzVXBsb2FkID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TM1VwbG9hZFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImFjY2Vzc19rZXlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInNlY3JldFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTEsXG4gICAgICBuYW1lOiBcInNlc3Npb25fdG9rZW5cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInJlZ2lvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiZW5kcG9pbnRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcImJ1Y2tldFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiZm9yY2VfcGF0aF9zdHlsZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJtZXRhZGF0YVwiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcInRhZ2dpbmdcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcImNvbnRlbnRfZGlzcG9zaXRpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwicHJveHlcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFByb3h5Q29uZmlnIH1cbiAgXVxuKTtcbmNvbnN0IEdDUFVwbG9hZCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuR0NQVXBsb2FkXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiY3JlZGVudGlhbHNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImJ1Y2tldFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInByb3h5XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQcm94eUNvbmZpZyB9XG4gIF1cbik7XG5jb25zdCBBenVyZUJsb2JVcGxvYWQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkF6dXJlQmxvYlVwbG9hZFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImFjY291bnRfbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiYWNjb3VudF9rZXlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImNvbnRhaW5lcl9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBBbGlPU1NVcGxvYWQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkFsaU9TU1VwbG9hZFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImFjY2Vzc19rZXlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInNlY3JldFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwicmVnaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJlbmRwb2ludFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwiYnVja2V0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBQcm94eUNvbmZpZyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUHJveHlDb25maWdcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ1cmxcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInVzZXJuYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJwYXNzd29yZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgU3RyZWFtT3V0cHV0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TdHJlYW1PdXRwdXRcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicHJvdG9jb2xcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdHJlYW1Qcm90b2NvbCkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInVybHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgRW5jb2RpbmdPcHRpb25zID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5FbmNvZGluZ09wdGlvbnNcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ3aWR0aFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJoZWlnaHRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiZGVwdGhcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiZnJhbWVyYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJhdWRpb19jb2RlY1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvQ29kZWMpIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcImF1ZGlvX2JpdHJhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTEsXG4gICAgICBuYW1lOiBcImF1ZGlvX3F1YWxpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwiYXVkaW9fZnJlcXVlbmN5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJ2aWRlb19jb2RlY1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvQ29kZWMpIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcInZpZGVvX2JpdHJhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTIsXG4gICAgICBuYW1lOiBcInZpZGVvX3F1YWxpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA1XG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTAsXG4gICAgICBuYW1lOiBcImtleV9mcmFtZV9pbnRlcnZhbFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDFcbiAgICAgIC8qIFNjYWxhclR5cGUuRE9VQkxFICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgVXBkYXRlTGF5b3V0UmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlTGF5b3V0UmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImVncmVzc19pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwibGF5b3V0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBVcGRhdGVTdHJlYW1SZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5VcGRhdGVTdHJlYW1SZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiZWdyZXNzX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiYWRkX291dHB1dF91cmxzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJyZW1vdmVfb3V0cHV0X3VybHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgTGlzdEVncmVzc1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lkxpc3RFZ3Jlc3NSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbV9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJlZ3Jlc3NfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImFjdGl2ZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IExpc3RFZ3Jlc3NSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdEVncmVzc1Jlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIml0ZW1zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBFZ3Jlc3NJbmZvLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBTdG9wRWdyZXNzUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU3RvcEVncmVzc1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJlZ3Jlc3NfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IEVncmVzc0luZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkVncmVzc0luZm9cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJlZ3Jlc3NfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInJvb21faWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEzLFxuICAgICAgbmFtZTogXCJyb29tX25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMjYsIG5hbWU6IFwic291cmNlX3R5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFZ3Jlc3NTb3VyY2VUeXBlKSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwic3RhdHVzXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRWdyZXNzU3RhdHVzKSB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwic3RhcnRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwiZW5kZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTgsXG4gICAgICBuYW1lOiBcInVwZGF0ZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMjEsXG4gICAgICBuYW1lOiBcImRldGFpbHNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyMixcbiAgICAgIG5hbWU6IFwiZXJyb3JfY29kZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicm9vbV9jb21wb3NpdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb21Db21wb3NpdGVFZ3Jlc3NSZXF1ZXN0LCBvbmVvZjogXCJyZXF1ZXN0XCIgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJ3ZWJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFdlYkVncmVzc1JlcXVlc3QsIG9uZW9mOiBcInJlcXVlc3RcIiB9LFxuICAgIHsgbm86IDE5LCBuYW1lOiBcInBhcnRpY2lwYW50XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEVncmVzc1JlcXVlc3QsIG9uZW9mOiBcInJlcXVlc3RcIiB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwidHJhY2tfY29tcG9zaXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja0NvbXBvc2l0ZUVncmVzc1JlcXVlc3QsIG9uZW9mOiBcInJlcXVlc3RcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwidHJhY2tcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrRWdyZXNzUmVxdWVzdCwgb25lb2Y6IFwicmVxdWVzdFwiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJzdHJlYW1cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN0cmVhbUluZm9MaXN0LCBvbmVvZjogXCJyZXN1bHRcIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiZmlsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRmlsZUluZm8sIG9uZW9mOiBcInJlc3VsdFwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwic2VnbWVudHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlZ21lbnRzSW5mbywgb25lb2Y6IFwicmVzdWx0XCIgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJzdHJlYW1fcmVzdWx0c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3RyZWFtSW5mbywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJmaWxlX3Jlc3VsdHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEZpbGVJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcInNlZ21lbnRfcmVzdWx0c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2VnbWVudHNJbmZvLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIwLCBuYW1lOiBcImltYWdlX3Jlc3VsdHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEltYWdlc0luZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDIzLFxuICAgICAgbmFtZTogXCJtYW5pZmVzdF9sb2NhdGlvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMjUsXG4gICAgICBuYW1lOiBcImJhY2t1cF9zdG9yYWdlX3VzZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTdHJlYW1JbmZvTGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU3RyZWFtSW5mb0xpc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaW5mb1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3RyZWFtSW5mbywgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgU3RyZWFtSW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU3RyZWFtSW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInVybFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwic3RhcnRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJlbmRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJkdXJhdGlvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwic3RhdHVzXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtSW5mb19TdGF0dXMpIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTdHJlYW1JbmZvX1N0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TdHJlYW1JbmZvLlN0YXR1c1wiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJBQ1RJVkVcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiRklOSVNIRURcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiRkFJTEVEXCIgfVxuICBdXG4pO1xuY29uc3QgRmlsZUluZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkZpbGVJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiZmlsZW5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInN0YXJ0ZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiZW5kZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiZHVyYXRpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwic2l6ZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJsb2NhdGlvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgU2VnbWVudHNJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TZWdtZW50c0luZm9cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJwbGF5bGlzdF9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJsaXZlX3BsYXlsaXN0X25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImR1cmF0aW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInNpemVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwicGxheWxpc3RfbG9jYXRpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcImxpdmVfcGxheWxpc3RfbG9jYXRpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcInNlZ21lbnRfY291bnRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwic3RhcnRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJlbmRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBJbWFnZXNJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5JbWFnZXNJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiZmlsZW5hbWVfcHJlZml4XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJpbWFnZV9jb3VudFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJzdGFydGVkX2F0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImVuZGVkX2F0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IEF1dG9QYXJ0aWNpcGFudEVncmVzcyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQXV0b1BhcnRpY2lwYW50RWdyZXNzXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInByZXNldFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY29kaW5nT3B0aW9uc1ByZXNldCksIG9uZW9mOiBcIm9wdGlvbnNcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiYWR2YW5jZWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVuY29kaW5nT3B0aW9ucywgb25lb2Y6IFwib3B0aW9uc1wiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJmaWxlX291dHB1dHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEVuY29kZWRGaWxlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwic2VnbWVudF9vdXRwdXRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZWdtZW50ZWRGaWxlT3V0cHV0LCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBBdXRvVHJhY2tFZ3Jlc3MgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkF1dG9UcmFja0VncmVzc1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImZpbGVwYXRoXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJkaXNhYmxlX21hbmlmZXN0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInMzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTM1VwbG9hZCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImdjcFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogR0NQVXBsb2FkLCBvbmVvZjogXCJvdXRwdXRcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiYXp1cmVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEF6dXJlQmxvYlVwbG9hZCwgb25lb2Y6IFwib3V0cHV0XCIgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImFsaU9TU1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWxpT1NTVXBsb2FkLCBvbmVvZjogXCJvdXRwdXRcIiB9XG4gIF1cbik7XG5cbmNvbnN0IEluZ3Jlc3NJbnB1dCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5JbmdyZXNzSW5wdXRcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiUlRNUF9JTlBVVFwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJXSElQX0lOUFVUXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIlVSTF9JTlBVVFwiIH1cbiAgXVxuKTtcbmNvbnN0IEluZ3Jlc3NBdWRpb0VuY29kaW5nUHJlc2V0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkluZ3Jlc3NBdWRpb0VuY29kaW5nUHJlc2V0XCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIk9QVVNfU1RFUkVPXzk2S0JQU1wiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJPUFVTX01PTk9fNjRLQlNcIiB9XG4gIF1cbik7XG5jb25zdCBJbmdyZXNzVmlkZW9FbmNvZGluZ1ByZXNldCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5JbmdyZXNzVmlkZW9FbmNvZGluZ1ByZXNldFwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJIMjY0XzcyMFBfMzBGUFNfM19MQVlFUlNcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiSDI2NF8xMDgwUF8zMEZQU18zX0xBWUVSU1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJIMjY0XzU0MFBfMjVGUFNfMl9MQVlFUlNcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiSDI2NF83MjBQXzMwRlBTXzFfTEFZRVJcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiSDI2NF8xMDgwUF8zMEZQU18xX0xBWUVSXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIkgyNjRfNzIwUF8zMEZQU18zX0xBWUVSU19ISUdIX01PVElPTlwiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJIMjY0XzEwODBQXzMwRlBTXzNfTEFZRVJTX0hJR0hfTU9USU9OXCIgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcIkgyNjRfNTQwUF8yNUZQU18yX0xBWUVSU19ISUdIX01PVElPTlwiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJIMjY0XzcyMFBfMzBGUFNfMV9MQVlFUl9ISUdIX01PVElPTlwiIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJIMjY0XzEwODBQXzMwRlBTXzFfTEFZRVJfSElHSF9NT1RJT05cIiB9XG4gIF1cbik7XG5jb25zdCBDcmVhdGVJbmdyZXNzUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQ3JlYXRlSW5ncmVzc1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaW5wdXRfdHlwZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEluZ3Jlc3NJbnB1dCkgfSxcbiAgICB7XG4gICAgICBubzogOSxcbiAgICAgIG5hbWU6IFwidXJsXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJyb29tX25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfbWV0YWRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcImJ5cGFzc190cmFuc2NvZGluZ1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwiZW5hYmxlX3RyYW5zY29kaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDgsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiYXVkaW9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEluZ3Jlc3NBdWRpb09wdGlvbnMgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInZpZGVvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBJbmdyZXNzVmlkZW9PcHRpb25zIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiZW5hYmxlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4LCBvcHQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgSW5ncmVzc0F1ZGlvT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuSW5ncmVzc0F1ZGlvT3B0aW9uc1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzb3VyY2VcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSkgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInByZXNldFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEluZ3Jlc3NBdWRpb0VuY29kaW5nUHJlc2V0KSwgb25lb2Y6IFwiZW5jb2Rpbmdfb3B0aW9uc1wiIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJvcHRpb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBJbmdyZXNzQXVkaW9FbmNvZGluZ09wdGlvbnMsIG9uZW9mOiBcImVuY29kaW5nX29wdGlvbnNcIiB9XG4gIF1cbik7XG5jb25zdCBJbmdyZXNzVmlkZW9PcHRpb25zID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5JbmdyZXNzVmlkZW9PcHRpb25zXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInNvdXJjZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrU291cmNlKSB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHJlc2V0XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoSW5ncmVzc1ZpZGVvRW5jb2RpbmdQcmVzZXQpLCBvbmVvZjogXCJlbmNvZGluZ19vcHRpb25zXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIm9wdGlvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEluZ3Jlc3NWaWRlb0VuY29kaW5nT3B0aW9ucywgb25lb2Y6IFwiZW5jb2Rpbmdfb3B0aW9uc1wiIH1cbiAgXVxuKTtcbmNvbnN0IEluZ3Jlc3NBdWRpb0VuY29kaW5nT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuSW5ncmVzc0F1ZGlvRW5jb2RpbmdPcHRpb25zXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImF1ZGlvX2NvZGVjXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9Db2RlYykgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiYml0cmF0ZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcImRpc2FibGVfZHR4XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiY2hhbm5lbHNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBJbmdyZXNzVmlkZW9FbmNvZGluZ09wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkluZ3Jlc3NWaWRlb0VuY29kaW5nT3B0aW9uc1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ2aWRlb19jb2RlY1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFZpZGVvQ29kZWMpIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImZyYW1lX3JhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxXG4gICAgICAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xuICAgIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IEluZ3Jlc3NJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5JbmdyZXNzSW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImluZ3Jlc3NfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInN0cmVhbV9rZXlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInVybFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImlucHV0X3R5cGVcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShJbmdyZXNzSW5wdXQpIH0sXG4gICAge1xuICAgICAgbm86IDEzLFxuICAgICAgbmFtZTogXCJieXBhc3NfdHJhbnNjb2RpbmdcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcImVuYWJsZV90cmFuc2NvZGluZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImF1ZGlvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBJbmdyZXNzQXVkaW9PcHRpb25zIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJ2aWRlb1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSW5ncmVzc1ZpZGVvT3B0aW9ucyB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJyb29tX25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTQsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X21ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwicmV1c2FibGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInN0YXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBJbmdyZXNzU3RhdGUgfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJlbmFibGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDgsIG9wdDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBJbmdyZXNzU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkluZ3Jlc3NTdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzdGF0dXNcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShJbmdyZXNzU3RhdGVfU3RhdHVzKSB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInZpZGVvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBJbnB1dFZpZGVvU3RhdGUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImF1ZGlvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBJbnB1dEF1ZGlvU3RhdGUgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwicm9vbV9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwic3RhcnRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJlbmRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwidXBkYXRlZF9hdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA5LFxuICAgICAgbmFtZTogXCJyZXNvdXJjZV9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcInRyYWNrc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tJbmZvLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBJbmdyZXNzU3RhdGVfU3RhdHVzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkluZ3Jlc3NTdGF0ZS5TdGF0dXNcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiRU5EUE9JTlRfSU5BQ1RJVkVcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiRU5EUE9JTlRfQlVGRkVSSU5HXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIkVORFBPSU5UX1BVQkxJU0hJTkdcIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiRU5EUE9JTlRfRVJST1JcIiB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiRU5EUE9JTlRfQ09NUExFVEVcIiB9XG4gIF1cbik7XG5jb25zdCBJbnB1dFZpZGVvU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LklucHV0VmlkZW9TdGF0ZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcIm1pbWVfdHlwZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiYXZlcmFnZV9iaXRyYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwid2lkdGhcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJoZWlnaHRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJmcmFtZXJhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxXG4gICAgICAvKiBTY2FsYXJUeXBlLkRPVUJMRSAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IElucHV0QXVkaW9TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuSW5wdXRBdWRpb1N0YXRlXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwibWltZV90eXBlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJhdmVyYWdlX2JpdHJhdGVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJjaGFubmVsc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInNhbXBsZV9yYXRlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgVXBkYXRlSW5ncmVzc1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZUluZ3Jlc3NSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiaW5ncmVzc19pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwicm9vbV9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOSxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfbWV0YWRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJieXBhc3NfdHJhbnNjb2RpbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCwgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwiZW5hYmxlX3RyYW5zY29kaW5nXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDgsIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiYXVkaW9cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEluZ3Jlc3NBdWRpb09wdGlvbnMgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInZpZGVvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBJbmdyZXNzVmlkZW9PcHRpb25zIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwiZW5hYmxlZFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4LCBvcHQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgTGlzdEluZ3Jlc3NSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5MaXN0SW5ncmVzc1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJyb29tX25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImluZ3Jlc3NfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IExpc3RJbmdyZXNzUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lkxpc3RJbmdyZXNzUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaXRlbXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEluZ3Jlc3NJbmZvLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBEZWxldGVJbmdyZXNzUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGVsZXRlSW5ncmVzc1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJpbmdyZXNzX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5cbmNvbnN0IENyZWF0ZVJvb21SZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5DcmVhdGVSb29tUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEyLFxuICAgICAgbmFtZTogXCJyb29tX3ByZXNldFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiZW1wdHlfdGltZW91dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEwLFxuICAgICAgbmFtZTogXCJkZXBhcnR1cmVfdGltZW91dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcIm1heF9wYXJ0aWNpcGFudHNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJub2RlX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImVncmVzc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbUVncmVzcyB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJtaW5fcGxheW91dF9kZWxheVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcIm1heF9wbGF5b3V0X2RlbGF5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOSxcbiAgICAgIG5hbWU6IFwic3luY19zdHJlYW1zXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTMsXG4gICAgICBuYW1lOiBcInJlcGxheV9lbmFibGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJhZ2VudHNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb21BZ2VudERpc3BhdGNoLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBSb29tRWdyZXNzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Sb29tRWdyZXNzXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJvb21cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb21Db21wb3NpdGVFZ3Jlc3NSZXF1ZXN0IH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwYXJ0aWNpcGFudFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQXV0b1BhcnRpY2lwYW50RWdyZXNzIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFja3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEF1dG9UcmFja0VncmVzcyB9XG4gIF1cbik7XG5jb25zdCBSb29tQWdlbnQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJvb21BZ2VudFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJkaXNwYXRjaGVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSb29tQWdlbnREaXNwYXRjaCwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgTGlzdFJvb21zUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdFJvb21zUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJuYW1lc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBMaXN0Um9vbXNSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdFJvb21zUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicm9vbXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb20sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IERlbGV0ZVJvb21SZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5EZWxldGVSb29tUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInJvb21cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IERlbGV0ZVJvb21SZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGVsZXRlUm9vbVJlc3BvbnNlXCIsXG4gIFtdXG4pO1xuY29uc3QgTGlzdFBhcnRpY2lwYW50c1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lkxpc3RQYXJ0aWNpcGFudHNSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgTGlzdFBhcnRpY2lwYW50c1Jlc3BvbnNlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5MaXN0UGFydGljaXBhbnRzUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicGFydGljaXBhbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEluZm8sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFJvb21QYXJ0aWNpcGFudElkZW50aXR5ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Sb29tUGFydGljaXBhbnRJZGVudGl0eVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInJvb21cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImlkZW50aXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBSZW1vdmVQYXJ0aWNpcGFudFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5SZW1vdmVQYXJ0aWNpcGFudFJlc3BvbnNlXCIsXG4gIFtdXG4pO1xuY29uc3QgTXV0ZVJvb21UcmFja1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lk11dGVSb29tVHJhY2tSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwibXV0ZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBNdXRlUm9vbVRyYWNrUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lk11dGVSb29tVHJhY2tSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cmFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tJbmZvIH1cbiAgXVxuKTtcbmNvbnN0IFVwZGF0ZVBhcnRpY2lwYW50UmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicGVybWlzc2lvblwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRQZXJtaXNzaW9uIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJhdHRyaWJ1dGVzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDksIFY6IHtcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0gfVxuICBdXG4pO1xuY29uc3QgVXBkYXRlU3Vic2NyaXB0aW9uc1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0cmFja19zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInN1YnNjcmliZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJwYXJ0aWNpcGFudF90cmFja3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50VHJhY2tzLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBVcGRhdGVTdWJzY3JpcHRpb25zUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvbnNSZXNwb25zZVwiLFxuICBbXVxuKTtcbmNvbnN0IFNlbmREYXRhUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU2VuZERhdGFSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEyXG4gICAgICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImtpbmRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEYXRhUGFja2V0X0tpbmQpIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJkZXN0aW5hdGlvbl9zaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJkZXN0aW5hdGlvbl9pZGVudGl0aWVzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJ0b3BpY1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvcHQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwibm9uY2VcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxMlxuICAgICAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFNlbmREYXRhUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNlbmREYXRhUmVzcG9uc2VcIixcbiAgW11cbik7XG5jb25zdCBVcGRhdGVSb29tTWV0YWRhdGFSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5VcGRhdGVSb29tTWV0YWRhdGFSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwibWV0YWRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFJvb21Db25maWd1cmF0aW9uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Sb29tQ29uZmlndXJhdGlvblwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImVtcHR5X3RpbWVvdXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJkZXBhcnR1cmVfdGltZW91dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcIm1heF9wYXJ0aWNpcGFudHNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiZWdyZXNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSb29tRWdyZXNzIH0sXG4gICAge1xuICAgICAgbm86IDcsXG4gICAgICBuYW1lOiBcIm1pbl9wbGF5b3V0X2RlbGF5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOCxcbiAgICAgIG5hbWU6IFwibWF4X3BsYXlvdXRfZGVsYXlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA5LFxuICAgICAgbmFtZTogXCJzeW5jX3N0cmVhbXNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImFnZW50c1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbUFnZW50RGlzcGF0Y2gsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IEZvcndhcmRQYXJ0aWNpcGFudFJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkZvcndhcmRQYXJ0aWNpcGFudFJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJyb29tXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJpZGVudGl0eVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiZGVzdGluYXRpb25fcm9vbVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgRm9yd2FyZFBhcnRpY2lwYW50UmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkZvcndhcmRQYXJ0aWNpcGFudFJlc3BvbnNlXCIsXG4gIFtdXG4pO1xuXG5jb25zdCBTaWduYWxUYXJnZXQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuU2lnbmFsVGFyZ2V0XCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlBVQkxJU0hFUlwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJTVUJTQ1JJQkVSXCIgfVxuICBdXG4pO1xuY29uc3QgU3RyZWFtU3RhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuU3RyZWFtU3RhdGVcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiQUNUSVZFXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlBBVVNFRFwiIH1cbiAgXVxuKTtcbmNvbnN0IENhbmRpZGF0ZVByb3RvY29sID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LkNhbmRpZGF0ZVByb3RvY29sXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlVEUFwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJUQ1BcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiVExTXCIgfVxuICBdXG4pO1xuY29uc3QgU2lnbmFsUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU2lnbmFsUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJvZmZlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImFuc3dlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInRyaWNrbGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyaWNrbGVSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImFkZF90cmFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogQWRkVHJhY2tSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcIm11dGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IE11dGVUcmFja1JlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVTdWJzY3JpcHRpb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwidHJhY2tfc2V0dGluZ1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlVHJhY2tTZXR0aW5ncywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogOCwgbmFtZTogXCJsZWF2ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTGVhdmVSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJ1cGRhdGVfbGF5ZXJzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVWaWRlb0xheWVycywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Blcm1pc3Npb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb24sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInN5bmNfc3RhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN5bmNTdGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwic2ltdWxhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNpbXVsYXRlU2NlbmFyaW8sIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcInBpbmdcIiwga2luZDogXCJzY2FsYXJcIiwgVDogMywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTUsIG5hbWU6IFwidXBkYXRlX21ldGFkYXRhXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNiwgbmFtZTogXCJwaW5nX3JlcVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGluZywgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwidXBkYXRlX2F1ZGlvX3RyYWNrXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBVcGRhdGVMb2NhbEF1ZGlvVHJhY2ssIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE4LCBuYW1lOiBcInVwZGF0ZV92aWRlb190cmFja1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVXBkYXRlTG9jYWxWaWRlb1RyYWNrLCBvbmVvZjogXCJtZXNzYWdlXCIgfVxuICBdXG4pO1xuY29uc3QgU2lnbmFsUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNpZ25hbFJlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImpvaW5cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IEpvaW5SZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJhbnN3ZXJcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNlc3Npb25EZXNjcmlwdGlvbiwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJvZmZlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInRyaWNrbGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyaWNrbGVSZXF1ZXN0LCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcInVwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRVcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwidHJhY2tfcHVibGlzaGVkXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImxlYXZlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBMZWF2ZVJlcXVlc3QsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwibXV0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTXV0ZVRyYWNrUmVxdWVzdCwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwic3BlYWtlcnNfY2hhbmdlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3BlYWtlcnNDaGFuZ2VkLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxMSwgbmFtZTogXCJyb29tX3VwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbVVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiY29ubmVjdGlvbl9xdWFsaXR5XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTMsIG5hbWU6IFwic3RyZWFtX3N0YXRlX3VwZGF0ZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3RyZWFtU3RhdGVVcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0eV91cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxNSwgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvbl91cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDE2LCBuYW1lOiBcInJlZnJlc2hfdG9rZW5cIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTcsIG5hbWU6IFwidHJhY2tfdW5wdWJsaXNoZWRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMTgsIG5hbWU6IFwicG9uZ1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAxOSwgbmFtZTogXCJyZWNvbm5lY3RcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlY29ubmVjdFJlc3BvbnNlLCBvbmVvZjogXCJtZXNzYWdlXCIgfSxcbiAgICB7IG5vOiAyMCwgbmFtZTogXCJwb25nX3Jlc3BcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBvbmcsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDIxLCBuYW1lOiBcInN1YnNjcmlwdGlvbl9yZXNwb25zZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaXB0aW9uUmVzcG9uc2UsIG9uZW9mOiBcIm1lc3NhZ2VcIiB9LFxuICAgIHsgbm86IDIyLCBuYW1lOiBcInJlcXVlc3RfcmVzcG9uc2VcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlcXVlc3RSZXNwb25zZSwgb25lb2Y6IFwibWVzc2FnZVwiIH0sXG4gICAgeyBubzogMjMsIG5hbWU6IFwidHJhY2tfc3Vic2NyaWJlZFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVHJhY2tTdWJzY3JpYmVkLCBvbmVvZjogXCJtZXNzYWdlXCIgfVxuICBdXG4pO1xuY29uc3QgU2ltdWxjYXN0Q29kZWMgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiY29kZWNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImNpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgQWRkVHJhY2tSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5BZGRUcmFja1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJjaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0eXBlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKSB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJ3aWR0aFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcImhlaWdodFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcIm11dGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwic291cmNlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJsYXllcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFZpZGVvTGF5ZXIsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwic2ltdWxjYXN0X2NvZGVjc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2ltdWxjYXN0Q29kZWMsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDExLFxuICAgICAgbmFtZTogXCJzaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDEyLFxuICAgICAgbmFtZTogXCJzdGVyZW9cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMyxcbiAgICAgIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDE0LCBuYW1lOiBcImVuY3J5cHRpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpIH0sXG4gICAge1xuICAgICAgbm86IDE1LFxuICAgICAgbmFtZTogXCJzdHJlYW1cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwiYmFja3VwX2NvZGVjX3BvbGljeVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEJhY2t1cENvZGVjUG9saWN5KSB9XG4gIF1cbik7XG5jb25zdCBUcmlja2xlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJpY2tsZVJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJjYW5kaWRhdGVJbml0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwidGFyZ2V0XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KSB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJmaW5hbFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IE11dGVUcmFja1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lk11dGVUcmFja1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJzaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIm11dGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgSm9pblJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Kb2luUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicm9vbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicGFydGljaXBhbnRcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFBhcnRpY2lwYW50SW5mbyB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwib3RoZXJfcGFydGljaXBhbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInNlcnZlcl92ZXJzaW9uXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiaWNlX3NlcnZlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IElDRVNlcnZlciwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwic3Vic2NyaWJlcl9wcmltYXJ5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwiYWx0ZXJuYXRpdmVfdXJsXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENsaWVudENvbmZpZ3VyYXRpb24gfSxcbiAgICB7XG4gICAgICBubzogOSxcbiAgICAgIG5hbWU6IFwic2VydmVyX3JlZ2lvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTAsXG4gICAgICBuYW1lOiBcInBpbmdfdGltZW91dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwicGluZ19pbnRlcnZhbFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDVcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbiAgICB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcInNlcnZlcl9pbmZvXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTZXJ2ZXJJbmZvIH0sXG4gICAge1xuICAgICAgbm86IDEzLFxuICAgICAgbmFtZTogXCJzaWZfdHJhaWxlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEyXG4gICAgICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG4gICAgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJlbmFibGVkX3B1Ymxpc2hfY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBDb2RlYywgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogMTUsXG4gICAgICBuYW1lOiBcImZhc3RfcHVibGlzaFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFJlY29ubmVjdFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5SZWNvbm5lY3RSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJpY2Vfc2VydmVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSUNFU2VydmVyLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENsaWVudENvbmZpZ3VyYXRpb24gfVxuICBdXG4pO1xuY29uc3QgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhY2tQdWJsaXNoZWRSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImNpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRyYWNrXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja0luZm8gfVxuICBdXG4pO1xuY29uc3QgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5UcmFja1VucHVibGlzaGVkUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFNlc3Npb25EZXNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwidHlwZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwic2RwXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBQYXJ0aWNpcGFudFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUGFydGljaXBhbnRVcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicGFydGljaXBhbnRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYXJ0aWNpcGFudEluZm8sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFVwZGF0ZVN1YnNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlU3Vic2NyaXB0aW9uXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRyYWNrX3NpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwic3Vic2NyaWJlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInBhcnRpY2lwYW50X3RyYWNrc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRUcmFja3MsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFVwZGF0ZVRyYWNrU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJhY2tfc2lkc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJkaXNhYmxlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJxdWFsaXR5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KSB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJ3aWR0aFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcImhlaWdodFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDcsXG4gICAgICBuYW1lOiBcImZwc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcInByaW9yaXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgVXBkYXRlTG9jYWxBdWRpb1RyYWNrID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5VcGRhdGVMb2NhbEF1ZGlvVHJhY2tcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJmZWF0dXJlc1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgVXBkYXRlTG9jYWxWaWRlb1RyYWNrID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5VcGRhdGVMb2NhbFZpZGVvVHJhY2tcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIndpZHRoXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiaGVpZ2h0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgTGVhdmVSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJjYW5fcmVjb25uZWN0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInJlYXNvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJhY3Rpb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShMZWF2ZVJlcXVlc3RfQWN0aW9uKSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwicmVnaW9uc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUmVnaW9uU2V0dGluZ3MgfVxuICBdXG4pO1xuY29uc3QgTGVhdmVSZXF1ZXN0X0FjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3QuQWN0aW9uXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIkRJU0NPTk5FQ1RcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiUkVTVU1FXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIlJFQ09OTkVDVFwiIH1cbiAgXVxuKTtcbmNvbnN0IFVwZGF0ZVZpZGVvTGF5ZXJzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImxheWVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogVmlkZW9MYXllciwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwiYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInJlcXVlc3RfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBJQ0VTZXJ2ZXIgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LklDRVNlcnZlclwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ1cmxzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInVzZXJuYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJjcmVkZW50aWFsXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTcGVha2Vyc0NoYW5nZWQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNwZWFrZXJzQ2hhbmdlZFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzcGVha2Vyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3BlYWtlckluZm8sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFJvb21VcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJvb21VcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwicm9vbVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUm9vbSB9XG4gIF1cbik7XG5jb25zdCBDb25uZWN0aW9uUXVhbGl0eUluZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5SW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInF1YWxpdHlcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDb25uZWN0aW9uUXVhbGl0eSkgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwic2NvcmVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAyXG4gICAgICAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInVwZGF0ZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IENvbm5lY3Rpb25RdWFsaXR5SW5mbywgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgU3RyZWFtU3RhdGVJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm9cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInN0YXRlXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3RyZWFtU3RhdGUpIH1cbiAgXVxuKTtcbmNvbnN0IFN0cmVhbVN0YXRlVXBkYXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TdHJlYW1TdGF0ZVVwZGF0ZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzdHJlYW1fc3RhdGVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdHJlYW1TdGF0ZUluZm8sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFN1YnNjcmliZWRRdWFsaXR5ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJxdWFsaXR5XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5KSB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJlbmFibGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgU3Vic2NyaWJlZENvZGVjID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TdWJzY3JpYmVkQ29kZWNcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJjb2RlY1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInF1YWxpdGllc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU3Vic2NyaWJlZFF1YWxpdHksIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZVwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0aWVzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpYmVkUXVhbGl0eSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInN1YnNjcmliZWRfY29kZWNzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTdWJzY3JpYmVkQ29kZWMsIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFRyYWNrUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuVHJhY2tQZXJtaXNzaW9uXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJhbGxfdHJhY2tzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInRyYWNrX3NpZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFN1YnNjcmlwdGlvblBlcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJhbGxfcGFydGljaXBhbnRzXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRyYWNrX3Blcm1pc3Npb25zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja1Blcm1pc3Npb24sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiYWxsb3dlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFN5bmNTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU3luY1N0YXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImFuc3dlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJzdWJzY3JpcHRpb25cIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFVwZGF0ZVN1YnNjcmlwdGlvbiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwicHVibGlzaF90cmFja3NcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJkYXRhX2NoYW5uZWxzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEYXRhQ2hhbm5lbEluZm8sIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJvZmZlclwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU2Vzc2lvbkRlc2NyaXB0aW9uIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJ0cmFja19zaWRzX2Rpc2FibGVkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IERhdGFDaGFubmVsSW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGF0YUNoYW5uZWxJbmZvXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwibGFiZWxcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcImlkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogMTNcbiAgICAgIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG4gICAgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcInRhcmdldFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNpZ25hbFRhcmdldCkgfVxuICBdXG4pO1xuY29uc3QgU2ltdWxhdGVTY2VuYXJpbyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU2ltdWxhdGVTY2VuYXJpb1wiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJzcGVha2VyX3VwZGF0ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA1LCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJub2RlX2ZhaWx1cmVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCwgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwibWlncmF0aW9uXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDgsIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcInNlcnZlcl9sZWF2ZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA4LCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJzd2l0Y2hfY2FuZGlkYXRlX3Byb3RvY29sXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJzdWJzY3JpYmVyX2JhbmR3aWR0aFwiLCBraW5kOiBcInNjYWxhclwiLCBUOiAzLCBvbmVvZjogXCJzY2VuYXJpb1wiIH0sXG4gICAgeyBubzogNywgbmFtZTogXCJkaXNjb25uZWN0X3NpZ25hbF9vbl9yZXN1bWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCwgb25lb2Y6IFwic2NlbmFyaW9cIiB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDgsIG9uZW9mOiBcInNjZW5hcmlvXCIgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcImxlYXZlX3JlcXVlc3RfZnVsbF9yZWNvbm5lY3RcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOCwgb25lb2Y6IFwic2NlbmFyaW9cIiB9XG4gIF1cbik7XG5jb25zdCBQaW5nID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5QaW5nXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwidGltZXN0YW1wXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInJ0dFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBQb25nID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5Qb25nXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwibGFzdF9waW5nX3RpbWVzdGFtcFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDNcbiAgICAgIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgUmVnaW9uU2V0dGluZ3MgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJlZ2lvblNldHRpbmdzXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInJlZ2lvbnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJlZ2lvbkluZm8sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IFJlZ2lvbkluZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlJlZ2lvbkluZm9cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJyZWdpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInVybFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiZGlzdGFuY2VcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgU3Vic2NyaXB0aW9uUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlN1YnNjcmlwdGlvblJlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiZXJyXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU3Vic2NyaXB0aW9uRXJyb3IpIH1cbiAgXVxuKTtcbmNvbnN0IFJlcXVlc3RSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuUmVxdWVzdFJlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDEzXG4gICAgICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xuICAgIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJyZWFzb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShSZXF1ZXN0UmVzcG9uc2VfUmVhc29uKSB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJtZXNzYWdlXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlJlcXVlc3RSZXNwb25zZS5SZWFzb25cIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiT0tcIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiTk9UX0ZPVU5EXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIk5PVF9BTExPV0VEXCIgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIkxJTUlUX0VYQ0VFREVEXCIgfVxuICBdXG4pO1xuY29uc3QgVHJhY2tTdWJzY3JpYmVkID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5UcmFja1N1YnNjcmliZWRcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcblxuY29uc3QgU0lQU3RhdHVzQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TSVBTdGF0dXNDb2RlXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlNJUF9TVEFUVVNfVU5LTk9XTlwiIH0sXG4gICAgeyBubzogMTAwLCBuYW1lOiBcIlNJUF9TVEFUVVNfVFJZSU5HXCIgfSxcbiAgICB7IG5vOiAxODAsIG5hbWU6IFwiU0lQX1NUQVRVU19SSU5HSU5HXCIgfSxcbiAgICB7IG5vOiAxODEsIG5hbWU6IFwiU0lQX1NUQVRVU19DQUxMX0lTX0ZPUldBUkRFRFwiIH0sXG4gICAgeyBubzogMTgyLCBuYW1lOiBcIlNJUF9TVEFUVVNfUVVFVUVEXCIgfSxcbiAgICB7IG5vOiAxODMsIG5hbWU6IFwiU0lQX1NUQVRVU19TRVNTSU9OX1BST0dSRVNTXCIgfSxcbiAgICB7IG5vOiAyMDAsIG5hbWU6IFwiU0lQX1NUQVRVU19PS1wiIH0sXG4gICAgeyBubzogMjAyLCBuYW1lOiBcIlNJUF9TVEFUVVNfQUNDRVBURURcIiB9LFxuICAgIHsgbm86IDMwMSwgbmFtZTogXCJTSVBfU1RBVFVTX01PVkVEX1BFUk1BTkVOVExZXCIgfSxcbiAgICB7IG5vOiAzMDIsIG5hbWU6IFwiU0lQX1NUQVRVU19NT1ZFRF9URU1QT1JBUklMWVwiIH0sXG4gICAgeyBubzogMzA1LCBuYW1lOiBcIlNJUF9TVEFUVVNfVVNFX1BST1hZXCIgfSxcbiAgICB7IG5vOiA0MDAsIG5hbWU6IFwiU0lQX1NUQVRVU19CQURfUkVRVUVTVFwiIH0sXG4gICAgeyBubzogNDAxLCBuYW1lOiBcIlNJUF9TVEFUVVNfVU5BVVRIT1JJWkVEXCIgfSxcbiAgICB7IG5vOiA0MDIsIG5hbWU6IFwiU0lQX1NUQVRVU19QQVlNRU5UX1JFUVVJUkVEXCIgfSxcbiAgICB7IG5vOiA0MDMsIG5hbWU6IFwiU0lQX1NUQVRVU19GT1JCSURERU5cIiB9LFxuICAgIHsgbm86IDQwNCwgbmFtZTogXCJTSVBfU1RBVFVTX05PVEZPVU5EXCIgfSxcbiAgICB7IG5vOiA0MDUsIG5hbWU6IFwiU0lQX1NUQVRVU19NRVRIT0RfTk9UX0FMTE9XRURcIiB9LFxuICAgIHsgbm86IDQwNiwgbmFtZTogXCJTSVBfU1RBVFVTX05PVF9BQ0NFUFRBQkxFXCIgfSxcbiAgICB7IG5vOiA0MDcsIG5hbWU6IFwiU0lQX1NUQVRVU19QUk9YWV9BVVRIX1JFUVVJUkVEXCIgfSxcbiAgICB7IG5vOiA0MDgsIG5hbWU6IFwiU0lQX1NUQVRVU19SRVFVRVNUX1RJTUVPVVRcIiB9LFxuICAgIHsgbm86IDQwOSwgbmFtZTogXCJTSVBfU1RBVFVTX0NPTkZMSUNUXCIgfSxcbiAgICB7IG5vOiA0MTAsIG5hbWU6IFwiU0lQX1NUQVRVU19HT05FXCIgfSxcbiAgICB7IG5vOiA0MTMsIG5hbWU6IFwiU0lQX1NUQVRVU19SRVFVRVNUX0VOVElUWV9UT09fTEFSR0VcIiB9LFxuICAgIHsgbm86IDQxNCwgbmFtZTogXCJTSVBfU1RBVFVTX1JFUVVFU1RfVVJJX1RPT19MT05HXCIgfSxcbiAgICB7IG5vOiA0MTUsIG5hbWU6IFwiU0lQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFXCIgfSxcbiAgICB7IG5vOiA0MTYsIG5hbWU6IFwiU0lQX1NUQVRVU19SRVFVRVNURURfUkFOR0VfTk9UX1NBVElTRklBQkxFXCIgfSxcbiAgICB7IG5vOiA0MjAsIG5hbWU6IFwiU0lQX1NUQVRVU19CQURfRVhURU5TSU9OXCIgfSxcbiAgICB7IG5vOiA0MjEsIG5hbWU6IFwiU0lQX1NUQVRVU19FWFRFTlNJT05fUkVRVUlSRURcIiB9LFxuICAgIHsgbm86IDQyMywgbmFtZTogXCJTSVBfU1RBVFVTX0lOVEVSVkFMX1RPT19CUklFRlwiIH0sXG4gICAgeyBubzogNDgwLCBuYW1lOiBcIlNJUF9TVEFUVVNfVEVNUE9SQVJJTFlfVU5BVkFJTEFCTEVcIiB9LFxuICAgIHsgbm86IDQ4MSwgbmFtZTogXCJTSVBfU1RBVFVTX0NBTExfVFJBTlNBQ1RJT05fRE9FU19OT1RfRVhJU1RTXCIgfSxcbiAgICB7IG5vOiA0ODIsIG5hbWU6IFwiU0lQX1NUQVRVU19MT09QX0RFVEVDVEVEXCIgfSxcbiAgICB7IG5vOiA0ODMsIG5hbWU6IFwiU0lQX1NUQVRVU19UT09fTUFOWV9IT1BTXCIgfSxcbiAgICB7IG5vOiA0ODQsIG5hbWU6IFwiU0lQX1NUQVRVU19BRERSRVNTX0lOQ09NUExFVEVcIiB9LFxuICAgIHsgbm86IDQ4NSwgbmFtZTogXCJTSVBfU1RBVFVTX0FNQklHVU9VU1wiIH0sXG4gICAgeyBubzogNDg2LCBuYW1lOiBcIlNJUF9TVEFUVVNfQlVTWV9IRVJFXCIgfSxcbiAgICB7IG5vOiA0ODcsIG5hbWU6IFwiU0lQX1NUQVRVU19SRVFVRVNUX1RFUk1JTkFURURcIiB9LFxuICAgIHsgbm86IDQ4OCwgbmFtZTogXCJTSVBfU1RBVFVTX05PVF9BQ0NFUFRBQkxFX0hFUkVcIiB9LFxuICAgIHsgbm86IDUwMCwgbmFtZTogXCJTSVBfU1RBVFVTX0lOVEVSTkFMX1NFUlZFUl9FUlJPUlwiIH0sXG4gICAgeyBubzogNTAxLCBuYW1lOiBcIlNJUF9TVEFUVVNfTk9UX0lNUExFTUVOVEVEXCIgfSxcbiAgICB7IG5vOiA1MDIsIG5hbWU6IFwiU0lQX1NUQVRVU19CQURfR0FURVdBWVwiIH0sXG4gICAgeyBubzogNTAzLCBuYW1lOiBcIlNJUF9TVEFUVVNfU0VSVklDRV9VTkFWQUlMQUJMRVwiIH0sXG4gICAgeyBubzogNTA0LCBuYW1lOiBcIlNJUF9TVEFUVVNfR0FURVdBWV9USU1FT1VUXCIgfSxcbiAgICB7IG5vOiA1MDUsIG5hbWU6IFwiU0lQX1NUQVRVU19WRVJTSU9OX05PVF9TVVBQT1JURURcIiB9LFxuICAgIHsgbm86IDUxMywgbmFtZTogXCJTSVBfU1RBVFVTX01FU1NBR0VfVE9PX0xBUkdFXCIgfSxcbiAgICB7IG5vOiA2MDAsIG5hbWU6IFwiU0lQX1NUQVRVU19HTE9CQUxfQlVTWV9FVkVSWVdIRVJFXCIgfSxcbiAgICB7IG5vOiA2MDMsIG5hbWU6IFwiU0lQX1NUQVRVU19HTE9CQUxfREVDTElORVwiIH0sXG4gICAgeyBubzogNjA0LCBuYW1lOiBcIlNJUF9TVEFUVVNfR0xPQkFMX0RPRVNfTk9UX0VYSVNUX0FOWVdIRVJFXCIgfSxcbiAgICB7IG5vOiA2MDYsIG5hbWU6IFwiU0lQX1NUQVRVU19HTE9CQUxfTk9UX0FDQ0VQVEFCTEVcIiB9XG4gIF1cbik7XG5jb25zdCBTSVBUcmFuc3BvcnQgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuU0lQVHJhbnNwb3J0XCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlNJUF9UUkFOU1BPUlRfQVVUT1wiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJTSVBfVFJBTlNQT1JUX1VEUFwiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJTSVBfVFJBTlNQT1JUX1RDUFwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJTSVBfVFJBTlNQT1JUX1RMU1wiIH1cbiAgXVxuKTtcbmNvbnN0IFNJUEhlYWRlck9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuU0lQSGVhZGVyT3B0aW9uc1wiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJTSVBfTk9fSEVBREVSU1wiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJTSVBfWF9IRUFERVJTXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIlNJUF9BTExfSEVBREVSU1wiIH1cbiAgXVxuKTtcbmNvbnN0IFNJUE1lZGlhRW5jcnlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TSVBNZWRpYUVuY3J5cHRpb25cIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiU0lQX01FRElBX0VOQ1JZUFRfRElTQUJMRVwiIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJTSVBfTUVESUFfRU5DUllQVF9BTExPV1wiIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJTSVBfTUVESUFfRU5DUllQVF9SRVFVSVJFXCIgfVxuICBdXG4pO1xuY29uc3QgU0lQQ2FsbFN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZUVudW0oXG4gIFwibGl2ZWtpdC5TSVBDYWxsU3RhdHVzXCIsXG4gIFtcbiAgICB7IG5vOiAwLCBuYW1lOiBcIlNDU19DQUxMX0lOQ09NSU5HXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlNDU19QQVJUSUNJUEFOVF9KT0lORURcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiU0NTX0FDVElWRVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJTQ1NfRElTQ09OTkVDVEVEXCIgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcIlNDU19FUlJPUlwiIH1cbiAgXVxuKTtcbmNvbnN0IFNJUEZlYXR1cmUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VFbnVtKFxuICBcImxpdmVraXQuU0lQRmVhdHVyZVwiLFxuICBbXG4gICAgeyBubzogMCwgbmFtZTogXCJOT05FXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIktSSVNQX0VOQUJMRURcIiB9XG4gIF1cbik7XG5jb25zdCBTSVBDYWxsRGlyZWN0aW9uID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlNJUENhbGxEaXJlY3Rpb25cIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiU0NEX1VOS05PV05cIiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiU0NEX0lOQk9VTkRcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiU0NEX09VVEJPVU5EXCIgfVxuICBdXG4pO1xuY29uc3QgU0lQU3RhdHVzID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBTdGF0dXNcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiY29kZVwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUFN0YXR1c0NvZGUpIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInN0YXR1c1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgQ3JlYXRlU0lQVHJ1bmtSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5DcmVhdGVTSVBUcnVua1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwiaW5ib3VuZF9hZGRyZXNzZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwib3V0Ym91bmRfYWRkcmVzc1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwib3V0Ym91bmRfbnVtYmVyXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiaW5ib3VuZF9udW1iZXJzX3JlZ2V4XCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJpbmJvdW5kX251bWJlcnNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNSxcbiAgICAgIG5hbWU6IFwiaW5ib3VuZF91c2VybmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiaW5ib3VuZF9wYXNzd29yZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwib3V0Ym91bmRfdXNlcm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcIm91dGJvdW5kX3Bhc3N3b3JkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTEsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTSVBUcnVua0luZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNJUFRydW5rSW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpcF90cnVua19pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJraW5kXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU0lQVHJ1bmtJbmZvX1RydW5rS2luZCkgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImluYm91bmRfYWRkcmVzc2VzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcIm91dGJvdW5kX2FkZHJlc3NcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcIm91dGJvdW5kX251bWJlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJ0cmFuc3BvcnRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTSVBUcmFuc3BvcnQpIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJpbmJvdW5kX251bWJlcnNfcmVnZXhcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJpbmJvdW5kX251bWJlcnNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiaW5ib3VuZF91c2VybmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNyxcbiAgICAgIG5hbWU6IFwiaW5ib3VuZF9wYXNzd29yZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogOCxcbiAgICAgIG5hbWU6IFwib3V0Ym91bmRfdXNlcm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcIm91dGJvdW5kX3Bhc3N3b3JkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTIsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTSVBUcnVua0luZm9fVHJ1bmtLaW5kID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlRW51bShcbiAgXCJsaXZla2l0LlNJUFRydW5rSW5mby5UcnVua0tpbmRcIixcbiAgW1xuICAgIHsgbm86IDAsIG5hbWU6IFwiVFJVTktfTEVHQUNZXCIgfSxcbiAgICB7IG5vOiAxLCBuYW1lOiBcIlRSVU5LX0lOQk9VTkRcIiB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiVFJVTktfT1VUQk9VTkRcIiB9XG4gIF1cbik7XG5jb25zdCBDcmVhdGVTSVBJbmJvdW5kVHJ1bmtSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5DcmVhdGVTSVBJbmJvdW5kVHJ1bmtSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcInRydW5rXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTSVBJbmJvdW5kVHJ1bmtJbmZvIH1cbiAgXVxuKTtcbmNvbnN0IFVwZGF0ZVNJUEluYm91bmRUcnVua1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZVNJUEluYm91bmRUcnVua1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJzaXBfdHJ1bmtfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJyZXBsYWNlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTSVBJbmJvdW5kVHJ1bmtJbmZvLCBvbmVvZjogXCJhY3Rpb25cIiB9LFxuICAgIHsgbm86IDMsIG5hbWU6IFwidXBkYXRlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTSVBJbmJvdW5kVHJ1bmtVcGRhdGUsIG9uZW9mOiBcImFjdGlvblwiIH1cbiAgXVxuKTtcbmNvbnN0IFNJUEluYm91bmRUcnVua0luZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNJUEluYm91bmRUcnVua0luZm9cIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJzaXBfdHJ1bmtfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDMsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwibnVtYmVyc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiYWxsb3dlZF9hZGRyZXNzZXNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImFsbG93ZWRfbnVtYmVyc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJhdXRoX3VzZXJuYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJhdXRoX3Bhc3N3b3JkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwiaGVhZGVyc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAgeyBubzogMTAsIG5hbWU6IFwiaGVhZGVyc190b19hdHRyaWJ1dGVzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDksIFY6IHtcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0gfSxcbiAgICB7IG5vOiAxNCwgbmFtZTogXCJhdHRyaWJ1dGVzX3RvX2hlYWRlcnNcIiwga2luZDogXCJtYXBcIiwgSzogOSwgVjoge1xuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcImluY2x1ZGVfaGVhZGVyc1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUEhlYWRlck9wdGlvbnMpIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicmluZ2luZ190aW1lb3V0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEdXJhdGlvbiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcIm1heF9jYWxsX2R1cmF0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEdXJhdGlvbiB9LFxuICAgIHtcbiAgICAgIG5vOiAxMyxcbiAgICAgIG5hbWU6IFwia3Jpc3BfZW5hYmxlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogMTYsIG5hbWU6IFwibWVkaWFfZW5jcnlwdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUE1lZGlhRW5jcnlwdGlvbikgfVxuICBdXG4pO1xuY29uc3QgU0lQSW5ib3VuZFRydW5rVXBkYXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBJbmJvdW5kVHJ1bmtVcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwibnVtYmVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTGlzdFVwZGF0ZSB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwiYWxsb3dlZF9hZGRyZXNzZXNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IExpc3RVcGRhdGUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcImFsbG93ZWRfbnVtYmVyc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogTGlzdFVwZGF0ZSB9LFxuICAgIHsgbm86IDQsIG5hbWU6IFwiYXV0aF91c2VybmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImF1dGhfcGFzc3dvcmRcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJuYW1lXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwibWV0YWRhdGFcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgb3B0OiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IENyZWF0ZVNJUE91dGJvdW5kVHJ1bmtSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5DcmVhdGVTSVBPdXRib3VuZFRydW5rUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cnVua1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQT3V0Ym91bmRUcnVua0luZm8gfVxuICBdXG4pO1xuY29uc3QgVXBkYXRlU0lQT3V0Ym91bmRUcnVua1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZVNJUE91dGJvdW5kVHJ1bmtSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwic2lwX3RydW5rX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicmVwbGFjZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQT3V0Ym91bmRUcnVua0luZm8sIG9uZW9mOiBcImFjdGlvblwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ1cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNJUE91dGJvdW5kVHJ1bmtVcGRhdGUsIG9uZW9mOiBcImFjdGlvblwiIH1cbiAgXVxuKTtcbmNvbnN0IFNJUE91dGJvdW5kVHJ1bmtJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBPdXRib3VuZFRydW5rSW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpcF90cnVua19pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwibWV0YWRhdGFcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcImFkZHJlc3NcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJ0cmFuc3BvcnRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTSVBUcmFuc3BvcnQpIH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJudW1iZXJzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDcsXG4gICAgICBuYW1lOiBcImF1dGhfdXNlcm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcImF1dGhfcGFzc3dvcmRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJoZWFkZXJzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDksIFY6IHtcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0gfSxcbiAgICB7IG5vOiAxMCwgbmFtZTogXCJoZWFkZXJzX3RvX2F0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSwgVjoge1xuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSB9LFxuICAgIHsgbm86IDExLCBuYW1lOiBcImF0dHJpYnV0ZXNfdG9faGVhZGVyc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiaW5jbHVkZV9oZWFkZXJzXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU0lQSGVhZGVyT3B0aW9ucykgfSxcbiAgICB7IG5vOiAxMywgbmFtZTogXCJtZWRpYV9lbmNyeXB0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU0lQTWVkaWFFbmNyeXB0aW9uKSB9XG4gIF1cbik7XG5jb25zdCBTSVBPdXRib3VuZFRydW5rVXBkYXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBPdXRib3VuZFRydW5rVXBkYXRlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcImFkZHJlc3NcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cmFuc3BvcnRcIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTSVBUcmFuc3BvcnQpLCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm51bWJlcnNcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IExpc3RVcGRhdGUgfSxcbiAgICB7IG5vOiA0LCBuYW1lOiBcImF1dGhfdXNlcm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNSwgbmFtZTogXCJhdXRoX3Bhc3N3b3JkXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIG9wdDogdHJ1ZSB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwibmFtZVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcIm1ldGFkYXRhXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIG9wdDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBHZXRTSVBJbmJvdW5kVHJ1bmtSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5HZXRTSVBJbmJvdW5kVHJ1bmtSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwic2lwX3RydW5rX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBHZXRTSVBJbmJvdW5kVHJ1bmtSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuR2V0U0lQSW5ib3VuZFRydW5rUmVzcG9uc2VcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJ1bmtcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNJUEluYm91bmRUcnVua0luZm8gfVxuICBdXG4pO1xuY29uc3QgR2V0U0lQT3V0Ym91bmRUcnVua1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkdldFNJUE91dGJvdW5kVHJ1bmtSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwic2lwX3RydW5rX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBHZXRTSVBPdXRib3VuZFRydW5rUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkdldFNJUE91dGJvdW5kVHJ1bmtSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cnVua1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQT3V0Ym91bmRUcnVua0luZm8gfVxuICBdXG4pO1xuY29uc3QgTGlzdFNJUFRydW5rUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdFNJUFRydW5rUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJwYWdlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYWdpbmF0aW9uIH1cbiAgXVxuKTtcbmNvbnN0IExpc3RTSVBUcnVua1Jlc3BvbnNlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5MaXN0U0lQVHJ1bmtSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJpdGVtc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQVHJ1bmtJbmZvLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBMaXN0U0lQSW5ib3VuZFRydW5rUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdFNJUEluYm91bmRUcnVua1JlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDMsIG5hbWU6IFwicGFnZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFnaW5hdGlvbiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwidHJ1bmtfaWRzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJudW1iZXJzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IExpc3RTSVBJbmJvdW5kVHJ1bmtSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdFNJUEluYm91bmRUcnVua1Jlc3BvbnNlXCIsXG4gICgpID0+IFtcbiAgICB7IG5vOiAxLCBuYW1lOiBcIml0ZW1zXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTSVBJbmJvdW5kVHJ1bmtJbmZvLCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBMaXN0U0lQT3V0Ym91bmRUcnVua1JlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lkxpc3RTSVBPdXRib3VuZFRydW5rUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMywgbmFtZTogXCJwYWdlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBQYWdpbmF0aW9uIH0sXG4gICAgeyBubzogMSwgbmFtZTogXCJ0cnVua19pZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcIm51bWJlcnNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgTGlzdFNJUE91dGJvdW5kVHJ1bmtSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdFNJUE91dGJvdW5kVHJ1bmtSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJpdGVtc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQT3V0Ym91bmRUcnVua0luZm8sIHJlcGVhdGVkOiB0cnVlIH1cbiAgXVxuKTtcbmNvbnN0IERlbGV0ZVNJUFRydW5rUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGVsZXRlU0lQVHJ1bmtSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwic2lwX3RydW5rX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTSVBEaXNwYXRjaFJ1bGVEaXJlY3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNJUERpc3BhdGNoUnVsZURpcmVjdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInJvb21fbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwicGluXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTSVBEaXNwYXRjaFJ1bGVJbmRpdmlkdWFsID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBEaXNwYXRjaFJ1bGVJbmRpdmlkdWFsXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicm9vbV9wcmVmaXhcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInBpblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgU0lQRGlzcGF0Y2hSdWxlQ2FsbGVlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBEaXNwYXRjaFJ1bGVDYWxsZWVcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJyb29tX3ByZWZpeFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwicGluXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJyYW5kb21pemVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTSVBEaXNwYXRjaFJ1bGUgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNJUERpc3BhdGNoUnVsZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJkaXNwYXRjaF9ydWxlX2RpcmVjdFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQRGlzcGF0Y2hSdWxlRGlyZWN0LCBvbmVvZjogXCJydWxlXCIgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcImRpc3BhdGNoX3J1bGVfaW5kaXZpZHVhbFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQRGlzcGF0Y2hSdWxlSW5kaXZpZHVhbCwgb25lb2Y6IFwicnVsZVwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJkaXNwYXRjaF9ydWxlX2NhbGxlZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQRGlzcGF0Y2hSdWxlQ2FsbGVlLCBvbmVvZjogXCJydWxlXCIgfVxuICBdXG4pO1xuY29uc3QgQ3JlYXRlU0lQRGlzcGF0Y2hSdWxlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuQ3JlYXRlU0lQRGlzcGF0Y2hSdWxlUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMTAsIG5hbWU6IFwiZGlzcGF0Y2hfcnVsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQRGlzcGF0Y2hSdWxlSW5mbyB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwicnVsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQRGlzcGF0Y2hSdWxlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJ0cnVua19pZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiaGlkZV9waG9uZV9udW1iZXJcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDYsIG5hbWU6IFwiaW5ib3VuZF9udW1iZXJzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAge1xuICAgICAgbm86IDgsXG4gICAgICBuYW1lOiBcInJvb21fcHJlc2V0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDksIG5hbWU6IFwicm9vbV9jb25maWdcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFJvb21Db25maWd1cmF0aW9uIH1cbiAgXVxuKTtcbmNvbnN0IFVwZGF0ZVNJUERpc3BhdGNoUnVsZVJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlVwZGF0ZVNJUERpc3BhdGNoUnVsZVJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJzaXBfZGlzcGF0Y2hfcnVsZV9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInJlcGxhY2VcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNJUERpc3BhdGNoUnVsZUluZm8sIG9uZW9mOiBcImFjdGlvblwiIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ1cGRhdGVcIiwga2luZDogXCJtZXNzYWdlXCIsIFQ6IFNJUERpc3BhdGNoUnVsZVVwZGF0ZSwgb25lb2Y6IFwiYWN0aW9uXCIgfVxuICBdXG4pO1xuY29uc3QgU0lQRGlzcGF0Y2hSdWxlSW5mbyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU0lQRGlzcGF0Y2hSdWxlSW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpcF9kaXNwYXRjaF9ydWxlX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDIsIG5hbWU6IFwicnVsZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQRGlzcGF0Y2hSdWxlIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJ0cnVua19pZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiaGlkZV9waG9uZV9udW1iZXJcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDcsIG5hbWU6IFwiaW5ib3VuZF9udW1iZXJzXCIsIGtpbmQ6IFwic2NhbGFyXCIsIFQ6IDksIHJlcGVhdGVkOiB0cnVlIH0sXG4gICAge1xuICAgICAgbm86IDUsXG4gICAgICBuYW1lOiBcIm5hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDYsXG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDgsIG5hbWU6IFwiYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcInJvb21fcHJlc2V0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcInJvb21fY29uZmlnXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSb29tQ29uZmlndXJhdGlvbiB9LFxuICAgIHtcbiAgICAgIG5vOiAxMSxcbiAgICAgIG5hbWU6IFwia3Jpc3BfZW5hYmxlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwibWVkaWFfZW5jcnlwdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUE1lZGlhRW5jcnlwdGlvbikgfVxuICBdXG4pO1xuY29uc3QgU0lQRGlzcGF0Y2hSdWxlVXBkYXRlID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBEaXNwYXRjaFJ1bGVVcGRhdGVcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDEsIG5hbWU6IFwidHJ1bmtfaWRzXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBMaXN0VXBkYXRlIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJydWxlXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTSVBEaXNwYXRjaFJ1bGUgfSxcbiAgICB7IG5vOiAzLCBuYW1lOiBcIm5hbWVcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgb3B0OiB0cnVlIH0sXG4gICAgeyBubzogNCwgbmFtZTogXCJtZXRhZGF0YVwiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCBvcHQ6IHRydWUgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImF0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSwgVjoge1xuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSB9XG4gIF1cbik7XG5jb25zdCBMaXN0U0lQRGlzcGF0Y2hSdWxlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuTGlzdFNJUERpc3BhdGNoUnVsZVJlcXVlc3RcIixcbiAgKCkgPT4gW1xuICAgIHsgbm86IDMsIG5hbWU6IFwicGFnZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFnaW5hdGlvbiB9LFxuICAgIHsgbm86IDEsIG5hbWU6IFwiZGlzcGF0Y2hfcnVsZV9pZHNcIiwga2luZDogXCJzY2FsYXJcIiwgVDogOSwgcmVwZWF0ZWQ6IHRydWUgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRydW5rX2lkc1wiLCBraW5kOiBcInNjYWxhclwiLCBUOiA5LCByZXBlYXRlZDogdHJ1ZSB9XG4gIF1cbik7XG5jb25zdCBMaXN0U0lQRGlzcGF0Y2hSdWxlUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0Lkxpc3RTSVBEaXNwYXRjaFJ1bGVSZXNwb25zZVwiLFxuICAoKSA9PiBbXG4gICAgeyBubzogMSwgbmFtZTogXCJpdGVtc1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQRGlzcGF0Y2hSdWxlSW5mbywgcmVwZWF0ZWQ6IHRydWUgfVxuICBdXG4pO1xuY29uc3QgRGVsZXRlU0lQRGlzcGF0Y2hSdWxlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuRGVsZXRlU0lQRGlzcGF0Y2hSdWxlUmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpcF9kaXNwYXRjaF9ydWxlX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTSVBPdXRib3VuZENvbmZpZyA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU0lQT3V0Ym91bmRDb25maWdcIixcbiAgKCkgPT4gW1xuICAgIHtcbiAgICAgIG5vOiAxLFxuICAgICAgbmFtZTogXCJob3N0bmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyLCBuYW1lOiBcInRyYW5zcG9ydFwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUFRyYW5zcG9ydCkgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiYXV0aF91c2VybmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogNCxcbiAgICAgIG5hbWU6IFwiYXV0aF9wYXNzd29yZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiA1LCBuYW1lOiBcImhlYWRlcnNfdG9fYXR0cmlidXRlc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH0sXG4gICAgeyBubzogNiwgbmFtZTogXCJhdHRyaWJ1dGVzX3RvX2hlYWRlcnNcIiwga2luZDogXCJtYXBcIiwgSzogOSwgVjoge1xuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSB9XG4gIF1cbik7XG5jb25zdCBDcmVhdGVTSVBQYXJ0aWNpcGFudFJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LkNyZWF0ZVNJUFBhcnRpY2lwYW50UmVxdWVzdFwiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInNpcF90cnVua19pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAyMCwgbmFtZTogXCJ0cnVua1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQT3V0Ym91bmRDb25maWcgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwic2lwX2NhbGxfdG9cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDE1LFxuICAgICAgbmFtZTogXCJzaXBfbnVtYmVyXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAzLFxuICAgICAgbmFtZTogXCJyb29tX25hbWVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA3LFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA4LFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9tZXRhZGF0YVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiA5LCBuYW1lOiBcInBhcnRpY2lwYW50X2F0dHJpYnV0ZXNcIiwga2luZDogXCJtYXBcIiwgSzogOSwgVjoge1xuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJkdG1mXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA2LFxuICAgICAgbmFtZTogXCJwbGF5X3Jpbmd0b25lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOFxuICAgICAgLyogU2NhbGFyVHlwZS5CT09MICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTMsXG4gICAgICBuYW1lOiBcInBsYXlfZGlhbHRvbmVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxMCxcbiAgICAgIG5hbWU6IFwiaGlkZV9waG9uZV9udW1iZXJcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDE2LCBuYW1lOiBcImhlYWRlcnNcIiwga2luZDogXCJtYXBcIiwgSzogOSwgVjoge1xuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSB9LFxuICAgIHsgbm86IDE3LCBuYW1lOiBcImluY2x1ZGVfaGVhZGVyc1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUEhlYWRlck9wdGlvbnMpIH0sXG4gICAgeyBubzogMTEsIG5hbWU6IFwicmluZ2luZ190aW1lb3V0XCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEdXJhdGlvbiB9LFxuICAgIHsgbm86IDEyLCBuYW1lOiBcIm1heF9jYWxsX2R1cmF0aW9uXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBEdXJhdGlvbiB9LFxuICAgIHtcbiAgICAgIG5vOiAxNCxcbiAgICAgIG5hbWU6IFwia3Jpc3BfZW5hYmxlZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDhcbiAgICAgIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xuICAgIH0sXG4gICAgeyBubzogMTgsIG5hbWU6IFwibWVkaWFfZW5jcnlwdGlvblwiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUE1lZGlhRW5jcnlwdGlvbikgfSxcbiAgICB7XG4gICAgICBubzogMTksXG4gICAgICBuYW1lOiBcIndhaXRfdW50aWxfYW5zd2VyZWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9XG4gIF1cbik7XG5jb25zdCBTSVBQYXJ0aWNpcGFudEluZm8gPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlNJUFBhcnRpY2lwYW50SW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcInBhcnRpY2lwYW50X2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAyLFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwicm9vbV9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJzaXBfY2FsbF9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfVxuICBdXG4pO1xuY29uc3QgVHJhbnNmZXJTSVBQYXJ0aWNpcGFudFJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi8gcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcbiAgXCJsaXZla2l0LlRyYW5zZmVyU0lQUGFydGljaXBhbnRSZXF1ZXN0XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInJvb21fbmFtZVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwidHJhbnNmZXJfdG9cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInBsYXlfZGlhbHRvbmVcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA4XG4gICAgICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwiaGVhZGVyc1wiLCBraW5kOiBcIm1hcFwiLCBLOiA5LCBWOiB7XG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9IH1cbiAgXVxuKTtcbmNvbnN0IFNJUENhbGxJbmZvID0gLyogQF9fUFVSRV9fICovIHByb3RvMy5tYWtlTWVzc2FnZVR5cGUoXG4gIFwibGl2ZWtpdC5TSVBDYWxsSW5mb1wiLFxuICAoKSA9PiBbXG4gICAge1xuICAgICAgbm86IDEsXG4gICAgICBuYW1lOiBcImNhbGxfaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDIsXG4gICAgICBuYW1lOiBcInRydW5rX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiAxNixcbiAgICAgIG5hbWU6IFwiZGlzcGF0Y2hfcnVsZV9pZFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTcsXG4gICAgICBuYW1lOiBcInJlZ2lvblwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwicm9vbV9uYW1lXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA0LFxuICAgICAgbmFtZTogXCJyb29tX2lkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogOVxuICAgICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIG5vOiA1LFxuICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7IG5vOiAxOCwgbmFtZTogXCJwYXJ0aWNpcGFudF9hdHRyaWJ1dGVzXCIsIGtpbmQ6IFwibWFwXCIsIEs6IDksIFY6IHtcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0gfSxcbiAgICB7IG5vOiA2LCBuYW1lOiBcImZyb21fdXJpXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBTSVBVcmkgfSxcbiAgICB7IG5vOiA3LCBuYW1lOiBcInRvX3VyaVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQVXJpIH0sXG4gICAge1xuICAgICAgbm86IDksXG4gICAgICBuYW1lOiBcImNyZWF0ZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTAsXG4gICAgICBuYW1lOiBcInN0YXJ0ZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTEsXG4gICAgICBuYW1lOiBcImVuZGVkX2F0XCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAgeyBubzogMTQsIG5hbWU6IFwiZW5hYmxlZF9mZWF0dXJlc1wiLCBraW5kOiBcImVudW1cIiwgVDogcHJvdG8zLmdldEVudW1UeXBlKFNJUEZlYXR1cmUpLCByZXBlYXRlZDogdHJ1ZSB9LFxuICAgIHsgbm86IDE1LCBuYW1lOiBcImNhbGxfZGlyZWN0aW9uXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU0lQQ2FsbERpcmVjdGlvbikgfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcImNhbGxfc3RhdHVzXCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU0lQQ2FsbFN0YXR1cykgfSxcbiAgICB7XG4gICAgICBubzogMjIsXG4gICAgICBuYW1lOiBcImNyZWF0ZWRfYXRfbnNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMjMsXG4gICAgICBuYW1lOiBcInN0YXJ0ZWRfYXRfbnNcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMjQsXG4gICAgICBuYW1lOiBcImVuZGVkX2F0X25zXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogM1xuICAgICAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xuICAgIH0sXG4gICAgeyBubzogMTIsIG5hbWU6IFwiZGlzY29ubmVjdF9yZWFzb25cIiwga2luZDogXCJlbnVtXCIsIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEaXNjb25uZWN0UmVhc29uKSB9LFxuICAgIHtcbiAgICAgIG5vOiAxMyxcbiAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMTksIG5hbWU6IFwiY2FsbF9zdGF0dXNfY29kZVwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogU0lQU3RhdHVzIH0sXG4gICAge1xuICAgICAgbm86IDIwLFxuICAgICAgbmFtZTogXCJhdWRpb19jb2RlY1wiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMjEsXG4gICAgICBuYW1lOiBcIm1lZGlhX2VuY3J5cHRpb25cIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH1cbiAgXVxuKTtcbmNvbnN0IFNJUFVyaSA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuU0lQVXJpXCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwidXNlclwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMixcbiAgICAgIG5hbWU6IFwiaG9zdFwiLFxuICAgICAga2luZDogXCJzY2FsYXJcIixcbiAgICAgIFQ6IDlcbiAgICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMyxcbiAgICAgIG5hbWU6IFwiaXBcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDQsXG4gICAgICBuYW1lOiBcInBvcnRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAxM1xuICAgICAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbiAgICB9LFxuICAgIHsgbm86IDUsIG5hbWU6IFwidHJhbnNwb3J0XCIsIGtpbmQ6IFwiZW51bVwiLCBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU0lQVHJhbnNwb3J0KSB9XG4gIF1cbik7XG5cbmNvbnN0IFdlYmhvb2tFdmVudCA9IC8qIEBfX1BVUkVfXyAqLyBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKFxuICBcImxpdmVraXQuV2ViaG9va0V2ZW50XCIsXG4gICgpID0+IFtcbiAgICB7XG4gICAgICBubzogMSxcbiAgICAgIG5hbWU6IFwiZXZlbnRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAgeyBubzogMiwgbmFtZTogXCJyb29tXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBSb29tIH0sXG4gICAgeyBubzogMywgbmFtZTogXCJwYXJ0aWNpcGFudFwiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogUGFydGljaXBhbnRJbmZvIH0sXG4gICAgeyBubzogOSwgbmFtZTogXCJlZ3Jlc3NfaW5mb1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogRWdyZXNzSW5mbyB9LFxuICAgIHsgbm86IDEwLCBuYW1lOiBcImluZ3Jlc3NfaW5mb1wiLCBraW5kOiBcIm1lc3NhZ2VcIiwgVDogSW5ncmVzc0luZm8gfSxcbiAgICB7IG5vOiA4LCBuYW1lOiBcInRyYWNrXCIsIGtpbmQ6IFwibWVzc2FnZVwiLCBUOiBUcmFja0luZm8gfSxcbiAgICB7XG4gICAgICBubzogNixcbiAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiA5XG4gICAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICAgIH0sXG4gICAge1xuICAgICAgbm86IDcsXG4gICAgICBuYW1lOiBcImNyZWF0ZWRfYXRcIixcbiAgICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgICBUOiAzXG4gICAgICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG4gICAgfSxcbiAgICB7XG4gICAgICBubzogMTEsXG4gICAgICBuYW1lOiBcIm51bV9kcm9wcGVkXCIsXG4gICAgICBraW5kOiBcInNjYWxhclwiLFxuICAgICAgVDogNVxuICAgICAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xuICAgIH1cbiAgXVxuKTtcblxuY29uc3QgdmVyc2lvbiA9IFwiMS4zNi4xXCI7XG5cbmV4cG9ydCB7IEFjdGl2ZVNwZWFrZXJVcGRhdGUsIEFkZFRyYWNrUmVxdWVzdCwgQWdlbnREaXNwYXRjaCwgQWdlbnREaXNwYXRjaFN0YXRlLCBBbGlPU1NVcGxvYWQsIEF1ZGlvQ29kZWMsIEF1ZGlvTWl4aW5nLCBBdWRpb1RyYWNrRmVhdHVyZSwgQXV0b1BhcnRpY2lwYW50RWdyZXNzLCBBdXRvVHJhY2tFZ3Jlc3MsIEF2YWlsYWJpbGl0eVJlcXVlc3QsIEF2YWlsYWJpbGl0eVJlc3BvbnNlLCBBenVyZUJsb2JVcGxvYWQsIEJhY2t1cENvZGVjUG9saWN5LCBDYW5kaWRhdGVQcm90b2NvbCwgQ2hhdE1lc3NhZ2UsIENsaWVudENvbmZpZ1NldHRpbmcsIENsaWVudENvbmZpZ3VyYXRpb24sIENsaWVudEluZm8sIENsaWVudEluZm9fU0RLLCBDb2RlYywgQ29ubmVjdGlvblF1YWxpdHksIENvbm5lY3Rpb25RdWFsaXR5SW5mbywgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIENyZWF0ZUFnZW50RGlzcGF0Y2hSZXF1ZXN0LCBDcmVhdGVJbmdyZXNzUmVxdWVzdCwgQ3JlYXRlUm9vbVJlcXVlc3QsIENyZWF0ZVNJUERpc3BhdGNoUnVsZVJlcXVlc3QsIENyZWF0ZVNJUEluYm91bmRUcnVua1JlcXVlc3QsIENyZWF0ZVNJUE91dGJvdW5kVHJ1bmtSZXF1ZXN0LCBDcmVhdGVTSVBQYXJ0aWNpcGFudFJlcXVlc3QsIENyZWF0ZVNJUFRydW5rUmVxdWVzdCwgRGF0YUNoYW5uZWxJbmZvLCBEYXRhUGFja2V0LCBEYXRhUGFja2V0X0tpbmQsIERhdGFTdHJlYW0sIERhdGFTdHJlYW1fQnl0ZUhlYWRlciwgRGF0YVN0cmVhbV9DaHVuaywgRGF0YVN0cmVhbV9IZWFkZXIsIERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSwgRGF0YVN0cmVhbV9UZXh0SGVhZGVyLCBEYXRhU3RyZWFtX1RyYWlsZXIsIERlbGV0ZUFnZW50RGlzcGF0Y2hSZXF1ZXN0LCBEZWxldGVJbmdyZXNzUmVxdWVzdCwgRGVsZXRlUm9vbVJlcXVlc3QsIERlbGV0ZVJvb21SZXNwb25zZSwgRGVsZXRlU0lQRGlzcGF0Y2hSdWxlUmVxdWVzdCwgRGVsZXRlU0lQVHJ1bmtSZXF1ZXN0LCBEaXJlY3RGaWxlT3V0cHV0LCBEaXNhYmxlZENvZGVjcywgRGlzY29ubmVjdFJlYXNvbiwgRWdyZXNzSW5mbywgRWdyZXNzU291cmNlVHlwZSwgRWdyZXNzU3RhdHVzLCBFbmNvZGVkRmlsZU91dHB1dCwgRW5jb2RlZEZpbGVUeXBlLCBFbmNvZGluZ09wdGlvbnMsIEVuY29kaW5nT3B0aW9uc1ByZXNldCwgRW5jcnlwdGlvbiwgRW5jcnlwdGlvbl9UeXBlLCBFdmVudE1ldHJpYywgRmlsZUluZm8sIEZvcndhcmRQYXJ0aWNpcGFudFJlcXVlc3QsIEZvcndhcmRQYXJ0aWNpcGFudFJlc3BvbnNlLCBHQ1BVcGxvYWQsIEdldFNJUEluYm91bmRUcnVua1JlcXVlc3QsIEdldFNJUEluYm91bmRUcnVua1Jlc3BvbnNlLCBHZXRTSVBPdXRib3VuZFRydW5rUmVxdWVzdCwgR2V0U0lQT3V0Ym91bmRUcnVua1Jlc3BvbnNlLCBJQ0VTZXJ2ZXIsIEltYWdlQ29kZWMsIEltYWdlRmlsZVN1ZmZpeCwgSW1hZ2VPdXRwdXQsIEltYWdlc0luZm8sIEluZ3Jlc3NBdWRpb0VuY29kaW5nT3B0aW9ucywgSW5ncmVzc0F1ZGlvRW5jb2RpbmdQcmVzZXQsIEluZ3Jlc3NBdWRpb09wdGlvbnMsIEluZ3Jlc3NJbmZvLCBJbmdyZXNzSW5wdXQsIEluZ3Jlc3NTdGF0ZSwgSW5ncmVzc1N0YXRlX1N0YXR1cywgSW5ncmVzc1ZpZGVvRW5jb2RpbmdPcHRpb25zLCBJbmdyZXNzVmlkZW9FbmNvZGluZ1ByZXNldCwgSW5ncmVzc1ZpZGVvT3B0aW9ucywgSW5wdXRBdWRpb1N0YXRlLCBJbnB1dFZpZGVvU3RhdGUsIEpvYiwgSm9iQXNzaWdubWVudCwgSm9iU3RhdGUsIEpvYlN0YXR1cywgSm9iVGVybWluYXRpb24sIEpvYlR5cGUsIEpvaW5SZXNwb25zZSwgTGVhdmVSZXF1ZXN0LCBMZWF2ZVJlcXVlc3RfQWN0aW9uLCBMaXN0QWdlbnREaXNwYXRjaFJlcXVlc3QsIExpc3RBZ2VudERpc3BhdGNoUmVzcG9uc2UsIExpc3RFZ3Jlc3NSZXF1ZXN0LCBMaXN0RWdyZXNzUmVzcG9uc2UsIExpc3RJbmdyZXNzUmVxdWVzdCwgTGlzdEluZ3Jlc3NSZXNwb25zZSwgTGlzdFBhcnRpY2lwYW50c1JlcXVlc3QsIExpc3RQYXJ0aWNpcGFudHNSZXNwb25zZSwgTGlzdFJvb21zUmVxdWVzdCwgTGlzdFJvb21zUmVzcG9uc2UsIExpc3RTSVBEaXNwYXRjaFJ1bGVSZXF1ZXN0LCBMaXN0U0lQRGlzcGF0Y2hSdWxlUmVzcG9uc2UsIExpc3RTSVBJbmJvdW5kVHJ1bmtSZXF1ZXN0LCBMaXN0U0lQSW5ib3VuZFRydW5rUmVzcG9uc2UsIExpc3RTSVBPdXRib3VuZFRydW5rUmVxdWVzdCwgTGlzdFNJUE91dGJvdW5kVHJ1bmtSZXNwb25zZSwgTGlzdFNJUFRydW5rUmVxdWVzdCwgTGlzdFNJUFRydW5rUmVzcG9uc2UsIExpc3RVcGRhdGUsIE1ldHJpY0xhYmVsLCBNZXRyaWNTYW1wbGUsIE1ldHJpY3NCYXRjaCwgTWlncmF0ZUpvYlJlcXVlc3QsIE11dGVSb29tVHJhY2tSZXF1ZXN0LCBNdXRlUm9vbVRyYWNrUmVzcG9uc2UsIE11dGVUcmFja1JlcXVlc3QsIFBhZ2luYXRpb24sIFBhcnRpY2lwYW50RWdyZXNzUmVxdWVzdCwgUGFydGljaXBhbnRJbmZvLCBQYXJ0aWNpcGFudEluZm9fS2luZCwgUGFydGljaXBhbnRJbmZvX0tpbmREZXRhaWwsIFBhcnRpY2lwYW50SW5mb19TdGF0ZSwgUGFydGljaXBhbnRQZXJtaXNzaW9uLCBQYXJ0aWNpcGFudFRyYWNrcywgUGFydGljaXBhbnRVcGRhdGUsIFBpbmcsIFBsYXlvdXREZWxheSwgUG9uZywgUHJveHlDb25maWcsIFJUQ1BTZW5kZXJSZXBvcnRTdGF0ZSwgUlRQRHJpZnQsIFJUUEZvcndhcmRlclN0YXRlLCBSVFBNdW5nZXJTdGF0ZSwgUlRQU3RhdHMsIFJlY29ubmVjdFJlYXNvbiwgUmVjb25uZWN0UmVzcG9uc2UsIFJlZ2lvbkluZm8sIFJlZ2lvblNldHRpbmdzLCBSZWdpc3RlcldvcmtlclJlcXVlc3QsIFJlZ2lzdGVyV29ya2VyUmVzcG9uc2UsIFJlbW92ZVBhcnRpY2lwYW50UmVzcG9uc2UsIFJlcXVlc3RSZXNwb25zZSwgUmVxdWVzdFJlc3BvbnNlX1JlYXNvbiwgUm9vbSwgUm9vbUFnZW50LCBSb29tQWdlbnREaXNwYXRjaCwgUm9vbUNvbXBvc2l0ZUVncmVzc1JlcXVlc3QsIFJvb21Db25maWd1cmF0aW9uLCBSb29tRWdyZXNzLCBSb29tUGFydGljaXBhbnRJZGVudGl0eSwgUm9vbVVwZGF0ZSwgUnBjQWNrLCBScGNFcnJvciwgUnBjUmVxdWVzdCwgUnBjUmVzcG9uc2UsIFMzVXBsb2FkLCBTSVBDYWxsRGlyZWN0aW9uLCBTSVBDYWxsSW5mbywgU0lQQ2FsbFN0YXR1cywgU0lQRGlzcGF0Y2hSdWxlLCBTSVBEaXNwYXRjaFJ1bGVDYWxsZWUsIFNJUERpc3BhdGNoUnVsZURpcmVjdCwgU0lQRGlzcGF0Y2hSdWxlSW5kaXZpZHVhbCwgU0lQRGlzcGF0Y2hSdWxlSW5mbywgU0lQRGlzcGF0Y2hSdWxlVXBkYXRlLCBTSVBGZWF0dXJlLCBTSVBIZWFkZXJPcHRpb25zLCBTSVBJbmJvdW5kVHJ1bmtJbmZvLCBTSVBJbmJvdW5kVHJ1bmtVcGRhdGUsIFNJUE1lZGlhRW5jcnlwdGlvbiwgU0lQT3V0Ym91bmRDb25maWcsIFNJUE91dGJvdW5kVHJ1bmtJbmZvLCBTSVBPdXRib3VuZFRydW5rVXBkYXRlLCBTSVBQYXJ0aWNpcGFudEluZm8sIFNJUFN0YXR1cywgU0lQU3RhdHVzQ29kZSwgU0lQVHJhbnNwb3J0LCBTSVBUcnVua0luZm8sIFNJUFRydW5rSW5mb19UcnVua0tpbmQsIFNJUFVyaSwgU2VnbWVudGVkRmlsZU91dHB1dCwgU2VnbWVudGVkRmlsZVByb3RvY29sLCBTZWdtZW50ZWRGaWxlU3VmZml4LCBTZWdtZW50c0luZm8sIFNlbmREYXRhUmVxdWVzdCwgU2VuZERhdGFSZXNwb25zZSwgU2VydmVySW5mbywgU2VydmVySW5mb19FZGl0aW9uLCBTZXJ2ZXJNZXNzYWdlLCBTZXNzaW9uRGVzY3JpcHRpb24sIFNpZ25hbFJlcXVlc3QsIFNpZ25hbFJlc3BvbnNlLCBTaWduYWxUYXJnZXQsIFNpbXVsYXRlSm9iUmVxdWVzdCwgU2ltdWxhdGVTY2VuYXJpbywgU2ltdWxjYXN0Q29kZWMsIFNpbXVsY2FzdENvZGVjSW5mbywgU2lwRFRNRiwgU3BlYWtlckluZm8sIFNwZWFrZXJzQ2hhbmdlZCwgU3RvcEVncmVzc1JlcXVlc3QsIFN0cmVhbUluZm8sIFN0cmVhbUluZm9MaXN0LCBTdHJlYW1JbmZvX1N0YXR1cywgU3RyZWFtT3V0cHV0LCBTdHJlYW1Qcm90b2NvbCwgU3RyZWFtU3RhdGUsIFN0cmVhbVN0YXRlSW5mbywgU3RyZWFtU3RhdGVVcGRhdGUsIFN1YnNjcmliZWRDb2RlYywgU3Vic2NyaWJlZFF1YWxpdHksIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLCBTdWJzY3JpcHRpb25FcnJvciwgU3Vic2NyaXB0aW9uUGVybWlzc2lvbiwgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgU3Vic2NyaXB0aW9uUmVzcG9uc2UsIFN5bmNTdGF0ZSwgVGltZVNlcmllc01ldHJpYywgVGltZWRWZXJzaW9uLCBUcmFja0NvbXBvc2l0ZUVncmVzc1JlcXVlc3QsIFRyYWNrRWdyZXNzUmVxdWVzdCwgVHJhY2tJbmZvLCBUcmFja1Blcm1pc3Npb24sIFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsIFRyYWNrU291cmNlLCBUcmFja1N1YnNjcmliZWQsIFRyYWNrVHlwZSwgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLCBUcmFuc2NyaXB0aW9uLCBUcmFuc2NyaXB0aW9uU2VnbWVudCwgVHJhbnNmZXJTSVBQYXJ0aWNpcGFudFJlcXVlc3QsIFRyaWNrbGVSZXF1ZXN0LCBVcGRhdGVJbmdyZXNzUmVxdWVzdCwgVXBkYXRlSm9iU3RhdHVzLCBVcGRhdGVMYXlvdXRSZXF1ZXN0LCBVcGRhdGVMb2NhbEF1ZGlvVHJhY2ssIFVwZGF0ZUxvY2FsVmlkZW9UcmFjaywgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSwgVXBkYXRlUGFydGljaXBhbnRSZXF1ZXN0LCBVcGRhdGVSb29tTWV0YWRhdGFSZXF1ZXN0LCBVcGRhdGVTSVBEaXNwYXRjaFJ1bGVSZXF1ZXN0LCBVcGRhdGVTSVBJbmJvdW5kVHJ1bmtSZXF1ZXN0LCBVcGRhdGVTSVBPdXRib3VuZFRydW5rUmVxdWVzdCwgVXBkYXRlU3RyZWFtUmVxdWVzdCwgVXBkYXRlU3Vic2NyaXB0aW9uLCBVcGRhdGVTdWJzY3JpcHRpb25zUmVxdWVzdCwgVXBkYXRlU3Vic2NyaXB0aW9uc1Jlc3BvbnNlLCBVcGRhdGVUcmFja1NldHRpbmdzLCBVcGRhdGVWaWRlb0xheWVycywgVXBkYXRlV29ya2VyU3RhdHVzLCBVc2VyUGFja2V0LCBWUDhNdW5nZXJTdGF0ZSwgVmlkZW9Db2RlYywgVmlkZW9Db25maWd1cmF0aW9uLCBWaWRlb0xheWVyLCBWaWRlb1F1YWxpdHksIFdlYkVncmVzc1JlcXVlc3QsIFdlYmhvb2tFdmVudCwgV29ya2VyTWVzc2FnZSwgV29ya2VyUGluZywgV29ya2VyUG9uZywgV29ya2VyU3RhdHVzLCB2ZXJzaW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbnVsbDtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcygpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGFjdHVhbCBtZXRob2RzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG5cbiAgICAgICAgLy8gUmV0dXJuIGFueSBpbXBvcnRhbnQgd2FybmluZ3MuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHRoaXMubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBfbGV2ZWwsIF9sb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGZhY3RvcnkpIHtcbiAgICAgIC8vIFByaXZhdGUgaW5zdGFuY2UgdmFyaWFibGVzLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbGV2ZWwgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgbG9nZ2VyIChvciBhIGdsb2JhbCBkZWZhdWx0KS4gV2VcbiAgICAgICAqIGNhY2hlIHRoaXMgaGVyZSByYXRoZXIgdGhhbiBkZWxlZ2F0aW5nIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBzdGF5c1xuICAgICAgICogaW4gc3luYyB3aXRoIHRoZSBhY3R1YWwgbG9nZ2luZyBtZXRob2RzIHRoYXQgd2UgaGF2ZSBpbnN0YWxsZWQgKHRoZVxuICAgICAgICogcGFyZW50IGNvdWxkIGNoYW5nZSBsZXZlbHMgYnV0IHdlIG1pZ2h0IG5vdCBoYXZlIHJlYnVpbHQgdGhlIGxvZ2dlcnNcbiAgICAgICAqIGluIHRoaXMgY2hpbGQgeWV0KS5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHZhciBpbmhlcml0ZWRMZXZlbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLCBpZiBhbnkuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBpbmhlcml0ZWRMZXZlbGAuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgKi9cbiAgICAgIHZhciBkZWZhdWx0TGV2ZWw7XG4gICAgICAvKipcbiAgICAgICAqIEEgdXNlci1zcGVjaWZpYyBsZXZlbCBmb3IgdGhpcyBsb2dnZXIuIElmIHNldCwgdGhpcyBvdmVycmlkZXNcbiAgICAgICAqIGBkZWZhdWx0TGV2ZWxgLlxuICAgICAgICogQHR5cGUge251bWJlcnxudWxsfVxuICAgICAgICovXG4gICAgICB2YXIgdXNlckxldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWVOYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoY29va2llTmFtZSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llLnNsaWNlKGxvY2F0aW9uICsgY29va2llTmFtZS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgICAgICAgIClbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPTsgZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAwIFVUQ1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbm9ybWFsaXplTGV2ZWwoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBpbnB1dDtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodXNlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VyTGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0TGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluaGVyaXRlZExldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUodXNlckxldmVsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBpbiB2MiwgdGhpcyBzaG91bGQgY2FsbCByZWJ1aWxkKCksIHdoaWNoIHVwZGF0ZXMgY2hpbGRyZW4uXG4gICAgICAgICAgcmV0dXJuIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBub3JtYWxpemVMZXZlbChsZXZlbCk7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlc2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbnVsbDtcbiAgICAgICAgICBjbGVhclBlcnNpc3RlZExldmVsKCk7XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyLmdldExldmVsKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcblxuICAgICAgICAgIGlmIChkZWZhdWx0TG9nZ2VyID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBfbG9nZ2Vyc0J5TmFtZSkge1xuICAgICAgICAgICAgICAgIF9sb2dnZXJzQnlOYW1lW2NoaWxkTmFtZV0ucmVidWlsZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgdGhlIGludGVybmFsIGxldmVscy5cbiAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoXG4gICAgICAgICAgZGVmYXVsdExvZ2dlciA/IGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSA6IFwiV0FSTlwiXG4gICAgICApO1xuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsICE9IG51bGwpIHtcbiAgICAgICAgICB1c2VyTGV2ZWwgPSBub3JtYWxpemVMZXZlbChpbml0aWFsTGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgZGVmYXVsdExvZ2dlclsnZGVmYXVsdCddID0gZGVmYXVsdExvZ2dlcjtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcblxuZXhwb3J0IGVudW0gTG9nTGV2ZWwge1xuICB0cmFjZSA9IDAsXG4gIGRlYnVnID0gMSxcbiAgaW5mbyA9IDIsXG4gIHdhcm4gPSAzLFxuICBlcnJvciA9IDQsXG4gIHNpbGVudCA9IDUsXG59XG5cbmV4cG9ydCBlbnVtIExvZ2dlck5hbWVzIHtcbiAgRGVmYXVsdCA9ICdsaXZla2l0JyxcbiAgUm9vbSA9ICdsaXZla2l0LXJvb20nLFxuICBQYXJ0aWNpcGFudCA9ICdsaXZla2l0LXBhcnRpY2lwYW50JyxcbiAgVHJhY2sgPSAnbGl2ZWtpdC10cmFjaycsXG4gIFB1YmxpY2F0aW9uID0gJ2xpdmVraXQtdHJhY2stcHVibGljYXRpb24nLFxuICBFbmdpbmUgPSAnbGl2ZWtpdC1lbmdpbmUnLFxuICBTaWduYWwgPSAnbGl2ZWtpdC1zaWduYWwnLFxuICBQQ01hbmFnZXIgPSAnbGl2ZWtpdC1wYy1tYW5hZ2VyJyxcbiAgUENUcmFuc3BvcnQgPSAnbGl2ZWtpdC1wYy10cmFuc3BvcnQnLFxuICBFMkVFID0gJ2xrLWUyZWUnLFxufVxuXG50eXBlIExvZ0xldmVsU3RyaW5nID0ga2V5b2YgdHlwZW9mIExvZ0xldmVsO1xuXG5leHBvcnQgdHlwZSBTdHJ1Y3R1cmVkTG9nZ2VyID0gbG9nLkxvZ2dlciAmIHtcbiAgdHJhY2U6IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgZGVidWc6IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgaW5mbzogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICB3YXJuOiAobXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG4gIGVycm9yOiAobXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG4gIHNldERlZmF1bHRMZXZlbDogKGxldmVsOiBsb2cuTG9nTGV2ZWxEZXNjKSA9PiB2b2lkO1xuICBzZXRMZXZlbDogKGxldmVsOiBsb2cuTG9nTGV2ZWxEZXNjKSA9PiB2b2lkO1xuICBnZXRMZXZlbDogKCkgPT4gbnVtYmVyO1xufTtcblxubGV0IGxpdmVraXRMb2dnZXIgPSBsb2cuZ2V0TG9nZ2VyKCdsaXZla2l0Jyk7XG5jb25zdCBsaXZla2l0TG9nZ2VycyA9IE9iamVjdC52YWx1ZXMoTG9nZ2VyTmFtZXMpLm1hcCgobmFtZSkgPT4gbG9nLmdldExvZ2dlcihuYW1lKSk7XG5cbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xuXG5leHBvcnQgZGVmYXVsdCBsaXZla2l0TG9nZ2VyIGFzIFN0cnVjdHVyZWRMb2dnZXI7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZTogc3RyaW5nKSB7XG4gIGNvbnN0IGxvZ2dlciA9IGxvZy5nZXRMb2dnZXIobmFtZSk7XG4gIGxvZ2dlci5zZXREZWZhdWx0TGV2ZWwobGl2ZWtpdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgcmV0dXJuIGxvZ2dlciBhcyBTdHJ1Y3R1cmVkTG9nZ2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWw6IExvZ0xldmVsIHwgTG9nTGV2ZWxTdHJpbmcsIGxvZ2dlck5hbWU/OiBMb2dnZXJOYW1lcykge1xuICBpZiAobG9nZ2VyTmFtZSkge1xuICAgIGxvZy5nZXRMb2dnZXIobG9nZ2VyTmFtZSkuc2V0TGV2ZWwobGV2ZWwpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgbG9nZ2VyIG9mIGxpdmVraXRMb2dnZXJzKSB7XG4gICAgICBsb2dnZXIuc2V0TGV2ZWwobGV2ZWwpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBMb2dFeHRlbnNpb24gPSAobGV2ZWw6IExvZ0xldmVsLCBtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcblxuLyoqXG4gKiB1c2UgdGhpcyB0byBob29rIGludG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24gdG8gYWxsb3cgc2VuZGluZyBpbnRlcm5hbCBsaXZla2l0IGxvZ3MgdG8gdGhpcmQgcGFydHkgc2VydmljZXNcbiAqIGlmIHNldCwgdGhlIGJyb3dzZXIgbG9ncyB3aWxsIGxvc2UgdGhlaXIgc3RhY2t0cmFjZSBpbmZvcm1hdGlvbiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCN3cml0aW5nLXBsdWdpbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dFeHRlbnNpb24oZXh0ZW5zaW9uOiBMb2dFeHRlbnNpb24sIGxvZ2dlcj86IFN0cnVjdHVyZWRMb2dnZXIpIHtcbiAgY29uc3QgbG9nZ2VycyA9IGxvZ2dlciA/IFtsb2dnZXJdIDogbGl2ZWtpdExvZ2dlcnM7XG5cbiAgbG9nZ2Vycy5mb3JFYWNoKChsb2dSKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbG9nUi5tZXRob2RGYWN0b3J5O1xuXG4gICAgbG9nUi5tZXRob2RGYWN0b3J5ID0gKG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpO1xuXG4gICAgICBjb25zdCBsb2dMZXZlbCA9IExvZ0xldmVsW21ldGhvZE5hbWUgYXMgTG9nTGV2ZWxTdHJpbmddO1xuICAgICAgY29uc3QgbmVlZExvZyA9IGxvZ0xldmVsID49IGNvbmZpZ0xldmVsICYmIGxvZ0xldmVsIDwgTG9nTGV2ZWwuc2lsZW50O1xuXG4gICAgICByZXR1cm4gKG1zZywgY29udGV4dD86IFttc2c6IHN0cmluZywgY29udGV4dDogb2JqZWN0XSkgPT4ge1xuICAgICAgICBpZiAoY29udGV4dCkgcmF3TWV0aG9kKG1zZywgY29udGV4dCk7XG4gICAgICAgIGVsc2UgcmF3TWV0aG9kKG1zZyk7XG4gICAgICAgIGlmIChuZWVkTG9nKSB7XG4gICAgICAgICAgZXh0ZW5zaW9uKGxvZ0xldmVsLCBtc2csIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgbG9nUi5zZXRMZXZlbChsb2dSLmdldExldmVsKCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IHdvcmtlckxvZ2dlciA9IGxvZy5nZXRMb2dnZXIoJ2xrLWUyZWUnKSBhcyBTdHJ1Y3R1cmVkTG9nZ2VyO1xuIiwiaW1wb3J0IHR5cGUgeyBSZWNvbm5lY3RDb250ZXh0LCBSZWNvbm5lY3RQb2xpY3kgfSBmcm9tICcuL1JlY29ubmVjdFBvbGljeSc7XG5cbmNvbnN0IG1heFJldHJ5RGVsYXkgPSA3MDAwO1xuXG5jb25zdCBERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyA9IFtcbiAgMCxcbiAgMzAwLFxuICAyICogMiAqIDMwMCxcbiAgMyAqIDMgKiAzMDAsXG4gIDQgKiA0ICogMzAwLFxuICBtYXhSZXRyeURlbGF5LFxuICBtYXhSZXRyeURlbGF5LFxuICBtYXhSZXRyeURlbGF5LFxuICBtYXhSZXRyeURlbGF5LFxuICBtYXhSZXRyeURlbGF5LFxuXTtcblxuY2xhc3MgRGVmYXVsdFJlY29ubmVjdFBvbGljeSBpbXBsZW1lbnRzIFJlY29ubmVjdFBvbGljeSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3JldHJ5RGVsYXlzOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihyZXRyeURlbGF5cz86IG51bWJlcltdKSB7XG4gICAgdGhpcy5fcmV0cnlEZWxheXMgPSByZXRyeURlbGF5cyAhPT0gdW5kZWZpbmVkID8gWy4uLnJldHJ5RGVsYXlzXSA6IERFRkFVTFRfUkVUUllfREVMQVlTX0lOX01TO1xuICB9XG5cbiAgcHVibGljIG5leHRSZXRyeURlbGF5SW5Ncyhjb250ZXh0OiBSZWNvbm5lY3RDb250ZXh0KTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKGNvbnRleHQucmV0cnlDb3VudCA+PSB0aGlzLl9yZXRyeURlbGF5cy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgcmV0cnlEZWxheSA9IHRoaXMuX3JldHJ5RGVsYXlzW2NvbnRleHQucmV0cnlDb3VudF07XG4gICAgaWYgKGNvbnRleHQucmV0cnlDb3VudCA8PSAxKSByZXR1cm4gcmV0cnlEZWxheTtcblxuICAgIHJldHVybiByZXRyeURlbGF5ICsgTWF0aC5yYW5kb20oKSAqIDFfMDAwO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERlZmF1bHRSZWNvbm5lY3RQb2xpY3k7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxubGV0IGxvZ0Rpc2FibGVkXyA9IHRydWU7XG5sZXQgZGVwcmVjYXRpb25XYXJuaW5nc18gPSB0cnVlO1xuXG4vKipcbiAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSB1YXN0cmluZyB1c2VyQWdlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7IW51bWJlcn0gYnJvd3NlciB2ZXJzaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFZlcnNpb24odWFzdHJpbmcsIGV4cHIsIHBvcykge1xuICBjb25zdCBtYXRjaCA9IHVhc3RyaW5nLm1hdGNoKGV4cHIpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IHBvcyAmJiBwYXJzZUludChtYXRjaFtwb3NdLCAxMCk7XG59XG5cbi8vIFdyYXBzIHRoZSBwZWVyY29ubmVjdGlvbiBldmVudCBldmVudE5hbWVUb1dyYXAgaW4gYSBmdW5jdGlvblxuLy8gd2hpY2ggcmV0dXJucyB0aGUgbW9kaWZpZWQgZXZlbnQgb2JqZWN0IChvciBmYWxzZSB0byBwcmV2ZW50XG4vLyB0aGUgZXZlbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3QgbmF0aXZlQWRkRXZlbnRMaXN0ZW5lciA9IHByb3RvLmFkZEV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwKSB7XG4gICAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZWRFdmVudCA9IHdyYXBwZXIoZSk7XG4gICAgICBpZiAobW9kaWZpZWRFdmVudCkge1xuICAgICAgICBpZiAoY2IuaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICBjYi5oYW5kbGVFdmVudChtb2RpZmllZEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihtb2RpZmllZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRNYXAgPSB0aGlzLl9ldmVudE1hcCB8fCB7fTtcbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0gPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2V0KGNiLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsXG4gICAgICB3cmFwcGVkQ2FsbGJhY2tdKTtcbiAgfTtcblxuICBjb25zdCBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXAgfHwgIXRoaXMuX2V2ZW50TWFwXG4gICAgICAgIHx8ICF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uaGFzKGNiKSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgdW53cmFwcGVkQ2IgPSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmdldChjYik7XG4gICAgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5kZWxldGUoY2IpO1xuICAgIGlmICh0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLnNpemUgPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZXZlbnRNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLFxuICAgICAgdW53cmFwcGVkQ2JdKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgfSxcbiAgICBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lVG9XcmFwLFxuICAgICAgICAgIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsXG4gICAgICAgICAgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0gPSBjYik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVMb2coYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArXG4gICAgICAgICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGxvZ0Rpc2FibGVkXyA9IGJvb2w7XG4gIHJldHVybiAoYm9vbCkgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6XG4gICAgJ2FkYXB0ZXIuanMgbG9nZ2luZyBlbmFibGVkJztcbn1cblxuLyoqXG4gKiBEaXNhYmxlIG9yIGVuYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5nc1xuICogQHBhcmFtIHshYm9vbGVhbn0gYm9vbCBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHdhcm5pbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVdhcm5pbmdzKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgdHlwZW9mIGJvb2wgK1xuICAgICAgICAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2coKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQob2xkTWV0aG9kLCBuZXdNZXRob2QpIHtcbiAgaWYgKCFkZXByZWNhdGlvbldhcm5pbmdzXykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4ob2xkTWV0aG9kICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBuZXdNZXRob2QgK1xuICAgICAgJyBpbnN0ZWFkLicpO1xufVxuXG4vKipcbiAqIEJyb3dzZXIgZGV0ZWN0b3IuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSByZXN1bHQgY29udGFpbmluZyBicm93c2VyIGFuZCB2ZXJzaW9uXG4gKiAgICAgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG4gIGNvbnN0IHJlc3VsdCA9IHticm93c2VyOiBudWxsLCB2ZXJzaW9uOiBudWxsfTtcblxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHxcbiAgICAgICF3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29uc3Qge25hdmlnYXRvcn0gPSB3aW5kb3c7XG5cbiAgLy8gUHJlZmVyIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLlxuICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuYnJhbmRzKSB7XG4gICAgY29uc3QgY2hyb21pdW0gPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5icmFuZHMuZmluZCgoYnJhbmQpID0+IHtcbiAgICAgIHJldHVybiBicmFuZC5icmFuZCA9PT0gJ0Nocm9taXVtJztcbiAgICB9KTtcbiAgICBpZiAoY2hyb21pdW0pIHtcbiAgICAgIHJldHVybiB7YnJvd3NlcjogJ2Nocm9tZScsIHZlcnNpb246IHBhcnNlSW50KGNocm9taXVtLnZlcnNpb24sIDEwKX07XG4gICAgfVxuICB9XG5cbiAgaWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHsgLy8gRmlyZWZveC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdmaXJlZm94JztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICAvRmlyZWZveFxcLyhcXGQrKVxcLi8sIDEpO1xuICB9IGVsc2UgaWYgKG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHxcbiAgICAgICh3aW5kb3cuaXNTZWN1cmVDb250ZXh0ID09PSBmYWxzZSAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgLy8gQ2hyb21lLCBDaHJvbWl1bSwgV2VidmlldywgT3BlcmEuXG4gICAgLy8gVmVyc2lvbiBtYXRjaGVzIENocm9tZS9XZWJSVEMgdmVyc2lvbi5cbiAgICAvLyBDaHJvbWUgNzQgcmVtb3ZlZCB3ZWJraXRHZXRVc2VyTWVkaWEgb24gaHR0cCBhcyB3ZWxsIHNvIHdlIG5lZWQgdGhlXG4gICAgLy8gbW9yZSBjb21wbGljYXRlZCBmYWxsYmFjayB0byB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIC9DaHJvbShlfGl1bSlcXC8oXFxkKylcXC4vLCAyKTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLykpIHsgLy8gU2FmYXJpLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLywgMSk7XG4gICAgcmVzdWx0LnN1cHBvcnRzVW5pZmllZFBsYW4gPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgJiZcbiAgICAgICAgJ2N1cnJlbnREaXJlY3Rpb24nIGluIHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7IC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgc3VwcG9ydGVkIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgc29tZXRoaW5nIHlvdSB3YW50IHRvIGNoZWNrLlxuICogQHJldHVybiB0cnVlIGlmIHZhbCBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBlbXB0eSBvYmplY3RzIGFuZCB1bmRlZmluZWQgdmFsdWVzXG4gKiBmcm9tIGEgbmVzdGVkIG9iamVjdCAtLSBhbiBlbmhhbmNlZCBhbmQgdmFuaWxsYSB2ZXJzaW9uXG4gKiBvZiBMb2Rhc2gncyBgY29tcGFjdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYWN0T2JqZWN0KGRhdGEpIHtcbiAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbihhY2N1bXVsYXRvciwga2V5KSB7XG4gICAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhW2tleV0pO1xuICAgIGNvbnN0IHZhbHVlID0gaXNPYmogPyBjb21wYWN0T2JqZWN0KGRhdGFba2V5XSkgOiBkYXRhW2tleV07XG4gICAgY29uc3QgaXNFbXB0eU9iamVjdCA9IGlzT2JqICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzRW1wdHlPYmplY3QpIHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjdW11bGF0b3IsIHtba2V5XTogdmFsdWV9KTtcbiAgfSwge30pO1xufVxuXG4vKiBpdGVyYXRlcyB0aGUgc3RhdHMgZ3JhcGggcmVjdXJzaXZlbHkuICovXG5leHBvcnQgZnVuY3Rpb24gd2Fsa1N0YXRzKHN0YXRzLCBiYXNlLCByZXN1bHRTZXQpIHtcbiAgaWYgKCFiYXNlIHx8IHJlc3VsdFNldC5oYXMoYmFzZS5pZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdWx0U2V0LnNldChiYXNlLmlkLCBiYXNlKTtcbiAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnSWQnKSkge1xuICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoYmFzZVtuYW1lXSksIHJlc3VsdFNldCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmVuZHNXaXRoKCdJZHMnKSkge1xuICAgICAgYmFzZVtuYW1lXS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoaWQpLCByZXN1bHRTZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogZmlsdGVyIGdldFN0YXRzIGZvciBhIHNlbmRlci9yZWNlaXZlciB0cmFjay4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHRyYWNrLCBvdXRib3VuZCkge1xuICBjb25zdCBzdHJlYW1TdGF0c1R5cGUgPSBvdXRib3VuZCA/ICdvdXRib3VuZC1ydHAnIDogJ2luYm91bmQtcnRwJztcbiAgY29uc3QgZmlsdGVyZWRSZXN1bHQgPSBuZXcgTWFwKCk7XG4gIGlmICh0cmFjayA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbiAgfVxuICBjb25zdCB0cmFja1N0YXRzID0gW107XG4gIHJlc3VsdC5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ3RyYWNrJyAmJlxuICAgICAgICB2YWx1ZS50cmFja0lkZW50aWZpZXIgPT09IHRyYWNrLmlkKSB7XG4gICAgICB0cmFja1N0YXRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHRyYWNrU3RhdHMuZm9yRWFjaCh0cmFja1N0YXQgPT4ge1xuICAgIHJlc3VsdC5mb3JFYWNoKHN0YXRzID0+IHtcbiAgICAgIGlmIChzdGF0cy50eXBlID09PSBzdHJlYW1TdGF0c1R5cGUgJiYgc3RhdHMudHJhY2tJZCA9PT0gdHJhY2tTdGF0LmlkKSB7XG4gICAgICAgIHdhbGtTdGF0cyhyZXN1bHQsIHN0YXRzLCBmaWx0ZXJlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG59XG5cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5jb25zdCBsb2dnaW5nID0gdXRpbHMubG9nO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNvbnN0cmFpbnRzVG9DaHJvbWVfID0gZnVuY3Rpb24oYykge1xuICAgIGlmICh0eXBlb2YgYyAhPT0gJ29iamVjdCcgfHwgYy5tYW5kYXRvcnkgfHwgYy5vcHRpb25hbCkge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGNvbnN0IGNjID0ge307XG4gICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlcXVpcmUnIHx8IGtleSA9PT0gJ2FkdmFuY2VkJyB8fCBrZXkgPT09ICdtZWRpYVNvdXJjZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgciA9ICh0eXBlb2YgY1trZXldID09PSAnb2JqZWN0JykgPyBjW2tleV0gOiB7aWRlYWw6IGNba2V5XX07XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByLm1pbiA9IHIubWF4ID0gci5leGFjdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZG5hbWVfID0gZnVuY3Rpb24ocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuYW1lID09PSAnZGV2aWNlSWQnKSA/ICdzb3VyY2VJZCcgOiBuYW1lO1xuICAgICAgfTtcbiAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2Mub3B0aW9uYWwgPSBjYy5vcHRpb25hbCB8fCBbXTtcbiAgICAgICAgbGV0IG9jID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygci5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWluJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICAgIG9jID0ge307XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21heCcsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXygnJywga2V5KV0gPSByLmV4YWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWydtaW4nLCAnbWF4J10uZm9yRWFjaChtaXggPT4ge1xuICAgICAgICAgIGlmIChyW21peF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKG1peCwga2V5KV0gPSByW21peF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYy5hZHZhbmNlZCkge1xuICAgICAgY2Mub3B0aW9uYWwgPSAoY2Mub3B0aW9uYWwgfHwgW10pLmNvbmNhdChjLmFkdmFuY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNjO1xuICB9O1xuXG4gIGNvbnN0IHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbihjb25zdHJhaW50cywgZnVuYykge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYxKSB7XG4gICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uKG9iaiwgYSwgYikge1xuICAgICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnZ29vZ0F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ2dvb2dOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLmF1ZGlvKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIFNoaW0gZmFjaW5nTW9kZSBmb3IgbW9iaWxlICYgc3VyZmFjZSBwcm8uXG4gICAgICBsZXQgZmFjZSA9IGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgICBmYWNlID0gZmFjZSAmJiAoKHR5cGVvZiBmYWNlID09PSAnb2JqZWN0JykgPyBmYWNlIDoge2lkZWFsOiBmYWNlfSk7XG4gICAgICBjb25zdCBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcblxuICAgICAgaWYgKChmYWNlICYmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5leGFjdCA9PT0gJ2Vudmlyb25tZW50JyB8fFxuICAgICAgICAgICAgICAgICAgICBmYWNlLmlkZWFsID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50JykpICYmXG4gICAgICAgICAgIShuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZmFjaW5nTW9kZSAmJlxuICAgICAgICAgICAgIWdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzKSkge1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICAgIGlmIChmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydiYWNrJywgJ3JlYXInXTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnZnJvbnQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIC8vIExvb2sgZm9yIG1hdGNoZXMgaW4gbGFiZWwsIG9yIHVzZSBsYXN0IGNhbSBmb3IgYmFjayAodHlwaWNhbCkuXG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgICAgICAudGhlbihkZXZpY2VzID0+IHtcbiAgICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSAndmlkZW9pbnB1dCcpO1xuICAgICAgICAgICAgICBsZXQgZGV2ID0gZGV2aWNlcy5maW5kKGQgPT4gbWF0Y2hlcy5zb21lKG1hdGNoID0+XG4gICAgICAgICAgICAgICAgZC5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG1hdGNoKSkpO1xuICAgICAgICAgICAgICBpZiAoIWRldiAmJiBkZXZpY2VzLmxlbmd0aCAmJiBtYXRjaGVzLmluY2x1ZGVzKCdiYWNrJykpIHtcbiAgICAgICAgICAgICAgICBkZXYgPSBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV07IC8vIG1vcmUgbGlrZWx5IHRoZSBiYWNrIGNhbVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkZXYpIHtcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGZhY2UuZXhhY3RcbiAgICAgICAgICAgICAgICAgID8ge2V4YWN0OiBkZXYuZGV2aWNlSWR9XG4gICAgICAgICAgICAgICAgICA6IHtpZGVhbDogZGV2LmRldmljZUlkfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcblxuICBjb25zdCBzaGltRXJyb3JfID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY0KSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgUGVybWlzc2lvbkRpc21pc3NlZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgSW52YWxpZFN0YXRlRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBEZXZpY2VzTm90Rm91bmRFcnJvcjogJ05vdEZvdW5kRXJyb3InLFxuICAgICAgICBDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3I6ICdPdmVyY29uc3RyYWluZWRFcnJvcicsXG4gICAgICAgIFRyYWNrU3RhcnRFcnJvcjogJ05vdFJlYWRhYmxlRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUtpbGxTd2l0Y2hPbjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFRhYkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBTY3JlZW5DYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgRGV2aWNlQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnQgfHwgZS5jb25zdHJhaW50TmFtZSxcbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgKHRoaXMubWVzc2FnZSAmJiAnOiAnKSArIHRoaXMubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgc2hpbUNvbnN0cmFpbnRzXyhjb25zdHJhaW50cywgYyA9PiB7XG4gICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKGMsIG9uU3VjY2VzcywgZSA9PiB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWFfLmJpbmQobmF2aWdhdG9yKTtcblxuICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgNDUgaGFzIG5hdmlnYXRvci5tZWRpYURldmljZXMgYW5kIGEgZ2V0VXNlck1lZGlhXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBpdCBkb2VzIG5vdCBhY2NlcHQgc3BlYy1zdHlsZVxuICAvLyBjb25zdHJhaW50cy5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgY29uc3Qgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLlxuICAgICAgYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uKGNzKSB7XG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgYyA9PiBvcmlnR2V0VXNlck1lZGlhKGMpLnRoZW4oc3RyZWFtID0+IHtcbiAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fFxuICAgICAgICAgICAgYy52aWRlbyAmJiAhc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJycsICdOb3RGb3VuZEVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sIGUgPT4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSkpKTtcbiAgICB9O1xuICB9XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5leHBvcnQge3NoaW1HZXRVc2VyTWVkaWF9IGZyb20gJy4vZ2V0dXNlcm1lZGlhJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ29udHJhY2snIGluXG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XG4gICAgICAgICAgdGhpcy5fb250cmFja3BvbHkgPSAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAgIC8vIHN0cmVhbS4gQnV0IHN0cmVhbS5vbmFkZHRyYWNrIGlzIGltcGxlbWVudGVkIHNvIHdlIHVzZSB0aGF0LlxuICAgICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCB0ZSA9PiB7XG4gICAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAgICAgICAuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdGUudHJhY2suaWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0ge3RyYWNrOiB0ZS50cmFja307XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0ZS50cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7cmVjZWl2ZXJ9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZS5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLmdldFJlY2VpdmVycygpXG4gICAgICAgICAgICAgICAgICAuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0ge3RyYWNrfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7cmVjZWl2ZXJ9O1xuICAgICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBldmVuIGlmIFJUQ1J0cFRyYW5zY2VpdmVyIGlzIGluIHdpbmRvdywgaXQgaXMgb25seSB1c2VkIGFuZFxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cbiAgICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLFxuICAgICAgICAgIHt2YWx1ZToge3JlY2VpdmVyOiBlLnJlY2VpdmVyfX0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KSB7XG4gIC8vIE92ZXJyaWRlcyBhZGRUcmFjay9yZW1vdmVUcmFjaywgZGVwZW5kcyBvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjay5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiZcbiAgICAgICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgY29uc3Qgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24ocGMsIHRyYWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFjayxcbiAgICAgICAgZ2V0IGR0bWYoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHBjLmNyZWF0ZURUTUZTZW5kZXIodHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgICB9LFxuICAgICAgICBfcGM6IHBjXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRlcnMuc2xpY2UoKTsgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPVxuICAgICAgICBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICAgICAgbGV0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spO1xuICAgICAgICAgICAgdGhpcy5fc2VuZGVycy5wdXNoKHNlbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuXG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0aGlzLl9zZW5kZXJzLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgICAgaWYgKHNlbmRlcikgeyAvLyByZW1vdmUgc2VuZGVyXG4gICAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZSh0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICAgICAgICAgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAnY3JlYXRlRFRNRlNlbmRlcicgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgIHdpbmRvdy5SVENSdHBTZW5kZXIgJiZcbiAgICAgICAgICAgICAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSwgJ2R0bWYnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kdG1mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gdGhpcy5fcGMuY3JlYXRlRFRNRlNlbmRlcih0aGlzLnRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmXG4gICAgICB3aW5kb3cuUlRDUnRwU2VuZGVyICYmIHdpbmRvdy5SVENSdHBSZWNlaXZlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIHNlbmRlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgICByZXR1cm4gc2VuZGVycztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICBjb25zdCBzZW5kZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT5cbiAgICAgICAgLyogTm90ZTogdGhpcyB3aWxsIGluY2x1ZGUgc3RhdHMgb2YgYWxsIHNlbmRlcnMgdGhhdFxuICAgICAgICAgKiAgIHNlbmQgYSB0cmFjayB3aXRoIHRoZSBzYW1lIGlkIGFzIHNlbmRlci50cmFjayBhc1xuICAgICAgICAgKiAgIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSB0aGUgUlRDUnRwU2VuZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdXRpbHMuZmlsdGVyU3RhdHMocmVzdWx0LCBzZW5kZXIudHJhY2ssIHRydWUpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gc2hpbSByZWNlaXZlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPVxuICAgICAgICBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICAgICAgY29uc3QgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gICAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3QgcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihyZXN1bHQgPT5cbiAgICAgICAgdXRpbHMuZmlsdGVyU3RhdHMocmVzdWx0LCByZWNlaXZlci50cmFjaywgZmFsc2UpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSAmJlxuICAgICAgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gUlRDUGVlckNvbm5lY3Rpb24uZ2V0U3RhdHModHJhY2spLlxuICBjb25zdCBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGxldCBzZW5kZXI7XG4gICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICBsZXQgZXJyO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChzID0+IHtcbiAgICAgICAgaWYgKHMudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZGVyID0gcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKHIgPT4ge1xuICAgICAgICBpZiAoci50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAocmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlY2VpdmVyID0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHIudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoZXJyIHx8IChzZW5kZXIgJiYgcmVjZWl2ZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLFxuICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiByZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICdUaGVyZSBpcyBubyBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLFxuICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUod2luZG93KSB7XG4gIC8vIHNoaW0gYWRkVHJhY2svcmVtb3ZlVHJhY2sgd2l0aCBuYXRpdmUgdmFyaWFudHMgaW4gb3JkZXIgdG8gbWFrZVxuICAvLyB0aGUgaW50ZXJhY3Rpb25zIHdpdGggbGVnYWN5IGdldExvY2FsU3RyZWFtcyBiZWhhdmUgYXMgaW4gb3RoZXIgYnJvd3NlcnMuXG4gIC8vIEtlZXBzIGEgbWFwcGluZyBzdHJlYW0uaWQgPT4gW3N0cmVhbSwgcnRwc2VuZGVycy4uLl1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPVxuICAgIGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpXG4gICAgICAgIC5tYXAoc3RyZWFtSWQgPT4gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF1bMF0pO1xuICAgIH07XG5cbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG5cbiAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKCF0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0pIHtcbiAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbSwgc2VuZGVyXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLmluZGV4T2Yoc2VuZGVyKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLnB1c2goc2VuZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcblxuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLFxuICAgICAgICAgICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBleGlzdGluZ1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKTtcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY29uc3QgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpXG4gICAgICAuZmlsdGVyKG5ld1NlbmRlciA9PiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMSk7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xuICB9O1xuXG4gIGNvbnN0IG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgIGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgZGVsZXRlIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICAgIHJldHVybiBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICBjb25zdCBvcmlnUmVtb3ZlVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5mb3JFYWNoKHN0cmVhbUlkID0+IHtcbiAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzaGltIGFkZFRyYWNrIGFuZCByZW1vdmVUcmFjay5cbiAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgJiZcbiAgICAgIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcbiAgICByZXR1cm4gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdyk7XG4gIH1cblxuICAvLyBhbHNvIHNoaW0gcGMuZ2V0TG9jYWxTdHJlYW1zIHdoZW4gYWRkVHJhY2sgaXMgc2hpbW1lZFxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXG4gIGNvbnN0IG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlXG4gICAgLmdldExvY2FsU3RyZWFtcztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPVxuICAgIGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZVN0cmVhbXMgPSBvcmlnR2V0TG9jYWxTdHJlYW1zLmFwcGx5KHRoaXMpO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICAgIHJldHVybiBuYXRpdmVTdHJlYW1zLm1hcChzdHJlYW0gPT4gdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgfTtcblxuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsXG4gICAgICAgICAgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBpZGVudGl0eSBtYXBwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIGFkZFRyYWNrLlxuICAgIC8vIFVubGVzcyB0aGlzIGlzIGJlaW5nIHVzZWQgd2l0aCBhIHN0cmVhbSBmcm9tIGFkZFRyYWNrLlxuICAgIGlmICghdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgY29uc3QgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShzdHJlYW0uZ2V0VHJhY2tzKCkpO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICB9XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gIH07XG5cbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuXG4gICAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFsodGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdIHx8IHN0cmVhbSldKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9yZXZlcnNlU3RyZWFtc1sodGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID9cbiAgICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdLmlkIDogc3RyZWFtLmlkKV07XG4gICAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIH07XG5cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9XG4gICAgZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXG4gICAgICAgICAgJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsXG4gICAgICAgICAgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgIXN0cmVhbXNbMF0uZ2V0VHJhY2tzKCkuZmluZCh0ID0+IHQgPT09IHRyYWNrKSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0IGJ1dCBhbGwgd2UgY2FuIG1hbmFnZSB3aXRob3V0XG4gICAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGUgYWRhcHRlci5qcyBhZGRUcmFjayBwb2x5ZmlsbCBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlICcgK1xuICAgICAgICAgICcgc3RyZWFtIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHRyYWNrLicsXG4gICAgICAgICAgJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICAgIGNvbnN0IG9sZFN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICAgIGlmIChvbGRTdHJlYW0pIHtcbiAgICAgICAgLy8gdGhpcyBpcyB1c2luZyBvZGQgQ2hyb21lIGJlaGF2aW91ciwgdXNlIHdpdGggY2F1dGlvbjpcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTc4MTVcbiAgICAgICAgLy8gTm90ZTogd2UgcmVseSBvbiB0aGUgaGlnaC1sZXZlbCBhZGRUcmFjay9kdG1mIHNoaW0gdG9cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBzZW5kZXIgd2l0aCBhIGR0bWYgc2VuZGVyLlxuICAgICAgICBvbGRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgT05OIGFzeW5jLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuYWRkU3RyZWFtKG5ld1N0cmVhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChzID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICB9O1xuXG4gIC8vIHJlcGxhY2UgdGhlIGludGVybmFsIHN0cmVhbSBpZCB3aXRoIHRoZSBleHRlcm5hbCBvbmUgYW5kXG4gIC8vIHZpY2UgdmVyc2EuXG4gIGZ1bmN0aW9uIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIGxldCBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGludGVybmFsSWQgPT4ge1xuICAgICAgY29uc3QgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICBjb25zdCBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoaW50ZXJuYWxTdHJlYW0uaWQsICdnJyksXG4gICAgICAgIGV4dGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChleHRlcm5hbFN0cmVhbS5pZCwgJ2cnKSxcbiAgICAgICAgaW50ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtbbWV0aG9kXSgpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBjb25zdCBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmIChpc0xlZ2FjeUNhbGwpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgKGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY10pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGFyZ3VtZW50c1syXVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAudGhlbihkZXNjcmlwdGlvbiA9PiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbikpO1xuICAgIH19O1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICB9KTtcblxuICBjb25zdCBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9XG4gICAgZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCAhYXJndW1lbnRzWzBdLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBhcmd1bWVudHNbMF0gPSByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAvLyBUT0RPOiBtYW5nbGUgZ2V0U3RhdHM6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RvbS1ydGNtZWRpYXN0cmVhbXN0YXRzLXN0cmVhbWlkZW50aWZpZXJcblxuICBjb25zdCBvcmlnTG9jYWxEZXNjcmlwdGlvbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsXG4gICAgJ2xvY2FsRGVzY3JpcHRpb24nLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gb3JpZ0xvY2FsRGVzY3JpcHRpb24uZ2V0LmFwcGx5KHRoaXMpO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHRoaXMsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID1cbiAgICBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgICdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLFxuICAgICAgICAgICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgICAgfVxuICAgICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxuICAgICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxuICAgICAgaWYgKCFzZW5kZXIuX3BjKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArXG4gICAgICAgICAgICAnZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBSVENSdHBTZW5kZXIuJywgJ1R5cGVFcnJvcicpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNMb2NhbCA9IHNlbmRlci5fcGMgPT09IHRoaXM7XG4gICAgICBpZiAoIWlzTG9jYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJyxcbiAgICAgICAgICAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5hdGl2ZSBzdHJlYW0gdGhlIHNlbmRlcnMgdHJhY2sgYmVsb25ncyB0by5cbiAgICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgICAgbGV0IHN0cmVhbTtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N0cmVhbXMpLmZvckVhY2goc3RyZWFtaWQgPT4ge1xuICAgICAgICBjb25zdCBoYXNUcmFjayA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdLmdldFRyYWNrcygpXG4gICAgICAgICAgLmZpbmQodHJhY2sgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIGlmIChoYXNUcmFjaykge1xuICAgICAgICAgIHN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgdHJhY2sgb2YgdGhlIHN0cmVhbSwgcmVtb3ZlIHRoZSBzdHJlYW0uIFRoaXNcbiAgICAgICAgICAvLyB0YWtlcyBjYXJlIG9mIGFueSBzaGltbWVkIF9zZW5kZXJzLlxuICAgICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtKHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIHNhbWUgb2RkIGNocm9tZSBiZWhhdmlvdXIgYXMgYWJvdmUuXG4gICAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHNlbmRlci50cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gaW1wbGljaXQgY3JlYXRpb24gb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uL1JUQ0ljZUNhbmRpZGF0ZVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgICBjb25zdCBtZXRob2RPYmogPSB7W21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3ICgobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJykgP1xuICAgICAgICAgICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6XG4gICAgICAgICAgICB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfX07XG4gICAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgICAgfSk7XG4gIH1cbn1cblxuLy8gQXR0ZW1wdCB0byBmaXggT05OIGluIHBsYW4tYiBtb2RlLlxuZXhwb3J0IGZ1bmN0aW9uIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnbmVnb3RpYXRpb25uZWVkZWQnLCBlID0+IHtcbiAgICBjb25zdCBwYyA9IGUudGFyZ2V0O1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNzIgfHwgKHBjLmdldENvbmZpZ3VyYXRpb24gJiZcbiAgICAgICAgcGMuZ2V0Q29uZmlndXJhdGlvbigpLnNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpKSB7XG4gICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuICBjb25zdCBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xuXG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgLy8gUmVwbGFjZSBGaXJlZm94IDQ0KydzIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2l0aCB1bnByZWZpeGVkIHZlcnNpb24uXG4gICAgdXRpbHMuZGVwcmVjYXRlZCgnbmF2aWdhdG9yLmdldFVzZXJNZWRpYScsXG4gICAgICAnbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEnKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9O1xuXG4gIGlmICghKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPiA1NSAmJlxuICAgICAgJ2F1dG9HYWluQ29udHJvbCcgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpKSkge1xuICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24ob2JqLCBhLCBiKSB7XG4gICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5cbiAgICAgIGJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAodHlwZW9mIGMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKGMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVHZXRVc2VyTWVkaWEoYyk7XG4gICAgfTtcblxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzKSB7XG4gICAgICBjb25zdCBuYXRpdmVHZXRTZXR0aW5ncyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmF0aXZlR2V0U2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96QXV0b0dhaW5Db250cm9sJywgJ2F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChvYmosICdtb3pOb2lzZVN1cHByZXNzaW9uJywgJ25vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cykge1xuICAgICAgY29uc3QgbmF0aXZlQXBwbHlDb25zdHJhaW50cyA9XG4gICAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHM7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzID0gZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmIHR5cGVvZiBjID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIHByZWZlcnJlZE1lZGlhU291cmNlKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJlxuICAgICdnZXREaXNwbGF5TWVkaWEnIGluIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPVxuICAgIGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgICAgaWYgKCEoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8pKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgK1xuICAgICAgICAgICAgJ2NvbnN0cmFpbnRzIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcbiAgICAgICAgLy8gZnJvbSBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtRE9NRXhjZXB0aW9uLWVycm9yLW5hbWVzXG4gICAgICAgIGVyci5jb2RlID0gODtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICBpZiAoY29uc3RyYWludHMudmlkZW8gPT09IHRydWUpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7bWVkaWFTb3VyY2U6IHByZWZlcnJlZE1lZGlhU291cmNlfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1lZGlhU291cmNlID0gcHJlZmVycmVkTWVkaWFTb3VyY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuZXhwb3J0IHtzaGltR2V0VXNlck1lZGlhfSBmcm9tICcuL2dldHVzZXJtZWRpYSc7XG5leHBvcnQge3NoaW1HZXREaXNwbGF5TWVkaWF9IGZyb20gJy4vZ2V0ZGlzcGxheW1lZGlhJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiZcbiAgICAgICgncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkgJiZcbiAgICAgICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge3JlY2VpdmVyOiB0aGlzLnJlY2VpdmVyfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuOyAvLyBwcm9iYWJseSBtZWRpYS5wZWVyY29ubmVjdGlvbi5lbmFibGVkPWZhbHNlIGluIGFib3V0OmNvbmZpZ1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICAvLyBzaGltIGF3YXkgbmVlZCBmb3Igb2Jzb2xldGUgUlRDSWNlQ2FuZGlkYXRlL1JUQ1Nlc3Npb25EZXNjcmlwdGlvbi5cbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ11cbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtbbWV0aG9kXSgpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnKSA/XG4gICAgICAgICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDpcbiAgICAgICAgICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9fTtcbiAgICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVyblN0YXRzVHlwZXMgPSB7XG4gICAgaW5ib3VuZHJ0cDogJ2luYm91bmQtcnRwJyxcbiAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXG4gICAgY2FuZGlkYXRlcGFpcjogJ2NhbmRpZGF0ZS1wYWlyJyxcbiAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgfTtcblxuICBjb25zdCBuYXRpdmVHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBjb25zdCBbc2VsZWN0b3IsIG9uU3VjYywgb25FcnJdID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuYXRpdmVHZXRTdGF0cy5hcHBseSh0aGlzLCBbc2VsZWN0b3IgfHwgbnVsbF0pXG4gICAgICAudGhlbihzdGF0cyA9PiB7XG4gICAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMgJiYgIW9uU3VjYykge1xuICAgICAgICAgIC8vIFNoaW0gb25seSBwcm9taXNlIGdldFN0YXRzIHdpdGggc3BlYy1oeXBoZW5zIGluIHR5cGUgbmFtZXNcbiAgICAgICAgICAvLyBMZWF2ZSBjYWxsYmFjayB2ZXJzaW9uIGFsb25lOyBtaXNjIG9sZCB1c2VzIG9mIGZvckVhY2ggYmVmb3JlIE1hcFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICAgICAgICBzdGF0LnR5cGUgPSBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUubmFtZSAhPT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF2b2lkIFR5cGVFcnJvcjogXCJ0eXBlXCIgaXMgcmVhZC1vbmx5LCBpbiBvbGQgdmVyc2lvbnMuIDM0LTQzaXNoXG4gICAgICAgICAgICBzdGF0cy5mb3JFYWNoKChzdGF0LCBpKSA9PiB7XG4gICAgICAgICAgICAgIHN0YXRzLnNldChpLCBPYmplY3QuYXNzaWduKHt9LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRzO1xuICAgICAgfSlcbiAgICAgIC50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiZcbiAgICAgIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gIGlmIChvcmlnR2V0U2VuZGVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICBjb25zdCBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKHNlbmRlciA9PiBzZW5kZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH07XG4gIH1cbiAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayA/IHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spIDpcbiAgICAgIFByb21pc2UucmVzb2x2ZShuZXcgTWFwKCkpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgcmVjZWl2ZXJzLmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIuX3BjID0gdGhpcyk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgIH07XG4gIH1cbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBlID0+IHtcbiAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG4gIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjayk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUmVtb3ZlU3RyZWFtKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdXRpbHMuZGVwcmVjYXRlZCgncmVtb3ZlU3RyZWFtJywgJ3JlbW92ZVRyYWNrJyk7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgIGlmIChzZW5kZXIudHJhY2sgJiYgc3RyZWFtLmdldFRyYWNrcygpLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUlRDRGF0YUNoYW5uZWwod2luZG93KSB7XG4gIC8vIHJlbmFtZSBEYXRhQ2hhbm5lbCB0byBSVENEYXRhQ2hhbm5lbCAobmF0aXZlIGZpeCBpbiBGRjYwKTpcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE3Mzg1MVxuICBpZiAod2luZG93LkRhdGFDaGFubmVsICYmICF3aW5kb3cuUlRDRGF0YUNoYW5uZWwpIHtcbiAgICB3aW5kb3cuUlRDRGF0YUNoYW5uZWwgPSB3aW5kb3cuRGF0YUNoYW5uZWw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQWRkVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyO1xuICBpZiAob3JpZ0FkZFRyYW5zY2VpdmVyKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlciA9XG4gICAgICBmdW5jdGlvbiBhZGRUcmFuc2NlaXZlcigpIHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gV2ViSURMIGlucHV0IGNvZXJjaW9uIGFuZCB2YWxpZGF0aW9uXG4gICAgICAgIGxldCBzZW5kRW5jb2RpbmdzID0gYXJndW1lbnRzWzFdICYmIGFyZ3VtZW50c1sxXS5zZW5kRW5jb2RpbmdzO1xuICAgICAgICBpZiAoc2VuZEVuY29kaW5ncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VuZEVuY29kaW5ncyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHNlbmRFbmNvZGluZ3MgPSBbLi4uc2VuZEVuY29kaW5nc107XG4gICAgICAgIGNvbnN0IHNob3VsZFBlcmZvcm1DaGVjayA9IHNlbmRFbmNvZGluZ3MubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxuICAgICAgICAgIHNlbmRFbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmdQYXJhbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCdyaWQnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgICAgY29uc3QgcmlkUmVnZXggPSAvXlthLXowLTldezAsMTZ9JC9pO1xuICAgICAgICAgICAgICBpZiAoIXJpZFJlZ2V4LnRlc3QoZW5jb2RpbmdQYXJhbS5yaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBSSUQgdmFsdWUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnc2NhbGVSZXNvbHV0aW9uRG93bkJ5JyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5zY2FsZVJlc29sdXRpb25Eb3duQnkpID49IDEuMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2NhbGVfcmVzb2x1dGlvbl9kb3duX2J5IG11c3QgYmUgPj0gMS4wJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnbWF4RnJhbWVyYXRlJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5tYXhGcmFtZXJhdGUpID49IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21heF9mcmFtZXJhdGUgbXVzdCBiZSA+PSAwLjAnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gb3JpZ0FkZFRyYW5zY2VpdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5pdCBvcHRpb25zIHdlcmUgYXBwbGllZC4gSWYgbm90IHdlIGRvIHRoaXMgaW4gYW5cbiAgICAgICAgICAvLyBhc3luY2hyb25vdXMgd2F5IGFuZCBzYXZlIHRoZSBwcm9taXNlIHJlZmVyZW5jZSBpbiBhIGdsb2JhbCBvYmplY3QuXG4gICAgICAgICAgLy8gVGhpcyBpcyBhbiB1Z2x5IGhhY2ssIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIGlzIHdheSBtb3JlIHJvYnVzdCB0aGFuXG4gICAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHNlbmRlciBwYXJhbWV0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNyZWF0ZU9mZmVyXG4gICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgYWZ0ZXIgdGhlIGNyZWF0ZW9mZmVyIHdlIGFyZSBub3QgMTAwJSBzdXJlIHRoYXRcbiAgICAgICAgICAvLyB0aGUgcGFyYW1zIHdlcmUgYXN5bmNocm9ub3VzbHkgYXBwbGllZCBzbyB3ZSBtaWdodCBtaXNzIHRoZVxuICAgICAgICAgIC8vIG9wcG9ydHVuaXR5IHRvIHJlY3JlYXRlIG9mZmVyLlxuICAgICAgICAgIGNvbnN0IHtzZW5kZXJ9ID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpIHx8XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGJlaW5nIGZvb2xlZCBieSBwYXRjaGVkIGdldFBhcmFtZXRlcnMoKSBiZWxvdy5cbiAgICAgICAgICAgICAgKHBhcmFtcy5lbmNvZGluZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMuZW5jb2RpbmdzWzBdKS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gc2VuZEVuY29kaW5ncztcbiAgICAgICAgICAgIHNlbmRlci5zZW5kRW5jb2RpbmdzID0gc2VuZEVuY29kaW5ncztcbiAgICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLnB1c2goc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKVxuICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyO1xuICAgICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFBhcmFtZXRlcnMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdHZXRQYXJhbWV0ZXJzID0gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycztcbiAgaWYgKG9yaWdHZXRQYXJhbWV0ZXJzKSB7XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0UGFyYW1ldGVycyA9XG4gICAgICBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBvcmlnR2V0UGFyYW1ldGVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpKSB7XG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IFtdLmNvbmNhdCh0aGlzLnNlbmRFbmNvZGluZ3MgfHwgW3t9XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoKSB7XG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KVxuICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1DcmVhdGVBbnN3ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KVxuICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRMb2NhbFN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPVxuICAgICAgZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0cmVhbXM7XG4gICAgICB9O1xuICB9XG4gIGlmICghKCdhZGRTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgY29uc3QgX2FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgQ2hyb21lJ3MgYmVoYXZpb3VyIG9mIGFkZGluZyBpbiBhdWRpby12aWRlbyBvcmRlci5cbiAgICAgIC8vIFNhZmFyaSBvcmRlcnMgYnkgdHJhY2sgaWQuXG4gICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IF9hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrLFxuICAgICAgICBzdHJlYW0pKTtcbiAgICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssXG4gICAgICAgIHN0cmVhbSkpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID1cbiAgICAgIGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCAuLi5zdHJlYW1zKSB7XG4gICAgICAgIGlmIChzdHJlYW1zKSB7XG4gICAgICAgICAgc3RyZWFtcy5mb3JFYWNoKChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICB9XG4gIGlmICghKCdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPVxuICAgICAgZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgICAgaWYgKHRyYWNrcy5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0UmVtb3RlU3RyZWFtcycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbXMgPVxuICAgICAgZnVuY3Rpb24gZ2V0UmVtb3RlU3RyZWFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbXMgPyB0aGlzLl9yZW1vdGVTdHJlYW1zIDogW107XG4gICAgICB9O1xuICB9XG4gIGlmICghKCdvbmFkZHN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29uYWRkc3RyZWFtJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25hZGRzdHJlYW07XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uYWRkc3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSA9IGYpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gKGUpID0+IHtcbiAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdGVTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgICBjb25zdCBwYyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fb25hZGRzdHJlYW1wb2x5KSB7XG4gICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICAgIGlmICghcGMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwYy5fcmVtb3RlU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkocGMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICBjb25zdCBvcmlnQ3JlYXRlT2ZmZXIgPSBwcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIGNvbnN0IG9yaWdDcmVhdGVBbnN3ZXIgPSBwcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICBjb25zdCBzZXRMb2NhbERlc2NyaXB0aW9uID0gcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIGNvbnN0IHNldFJlbW90ZURlc2NyaXB0aW9uID0gcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICBjb25zdCBhZGRJY2VDYW5kaWRhdGUgPSBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuXG4gIHByb3RvdHlwZS5jcmVhdGVPZmZlciA9XG4gICAgZnVuY3Rpb24gY3JlYXRlT2ZmZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSAoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuICAgICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuXG4gIHByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IChhcmd1bWVudHMubGVuZ3RoID49IDIpID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgcHJvbWlzZSA9IG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuICAgICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuXG4gIGxldCB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gc2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcblxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gc2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuXG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gYWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIFtjYW5kaWRhdGVdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gd2l0aENhbGxiYWNrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBzaGltIG5vdCBuZWVkZWQgaW4gU2FmYXJpIDEyLjFcbiAgICBjb25zdCBtZWRpYURldmljZXMgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzO1xuICAgIGNvbnN0IF9nZXRVc2VyTWVkaWEgPSBtZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IChjb25zdHJhaW50cykgPT4ge1xuICAgICAgcmV0dXJuIF9nZXRVc2VyTWVkaWEoc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmXG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBjYiwgZXJyY2IpIHtcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgICAgICAudGhlbihjYiwgZXJyY2IpO1xuICAgIH0uYmluZChuYXZpZ2F0b3IpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgaWYgKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAge3ZpZGVvOiB1dGlscy5jb21wYWN0T2JqZWN0KGNvbnN0cmFpbnRzLnZpZGVvKX1cbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG1pZ3JhdGUgZnJvbSBub24tc3BlYyBSVENJY2VTZXJ2ZXIudXJsIHRvIFJUQ0ljZVNlcnZlci51cmxzXG4gIGNvbnN0IE9yaWdQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID1cbiAgICBmdW5jdGlvbiBSVENQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cykge1xuICAgICAgaWYgKHBjQ29uZmlnICYmIHBjQ29uZmlnLmljZVNlcnZlcnMpIHtcbiAgICAgICAgY29uc3QgbmV3SWNlU2VydmVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBjQ29uZmlnLmljZVNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2VydmVyID0gcGNDb25maWcuaWNlU2VydmVyc1tpXTtcbiAgICAgICAgICBpZiAoc2VydmVyLnVybHMgPT09IHVuZGVmaW5lZCAmJiBzZXJ2ZXIudXJsKSB7XG4gICAgICAgICAgICB1dGlscy5kZXByZWNhdGVkKCdSVENJY2VTZXJ2ZXIudXJsJywgJ1JUQ0ljZVNlcnZlci51cmxzJyk7XG4gICAgICAgICAgICBzZXJ2ZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNlcnZlcikpO1xuICAgICAgICAgICAgc2VydmVyLnVybHMgPSBzZXJ2ZXIudXJsO1xuICAgICAgICAgICAgZGVsZXRlIHNlcnZlci51cmw7XG4gICAgICAgICAgICBuZXdJY2VTZXJ2ZXJzLnB1c2goc2VydmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHBjQ29uZmlnLmljZVNlcnZlcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwY0NvbmZpZy5pY2VTZXJ2ZXJzID0gbmV3SWNlU2VydmVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgT3JpZ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcbiAgICB9O1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlID0gT3JpZ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgLy8gd3JhcCBzdGF0aWMgbWV0aG9kcy4gQ3VycmVudGx5IGp1c3QgZ2VuZXJhdGVDZXJ0aWZpY2F0ZS5cbiAgaWYgKCdnZW5lcmF0ZUNlcnRpZmljYXRlJyBpbiBPcmlnUGVlckNvbm5lY3Rpb24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLCAnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE9yaWdQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyKHdpbmRvdykge1xuICAvLyBBZGQgZXZlbnQudHJhbnNjZWl2ZXIgbWVtYmVyIG92ZXIgZGVwcmVjYXRlZCBldmVudC5yZWNlaXZlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiZcbiAgICAgICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmXG4gICAgICAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtyZWNlaXZlcjogdGhpcy5yZWNlaXZlcn07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpIHtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9XG4gICAgZnVuY3Rpb24gY3JlYXRlT2ZmZXIob2ZmZXJPcHRpb25zKSB7XG4gICAgICBpZiAob2ZmZXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXG4gICAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPVxuICAgICAgICAgICAgISFvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdWRpb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ2F1ZGlvJyk7XG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gZmFsc2UgJiYgYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IHRydWUgJiZcbiAgICAgICAgICAgICFhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcignYXVkaW8nLCB7ZGlyZWN0aW9uOiAncmVjdm9ubHknfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID1cbiAgICAgICAgICAgICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmlkZW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZCh0cmFuc2NlaXZlciA9PlxuICAgICAgICAgIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPT09IGZhbHNlICYmIHZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSB0cnVlICYmXG4gICAgICAgICAgICAhdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywge2RpcmVjdGlvbjogJ3JlY3Zvbmx5J30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1BdWRpb0NvbnRleHQod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCB3aW5kb3cuQXVkaW9Db250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xufVxuXG4iLCIvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gU0RQIGhlbHBlcnMuXG5jb25zdCBTRFBVdGlscyA9IHt9O1xuXG4vLyBHZW5lcmF0ZSBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciBmb3IgY25hbWUgb3IgbWlkcy5cbi8vIFRPRE86IHVzZSBVVUlEcyBpbnN0ZWFkPyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qZWQvOTgyODgzXG5TRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMik7XG59O1xuXG4vLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cblNEUFV0aWxzLmxvY2FsQ05hbWUgPSBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuLy8gU3BsaXRzIFNEUCBpbnRvIGxpbmVzLCBkZWFsaW5nIHdpdGggYm90aCBDUkxGIGFuZCBMRi5cblNEUFV0aWxzLnNwbGl0TGluZXMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHJldHVybiBibG9iLnRyaW0oKS5zcGxpdCgnXFxuJykubWFwKGxpbmUgPT4gbGluZS50cmltKCkpO1xufTtcbi8vIFNwbGl0cyBTRFAgaW50byBzZXNzaW9ucGFydCBhbmQgbWVkaWFzZWN0aW9ucy4gRW5zdXJlcyBDUkxGLlxuU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3QgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xuICByZXR1cm4gcGFydHMubWFwKChwYXJ0LCBpbmRleCkgPT4gKGluZGV4ID4gMCA/XG4gICAgJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJyk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uLlxuU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbihibG9iKSB7XG4gIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgcmV0dXJuIHNlY3Rpb25zICYmIHNlY3Rpb25zWzBdO1xufTtcblxuLy8gUmV0dXJucyB0aGUgaW5kaXZpZHVhbCBtZWRpYSBzZWN0aW9ucy5cblNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbihibG9iKSB7XG4gIGNvbnN0IHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgcmV0dXJuIHNlY3Rpb25zO1xufTtcblxuLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cblNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24oYmxvYiwgcHJlZml4KSB7XG4gIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGxpbmUuIFNhbXBsZSBpbnB1dDpcbi8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuLy8gcnBvcnQgNTU5OTZcIlxuLy8gSW5wdXQgY2FuIGJlIHByZWZpeGVkIHdpdGggYT0uXG5TRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgbGV0IHBhcnRzO1xuICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICBpZiAobGluZS5pbmRleE9mKCdhPWNhbmRpZGF0ZTonKSA9PT0gMCkge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTIpLnNwbGl0KCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMCkuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGNvbnN0IGNhbmRpZGF0ZSA9IHtcbiAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICBjb21wb25lbnQ6IHsxOiAncnRwJywgMjogJ3J0Y3AnfVtwYXJ0c1sxXV0gfHwgcGFydHNbMV0sXG4gICAgcHJvdG9jb2w6IHBhcnRzWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXG4gICAgaXA6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzRdLCAvLyBhZGRyZXNzIGlzIGFuIGFsaWFzIGZvciBpcC5cbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1s1XSwgMTApLFxuICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICB0eXBlOiBwYXJ0c1s3XSxcbiAgfTtcblxuICBmb3IgKGxldCBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgc3dpdGNoIChwYXJ0c1tpXSkge1xuICAgICAgY2FzZSAncmFkZHInOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncnBvcnQnOlxuICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0Y3B0eXBlJzpcbiAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndWZyYWcnOlxuICAgICAgICBjYW5kaWRhdGUudWZyYWcgPSBwYXJ0c1tpICsgMV07IC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgICBjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBleHRlbnNpb24gaGFuZGxpbmcsIGluIHBhcnRpY3VsYXIgdWZyYWcuIERvbid0IG92ZXJ3cml0ZS5cbiAgICAgICAgaWYgKGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGU7XG59O1xuXG4vLyBUcmFuc2xhdGVzIGEgY2FuZGlkYXRlIG9iamVjdCBpbnRvIFNEUCBjYW5kaWRhdGUgYXR0cmlidXRlLlxuLy8gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBhPSBwcmVmaXghXG5TRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICBjb25zdCBzZHAgPSBbXTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmZvdW5kYXRpb24pO1xuXG4gIGNvbnN0IGNvbXBvbmVudCA9IGNhbmRpZGF0ZS5jb21wb25lbnQ7XG4gIGlmIChjb21wb25lbnQgPT09ICdydHAnKSB7XG4gICAgc2RwLnB1c2goMSk7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50ID09PSAncnRjcCcpIHtcbiAgICBzZHAucHVzaCgyKTtcbiAgfSBlbHNlIHtcbiAgICBzZHAucHVzaChjb21wb25lbnQpO1xuICB9XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByaW9yaXR5KTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuXG4gIGNvbnN0IHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgc2RwLnB1c2goJ3R5cCcpO1xuICBzZHAucHVzaCh0eXBlKTtcbiAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiZcbiAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCkge1xuICAgIHNkcC5wdXNoKCdyYWRkcicpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyk7XG4gICAgc2RwLnB1c2goJ3Jwb3J0Jyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnRjcFR5cGUgJiYgY2FuZGlkYXRlLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICd0Y3AnKSB7XG4gICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUudGNwVHlwZSk7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZykge1xuICAgIHNkcC5wdXNoKCd1ZnJhZycpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZyk7XG4gIH1cbiAgcmV0dXJuICdjYW5kaWRhdGU6JyArIHNkcC5qb2luKCcgJyk7XG59O1xuXG4vLyBQYXJzZXMgYW4gaWNlLW9wdGlvbnMgbGluZSwgcmV0dXJucyBhbiBhcnJheSBvZiBvcHRpb24gdGFncy5cbi8vIFNhbXBsZSBpbnB1dDpcbi8vIGE9aWNlLW9wdGlvbnM6Zm9vIGJhclxuU0RQVXRpbHMucGFyc2VJY2VPcHRpb25zID0gZnVuY3Rpb24obGluZSkge1xuICByZXR1cm4gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG59O1xuXG4vLyBQYXJzZXMgYSBydHBtYXAgbGluZSwgcmV0dXJucyBSVENSdHBDb2RkZWNQYXJhbWV0ZXJzLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0cG1hcDoxMTEgb3B1cy80ODAwMC8yXG5TRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgbGV0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCksIC8vIHdhczogaWRcbiAgfTtcblxuICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cbiAgcGFyc2VkLm5hbWUgPSBwYXJ0c1swXTtcbiAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXG4gIHBhcnNlZC5jaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICAvLyBsZWdhY3kgYWxpYXMsIGdvdCByZW5hbWVkIGJhY2sgdG8gY2hhbm5lbHMgaW4gT1JUQy5cbiAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFyc2VkLmNoYW5uZWxzO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGVzIGEgcnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3Jcbi8vIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRwTWFwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBjb25zdCBjaGFubmVscyA9IGNvZGVjLmNoYW5uZWxzIHx8IGNvZGVjLm51bUNoYW5uZWxzIHx8IDE7XG4gIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArXG4gICAgICAoY2hhbm5lbHMgIT09IDEgPyAnLycgKyBjaGFubmVscyA6ICcnKSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGEgZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4vLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcblNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgdXJpOiBwYXJ0c1sxXSxcbiAgICBhdHRyaWJ1dGVzOiBwYXJ0cy5zbGljZSgyKS5qb2luKCcgJyksXG4gIH07XG59O1xuXG4vLyBHZW5lcmF0ZXMgYW4gZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4vLyBSVENSdHBIZWFkZXJFeHRlbnNpb24uXG5TRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uKGhlYWRlckV4dGVuc2lvbikge1xuICByZXR1cm4gJ2E9ZXh0bWFwOicgKyAoaGVhZGVyRXh0ZW5zaW9uLmlkIHx8IGhlYWRlckV4dGVuc2lvbi5wcmVmZXJyZWRJZCkgK1xuICAgICAgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2J1xuICAgICAgICA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgOiAnJykgK1xuICAgICAgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArXG4gICAgICAoaGVhZGVyRXh0ZW5zaW9uLmF0dHJpYnV0ZXMgPyAnICcgKyBoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA6ICcnKSArXG4gICAgICAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhIGZtdHAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXG5TRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga3Y7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnOycpO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICBwYXJzZWRba3ZbMF0udHJpbSgpXSA9IGt2WzFdO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBmbXRwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IGxpbmUgPSAnJztcbiAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vLyBQYXJzZXMgYSBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcblNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24obGluZSkge1xuICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpLFxuICB9O1xufTtcblxuLy8gR2VuZXJhdGUgYT1ydGNwLWZiIGxpbmVzIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yIFJUQ1J0cENvZGVjUGFyYW1ldGVycy5cblNEUFV0aWxzLndyaXRlUnRjcEZiID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgbGV0IGxpbmVzID0gJyc7XG4gIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgaWYgKGNvZGVjLnJ0Y3BGZWVkYmFjayAmJiBjb2RlYy5ydGNwRmVlZGJhY2subGVuZ3RoKSB7XG4gICAgLy8gRklYTUU6IHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyci1pbnQ/XG4gICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZmIgPT4ge1xuICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICtcbiAgICAgIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufTtcblxuLy8gUGFyc2VzIGEgUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHNwID0gbGluZS5pbmRleE9mKCcgJyk7XG4gIGNvbnN0IHBhcnRzID0ge1xuICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKDcsIHNwKSwgMTApLFxuICB9O1xuICBjb25zdCBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgaWYgKGNvbG9uID4gLTEpIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEsIGNvbG9uKTtcbiAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGNvbG9uICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxKTtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59O1xuXG4vLyBQYXJzZSBhIHNzcmMtZ3JvdXAgbGluZSAoc2VlIFJGQyA1NTc2KS4gU2FtcGxlIGlucHV0OlxuLy8gYT1zc3JjLWdyb3VwOnNlbWFudGljcyAxMiAzNFxuU0RQVXRpbHMucGFyc2VTc3JjR3JvdXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTMpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgc2VtYW50aWNzOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHNzcmNzOiBwYXJ0cy5tYXAoc3NyYyA9PiBwYXJzZUludChzc3JjLCAxMCkpLFxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuLy8gUmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXG5TRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbWlkID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1taWQ6JylbMF07XG4gIGlmIChtaWQpIHtcbiAgICByZXR1cm4gbWlkLnN1YnN0cmluZyg2KTtcbiAgfVxufTtcblxuLy8gUGFyc2VzIGEgZmluZ2VycHJpbnQgbGluZSBmb3IgRFRMUy1TUlRQLlxuU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBhbGdvcml0aG06IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgIHZhbHVlOiBwYXJ0c1sxXS50b1VwcGVyQ2FzZSgpLCAvLyB0aGUgZGVmaW5pdGlvbiBpcyB1cHBlci1jYXNlIGluIFJGQyA0NTcyLlxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBmaW5nZXJwcmludCBsaW5lIGFzIGlucHV0LiBTZWUgYWxzbyBnZXRJY2VQYXJhbWV0ZXJzLlxuU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9ZmluZ2VycHJpbnQ6Jyk7XG4gIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUgaW4gRWRnZS5cbiAgcmV0dXJuIHtcbiAgICByb2xlOiAnYXV0bycsXG4gICAgZmluZ2VycHJpbnRzOiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VGaW5nZXJwcmludCksXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgbGV0IHNkcCA9ICdhPXNldHVwOicgKyBzZXR1cFR5cGUgKyAnXFxyXFxuJztcbiAgcGFyYW1zLmZpbmdlcnByaW50cy5mb3JFYWNoKGZwID0+IHtcbiAgICBzZHAgKz0gJ2E9ZmluZ2VycHJpbnQ6JyArIGZwLmFsZ29yaXRobSArICcgJyArIGZwLnZhbHVlICsgJ1xcclxcbic7XG4gIH0pO1xuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIGE9Y3J5cHRvIGxpbmVzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNkaWN0aW9uYXJ5LXJ0Y3NydHBzZGVzcGFyYW1ldGVycy1tZW1iZXJzXG5TRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoOSkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB0YWc6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgY3J5cHRvU3VpdGU6IHBhcnRzWzFdLFxuICAgIGtleVBhcmFtczogcGFydHNbMl0sXG4gICAgc2Vzc2lvblBhcmFtczogcGFydHMuc2xpY2UoMyksXG4gIH07XG59O1xuXG5TRFBVdGlscy53cml0ZUNyeXB0b0xpbmUgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiAnYT1jcnlwdG86JyArIHBhcmFtZXRlcnMudGFnICsgJyAnICtcbiAgICBwYXJhbWV0ZXJzLmNyeXB0b1N1aXRlICsgJyAnICtcbiAgICAodHlwZW9mIHBhcmFtZXRlcnMua2V5UGFyYW1zID09PSAnb2JqZWN0J1xuICAgICAgPyBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyhwYXJhbWV0ZXJzLmtleVBhcmFtcylcbiAgICAgIDogcGFyYW1ldGVycy5rZXlQYXJhbXMpICtcbiAgICAocGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zID8gJyAnICsgcGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zLmpvaW4oJyAnKSA6ICcnKSArXG4gICAgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgdGhlIGNyeXB0byBrZXkgcGFyYW1ldGVycyBpbnRvXG4vLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjcnRjc3J0cGtleXBhcmFtKlxuU0RQVXRpbHMucGFyc2VDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbihrZXlQYXJhbXMpIHtcbiAgaWYgKGtleVBhcmFtcy5pbmRleE9mKCdpbmxpbmU6JykgIT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwYXJ0cyA9IGtleVBhcmFtcy5zdWJzdHJpbmcoNykuc3BsaXQoJ3wnKTtcbiAgcmV0dXJuIHtcbiAgICBrZXlNZXRob2Q6ICdpbmxpbmUnLFxuICAgIGtleVNhbHQ6IHBhcnRzWzBdLFxuICAgIGxpZmVUaW1lOiBwYXJ0c1sxXSxcbiAgICBta2lWYWx1ZTogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzBdIDogdW5kZWZpbmVkLFxuICAgIG1raUxlbmd0aDogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzFdIDogdW5kZWZpbmVkLFxuICB9O1xufTtcblxuU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbihrZXlQYXJhbXMpIHtcbiAgcmV0dXJuIGtleVBhcmFtcy5rZXlNZXRob2QgKyAnOidcbiAgICArIGtleVBhcmFtcy5rZXlTYWx0ICtcbiAgICAoa2V5UGFyYW1zLmxpZmVUaW1lID8gJ3wnICsga2V5UGFyYW1zLmxpZmVUaW1lIDogJycpICtcbiAgICAoa2V5UGFyYW1zLm1raVZhbHVlICYmIGtleVBhcmFtcy5ta2lMZW5ndGhcbiAgICAgID8gJ3wnICsga2V5UGFyYW1zLm1raVZhbHVlICsgJzonICsga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgOiAnJyk7XG59O1xuXG4vLyBFeHRyYWN0cyBhbGwgU0RFUyBwYXJhbWV0ZXJzLlxuU0RQVXRpbHMuZ2V0Q3J5cHRvUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1jcnlwdG86Jyk7XG4gIHJldHVybiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lKTtcbn07XG5cbi8vIFBhcnNlcyBJQ0UgaW5mb3JtYXRpb24gZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGljZS11ZnJhZyBhbmQgaWNlLXB3ZCBsaW5lcyBhcyBpbnB1dC5cblNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIGNvbnN0IHVmcmFnID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9aWNlLXVmcmFnOicpWzBdO1xuICBjb25zdCBwd2QgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1pY2UtcHdkOicpWzBdO1xuICBpZiAoISh1ZnJhZyAmJiBwd2QpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1c2VybmFtZUZyYWdtZW50OiB1ZnJhZy5zdWJzdHJpbmcoMTIpLFxuICAgIHBhc3N3b3JkOiBwd2Quc3Vic3RyaW5nKDEwKSxcbiAgfTtcbn07XG5cbi8vIFNlcmlhbGl6ZXMgSUNFIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGxldCBzZHAgPSAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgK1xuICAgICAgJ2E9aWNlLXB3ZDonICsgcGFyYW1zLnBhc3N3b3JkICsgJ1xcclxcbic7XG4gIGlmIChwYXJhbXMuaWNlTGl0ZSkge1xuICAgIHNkcCArPSAnYT1pY2UtbGl0ZVxcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgUlRDUnRwUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcbiAgICBjb2RlY3M6IFtdLFxuICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgIGZlY01lY2hhbmlzbXM6IFtdLFxuICAgIHJ0Y3A6IFtdLFxuICB9O1xuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICBkZXNjcmlwdGlvbi5wcm9maWxlID0gbWxpbmVbMl07XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHsgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgIGNvbnN0IHB0ID0gbWxpbmVbaV07XG4gICAgY29uc3QgcnRwbWFwbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICBpZiAocnRwbWFwbGluZSkge1xuICAgICAgY29uc3QgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgIGNvbnN0IGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9Zm10cDonICsgcHQgKyAnICcpO1xuICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgIGNvZGVjLnBhcmFtZXRlcnMgPSBmbXRwcy5sZW5ndGggPyBTRFBVdGlscy5wYXJzZUZtdHAoZm10cHNbMF0pIDoge307XG4gICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOicgKyBwdCArICcgJylcbiAgICAgICAgLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MucHVzaChjb2RlYyk7XG4gICAgICAvLyBwYXJzZSBGRUMgbWVjaGFuaXNtcyBmcm9tIHJ0cG1hcCBsaW5lcy5cbiAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ1JFRCc6XG4gICAgICAgIGNhc2UgJ1VMUEZFQyc6XG4gICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIG9ubHkgUkVEIGFuZCBVTFBGRUMgYXJlIHJlY29nbml6ZWQgYXMgRkVDIG1lY2hhbmlzbXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9ZXh0bWFwOicpLmZvckVhY2gobGluZSA9PiB7XG4gICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgfSk7XG4gIGNvbnN0IHdpbGRjYXJkUnRjcEZiID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLWZiOiogJylcbiAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIHdpbGRjYXJkUnRjcEZiLmZvckVhY2goZmI9PiB7XG4gICAgICBjb25zdCBkdXBsaWNhdGUgPSBjb2RlYy5ydGNwRmVlZGJhY2suZmluZChleGlzdGluZ0ZlZWRiYWNrID0+IHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nRmVlZGJhY2sudHlwZSA9PT0gZmIudHlwZSAmJlxuICAgICAgICAgIGV4aXN0aW5nRmVlZGJhY2sucGFyYW1ldGVyID09PSBmYi5wYXJhbWV0ZXI7XG4gICAgICB9KTtcbiAgICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5wdXNoKGZiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICByZXR1cm4gZGVzY3JpcHRpb247XG59O1xuXG4vLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4vLyBwYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGtpbmQsIGNhcHMpIHtcbiAgbGV0IHNkcCA9ICcnO1xuXG4gIC8vIEJ1aWxkIHRoZSBtbGluZS5cbiAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubGVuZ3RoID4gMCA/ICc5JyA6ICcwJzsgLy8gcmVqZWN0IGlmIG5vIGNvZGVjcy5cbiAgc2RwICs9ICcgJyArIChjYXBzLnByb2ZpbGUgfHwgJ1VEUC9UTFMvUlRQL1NBVlBGJykgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoY29kZWMgPT4ge1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG5cbiAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcbiAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgLy8gQWRkIGE9cnRwbWFwIGxpbmVzIGZvciBlYWNoIGNvZGVjLiBBbHNvIGZtdHAgYW5kIHJ0Y3AtZmIuXG4gIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRm10cChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRjcEZiKGNvZGVjKTtcbiAgfSk7XG4gIGxldCBtYXhwdGltZSA9IDA7XG4gIGNhcHMuY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgIGlmIChjb2RlYy5tYXhwdGltZSA+IG1heHB0aW1lKSB7XG4gICAgICBtYXhwdGltZSA9IGNvZGVjLm1heHB0aW1lO1xuICAgIH1cbiAgfSk7XG4gIGlmIChtYXhwdGltZSA+IDApIHtcbiAgICBzZHAgKz0gJ2E9bWF4cHRpbWU6JyArIG1heHB0aW1lICsgJ1xcclxcbic7XG4gIH1cblxuICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgY2Fwcy5oZWFkZXJFeHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICAgIH0pO1xuICB9XG4gIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuLy8gUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICBjb25zdCBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcblxuICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gIGNvbnN0IHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKVxuICAgIC5maWx0ZXIocGFydHMgPT4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnKTtcbiAgY29uc3QgcHJpbWFyeVNzcmMgPSBzc3Jjcy5sZW5ndGggPiAwICYmIHNzcmNzWzBdLnNzcmM7XG4gIGxldCBzZWNvbmRhcnlTc3JjO1xuXG4gIGNvbnN0IGZsb3dzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjLWdyb3VwOkZJRCcpXG4gICAgLm1hcChsaW5lID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTcpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4gcGFydHMubWFwKHBhcnQgPT4gcGFyc2VJbnQocGFydCwgMTApKTtcbiAgICB9KTtcbiAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gIH1cblxuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgaWYgKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1JUWCcgJiYgY29kZWMucGFyYW1ldGVycy5hcHQpIHtcbiAgICAgIGxldCBlbmNQYXJhbSA9IHtcbiAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgIGNvZGVjUGF5bG9hZFR5cGU6IHBhcnNlSW50KGNvZGVjLnBhcmFtZXRlcnMuYXB0LCAxMCksXG4gICAgICB9O1xuICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcbiAgICAgICAgZW5jUGFyYW0ucnR4ID0ge3NzcmM6IHNlY29uZGFyeVNzcmN9O1xuICAgICAgfVxuICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgZW5jUGFyYW0uZmVjID0ge1xuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCcsXG4gICAgICAgIH07XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xuICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gd2Ugc3VwcG9ydCBib3RoIGI9QVMgYW5kIGI9VElBUyBidXQgaW50ZXJwcmV0IEFTIGFzIFRJQVMuXG4gIGxldCBiYW5kd2lkdGggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdiPScpO1xuICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1USUFTOicpID09PSAwKSB7XG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDcpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgLy8gdXNlIGZvcm11bGEgZnJvbSBKU0VQIHRvIGNvbnZlcnQgYj1BUyB0byBUSUFTIHZhbHVlLlxuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cmluZyg1KSwgMTApICogMTAwMCAqIDAuOTVcbiAgICAgICAgICAtICg1MCAqIDQwICogOCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2gocGFyYW1zID0+IHtcbiAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XG59O1xuXG4vLyBwYXJzZXMgaHR0cDovL2RyYWZ0Lm9ydGMub3JnLyNydGNydGNwcGFyYW1ldGVycypcblNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgLy8gU1NSQ3MuXG4gIGNvbnN0IHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpXG4gICAgLmZpbHRlcihvYmogPT4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJylbMF07XG4gIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgcnRjcFBhcmFtZXRlcnMuY25hbWUgPSByZW1vdGVTc3JjLnZhbHVlO1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgPSByZW1vdGVTc3JjLnNzcmM7XG4gIH1cblxuICAvLyBFZGdlIHVzZXMgdGhlIGNvbXBvdW5kIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIHJlZHVjZWRTaXplXG4gIC8vIGNvbXBvdW5kIGlzICFyZWR1Y2VkU2l6ZVxuICBjb25zdCByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XG4gIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXG4gIGNvbnN0IG11eCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1tdXgnKTtcbiAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG5cbiAgcmV0dXJuIHJ0Y3BQYXJhbWV0ZXJzO1xufTtcblxuU0RQVXRpbHMud3JpdGVSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHJ0Y3BQYXJhbWV0ZXJzKSB7XG4gIGxldCBzZHAgPSAnJztcbiAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnJlZHVjZWRTaXplKSB7XG4gICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xuICB9XG4gIGlmIChydGNwUGFyYW1ldGVycy5tdXgpIHtcbiAgICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuICB9XG4gIGlmIChydGNwUGFyYW1ldGVycy5zc3JjICE9PSB1bmRlZmluZWQgJiYgcnRjcFBhcmFtZXRlcnMuY25hbWUpIHtcbiAgICBzZHAgKz0gJ2E9c3NyYzonICsgcnRjcFBhcmFtZXRlcnMuc3NyYyArXG4gICAgICAnIGNuYW1lOicgKyBydGNwUGFyYW1ldGVycy5jbmFtZSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59O1xuXG5cbi8vIHBhcnNlcyBlaXRoZXIgYT1tc2lkOiBvciBhPXNzcmM6Li4uIG1zaWQgbGluZXMgYW5kIHJldHVybnNcbi8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG5TRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgbGV0IHBhcnRzO1xuICBjb25zdCBzcGVjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tc2lkOicpO1xuICBpZiAoc3BlYy5sZW5ndGggPT09IDEpIHtcbiAgICBwYXJ0cyA9IHNwZWNbMF0uc3Vic3RyaW5nKDcpLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG4gIGNvbnN0IHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKVxuICAgIC5maWx0ZXIobXNpZFBhcnRzID0+IG1zaWRQYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJyk7XG4gIGlmIChwbGFuQi5sZW5ndGggPiAwKSB7XG4gICAgcGFydHMgPSBwbGFuQlswXS52YWx1ZS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxufTtcblxuLy8gU0NUUFxuLy8gcGFyc2VzIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IGZpcnN0IGFuZCBmYWxscyBiYWNrXG4vLyB0byBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNVxuU0RQVXRpbHMucGFyc2VTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbWxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IG1heFNpemVMaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXhTaXplTGluZVswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XG4gIH1cbiAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xuICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gIH1cbiAgY29uc3Qgc2N0cFBvcnQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHAtcG9ydDonKTtcbiAgaWYgKHNjdHBQb3J0Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9ydDogcGFyc2VJbnQoc2N0cFBvcnRbMF0uc3Vic3RyaW5nKDEyKSwgMTApLFxuICAgICAgcHJvdG9jb2w6IG1saW5lLmZtdCxcbiAgICAgIG1heE1lc3NhZ2VTaXplLFxuICAgIH07XG4gIH1cbiAgY29uc3Qgc2N0cE1hcExpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwbWFwOicpO1xuICBpZiAoc2N0cE1hcExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwYXJ0cyA9IHNjdHBNYXBMaW5lc1swXVxuICAgICAgLnN1YnN0cmluZygxMClcbiAgICAgIC5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgbWF4TWVzc2FnZVNpemUsXG4gICAgfTtcbiAgfVxufTtcblxuLy8gU0NUUFxuLy8gb3V0cHV0cyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgdmVyc2lvbiB0aGF0IGFsbCBicm93c2Vyc1xuLy8gc3VwcG9ydCBieSBub3cgcmVjZWl2aW5nIGluIHRoaXMgZm9ybWF0LCB1bmxlc3Mgd2Ugb3JpZ2luYWxseSBwYXJzZWRcbi8vIGFzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNSBmb3JtYXQgKGluZGljYXRlZCBieSB0aGUgbS1saW5lXG4vLyBwcm90b2NvbCBvZiBEVExTL1NDVFAgLS0gd2l0aG91dCBVRFAvIG9yIFRDUC8pXG5TRFBVdGlscy53cml0ZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhLCBzY3RwKSB7XG4gIGxldCBvdXRwdXQgPSBbXTtcbiAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJyxcbiAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyxcbiAgICAgICdhPXNjdHAtcG9ydDonICsgc2N0cC5wb3J0ICsgJ1xcclxcbicsXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBbXG4gICAgICAnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJyxcbiAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyxcbiAgICAgICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJyxcbiAgICBdO1xuICB9XG4gIGlmIChzY3RwLm1heE1lc3NhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBvdXRwdXQucHVzaCgnYT1tYXgtbWVzc2FnZS1zaXplOicgKyBzY3RwLm1heE1lc3NhZ2VTaXplICsgJ1xcclxcbicpO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vLyBHZW5lcmF0ZSBhIHNlc3Npb24gSUQgZm9yIFNEUC5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLXJ0Y3dlYi1qc2VwLTIwI3NlY3Rpb24tNS4yLjFcbi8vIHJlY29tbWVuZHMgdXNpbmcgYSBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gK3ZlIDY0LWJpdCB2YWx1ZVxuLy8gYnV0IHJpZ2h0IG5vdyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIGFuZCB3aXRoaW4gdGhlIHJpZ2h0IHJhbmdlXG5TRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cigyLCAyMik7XG59O1xuXG4vLyBXcml0ZSBib2lsZXIgcGxhdGUgZm9yIHN0YXJ0IG9mIFNEUFxuLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcbi8vIGJlIGdlbmVyYXRlZCByYW5kb21seVxuLy8gc2Vzc1ZlcnNpb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDJcbi8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXG5TRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSA9IGZ1bmN0aW9uKHNlc3NJZCwgc2Vzc1Zlciwgc2Vzc1VzZXIpIHtcbiAgbGV0IHNlc3Npb25JZDtcbiAgY29uc3QgdmVyc2lvbiA9IHNlc3NWZXIgIT09IHVuZGVmaW5lZCA/IHNlc3NWZXIgOiAyO1xuICBpZiAoc2Vzc0lkKSB7XG4gICAgc2Vzc2lvbklkID0gc2Vzc0lkO1xuICB9IGVsc2Uge1xuICAgIHNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gIH1cbiAgY29uc3QgdXNlciA9IHNlc3NVc2VyIHx8ICd0aGlzaXNhZGFwdGVyb3J0Yyc7XG4gIC8vIEZJWE1FOiBzZXNzLWlkIHNob3VsZCBiZSBhbiBOVFAgdGltZXN0YW1wLlxuICByZXR1cm4gJ3Y9MFxcclxcbicgK1xuICAgICAgJ289JyArIHVzZXIgKyAnICcgKyBzZXNzaW9uSWQgKyAnICcgKyB2ZXJzaW9uICtcbiAgICAgICAgJyBJTiBJUDQgMTI3LjAuMC4xXFxyXFxuJyArXG4gICAgICAncz0tXFxyXFxuJyArXG4gICAgICAndD0wIDBcXHJcXG4nO1xufTtcblxuLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG5TRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIC8vIExvb2sgZm9yIHNlbmRyZWN2LCBzZW5kb25seSwgcmVjdm9ubHksIGluYWN0aXZlLCBkZWZhdWx0IHRvIHNlbmRyZWN2LlxuICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaCAobGluZXNbaV0pIHtcbiAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgY2FzZSAnYT1zZW5kb25seSc6XG4gICAgICBjYXNlICdhPXJlY3Zvbmx5JzpcbiAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICByZXR1cm4gbGluZXNbaV0uc3Vic3RyaW5nKDIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRklYTUU6IFdoYXQgc2hvdWxkIGhhcHBlbiBoZXJlP1xuICAgIH1cbiAgfVxuICBpZiAoc2Vzc2lvbnBhcnQpIHtcbiAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgfVxuICByZXR1cm4gJ3NlbmRyZWN2Jztcbn07XG5cblNEUFV0aWxzLmdldEtpbmQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cmluZygyKTtcbn07XG5cblNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG59O1xuXG5TRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBjb25zdCBwYXJ0cyA9IGxpbmVzWzBdLnN1YnN0cmluZygyKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IHBhcnRzWzBdLFxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgcHJvdG9jb2w6IHBhcnRzWzJdLFxuICAgIGZtdDogcGFydHMuc2xpY2UoMykuam9pbignICcpLFxuICB9O1xufTtcblxuU0RQVXRpbHMucGFyc2VPTGluZSA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICBjb25zdCBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcbiAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygyKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICBzZXNzaW9uSWQ6IHBhcnRzWzFdLFxuICAgIHNlc3Npb25WZXJzaW9uOiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxuICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgIGFkZHJlc3NUeXBlOiBwYXJ0c1s0XSxcbiAgICBhZGRyZXNzOiBwYXJ0c1s1XSxcbiAgfTtcbn07XG5cbi8vIGEgdmVyeSBuYWl2ZSBpbnRlcnByZXRhdGlvbiBvZiBhIHZhbGlkIFNEUC5cblNEUFV0aWxzLmlzVmFsaWRTRFAgPSBmdW5jdGlvbihibG9iKSB7XG4gIGlmICh0eXBlb2YgYmxvYiAhPT0gJ3N0cmluZycgfHwgYmxvYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTRFBVdGlscztcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBTRFBVdGlscyBmcm9tICdzZHAnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdykge1xuICAvLyBmb3VuZGF0aW9uIGlzIGFyYml0cmFyaWx5IGNob3NlbiBhcyBhbiBpbmRpY2F0b3IgZm9yIGZ1bGwgc3VwcG9ydCBmb3JcbiAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1wYy8jcnRjaWNlY2FuZGlkYXRlLWludGVyZmFjZVxuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgKHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ2ZvdW5kYXRpb24nIGluXG4gICAgICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiZcbiAgICAgICAgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmxlbmd0aCkge1xuICAgICAgLy8gQXVnbWVudCB0aGUgbmF0aXZlIGNhbmRpZGF0ZSB3aXRoIHRoZSBwYXJzZWQgZmllbGRzLlxuICAgICAgY29uc3QgbmF0aXZlQ2FuZGlkYXRlID0gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgICAgIGNvbnN0IHBhcnNlZENhbmRpZGF0ZSA9IFNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlKGFyZ3MuY2FuZGlkYXRlKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcnNlZENhbmRpZGF0ZSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gbmF0aXZlQ2FuZGlkYXRlKSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXRpdmVDYW5kaWRhdGUsIGtleSxcbiAgICAgICAgICAgIHt2YWx1ZTogcGFyc2VkQ2FuZGlkYXRlW2tleV19KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPdmVycmlkZSBzZXJpYWxpemVyIHRvIG5vdCBzZXJpYWxpemUgdGhlIGV4dHJhIGF0dHJpYnV0ZXMuXG4gICAgICBuYXRpdmVDYW5kaWRhdGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbmRpZGF0ZTogbmF0aXZlQ2FuZGlkYXRlLmNhbmRpZGF0ZSxcbiAgICAgICAgICBzZHBNaWQ6IG5hdGl2ZUNhbmRpZGF0ZS5zZHBNaWQsXG4gICAgICAgICAgc2RwTUxpbmVJbmRleDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgdXNlcm5hbWVGcmFnbWVudDogbmF0aXZlQ2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5hdGl2ZUNhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gIH07XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlID0gTmF0aXZlUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZTtcblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdjYW5kaWRhdGUnLCB7XG4gICAgICAgIHZhbHVlOiBuZXcgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSksXG4gICAgICAgIHdyaXRhYmxlOiAnZmFsc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCAod2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAncmVsYXlQcm90b2NvbCcgaW5cbiAgICAgIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEhvb2sgdXAgdGhlIGF1Z21lbnRlZCBjYW5kaWRhdGUgaW4gb25pY2VjYW5kaWRhdGUgYW5kXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNhbmRpZGF0ZScsIC4uLilcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnaWNlY2FuZGlkYXRlJywgZSA9PiB7XG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZS5jYW5kaWRhdGUpO1xuICAgICAgaWYgKHBhcnNlZENhbmRpZGF0ZS50eXBlID09PSAncmVsYXknKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsaWJ3ZWJydGMtc3BlY2lmaWMgbWFwcGluZyBvZiBsb2NhbCB0eXBlIHByZWZlcmVuY2VcbiAgICAgICAgLy8gdG8gcmVsYXlQcm90b2NvbC5cbiAgICAgICAgZS5jYW5kaWRhdGUucmVsYXlQcm90b2NvbCA9IHtcbiAgICAgICAgICAwOiAndGxzJyxcbiAgICAgICAgICAxOiAndGNwJyxcbiAgICAgICAgICAyOiAndWRwJyxcbiAgICAgICAgfVtwYXJzZWRDYW5kaWRhdGUucHJpb3JpdHkgPj4gMjRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghKCdzY3RwJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnc2N0cCcsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc2N0cEluRGVzY3JpcHRpb24gPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucy5zb21lKG1lZGlhU2VjdGlvbiA9PiB7XG4gICAgICBjb25zdCBtTGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICAgIHJldHVybiBtTGluZSAmJiBtTGluZS5raW5kID09PSAnYXBwbGljYXRpb24nXG4gICAgICAgICAgJiYgbUxpbmUucHJvdG9jb2wuaW5kZXhPZignU0NUUCcpICE9PSAtMTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIGRldGVjdGluZyBGaXJlZm94P1xuICAgIGNvbnN0IG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9tb3ppbGxhLi4uVEhJU19JU19TRFBBUlRBLShcXGQrKS8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIC8vIFRlc3QgZm9yIE5hTiAoeWVzLCB0aGlzIGlzIHVnbHkpXG4gICAgcmV0dXJuIHZlcnNpb24gIT09IHZlcnNpb24gPyAtMSA6IHZlcnNpb247XG4gIH07XG5cbiAgY29uc3QgZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24ocmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gRXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBjYW4gc2VuZCBhdCBsZWFzdCA2NCBLaUIuXG4gICAgLy8gTm90ZTogQWx0aG91Z2ggQ2hyb21lIGlzIHRlY2huaWNhbGx5IGFibGUgdG8gc2VuZCB1cCB0byAyNTYgS2lCLCB0aGVcbiAgICAvLyAgICAgICBkYXRhIGRvZXMgbm90IHJlYWNoIHRoZSBvdGhlciBwZWVyIHJlbGlhYmx5LlxuICAgIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTg0MTlcbiAgICBsZXQgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94Jykge1xuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Nykge1xuICAgICAgICBpZiAocmVtb3RlSXNGaXJlZm94ID09PSAtMSkge1xuICAgICAgICAgIC8vIEZGIDwgNTcgd2lsbCBzZW5kIGluIDE2IEtpQiBjaHVua3MgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgUFBJRFxuICAgICAgICAgIC8vIGZyYWdtZW50YXRpb24uXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMTYzODQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSG93ZXZlciwgb3RoZXIgRkYgKGFuZCBSQVdSVEMpIGNhbiByZWFzc2VtYmxlIFBQSUQtZnJhZ21lbnRlZFxuICAgICAgICAgIC8vIG1lc3NhZ2VzLiBUaHVzLCBzdXBwb3J0aW5nIH4yIEdpQiB3aGVuIHNlbmRpbmcuXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjApIHtcbiAgICAgICAgLy8gQ3VycmVudGx5LCBhbGwgRkYgPj0gNTcgd2lsbCByZXNldCB0aGUgcmVtb3RlIG1heGltdW0gbWVzc2FnZSBzaXplXG4gICAgICAgIC8vIHRvIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gYSBkYXRhIGNoYW5uZWwgaXMgY3JlYXRlZCBhdCBhIGxhdGVyXG4gICAgICAgIC8vIHN0YWdlLiA6KFxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjY4MzFcbiAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID1cbiAgICAgICAgICBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1NyA/IDY1NTM1IDogNjU1MzY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGRiA+PSA2MCBzdXBwb3J0cyBzZW5kaW5nIH4yIEdpQlxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuU2VuZE1heE1lc3NhZ2VTaXplO1xuICB9O1xuXG4gIGNvbnN0IGdldE1heE1lc3NhZ2VTaXplID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHJlbW90ZUlzRmlyZWZveCkge1xuICAgIC8vIE5vdGU6IDY1NTM2IGJ5dGVzIGlzIHRoZSBkZWZhdWx0IHZhbHVlIGZyb20gdGhlIFNEUCBzcGVjLiBBbHNvLFxuICAgIC8vICAgICAgIGV2ZXJ5IGltcGxlbWVudGF0aW9uIHdlIGtub3cgc3VwcG9ydHMgcmVjZWl2aW5nIDY1NTM2IGJ5dGVzLlxuICAgIGxldCBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuXG4gICAgLy8gRkYgNTcgaGFzIGEgc2xpZ2h0bHkgaW5jb3JyZWN0IGRlZmF1bHQgcmVtb3RlIG1heCBtZXNzYWdlIHNpemUsIHNvXG4gICAgLy8gd2UgbmVlZCB0byBhZGp1c3QgaXQgaGVyZSB0byBhdm9pZCBhIGZhaWx1cmUgd2hlbiBzZW5kaW5nLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNTY5N1xuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCdcbiAgICAgICAgICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3KSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM1O1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoZGVzY3JpcHRpb24uc2RwLFxuICAgICAgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgICBpZiAobWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXRjaFswXS5zdWJzdHJpbmcoMTkpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiZcbiAgICAgICAgICAgICAgICByZW1vdGVJc0ZpcmVmb3ggIT09IC0xKSB7XG4gICAgICAvLyBJZiB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgaXMgbm90IHByZXNlbnQgaW4gdGhlIHJlbW90ZSBTRFAgYW5kXG4gICAgICAvLyBib3RoIGxvY2FsIGFuZCByZW1vdGUgYXJlIEZpcmVmb3gsIHRoZSByZW1vdGUgcGVlciBjYW4gcmVjZWl2ZVxuICAgICAgLy8gfjIgR2lCLlxuICAgICAgbWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgIH1cbiAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gIH07XG5cbiAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID1cbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPVxuICAgIGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgdGhpcy5fc2N0cCA9IG51bGw7XG4gICAgICAvLyBDaHJvbWUgZGVjaWRlZCB0byBub3QgZXhwb3NlIC5zY3RwIGluIHBsYW4tYiBtb2RlLlxuICAgICAgLy8gQXMgdXN1YWwsIGFkYXB0ZXIuanMgaGFzIHRvIGRvIGFuICd1Z2x5IHdvcmFrYXJvdW5kJ1xuICAgICAgLy8gdG8gY292ZXIgdXAgdGhlIG1lc3MuXG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3Nikge1xuICAgICAgICBjb25zdCB7c2RwU2VtYW50aWNzfSA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBpZiAoc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2N0cCcsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjdHBJbkRlc2NyaXB0aW9uKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBGRi5cbiAgICAgICAgY29uc3QgaXNGaXJlZm94ID0gZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24oYXJndW1lbnRzWzBdKTtcblxuICAgICAgICAvLyBHZXQgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIHRoZSBsb2NhbCBwZWVyIGlzIGNhcGFibGUgb2Ygc2VuZGluZ1xuICAgICAgICBjb25zdCBjYW5TZW5kTU1TID0gZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplKGlzRmlyZWZveCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBvZiB0aGUgcmVtb3RlIHBlZXIuXG4gICAgICAgIGNvbnN0IHJlbW90ZU1NUyA9IGdldE1heE1lc3NhZ2VTaXplKGFyZ3VtZW50c1swXSwgaXNGaXJlZm94KTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgZmluYWwgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgbGV0IG1heE1lc3NhZ2VTaXplO1xuICAgICAgICBpZiAoY2FuU2VuZE1NUyA9PT0gMCAmJiByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW5TZW5kTU1TID09PSAwIHx8IHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICAgIG1heE1lc3NhZ2VTaXplID0gTWF0aC5tYXgoY2FuU2VuZE1NUywgcmVtb3RlTU1TKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWluKGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYSBkdW1teSBSVENTY3RwVHJhbnNwb3J0IG9iamVjdCBhbmQgdGhlICdtYXhNZXNzYWdlU2l6ZSdcbiAgICAgICAgLy8gYXR0cmlidXRlLlxuICAgICAgICBjb25zdCBzY3RwID0ge307XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY3RwLCAnbWF4TWVzc2FnZVNpemUnLCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NjdHAgPSBzY3RwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJlxuICAgICAgJ2NyZWF0ZURhdGFDaGFubmVsJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE5vdGU6IEFsdGhvdWdoIEZpcmVmb3ggPj0gNTcgaGFzIGEgbmF0aXZlIGltcGxlbWVudGF0aW9uLCB0aGUgbWF4aW11bVxuICAvLyAgICAgICBtZXNzYWdlIHNpemUgY2FuIGJlIHJlc2V0IGZvciBhbGwgZGF0YSBjaGFubmVscyBhdCBhIGxhdGVyIHN0YWdlLlxuICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjY4MzFcblxuICBmdW5jdGlvbiB3cmFwRGNTZW5kKGRjLCBwYykge1xuICAgIGNvbnN0IG9yaWdEYXRhQ2hhbm5lbFNlbmQgPSBkYy5zZW5kO1xuICAgIGRjLnNlbmQgPSBmdW5jdGlvbiBzZW5kKCkge1xuICAgICAgY29uc3QgZGF0YSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoIHx8IGRhdGEuc2l6ZSB8fCBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAoZGMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nICYmXG4gICAgICAgICAgcGMuc2N0cCAmJiBsZW5ndGggPiBwYy5zY3RwLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIChjYW4gc2VuZCBhIG1heGltdW0gb2YgJyArXG4gICAgICAgICAgcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ0RhdGFDaGFubmVsU2VuZC5hcHBseShkYywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbCA9XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbDtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCA9XG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwoKSB7XG4gICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd3JhcERjU2VuZChkYXRhQ2hhbm5lbCwgdGhpcyk7XG4gICAgICByZXR1cm4gZGF0YUNoYW5uZWw7XG4gICAgfTtcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnZGF0YWNoYW5uZWwnLCBlID0+IHtcbiAgICB3cmFwRGNTZW5kKGUuY2hhbm5lbCwgZS50YXJnZXQpO1xuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuXG4vKiBzaGltcyBSVENDb25uZWN0aW9uU3RhdGUgYnkgcHJldGVuZGluZyBpdCBpcyB0aGUgc2FtZSBhcyBpY2VDb25uZWN0aW9uU3RhdGUuXG4gKiBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTYxNDUjYzEyXG4gKiBmb3Igd2h5IHRoaXMgaXMgYSB2YWxpZCBoYWNrIGluIENocm9tZS4gSW4gRmlyZWZveCBpdCBpcyBzbGlnaHRseSBpbmNvcnJlY3RcbiAqIHNpbmNlIERUTFMgZmFpbHVyZXMgd291bGQgYmUgaGlkZGVuLiBTZWVcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNjU4MjdcbiAqIGZvciB0aGUgRmlyZWZveCB0cmFja2luZyBidWcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fFxuICAgICAgJ2Nvbm5lY3Rpb25TdGF0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2Nvbm5lY3Rpb25TdGF0ZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZWQ6ICdjb25uZWN0ZWQnLFxuICAgICAgICBjaGVja2luZzogJ2Nvbm5lY3RpbmcnXG4gICAgICB9W3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlXSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgfHwgbnVsbDtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJyxcbiAgICAgICAgICB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsXG4gICAgICAgICAgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBjYik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgICBjb25zdCBvcmlnTWV0aG9kID0gcHJvdG9bbWV0aG9kXTtcbiAgICBwcm90b1ttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSA9IGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XG4gICAgICAgICAgaWYgKHBjLl9sYXN0Q29ubmVjdGlvblN0YXRlICE9PSBwYy5jb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHBjLl9sYXN0Q29ubmVjdGlvblN0YXRlID0gcGMuY29ubmVjdGlvblN0YXRlO1xuICAgICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgRXZlbnQoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGUpO1xuICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsXG4gICAgICAgICAgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8qIHJlbW92ZSBhPWV4dG1hcC1hbGxvdy1taXhlZCBmb3Igd2VicnRjLm9yZyA8IE03MSAqL1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3MSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MDUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU1JEID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9XG4gIGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpIHtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLnNkcCAmJiBkZXNjLnNkcC5pbmRleE9mKCdcXG5hPWV4dG1hcC1hbGxvdy1taXhlZCcpICE9PSAtMSkge1xuICAgICAgY29uc3Qgc2RwID0gZGVzYy5zZHAuc3BsaXQoJ1xcbicpLmZpbHRlcigobGluZSkgPT4ge1xuICAgICAgICByZXR1cm4gbGluZS50cmltKCkgIT09ICdhPWV4dG1hcC1hbGxvdy1taXhlZCc7XG4gICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgIC8vIFNhZmFyaSBlbmZvcmNlcyByZWFkLW9ubHktbmVzcyBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24gZmllbGRzLlxuICAgICAgaWYgKHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gJiZcbiAgICAgICAgICBkZXNjIGluc3RhbmNlb2Ygd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgICAgdHlwZTogZGVzYy50eXBlLFxuICAgICAgICAgIHNkcCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXNjLnNkcCA9IHNkcDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVNSRC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgLy8gU3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAvLyBhcyB3ZWxsIGFzIGFkZEljZUNhbmRpZGF0ZSh7Y2FuZGlkYXRlOiBcIlwiLCAuLi59KVxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05Nzg1ODJcbiAgLy8gTm90ZTogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG90aGVyIHBvbHlmaWxscyB3aGljaCBjaGFuZ2UgdGhlIHNpZ25hdHVyZS5cbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgaWYgKCFuYXRpdmVBZGRJY2VDYW5kaWRhdGUgfHwgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9XG4gICAgZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICAvLyBGaXJlZm94IDY4KyBlbWl0cyBhbmQgcHJvY2Vzc2VzIHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0sIGlnbm9yZVxuICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMuXG4gICAgICAvLyBOYXRpdmUgc3VwcG9ydCBmb3IgaWdub3JpbmcgZXhpc3RzIGZvciBDaHJvbWUgTTc3Ky5cbiAgICAgIC8vIFNhZmFyaSBpZ25vcmVzIGFzIHdlbGwsIGV4YWN0IHZlcnNpb24gdW5rbm93biBidXQgd29ya3MgaW4gdGhlIHNhbWVcbiAgICAgIC8vIHZlcnNpb24gdGhhdCBhbHNvIGlnbm9yZXMgYWRkSWNlQ2FuZGlkYXRlKG51bGwpLlxuICAgICAgaWYgKCgoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDc4KVxuICAgICAgICAgICB8fCAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnXG4gICAgICAgICAgICAgICAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjgpXG4gICAgICAgICAgIHx8IChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnc2FmYXJpJykpXG4gICAgICAgICAgJiYgYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vLyBOb3RlOiBNYWtlIHN1cmUgdG8gY2FsbCB0aGlzIGFoZWFkIG9mIEFQSXMgdGhhdCBtb2RpZnlcbi8vIHNldExvY2FsRGVzY3JpcHRpb24ubGVuZ3RoXG5leHBvcnQgZnVuY3Rpb24gc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gPVxuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBpZiAoIW5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gfHwgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID1cbiAgICBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgICAgbGV0IGRlc2MgPSBhcmd1bWVudHNbMF0gfHwge307XG4gICAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnIHx8IChkZXNjLnR5cGUgJiYgZGVzYy5zZHApKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICAvLyBUaGUgcmVtYWluaW5nIHN0ZXBzIHNob3VsZCB0ZWNobmljYWxseSBoYXBwZW4gd2hlbiBTTEQgY29tZXMgb2ZmIHRoZVxuICAgICAgLy8gUlRDUGVlckNvbm5lY3Rpb24ncyBvcGVyYXRpb25zIGNoYWluIChub3QgYWhlYWQgb2YgZ29pbmcgb24gaXQpLCBidXRcbiAgICAgIC8vIHRoaXMgaXMgdG9vIGRpZmZpY3VsdCB0byBzaGltLiBJbnN0ZWFkLCB0aGlzIHNoaW0gb25seSBjb3ZlcnMgdGhlXG4gICAgICAvLyBjb21tb24gY2FzZSB3aGVyZSB0aGUgb3BlcmF0aW9ucyBjaGFpbiBpcyBlbXB0eS4gVGhpcyBpcyBpbXBlcmZlY3QsIGJ1dFxuICAgICAgLy8gc2hvdWxkIGNvdmVyIG1hbnkgY2FzZXMuIFJhdGlvbmFsZTogRXZlbiBpZiB3ZSBjYW4ndCByZWR1Y2UgdGhlIGdsYXJlXG4gICAgICAvLyB3aW5kb3cgdG8gemVybyBvbiBpbXBlcmZlY3QgaW1wbGVtZW50YXRpb25zLCB0aGVyZSdzIHZhbHVlIGluIHRhcHBpbmdcbiAgICAgIC8vIGludG8gdGhlIHBlcmZlY3QgbmVnb3RpYXRpb24gcGF0dGVybiB0aGF0IHNldmVyYWwgYnJvd3NlcnMgc3VwcG9ydC5cbiAgICAgIGRlc2MgPSB7dHlwZTogZGVzYy50eXBlLCBzZHA6IGRlc2Muc2RwfTtcbiAgICAgIGlmICghZGVzYy50eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ3N0YWJsZSc6XG4gICAgICAgICAgY2FzZSAnaGF2ZS1sb2NhbC1vZmZlcic6XG4gICAgICAgICAgY2FzZSAnaGF2ZS1yZW1vdGUtcHJhbnN3ZXInOlxuICAgICAgICAgICAgZGVzYy50eXBlID0gJ29mZmVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBkZXNjLnR5cGUgPSAnYW5zd2VyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVzYy5zZHAgfHwgKGRlc2MudHlwZSAhPT0gJ29mZmVyJyAmJiBkZXNjLnR5cGUgIT09ICdhbnN3ZXInKSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY10pO1xuICAgICAgfVxuICAgICAgY29uc3QgZnVuYyA9IGRlc2MudHlwZSA9PT0gJ29mZmVyJyA/IHRoaXMuY3JlYXRlT2ZmZXIgOiB0aGlzLmNyZWF0ZUFuc3dlcjtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMpXG4gICAgICAgIC50aGVuKGQgPT4gbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZF0pKTtcbiAgICB9O1xufVxuIiwiLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuLy8gQnJvd3NlciBzaGltcy5cbmltcG9ydCAqIGFzIGNocm9tZVNoaW0gZnJvbSAnLi9jaHJvbWUvY2hyb21lX3NoaW0nO1xuaW1wb3J0ICogYXMgZmlyZWZveFNoaW0gZnJvbSAnLi9maXJlZm94L2ZpcmVmb3hfc2hpbSc7XG5pbXBvcnQgKiBhcyBzYWZhcmlTaGltIGZyb20gJy4vc2FmYXJpL3NhZmFyaV9zaGltJztcbmltcG9ydCAqIGFzIGNvbW1vblNoaW0gZnJvbSAnLi9jb21tb25fc2hpbSc7XG5pbXBvcnQgKiBhcyBzZHAgZnJvbSAnc2RwJztcblxuLy8gU2hpbW1pbmcgc3RhcnRzIGhlcmUuXG5leHBvcnQgZnVuY3Rpb24gYWRhcHRlckZhY3Rvcnkoe3dpbmRvd30gPSB7fSwgb3B0aW9ucyA9IHtcbiAgc2hpbUNocm9tZTogdHJ1ZSxcbiAgc2hpbUZpcmVmb3g6IHRydWUsXG4gIHNoaW1TYWZhcmk6IHRydWUsXG59KSB7XG4gIC8vIFV0aWxzLlxuICBjb25zdCBsb2dnaW5nID0gdXRpbHMubG9nO1xuICBjb25zdCBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICBjb25zdCBhZGFwdGVyID0ge1xuICAgIGJyb3dzZXJEZXRhaWxzLFxuICAgIGNvbW1vblNoaW0sXG4gICAgZXh0cmFjdFZlcnNpb246IHV0aWxzLmV4dHJhY3RWZXJzaW9uLFxuICAgIGRpc2FibGVMb2c6IHV0aWxzLmRpc2FibGVMb2csXG4gICAgZGlzYWJsZVdhcm5pbmdzOiB1dGlscy5kaXNhYmxlV2FybmluZ3MsXG4gICAgLy8gRXhwb3NlIHNkcCBhcyBhIGNvbnZlbmllbmNlLiBGb3IgcHJvZHVjdGlvbiBhcHBzIGluY2x1ZGUgZGlyZWN0bHkuXG4gICAgc2RwLFxuICB9O1xuXG4gIC8vIFNoaW0gYnJvd3NlciBpZiBmb3VuZC5cbiAgc3dpdGNoIChicm93c2VyRGV0YWlscy5icm93c2VyKSB7XG4gICAgY2FzZSAnY2hyb21lJzpcbiAgICAgIGlmICghY2hyb21lU2hpbSB8fCAhY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgICAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBjYW4gbm90IGRldGVybWluZSB2ZXJzaW9uLCBub3Qgc2hpbW1pbmcuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1NZWRpYVN0cmVhbSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5zaGltT25UcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY2hyb21lU2hpbS5maXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcblxuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5yZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICBpZiAoIWZpcmVmb3hTaGltIHx8ICFmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHxcbiAgICAgICAgICAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBjb21tb25TaGltLnNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuXG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbU9uVHJhY2sod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUmVtb3ZlU3RyZWFtKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUlRDRGF0YUNoYW5uZWwod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQWRkVHJhbnNjZWl2ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0UGFyYW1ldGVycyh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1DcmVhdGVPZmZlcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1DcmVhdGVBbnN3ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgLy8gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNoaW1DYWxsYmFja0FQSS5cbiAgICAgIGNvbW1vblNoaW0uc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgY29tbW9uU2hpbS5zaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIHNhZmFyaVNoaW0uc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1BdWRpb0NvbnRleHQod2luZG93LCBicm93c2VyRGV0YWlscyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dnaW5nKCdVbnN1cHBvcnRlZCBicm93c2VyIScpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gYWRhcHRlcjtcbn1cbiIsIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHthZGFwdGVyRmFjdG9yeX0gZnJvbSAnLi9hZGFwdGVyX2ZhY3RvcnkuanMnO1xuXG5jb25zdCBhZGFwdGVyID1cbiAgYWRhcHRlckZhY3Rvcnkoe3dpbmRvdzogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiB3aW5kb3d9KTtcbmV4cG9ydCBkZWZhdWx0IGFkYXB0ZXI7XG4iLCJpbXBvcnQgdHlwZSB7IEtleVByb3ZpZGVyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgRU5DUllQVElPTl9BTEdPUklUSE0gPSAnQUVTLUdDTSc7XG5cbi8vIEhvdyBtYW55IGNvbnNlY3V0aXZlIGZyYW1lcyBjYW4gZmFpbCBkZWNyeXB0aW5nIGJlZm9yZSBhIHBhcnRpY3VsYXIga2V5IGdldHMgbWFya2VkIGFzIGludmFsaWRcbmV4cG9ydCBjb25zdCBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFID0gMTA7XG5cbi8vIFdlIGNvcHkgdGhlIGZpcnN0IGJ5dGVzIG9mIHRoZSBWUDggcGF5bG9hZCB1bmVuY3J5cHRlZC5cbi8vIEZvciBrZXlmcmFtZXMgdGhpcyBpcyAxMCBieXRlcywgZm9yIG5vbi1rZXlmcmFtZXMgKGRlbHRhKSAzLiBTZWVcbi8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzODYjc2VjdGlvbi05LjFcbi8vIFRoaXMgYWxsb3dzIHRoZSBicmlkZ2UgdG8gY29udGludWUgZGV0ZWN0aW5nIGtleWZyYW1lcyAob25seSBvbmUgYnl0ZSBuZWVkZWQgaW4gdGhlIEpWQilcbi8vIGFuZCBpcyBhbHNvIGEgYml0IGVhc2llciBmb3IgdGhlIFZQOCBkZWNvZGVyIChpLmUuIGl0IGdlbmVyYXRlcyBmdW5ueSBnYXJiYWdlIHBpY3R1cmVzXG4vLyBpbnN0ZWFkIG9mIGJlaW5nIHVuYWJsZSB0byBkZWNvZGUpLlxuLy8gVGhpcyBpcyBhIGJpdCBmb3Igc2hvdyBhbmQgd2UgbWlnaHQgd2FudCB0byByZWR1Y2UgdG8gMSB1bmNvbmRpdGlvbmFsbHkgaW4gdGhlIGZpbmFsIHZlcnNpb24uXG4vL1xuLy8gRm9yIGF1ZGlvICh3aGVyZSBmcmFtZS50eXBlIGlzIG5vdCBzZXQpIHdlIGRvIG5vdCBlbmNyeXB0IHRoZSBvcHVzIFRPQyBieXRlOlxuLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjcxNiNzZWN0aW9uLTMuMVxuZXhwb3J0IGNvbnN0IFVORU5DUllQVEVEX0JZVEVTID0ge1xuICBrZXk6IDEwLFxuICBkZWx0YTogMyxcbiAgYXVkaW86IDEsIC8vIGZyYW1lLnR5cGUgaXMgbm90IHNldCBvbiBhdWRpbywgc28gdGhpcyBpcyBzZXQgbWFudWFsbHlcbiAgZW1wdHk6IDAsXG59IGFzIGNvbnN0O1xuXG4vKiBXZSB1c2UgYSAxMiBieXRlIGJpdCBJVi4gVGhpcyBpcyBzaWduYWxsZWQgaW4gcGxhaW4gdG9nZXRoZXIgd2l0aCB0aGVcbiBwYWNrZXQuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2VuY3J5cHQjcGFyYW1ldGVycyAqL1xuZXhwb3J0IGNvbnN0IElWX0xFTkdUSCA9IDEyO1xuXG4vLyBmbGFnIHNldCB0byBpbmRpY2F0ZSB0aGF0IGUyZWUgaGFzIGJlZW4gc2V0dXAgZm9yIHNlbmRlci9yZWNlaXZlcjtcbmV4cG9ydCBjb25zdCBFMkVFX0ZMQUcgPSAnbGtfZTJlZSc7XG5cbmV4cG9ydCBjb25zdCBTQUxUID0gJ0xLRnJhbWVFbmNyeXB0aW9uS2V5JztcblxuZXhwb3J0IGNvbnN0IEtFWV9QUk9WSURFUl9ERUZBVUxUUzogS2V5UHJvdmlkZXJPcHRpb25zID0ge1xuICBzaGFyZWRLZXk6IGZhbHNlLFxuICByYXRjaGV0U2FsdDogU0FMVCxcbiAgcmF0Y2hldFdpbmRvd1NpemU6IDgsXG4gIGZhaWx1cmVUb2xlcmFuY2U6IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UsXG4gIGtleXJpbmdTaXplOiAxNixcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBNQVhfU0lGX0NPVU5UID0gMTAwO1xuZXhwb3J0IGNvbnN0IE1BWF9TSUZfRFVSQVRJT04gPSAyMDAwO1xuIiwiaW1wb3J0IHR5cGUgUGFydGljaXBhbnQgZnJvbSAnLi4vcm9vbS9wYXJ0aWNpcGFudC9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IENyeXB0b3JFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgS2V5SW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBLZXlQcm92aWRlckV2ZW50IHtcbiAgU2V0S2V5ID0gJ3NldEtleScsXG4gIFJhdGNoZXRSZXF1ZXN0ID0gJ3JhdGNoZXRSZXF1ZXN0JyxcbiAgS2V5UmF0Y2hldGVkID0gJ2tleVJhdGNoZXRlZCcsXG59XG5cbmV4cG9ydCB0eXBlIEtleVByb3ZpZGVyQ2FsbGJhY2tzID0ge1xuICBbS2V5UHJvdmlkZXJFdmVudC5TZXRLZXldOiAoa2V5SW5mbzogS2V5SW5mbykgPT4gdm9pZDtcbiAgW0tleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3RdOiAocGFydGljaXBhbnRJZGVudGl0eT86IHN0cmluZywga2V5SW5kZXg/OiBudW1iZXIpID0+IHZvaWQ7XG4gIFtLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZF06IChtYXRlcmlhbDogQ3J5cHRvS2V5LCBrZXlJbmRleD86IG51bWJlcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBlbnVtIEtleUhhbmRsZXJFdmVudCB7XG4gIEtleVJhdGNoZXRlZCA9ICdrZXlSYXRjaGV0ZWQnLFxufVxuXG5leHBvcnQgdHlwZSBQYXJ0aWNpcGFudEtleUhhbmRsZXJDYWxsYmFja3MgPSB7XG4gIFtLZXlIYW5kbGVyRXZlbnQuS2V5UmF0Y2hldGVkXTogKFxuICAgIG1hdGVyaWFsOiBDcnlwdG9LZXksXG4gICAgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nLFxuICAgIGtleUluZGV4PzogbnVtYmVyLFxuICApID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZW51bSBFbmNyeXB0aW9uRXZlbnQge1xuICBQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkID0gJ3BhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQnLFxuICBFbmNyeXB0aW9uRXJyb3IgPSAnZW5jcnlwdGlvbkVycm9yJyxcbn1cblxuZXhwb3J0IHR5cGUgRTJFRU1hbmFnZXJDYWxsYmFja3MgPSB7XG4gIFtFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZF06IChcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICBbRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvcl06IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBDcnlwdG9yQ2FsbGJhY2tzID0ge1xuICBbQ3J5cHRvckV2ZW50LkVycm9yXTogKGVycm9yOiBDcnlwdG9yRXJyb3IpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgZW51bSBDcnlwdG9yRXZlbnQge1xuICBFcnJvciA9ICdjcnlwdG9yRXJyb3InLFxufVxuIiwiaW1wb3J0IHsgRU5DUllQVElPTl9BTEdPUklUSE0gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0UyRUVTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93LlJUQ1J0cFNlbmRlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmNyZWF0ZUVuY29kZWRTdHJlYW1zICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaWRlb0ZyYW1lKFxuICBmcmFtZTogUlRDRW5jb2RlZEF1ZGlvRnJhbWUgfCBSVENFbmNvZGVkVmlkZW9GcmFtZSxcbik6IGZyYW1lIGlzIFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHtcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcG9ydEtleShcbiAga2V5Qnl0ZXM6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlcixcbiAgYWxnb3JpdGhtOiBzdHJpbmcgfCB7IG5hbWU6IHN0cmluZyB9ID0geyBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSB9LFxuICB1c2FnZTogJ2Rlcml2ZScgfCAnZW5jcnlwdCcgPSAnZW5jcnlwdCcsXG4pIHtcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9pbXBvcnRLZXlcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIGtleUJ5dGVzLFxuICAgIGFsZ29yaXRobSxcbiAgICBmYWxzZSxcbiAgICB1c2FnZSA9PT0gJ2Rlcml2ZScgPyBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10gOiBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddLFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKHBhc3N3b3JkOiBzdHJpbmcpIHtcbiAgbGV0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIGNvbnN0IGtleU1hdGVyaWFsID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgJ3JhdycsXG4gICAgZW5jLmVuY29kZShwYXNzd29yZCksXG4gICAge1xuICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBbJ2Rlcml2ZUJpdHMnLCAnZGVyaXZlS2V5J10sXG4gICk7XG5cbiAgcmV0dXJuIGtleU1hdGVyaWFsO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyKGNyeXB0b0J1ZmZlcjogQXJyYXlCdWZmZXIpIHtcbiAgY29uc3Qga2V5TWF0ZXJpYWwgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgY3J5cHRvQnVmZmVyLCAnSEtERicsIGZhbHNlLCBbXG4gICAgJ2Rlcml2ZUJpdHMnLFxuICAgICdkZXJpdmVLZXknLFxuICBdKTtcblxuICByZXR1cm4ga2V5TWF0ZXJpYWw7XG59XG5cbmZ1bmN0aW9uIGdldEFsZ29PcHRpb25zKGFsZ29yaXRobU5hbWU6IHN0cmluZywgc2FsdDogc3RyaW5nKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGVuY29kZWRTYWx0ID0gdGV4dEVuY29kZXIuZW5jb2RlKHNhbHQpO1xuICBzd2l0Y2ggKGFsZ29yaXRobU5hbWUpIHtcbiAgICBjYXNlICdIS0RGJzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdIS0RGJyxcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgaW5mbzogbmV3IEFycmF5QnVmZmVyKDEyOCksXG4gICAgICB9O1xuICAgIGNhc2UgJ1BCS0RGMic6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDAsXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbGdvcml0aG0gJHthbGdvcml0aG1OYW1lfSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG4vKipcbiAqIERlcml2ZXMgYSBzZXQgb2Yga2V5cyBmcm9tIHRoZSBtYXN0ZXIga2V5LlxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuMVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVyaXZlS2V5cyhtYXRlcmlhbDogQ3J5cHRvS2V5LCBzYWx0OiBzdHJpbmcpIHtcbiAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUtleSNIS0RGXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ia2RmUGFyYW1zXG4gIGNvbnN0IGVuY3J5cHRpb25LZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcbiAgICBhbGdvcml0aG1PcHRpb25zLFxuICAgIG1hdGVyaWFsLFxuICAgIHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgbGVuZ3RoOiAxMjgsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddLFxuICApO1xuXG4gIHJldHVybiB7IG1hdGVyaWFsLCBlbmNyeXB0aW9uS2V5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFMkVFS2V5KCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbn1cblxuLyoqXG4gKiBSYXRjaGV0cyBhIGtleS4gU2VlXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjUuMVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmF0Y2hldChtYXRlcmlhbDogQ3J5cHRvS2V5LCBzYWx0OiBzdHJpbmcpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVCaXRzXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIDI1Nik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZWVkc1Jic3BVbmVzY2FwaW5nKGZyYW1lRGF0YTogVWludDhBcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lRGF0YS5sZW5ndGggLSAzOyBpKyspIHtcbiAgICBpZiAoZnJhbWVEYXRhW2ldID09IDAgJiYgZnJhbWVEYXRhW2kgKyAxXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMl0gPT0gMykgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSYnNwKHN0cmVhbTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBkYXRhT3V0OiBudW1iZXJbXSA9IFtdO1xuICB2YXIgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0ubGVuZ3RoOyApIHtcbiAgICAvLyBCZSBjYXJlZnVsIGFib3V0IG92ZXIvdW5kZXJmbG93IGhlcmUuIGJ5dGVfbGVuZ3RoXyAtIDMgY2FuIHVuZGVyZmxvdywgYW5kXG4gICAgLy8gaSArIDMgY2FuIG92ZXJmbG93LCBidXQgYnl0ZV9sZW5ndGhfIC0gaSBjYW4ndCwgYmVjYXVzZSBpIDwgYnl0ZV9sZW5ndGhfXG4gICAgLy8gYWJvdmUsIGFuZCB0aGF0IGV4cHJlc3Npb24gd2lsbCBwcm9kdWNlIHRoZSBudW1iZXIgb2YgYnl0ZXMgbGVmdCBpblxuICAgIC8vIHRoZSBzdHJlYW0gaW5jbHVkaW5nIHRoZSBieXRlIGF0IGkuXG4gICAgaWYgKGxlbmd0aCAtIGkgPj0gMyAmJiAhc3RyZWFtW2ldICYmICFzdHJlYW1baSArIDFdICYmIHN0cmVhbVtpICsgMl0gPT0gMykge1xuICAgICAgLy8gVHdvIHJic3AgYnl0ZXMuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICAgIC8vIFNraXAgdGhlIGVtdWxhdGlvbiBieXRlLlxuICAgICAgaSsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW5nbGUgcmJzcCBieXRlLlxuICAgICAgZGF0YU91dC5wdXNoKHN0cmVhbVtpKytdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuXG5jb25zdCBrWmVyb3NJblN0YXJ0U2VxdWVuY2UgPSAyO1xuY29uc3Qga0VtdWxhdGlvbkJ5dGUgPSAzO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVSYnNwKGRhdGFfaW46IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgZGF0YU91dDogbnVtYmVyW10gPSBbXTtcbiAgdmFyIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFfaW4ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnl0ZSA9IGRhdGFfaW5baV07XG4gICAgaWYgKGJ5dGUgPD0ga0VtdWxhdGlvbkJ5dGUgJiYgbnVtQ29uc2VjdXRpdmVaZXJvcyA+PSBrWmVyb3NJblN0YXJ0U2VxdWVuY2UpIHtcbiAgICAgIC8vIE5lZWQgdG8gZXNjYXBlLlxuICAgICAgZGF0YU91dC5wdXNoKGtFbXVsYXRpb25CeXRlKTtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgICBkYXRhT3V0LnB1c2goYnl0ZSk7XG4gICAgaWYgKGJ5dGUgPT0gMCkge1xuICAgICAgKytudW1Db25zZWN1dGl2ZVplcm9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1Db25zZWN1dGl2ZVplcm9zID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGFPdXQpO1xufVxuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgS0VZX1BST1ZJREVSX0RFRkFVTFRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgdHlwZSBLZXlQcm92aWRlckNhbGxiYWNrcywgS2V5UHJvdmlkZXJFdmVudCB9IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgS2V5SW5mbywgS2V5UHJvdmlkZXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIsIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VLZXlQcm92aWRlciBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRXZlbnRFbWl0dGVyPEtleVByb3ZpZGVyQ2FsbGJhY2tzPikge1xuICBwcml2YXRlIGtleUluZm9NYXA6IE1hcDxzdHJpbmcsIEtleUluZm8+O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogS2V5UHJvdmlkZXJPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8S2V5UHJvdmlkZXJPcHRpb25zPiA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleUluZm9NYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5LRVlfUFJPVklERVJfREVGQVVMVFMsIC4uLm9wdGlvbnMgfTtcbiAgICB0aGlzLm9uKEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCB0aGlzLm9uS2V5UmF0Y2hldGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxsYmFjayB0byBpbnZva2Ugb25jZSBhIGtleSBoYXMgYmVlbiBzZXQgZm9yIGEgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gcGFydGljaXBhbnRJZGVudGl0eVxuICAgKiBAcGFyYW0ga2V5SW5kZXhcbiAgICovXG4gIHByb3RlY3RlZCBvblNldEVuY3J5cHRpb25LZXkoa2V5OiBDcnlwdG9LZXksIHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmcsIGtleUluZGV4PzogbnVtYmVyKSB7XG4gICAgY29uc3Qga2V5SW5mbzogS2V5SW5mbyA9IHsga2V5LCBwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlJbmRleCB9O1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNoYXJlZEtleSAmJiAhcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAncGFydGljaXBhbnQgaWRlbnRpdHkgbmVlZHMgdG8gYmUgcGFzc2VkIGZvciBlbmNyeXB0aW9uIGtleSBpZiBzaGFyZWRLZXkgb3B0aW9uIGlzIGZhbHNlJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMua2V5SW5mb01hcC5zZXQoYCR7cGFydGljaXBhbnRJZGVudGl0eSA/PyAnc2hhcmVkJ30tJHtrZXlJbmRleCA/PyAwfWAsIGtleUluZm8pO1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogY2FsbGJhY2sgYmVpbmcgaW52b2tlZCBhZnRlciBhIHJhdGNoZXQgcmVxdWVzdCBoYXMgYmVlbiBwZXJmb3JtZWQgb24gYSBwYXJ0aWNpcGFudFxuICAgKiB0aGF0IHN1cmZhY2VzIHRoZSBuZXcga2V5IG1hdGVyaWFsLlxuICAgKiBAcGFyYW0gbWF0ZXJpYWxcbiAgICogQHBhcmFtIGtleUluZGV4XG4gICAqL1xuICBwcm90ZWN0ZWQgb25LZXlSYXRjaGV0ZWQgPSAobWF0ZXJpYWw6IENyeXB0b0tleSwga2V5SW5kZXg/OiBudW1iZXIpID0+IHtcbiAgICBsb2cuZGVidWcoJ2tleSByYXRjaGV0ZWQgZXZlbnQgcmVjZWl2ZWQnLCB7IG1hdGVyaWFsLCBrZXlJbmRleCB9KTtcbiAgfTtcblxuICBnZXRLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5SW5mb01hcC52YWx1ZXMoKSk7XG4gIH1cblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cblxuICByYXRjaGV0S2V5KHBhcnRpY2lwYW50SWRlbnRpdHk/OiBzdHJpbmcsIGtleUluZGV4PzogbnVtYmVyKSB7XG4gICAgdGhpcy5lbWl0KEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYmFzaWMgS2V5UHJvdmlkZXIgaW1wbGVtZW50YXRpb24gaW50ZW5kZWQgZm9yIGEgc2luZ2xlIHNoYXJlZFxuICogcGFzc3BocmFzZSBiZXR3ZWVuIGFsbCBwYXJ0aWNpcGFudHNcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyIGV4dGVuZHMgQmFzZUtleVByb3ZpZGVyIHtcbiAgcmF0Y2hldEludGVydmFsOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUGFydGlhbDxPbWl0PEtleVByb3ZpZGVyT3B0aW9ucywgJ3NoYXJlZEtleSc+PiA9IHt9KSB7XG4gICAgY29uc3Qgb3B0czogUGFydGlhbDxLZXlQcm92aWRlck9wdGlvbnM+ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHNoYXJlZEtleTogdHJ1ZSxcbiAgICAgIC8vIGZvciBhIHNoYXJlZCBrZXkgcHJvdmlkZXIgZmFpbGluZyB0byBkZWNyeXB0IGZvciBhIHNwZWNpZmljIHBhcnRpY2lwYW50XG4gICAgICAvLyBzaG91bGQgbm90IG1hcmsgdGhlIGtleSBhcyBpbnZhbGlkLCBzbyB3ZSBhY2NlcHQgd3Jvbmcga2V5cyBmb3JldmVyXG4gICAgICAvLyBhbmQgd29uJ3QgdHJ5IHRvIGF1dG8tcmF0Y2hldFxuICAgICAgcmF0Y2hldFdpbmRvd1NpemU6IDAsXG4gICAgICBmYWlsdXJlVG9sZXJhbmNlOiAtMSxcbiAgICB9O1xuICAgIHN1cGVyKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBwYXNzcGhyYXNlIHRoYXQncyB1c2VkIHRvIGNyZWF0ZSB0aGUgY3J5cHRvIGtleXMuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhIHN0cmluZywgUEJLREYyIGlzIHVzZWQuXG4gICAqIFdoZW4gcGFzc2luZyBpbiBhbiBBcnJheSBidWZmZXIgb2YgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tIG51bWJlcnMsIEhLREYgaXMgYmVpbmcgdXNlZC4gKHJlY29tbWVuZGVkKVxuICAgKiBAcGFyYW0ga2V5XG4gICAqL1xuICBhc3luYyBzZXRLZXkoa2V5OiBzdHJpbmcgfCBBcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPVxuICAgICAgdHlwZW9mIGtleSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhd2FpdCBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcoa2V5KVxuICAgICAgICA6IGF3YWl0IGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihrZXkpO1xuICAgIHRoaXMub25TZXRFbmNyeXB0aW9uS2V5KGRlcml2ZWRLZXkpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXNjb25uZWN0UmVhc29uLCBSZXF1ZXN0UmVzcG9uc2VfUmVhc29uIH0gZnJvbSAnQGxpdmVraXQvcHJvdG9jb2wnO1xuXG5leHBvcnQgY2xhc3MgTGl2ZWtpdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoY29kZTogbnVtYmVyLCBtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSB8fCAnYW4gZXJyb3IgaGFzIG9jY3VyZWQnKTtcbiAgICB0aGlzLm5hbWUgPSAnTGl2ZUtpdEVycm9yJztcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5cbmV4cG9ydCBlbnVtIENvbm5lY3Rpb25FcnJvclJlYXNvbiB7XG4gIE5vdEFsbG93ZWQsXG4gIFNlcnZlclVucmVhY2hhYmxlLFxuICBJbnRlcm5hbEVycm9yLFxuICBDYW5jZWxsZWQsXG4gIExlYXZlUmVxdWVzdCxcbn1cblxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIHN0YXR1cz86IG51bWJlcjtcblxuICBjb250ZXh0PzogdW5rbm93biB8IERpc2Nvbm5lY3RSZWFzb247XG5cbiAgcmVhc29uOiBDb25uZWN0aW9uRXJyb3JSZWFzb247XG5cbiAgcmVhc29uTmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICByZWFzb246IENvbm5lY3Rpb25FcnJvclJlYXNvbixcbiAgICBzdGF0dXM/OiBudW1iZXIsXG4gICAgY29udGV4dD86IHVua25vd24gfCBEaXNjb25uZWN0UmVhc29uLFxuICApIHtcbiAgICBzdXBlcigxLCBtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnQ29ubmVjdGlvbkVycm9yJztcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMucmVhc29uTmFtZSA9IENvbm5lY3Rpb25FcnJvclJlYXNvbltyZWFzb25dO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDIxLCBtZXNzYWdlID8/ICdkZXZpY2UgaXMgdW5zdXBwb3J0ZWQnKTtcbiAgICB0aGlzLm5hbWUgPSAnRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyYWNrSW52YWxpZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDIwLCBtZXNzYWdlID8/ICd0cmFjayBpcyBpbnZhbGlkJyk7XG4gICAgdGhpcy5uYW1lID0gJ1RyYWNrSW52YWxpZEVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVW5zdXBwb3J0ZWRTZXJ2ZXIgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMTAsIG1lc3NhZ2UgPz8gJ3Vuc3VwcG9ydGVkIHNlcnZlcicpO1xuICAgIHRoaXMubmFtZSA9ICdVbnN1cHBvcnRlZFNlcnZlcic7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMTIsIG1lc3NhZ2UgPz8gJ3VuZXhwZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZScpO1xuICAgIHRoaXMubmFtZSA9ICdVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmVnb3RpYXRpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSA/PyAndW5hYmxlIHRvIG5lZ290aWF0ZScpO1xuICAgIHRoaXMubmFtZSA9ICdOZWdvdGlhdGlvbkVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxNCwgbWVzc2FnZSA/PyAndW5hYmxlIHRvIHB1Ymxpc2ggZGF0YScpO1xuICAgIHRoaXMubmFtZSA9ICdQdWJsaXNoRGF0YUVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHVibGlzaFRyYWNrRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBzdGF0dXM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyKSB7XG4gICAgc3VwZXIoMTUsIG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdQdWJsaXNoVHJhY2tFcnJvcic7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdEVycm9yUmVhc29uID1cbiAgfCBFeGNsdWRlPFJlcXVlc3RSZXNwb25zZV9SZWFzb24sIFJlcXVlc3RSZXNwb25zZV9SZWFzb24uT0s+XG4gIHwgJ1RpbWVvdXRFcnJvcic7XG5cbmV4cG9ydCBjbGFzcyBTaWduYWxSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICByZWFzb246IFJlcXVlc3RFcnJvclJlYXNvbjtcblxuICByZWFzb25OYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCByZWFzb246IFJlcXVlc3RFcnJvclJlYXNvbikge1xuICAgIHN1cGVyKDE1LCBtZXNzYWdlKTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLnJlYXNvbk5hbWUgPSB0eXBlb2YgcmVhc29uID09PSAnc3RyaW5nJyA/IHJlYXNvbiA6IFJlcXVlc3RSZXNwb25zZV9SZWFzb25bcmVhc29uXTtcbiAgfVxufVxuXG5leHBvcnQgZW51bSBNZWRpYURldmljZUZhaWx1cmUge1xuICAvLyB1c2VyIHJlamVjdGVkIHBlcm1pc3Npb25zXG4gIFBlcm1pc3Npb25EZW5pZWQgPSAnUGVybWlzc2lvbkRlbmllZCcsXG4gIC8vIGRldmljZSBpcyBub3QgYXZhaWxhYmxlXG4gIE5vdEZvdW5kID0gJ05vdEZvdW5kJyxcbiAgLy8gZGV2aWNlIGlzIGluIHVzZS4gT24gV2luZG93cywgb25seSBhIHNpbmdsZSB0YWIgbWF5IGdldCBhY2Nlc3MgdG8gYSBkZXZpY2UgYXQgYSB0aW1lLlxuICBEZXZpY2VJblVzZSA9ICdEZXZpY2VJblVzZScsXG4gIE90aGVyID0gJ090aGVyJyxcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNZWRpYURldmljZUZhaWx1cmUge1xuICBleHBvcnQgZnVuY3Rpb24gZ2V0RmFpbHVyZShlcnJvcjogYW55KTogTWVkaWFEZXZpY2VGYWlsdXJlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoZXJyb3IgJiYgJ25hbWUnIGluIGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdEZXZpY2VzTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5Ob3RGb3VuZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnUGVybWlzc2lvbkRlbmllZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLlBlcm1pc3Npb25EZW5pZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdFJlYWRhYmxlRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdUcmFja1N0YXJ0RXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuRGV2aWNlSW5Vc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk90aGVyO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgTGl2ZWtpdEVycm9yIH0gZnJvbSAnLi4vcm9vbS9lcnJvcnMnO1xuXG5leHBvcnQgZW51bSBDcnlwdG9yRXJyb3JSZWFzb24ge1xuICBJbnZhbGlkS2V5ID0gMCxcbiAgTWlzc2luZ0tleSA9IDEsXG4gIEludGVybmFsRXJyb3IgPSAyLFxufVxuXG5leHBvcnQgY2xhc3MgQ3J5cHRvckVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgcmVhc29uOiBDcnlwdG9yRXJyb3JSZWFzb247XG5cbiAgcGFydGljaXBhbnRJZGVudGl0eT86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlPzogc3RyaW5nLFxuICAgIHJlYXNvbjogQ3J5cHRvckVycm9yUmVhc29uID0gQ3J5cHRvckVycm9yUmVhc29uLkludGVybmFsRXJyb3IsXG4gICAgcGFydGljaXBhbnRJZGVudGl0eT86IHN0cmluZyxcbiAgKSB7XG4gICAgc3VwZXIoNDAsIG1lc3NhZ2UpO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XG4gIH1cbn1cbiIsIi8qKlxuICogRXZlbnRzIGFyZSB0aGUgcHJpbWFyeSB3YXkgTGl2ZUtpdCBub3RpZmllcyB5b3VyIGFwcGxpY2F0aW9uIG9mIGNoYW5nZXMuXG4gKlxuICogVGhlIGZvbGxvd2luZyBhcmUgZXZlbnRzIGVtaXR0ZWQgYnkgW1tSb29tXV0sIGxpc3RlbiB0byByb29tIGV2ZW50cyBsaWtlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogcm9vbS5vbihSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsICh0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KSA9PiB7fSlcbiAqIGBgYFxuICovXG5cbmV4cG9ydCBlbnVtIFJvb21FdmVudCB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gZXN0YWJsaXNoZWRcbiAgICovXG4gIENvbm5lY3RlZCA9ICdjb25uZWN0ZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGJlZW4gaW50ZXJydXB0ZWQgYW5kIGl0J3MgYXR0ZW1wdGluZ1xuICAgKiB0byByZWNvbm5lY3QuXG4gICAqL1xuICBSZWNvbm5lY3RpbmcgPSAncmVjb25uZWN0aW5nJyxcblxuICAvKipcbiAgICogV2hlbiB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBpbnRlcnJ1cHRlZC4gVGhpcyBpc24ndCBub3RpY2VhYmxlIHRvIHVzZXJzIG1vc3Qgb2YgdGhlIHRpbWUuXG4gICAqIEl0IHdpbGwgcmVzb2x2ZSB3aXRoIGEgYFJvb21FdmVudC5SZWNvbm5lY3RlZGAgb25jZSB0aGUgc2lnbmFsIGNvbm5lY3Rpb24gaGFzIGJlZW4gcmUtZXN0YWJsaXNoZWQuXG4gICAqIElmIG1lZGlhIGZhaWxzIGFkZGl0aW9uYWxseSBpdCBhbiBhZGRpdGlvbmFsIGBSb29tRXZlbnQuUmVjb25uZWN0aW5nYCB3aWxsIGJlIGVtaXR0ZWQuXG4gICAqL1xuICBTaWduYWxSZWNvbm5lY3RpbmcgPSAnc2lnbmFsUmVjb25uZWN0aW5nJyxcblxuICAvKipcbiAgICogRmlyZXMgd2hlbiBhIHJlY29ubmVjdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsLlxuICAgKi9cbiAgUmVjb25uZWN0ZWQgPSAncmVjb25uZWN0ZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIGRpc2Nvbm5lY3RlZCBmcm9tIHJvb20uIFRoaXMgZmlyZXMgd2hlbiByb29tLmRpc2Nvbm5lY3QoKSBpcyBjYWxsZWQgb3JcbiAgICogd2hlbiBhbiB1bnJlY292ZXJhYmxlIGNvbm5lY3Rpb24gaXNzdWUgaGFkIG9jY3VyZWQuXG4gICAqXG4gICAqIERpc2Nvbm5lY3RSZWFzb24gY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoeSB0aGUgcGFydGljaXBhbnQgd2FzIGRpc2Nvbm5lY3RlZC4gTm90YWJsZSByZWFzb25zIGFyZVxuICAgKiAtIERVUExJQ0FURV9JREVOVElUWTogYW5vdGhlciBjbGllbnQgd2l0aCB0aGUgc2FtZSBpZGVudGl0eSBoYXMgam9pbmVkIHRoZSByb29tXG4gICAqIC0gUEFSVElDSVBBTlRfUkVNT1ZFRDogcGFydGljaXBhbnQgd2FzIHJlbW92ZWQgYnkgUmVtb3ZlUGFydGljaXBhbnQgQVBJXG4gICAqIC0gUk9PTV9ERUxFVEVEOiB0aGUgcm9vbSBoYXMgZW5kZWQgdmlhIERlbGV0ZVJvb20gQVBJXG4gICAqXG4gICAqIGFyZ3M6IChbW0Rpc2Nvbm5lY3RSZWFzb25dXSlcbiAgICovXG4gIERpc2Nvbm5lY3RlZCA9ICdkaXNjb25uZWN0ZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuZXZlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSBvZiB0aGUgcm9vbSBjaGFuZ2VzXG4gICAqXG4gICAqIGFyZ3M6IChbW0Nvbm5lY3Rpb25TdGF0ZV1dKVxuICAgKi9cbiAgQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCA9ICdjb25uZWN0aW9uU3RhdGVDaGFuZ2VkJyxcblxuICAvKipcbiAgICogV2hlbiBpbnB1dCBvciBvdXRwdXQgZGV2aWNlcyBvbiB0aGUgbWFjaGluZSBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICBNZWRpYURldmljZXNDaGFuZ2VkID0gJ21lZGlhRGV2aWNlc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGpvaW5zICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50LiBJdCB3aWxsIG5vdCBlbWl0IGV2ZW50cyBmb3IgcGFydGljaXBhbnRzIHRoYXQgYXJlIGFscmVhZHlcbiAgICogaW4gdGhlIHJvb21cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50Q29ubmVjdGVkID0gJ3BhcnRpY2lwYW50Q29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiBhIFtbUmVtb3RlUGFydGljaXBhbnRdXSBsZWF2ZXMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RGlzY29ubmVjdGVkID0gJ3BhcnRpY2lwYW50RGlzY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2hlbiBhIG5ldyB0cmFjayBpcyBwdWJsaXNoZWQgdG8gcm9vbSAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLiBJdCB3aWxsIG5vdCBmaXJlIGZvciB0cmFja3MgdGhhdCBhcmUgYWxyZWFkeSBwdWJsaXNoZWQuXG4gICAqXG4gICAqIEEgdHJhY2sgcHVibGlzaGVkIGRvZXNuJ3QgbWVhbiB0aGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gaXQuIEl0J3NcbiAgICogc2ltcGx5IHJlZmxlY3RpbmcgdGhlIHN0YXRlIG9mIHRoZSByb29tLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrUHVibGlzaGVkID0gJ3RyYWNrUHVibGlzaGVkJyxcblxuICAvKipcbiAgICogVGhlIFtbTG9jYWxQYXJ0aWNpcGFudF1dIGhhcyBzdWJzY3JpYmVkIHRvIGEgbmV3IHRyYWNrLiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKlxuICAgKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaWJlZCA9ICd0cmFja1N1YnNjcmliZWQnLFxuXG4gIC8qKlxuICAgKiBDb3VsZCBub3Qgc3Vic2NyaWJlIHRvIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKHRyYWNrIHNpZCwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQgPSAndHJhY2tTdWJzY3JpcHRpb25GYWlsZWQnLFxuXG4gIC8qKlxuICAgKiBBIFtbUmVtb3RlUGFydGljaXBhbnRdXSBoYXMgdW5wdWJsaXNoZWQgYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrVW5wdWJsaXNoZWQgPSAndHJhY2tVbnB1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrVW5zdWJzY3JpYmVkID0gJ3RyYWNrVW5zdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyBtdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrTXV0ZWQgPSAndHJhY2tNdXRlZCcsXG5cbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgdW5tdXRlZCwgZmlyZXMgb24gYm90aCBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIGFuZCBbW0xvY2FsUGFydGljaXBhbnRdXVxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja1B1YmxpY2F0aW9uXV0sIFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrVW5tdXRlZCA9ICd0cmFja1VubXV0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgTG9jYWxUcmFja1B1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrUHVibGlzaGVkJyxcblxuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dLCBbW0xvY2FsUGFydGljaXBhbnRdXSlcbiAgICovXG4gIExvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrVW5wdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIGEgbG9jYWwgYXVkaW8gdHJhY2sgaXMgcHVibGlzaGVkIHRoZSBTREsgY2hlY2tzIHdoZXRoZXIgdGhlcmUgaXMgY29tcGxldGUgc2lsZW5jZVxuICAgKiBvbiB0aGF0IHRyYWNrIGFuZCBlbWl0cyB0aGUgTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCBldmVudCBpbiB0aGF0IGNhc2UuXG4gICAqIFRoaXMgYWxsb3dzIGZvciBhcHBsaWNhdGlvbnMgdG8gc2hvdyBVSSBpbmZvcm1pbmcgdXNlcnMgdGhhdCB0aGV5IG1pZ2h0IGhhdmUgdG9cbiAgICogcmVzZXQgdGhlaXIgYXVkaW8gaGFyZHdhcmUgb3IgY2hlY2sgZm9yIHByb3BlciBkZXZpY2UgY29ubmVjdGl2aXR5LlxuICAgKi9cbiAgTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCA9ICdsb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkJyxcblxuICAvKipcbiAgICogQWN0aXZlIHNwZWFrZXJzIGNoYW5nZWQuIExpc3Qgb2Ygc3BlYWtlcnMgYXJlIG9yZGVyZWQgYnkgdGhlaXIgYXVkaW8gbGV2ZWwuXG4gICAqIGxvdWRlc3Qgc3BlYWtlcnMgZmlyc3QuIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBMb2NhbFBhcnRpY2lwYW50IHRvby5cbiAgICpcbiAgICogU3BlYWtlciB1cGRhdGVzIGFyZSBzZW50IG9ubHkgdG8gdGhlIHB1Ymxpc2hpbmcgcGFydGljaXBhbnQgYW5kIHRoZWlyIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBhcmdzOiAoQXJyYXk8W1tQYXJ0aWNpcGFudF1dPilcbiAgICovXG4gIEFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCA9ICdhY3RpdmVTcGVha2Vyc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQgPSAncGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCdzIGRpc3BsYXkgbmFtZSBjaGFuZ2VkXG4gICAqXG4gICAqIGFyZ3M6IChuYW1lOiBzdHJpbmcsIFtbUGFydGljaXBhbnRdXSlcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50TmFtZUNoYW5nZWQgPSAncGFydGljaXBhbnROYW1lQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IGF0dHJpYnV0ZXMgaXMgYW4gYXBwLXNwZWNpZmljIGtleSB2YWx1ZSBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIGEgcGFydGljaXBhbnQncyBhdHRyaWJ1dGVzIGNoYW5nZWQsIHRoaXMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIGNoYW5nZWQgYXR0cmlidXRlcyBhbmQgdGhlIHBhcnRpY2lwYW50XG4gICAqIGFyZ3M6IChjaGFuZ2VkQXR0cmlidXRlczogW1tSZWNvcmQ8c3RyaW5nLCBzdHJpbmddXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWQgPSAncGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFJvb20gbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVSb29tTWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHJvb20ncyBzdGF0ZSxcbiAgICogKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHN0cmluZylcbiAgICovXG4gIFJvb21NZXRhZGF0YUNoYW5nZWQgPSAncm9vbU1ldGFkYXRhQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIERhdGEgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIHBhcnRpY2lwYW50LlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dLCB0b3BpYz86IHN0cmluZylcbiAgICovXG4gIERhdGFSZWNlaXZlZCA9ICdkYXRhUmVjZWl2ZWQnLFxuXG4gIC8qKlxuICAgKiBTSVAgRFRNRiB0b25lcyByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dLCBkdG1mOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgU2lwRFRNRlJlY2VpdmVkID0gJ3NpcERUTUZSZWNlaXZlZCcsXG5cbiAgLyoqXG4gICAqIFRyYW5zY3JpcHRpb24gcmVjZWl2ZWQgZnJvbSBhIHBhcnRpY2lwYW50J3MgdHJhY2suXG4gICAqIEBiZXRhXG4gICAqL1xuICBUcmFuc2NyaXB0aW9uUmVjZWl2ZWQgPSAndHJhbnNjcmlwdGlvblJlY2VpdmVkJyxcblxuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQgPSAnY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkJyxcblxuICAvKipcbiAgICogU3RyZWFtU3RhdGUgaW5kaWNhdGVzIGlmIGEgc3Vic2NyaWJlZCAocmVtb3RlKSB0cmFjayBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIFNGVVxuICAgKiAodHlwaWNhbGx5IHRoaXMgaGFwcGVucyBiZWNhdXNlIG9mIHN1YnNjcmliZXIncyBiYW5kd2lkdGggY29uc3RyYWludHMpXG4gICAqXG4gICAqIFdoZW4gYmFuZHdpZHRoIGNvbmRpdGlvbnMgYWxsb3csIHRoZSB0cmFjayB3aWxsIGJlIHJlc3VtZWQgYXV0b21hdGljYWxseS5cbiAgICogVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQgd2lsbCBhbHNvIGJlIGVtaXR0ZWQgd2hlbiB0aGF0IGhhcHBlbnMuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLCBzdHJlYW1TdGF0ZTogW1tUcmFjay5TdHJlYW1TdGF0ZV1dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkID0gJ3RyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkJyxcblxuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LiBJZiBwZXJtaXNzaW9uIHdhcyByZXZva2VkLCB0aGVuIHRoZSB0cmFjayB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAqIGJlIGVtaXR0ZWQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1c11dLFxuICAgKiAgICAgICAgcGFydGljaXBhbnQ6IFtbUmVtb3RlUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQgPSAndHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHN0YXR1cyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkID0gJ3RyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIExpdmVLaXQgd2lsbCBhdHRlbXB0IHRvIGF1dG9wbGF5IGFsbCBhdWRpbyB0cmFja3Mgd2hlbiB5b3UgYXR0YWNoIHRoZW0gdG9cbiAgICogYXVkaW8gZWxlbWVudHMuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIEF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBgUm9vbS5jYW5QbGF5YmFja0F1ZGlvYCB3aWxsIGluZGljYXRlIGlmIGF1ZGlvIHBsYXliYWNrIGlzIHBlcm1pdHRlZC5cbiAgICovXG4gIEF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkID0gJ2F1ZGlvUGxheWJhY2tDaGFuZ2VkJyxcblxuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIHZpZGVvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhIHZpZGVvIGVsZW1lbnQuIEhvd2V2ZXIsIGlmIHRoYXQgZmFpbHMsIHdlJ2xsIG5vdGlmeSB5b3UgdmlhIFZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLlxuICAgKiBDYWxsaW5nIGByb29tLnN0YXJ0VmlkZW8oKWAgaW4gYSB1c2VyIGdlc3R1cmUgZXZlbnQgaGFuZGxlciB3aWxsIHJlc3VtZSB0aGUgdmlkZW8gcGxheWJhY2suXG4gICAqL1xuICBWaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCA9ICd2aWRlb1BsYXliYWNrQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFdoZW4gd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHRyYWNrLlxuICAgKiBUaGUgZXJyb3JzIHRha2UgcGxhY2UgaW4gZ2V0VXNlck1lZGlhKCkuXG4gICAqIFVzZSBNZWRpYURldmljZUZhaWx1cmUuZ2V0RmFpbHVyZShlcnJvcikgdG8gZ2V0IHRoZSByZWFzb24gb2YgZmFpbHVyZS5cbiAgICogW1tMb2NhbFBhcnRpY2lwYW50Lmxhc3RDYW1lcmFFcnJvcl1dIGFuZCBbW0xvY2FsUGFydGljaXBhbnQubGFzdE1pY3JvcGhvbmVFcnJvcl1dXG4gICAqIHdpbGwgaW5kaWNhdGUgaWYgaXQgaGFkIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBhdWRpbyBvciB2aWRlbyB0cmFjayByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIGFyZ3M6IChlcnJvcjogRXJyb3IpXG4gICAqL1xuICBNZWRpYURldmljZXNFcnJvciA9ICdtZWRpYURldmljZXNFcnJvcicsXG5cbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQgPSAncGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBTaWduYWwgY29ubmVjdGVkLCBjYW4gcHVibGlzaCB0cmFja3MuXG4gICAqL1xuICBTaWduYWxDb25uZWN0ZWQgPSAnc2lnbmFsQ29ubmVjdGVkJyxcblxuICAvKipcbiAgICogUmVjb3JkaW5nIG9mIGEgcm9vbSBoYXMgc3RhcnRlZC9zdG9wcGVkLiBSb29tLmlzUmVjb3JkaW5nIHdpbGwgYmUgdXBkYXRlZCB0b28uXG4gICAqIGFyZ3M6IChpc1JlY29yZGluZzogYm9vbGVhbilcbiAgICovXG4gIFJlY29yZGluZ1N0YXR1c0NoYW5nZWQgPSAncmVjb3JkaW5nU3RhdHVzQ2hhbmdlZCcsXG5cbiAgUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCA9ICdwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkJyxcblxuICBFbmNyeXB0aW9uRXJyb3IgPSAnZW5jcnlwdGlvbkVycm9yJyxcbiAgLyoqXG4gICAqIEVtaXRzIHdoZW5ldmVyIHRoZSBjdXJyZW50IGJ1ZmZlciBzdGF0dXMgb2YgYSBkYXRhIGNoYW5uZWwgY2hhbmdlc1xuICAgKiBhcmdzOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBEQ0J1ZmZlclN0YXR1c0NoYW5nZWQgPSAnZGNCdWZmZXJTdGF0dXNDaGFuZ2VkJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGJ5IGEgY2FsbCB0byByb29tLnN3aXRjaEFjdGl2ZURldmljZVxuICAgKiBhcmdzOiAoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nKVxuICAgKi9cbiAgQWN0aXZlRGV2aWNlQ2hhbmdlZCA9ICdhY3RpdmVEZXZpY2VDaGFuZ2VkJyxcblxuICBDaGF0TWVzc2FnZSA9ICdjaGF0TWVzc2FnZScsXG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIGxvY2FsUGFydGljaXBhbnQncyB0cmFja1xuICAgKi9cbiAgTG9jYWxUcmFja1N1YnNjcmliZWQgPSAnbG9jYWxUcmFja1N1YnNjcmliZWQnLFxuXG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgY29ubmVjdGlvbiBtZXRyaWNzIGZyb20gb3RoZXIgcGFydGljaXBhbnRzXG4gICAqL1xuICBNZXRyaWNzUmVjZWl2ZWQgPSAnbWV0cmljc1JlY2VpdmVkJyxcbn1cblxuZXhwb3J0IGVudW0gUGFydGljaXBhbnRFdmVudCB7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrUHVibGlzaGVkID0gJ3RyYWNrUHVibGlzaGVkJyxcblxuICAvKipcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmliZWQgPSAndHJhY2tTdWJzY3JpYmVkJyxcblxuICAvKipcbiAgICogQ291bGQgbm90IHN1YnNjcmliZSB0byBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6ICh0cmFjayBzaWQpXG4gICAqL1xuICBUcmFja1N1YnNjcmlwdGlvbkZhaWxlZCA9ICd0cmFja1N1YnNjcmlwdGlvbkZhaWxlZCcsXG5cbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrVW5wdWJsaXNoZWQgPSAndHJhY2tVbnB1Ymxpc2hlZCcsXG5cbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBUcmFja1Vuc3Vic2NyaWJlZCA9ICd0cmFja1Vuc3Vic2NyaWJlZCcsXG5cbiAgLyoqXG4gICAqIEEgdHJhY2sgdGhhdCB3YXMgbXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgVHJhY2tNdXRlZCA9ICd0cmFja011dGVkJyxcblxuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFRyYWNrVW5tdXRlZCA9ICd0cmFja1VubXV0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBMb2NhbFRyYWNrUHVibGlzaGVkID0gJ2xvY2FsVHJhY2tQdWJsaXNoZWQnLFxuXG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBMb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAnbG9jYWxUcmFja1VucHVibGlzaGVkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQgbWV0YWRhdGEgaXMgYSBzaW1wbGUgd2F5IGZvciBhcHAtc3BlY2lmaWMgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBSb29tU2VydmljZS5VcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIGlzIGNhbGxlZCB0byBjaGFuZ2UgYSBwYXJ0aWNpcGFudCdzXG4gICAqIHN0YXRlLCAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKiBUbyBhY2Nlc3MgdGhlIGN1cnJlbnQgbWV0YWRhdGEsIHNlZSBbW1BhcnRpY2lwYW50Lm1ldGFkYXRhXV0uXG4gICAqXG4gICAqIGFyZ3M6IChwcmV2TWV0YWRhdGE6IHN0cmluZylcbiAgICpcbiAgICovXG4gIFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkJyxcblxuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gJ3BhcnRpY2lwYW50TmFtZUNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBEYXRhIHJlY2VpdmVkIGZyb20gdGhpcyBwYXJ0aWNpcGFudCBhcyBzZW5kZXIuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBEYXRhUmVjZWl2ZWQgPSAnZGF0YVJlY2VpdmVkJyxcblxuICAvKipcbiAgICogU0lQIERUTUYgdG9uZXMgcmVjZWl2ZWQgZnJvbSB0aGlzIHBhcnRpY2lwYW50IGFzIHNlbmRlci5cbiAgICpcbiAgICogYXJnczogKGR0bWY6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBTaXBEVE1GUmVjZWl2ZWQgPSAnc2lwRFRNRlJlY2VpdmVkJyxcblxuICAvKipcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgZGF0YSBzb3VyY2UuXG4gICAqIEBiZXRhXG4gICAqL1xuICBUcmFuc2NyaXB0aW9uUmVjZWl2ZWQgPSAndHJhbnNjcmlwdGlvblJlY2VpdmVkJyxcblxuICAvKipcbiAgICogSGFzIHNwZWFraW5nIHN0YXR1cyBjaGFuZ2VkIGZvciB0aGUgY3VycmVudCBwYXJ0aWNpcGFudFxuICAgKlxuICAgKiBhcmdzOiAoc3BlYWtpbmc6IGJvb2xlYW4pXG4gICAqL1xuICBJc1NwZWFraW5nQ2hhbmdlZCA9ICdpc1NwZWFraW5nQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIENvbm5lY3Rpb24gcXVhbGl0eSB3YXMgY2hhbmdlZCBmb3IgYSBQYXJ0aWNpcGFudC4gSXQnbGwgcmVjZWl2ZSB1cGRhdGVzXG4gICAqIGZyb20gdGhlIGxvY2FsIHBhcnRpY2lwYW50LCBhcyB3ZWxsIGFzIGFueSBbW1JlbW90ZVBhcnRpY2lwYW50XV1zIHRoYXQgd2UgYXJlXG4gICAqIHN1YnNjcmliZWQgdG8uXG4gICAqXG4gICAqIGFyZ3M6IChjb25uZWN0aW9uUXVhbGl0eTogW1tDb25uZWN0aW9uUXVhbGl0eV1dKVxuICAgKi9cbiAgQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gJ2Nvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSlcbiAgICovXG4gIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkID0gJ3RyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkJyxcblxuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgcGVybWlzc2lvbnMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHBhcnRpY2lwYW50LiBJZiBwZXJtaXNzaW9uIHdhcyByZXZva2VkLCB0aGVuIHRoZSB0cmFjayB3aWxsIG5vIGxvbmdlclxuICAgKiBiZSBzdWJzY3JpYmVkLiBJZiBwZXJtaXNzaW9uIHdhcyBncmFudGVkLCBhIFRyYWNrU3Vic2NyaWJlZCBldmVudCB3aWxsXG4gICAqIGJlIGVtaXR0ZWQuXG4gICAqXG4gICAqIGFyZ3M6IChwdWI6IFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dLFxuICAgKiAgICAgICAgc3RhdHVzOiBbW1RyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzXV0pXG4gICAqL1xuICBUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkID0gJ3RyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQnLFxuXG4gIC8qKlxuICAgKiBPbmUgb2YgdGhlIHJlbW90ZSBwYXJ0aWNpcGFudHMgcHVibGljYXRpb25zIGhhcyBjaGFuZ2VkIGl0cyBzdWJzY3JpcHRpb24gc3RhdHVzLlxuICAgKlxuICAgKi9cbiAgVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkID0gJ3RyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCcsXG5cbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgTWVkaWFEZXZpY2VzRXJyb3IgPSAnbWVkaWFEZXZpY2VzRXJyb3InLFxuXG4gIC8vIGZpcmVkIG9ubHkgb24gTG9jYWxQYXJ0aWNpcGFudFxuICAvKiogQGludGVybmFsICovXG4gIEF1ZGlvU3RyZWFtQWNxdWlyZWQgPSAnYXVkaW9TdHJlYW1BY3F1aXJlZCcsXG5cbiAgLyoqXG4gICAqIEEgcGFydGljaXBhbnQncyBwZXJtaXNzaW9uIGhhcyBjaGFuZ2VkLlxuICAgKiBhcmdzOiAocHJldlBlcm1pc3Npb25zOiBbW1BhcnRpY2lwYW50UGVybWlzc2lvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQgPSAncGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQnLFxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUENUcmFja0FkZGVkID0gJ3BjVHJhY2tBZGRlZCcsXG5cbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IGF0dHJpYnV0ZXMgaXMgYW4gYXBwLXNwZWNpZmljIGtleSB2YWx1ZSBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIGEgcGFydGljaXBhbnQncyBhdHRyaWJ1dGVzIGNoYW5nZWQsIHRoaXMgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIGNoYW5nZWQgYXR0cmlidXRlc1xuICAgKiBhcmdzOiAoY2hhbmdlZEF0dHJpYnV0ZXM6IFtbUmVjb3JkPHN0cmluZywgc3RyaW5nXV0pXG4gICAqL1xuICBBdHRyaWJ1dGVzQ2hhbmdlZCA9ICdhdHRyaWJ1dGVzQ2hhbmdlZCcsXG5cbiAgLyoqXG4gICAqIGZpcmVkIG9uIGxvY2FsIHBhcnRpY2lwYW50IG9ubHksIHdoZW4gdGhlIGZpcnN0IHJlbW90ZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byB0aGUgdHJhY2sgc3BlY2lmaWVkIGluIHRoZSBwYXlsb2FkXG4gICAqL1xuICBMb2NhbFRyYWNrU3Vic2NyaWJlZCA9ICdsb2NhbFRyYWNrU3Vic2NyaWJlZCcsXG5cbiAgLyoqIG9ubHkgZW1pdHRlZCBvbiBsb2NhbCBwYXJ0aWNpcGFudCAqL1xuICBDaGF0TWVzc2FnZSA9ICdjaGF0TWVzc2FnZScsXG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBlbnVtIEVuZ2luZUV2ZW50IHtcbiAgVHJhbnNwb3J0c0NyZWF0ZWQgPSAndHJhbnNwb3J0c0NyZWF0ZWQnLFxuICBDb25uZWN0ZWQgPSAnY29ubmVjdGVkJyxcbiAgRGlzY29ubmVjdGVkID0gJ2Rpc2Nvbm5lY3RlZCcsXG4gIFJlc3VtaW5nID0gJ3Jlc3VtaW5nJyxcbiAgUmVzdW1lZCA9ICdyZXN1bWVkJyxcbiAgUmVzdGFydGluZyA9ICdyZXN0YXJ0aW5nJyxcbiAgUmVzdGFydGVkID0gJ3Jlc3RhcnRlZCcsXG4gIFNpZ25hbFJlc3VtZWQgPSAnc2lnbmFsUmVzdW1lZCcsXG4gIFNpZ25hbFJlc3RhcnRlZCA9ICdzaWduYWxSZXN0YXJ0ZWQnLFxuICBDbG9zaW5nID0gJ2Nsb3NpbmcnLFxuICBNZWRpYVRyYWNrQWRkZWQgPSAnbWVkaWFUcmFja0FkZGVkJyxcbiAgQWN0aXZlU3BlYWtlcnNVcGRhdGUgPSAnYWN0aXZlU3BlYWtlcnNVcGRhdGUnLFxuICBEYXRhUGFja2V0UmVjZWl2ZWQgPSAnZGF0YVBhY2tldFJlY2VpdmVkJyxcbiAgUlRQVmlkZW9NYXBVcGRhdGUgPSAncnRwVmlkZW9NYXBVcGRhdGUnLFxuICBEQ0J1ZmZlclN0YXR1c0NoYW5nZWQgPSAnZGNCdWZmZXJTdGF0dXNDaGFuZ2VkJyxcbiAgUGFydGljaXBhbnRVcGRhdGUgPSAncGFydGljaXBhbnRVcGRhdGUnLFxuICBSb29tVXBkYXRlID0gJ3Jvb21VcGRhdGUnLFxuICBTcGVha2Vyc0NoYW5nZWQgPSAnc3BlYWtlcnNDaGFuZ2VkJyxcbiAgU3RyZWFtU3RhdGVDaGFuZ2VkID0gJ3N0cmVhbVN0YXRlQ2hhbmdlZCcsXG4gIENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gJ2Nvbm5lY3Rpb25RdWFsaXR5VXBkYXRlJyxcbiAgU3Vic2NyaXB0aW9uRXJyb3IgPSAnc3Vic2NyaXB0aW9uRXJyb3InLFxuICBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gJ3N1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUnLFxuICBSZW1vdGVNdXRlID0gJ3JlbW90ZU11dGUnLFxuICBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9ICdzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZScsXG4gIExvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICdsb2NhbFRyYWNrVW5wdWJsaXNoZWQnLFxuICBMb2NhbFRyYWNrU3Vic2NyaWJlZCA9ICdsb2NhbFRyYWNrU3Vic2NyaWJlZCcsXG4gIE9mZmxpbmUgPSAnb2ZmbGluZScsXG4gIFNpZ25hbFJlcXVlc3RSZXNwb25zZSA9ICdzaWduYWxSZXF1ZXN0UmVzcG9uc2UnLFxuICBTaWduYWxDb25uZWN0ZWQgPSAnc2lnbmFsQ29ubmVjdGVkJyxcbn1cblxuZXhwb3J0IGVudW0gVHJhY2tFdmVudCB7XG4gIE1lc3NhZ2UgPSAnbWVzc2FnZScsXG4gIE11dGVkID0gJ211dGVkJyxcbiAgVW5tdXRlZCA9ICd1bm11dGVkJyxcbiAgLyoqXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFJlc3RhcnRlZCA9ICdyZXN0YXJ0ZWQnLFxuICBFbmRlZCA9ICdlbmRlZCcsXG4gIFN1YnNjcmliZWQgPSAnc3Vic2NyaWJlZCcsXG4gIFVuc3Vic2NyaWJlZCA9ICd1bnN1YnNjcmliZWQnLFxuICAvKiogQGludGVybmFsICovXG4gIFVwZGF0ZVNldHRpbmdzID0gJ3VwZGF0ZVNldHRpbmdzJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBVcGRhdGVTdWJzY3JpcHRpb24gPSAndXBkYXRlU3Vic2NyaXB0aW9uJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBBdWRpb1BsYXliYWNrU3RhcnRlZCA9ICdhdWRpb1BsYXliYWNrU3RhcnRlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgQXVkaW9QbGF5YmFja0ZhaWxlZCA9ICdhdWRpb1BsYXliYWNrRmFpbGVkJyxcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsQXVkaW9UcmFjayBpbnN0YW5jZXNcbiAgICovXG4gIEF1ZGlvU2lsZW5jZURldGVjdGVkID0gJ2F1ZGlvU2lsZW5jZURldGVjdGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBWaXNpYmlsaXR5Q2hhbmdlZCA9ICd2aXNpYmlsaXR5Q2hhbmdlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCA9ICd2aWRlb0RpbWVuc2lvbnNDaGFuZ2VkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBWaWRlb1BsYXliYWNrU3RhcnRlZCA9ICd2aWRlb1BsYXliYWNrU3RhcnRlZCcsXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVmlkZW9QbGF5YmFja0ZhaWxlZCA9ICd2aWRlb1BsYXliYWNrRmFpbGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBFbGVtZW50QXR0YWNoZWQgPSAnZWxlbWVudEF0dGFjaGVkJyxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBFbGVtZW50RGV0YWNoZWQgPSAnZWxlbWVudERldGFjaGVkJyxcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBVcHN0cmVhbVBhdXNlZCA9ICd1cHN0cmVhbVBhdXNlZCcsXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVXBzdHJlYW1SZXN1bWVkID0gJ3Vwc3RyZWFtUmVzdW1lZCcsXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQgPSAnc3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQnLFxuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCA9ICdzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkJyxcbiAgLyoqXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFN1YnNjcmlwdGlvbkZhaWxlZCA9ICdzdWJzY3JpcHRpb25GYWlsZWQnLFxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBUcmFja1Byb2Nlc3NvclVwZGF0ZSA9ICd0cmFja1Byb2Nlc3NvclVwZGF0ZScsXG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUgPSAnYXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUnLFxuXG4gIC8qKlxuICAgKiBAYmV0YVxuICAgKi9cbiAgVHJhbnNjcmlwdGlvblJlY2VpdmVkID0gJ3RyYW5zY3JpcHRpb25SZWNlaXZlZCcsXG5cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIFRpbWVTeW5jVXBkYXRlID0gJ3RpbWVTeW5jVXBkYXRlJyxcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjbG9uZURlZXA8VD4odmFsdWU6IFQpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgYXMgVDtcbiAgfVxufVxuIiwiLy8gdGlueSwgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9sYW5jZWRpa3Nvbi9ib3dzZXIvYmxvYi9tYXN0ZXIvc3JjL3BhcnNlci1icm93c2Vycy5qc1xuLy8gcmVkdWNlZCB0byBvbmx5IGRpZmZlcmVudGlhdGUgQ2hyb21lKGl1bSkgYmFzZWQgYnJvd3NlcnMgLyBGaXJlZm94IC8gU2FmYXJpXG5cbmNvbnN0IGNvbW1vblZlcnNpb25JZGVudGlmaWVyID0gL3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2k7XG5cbmV4cG9ydCB0eXBlIERldGVjdGFibGVCcm93c2VyID0gJ0Nocm9tZScgfCAnRmlyZWZveCcgfCAnU2FmYXJpJztcbmV4cG9ydCB0eXBlIERldGVjdGFibGVPUyA9ICdpT1MnIHwgJ21hY09TJztcblxuZXhwb3J0IHR5cGUgQnJvd3NlckRldGFpbHMgPSB7XG4gIG5hbWU6IERldGVjdGFibGVCcm93c2VyO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIG9zPzogRGV0ZWN0YWJsZU9TO1xuICBvc1ZlcnNpb24/OiBzdHJpbmc7XG59O1xuXG5sZXQgYnJvd3NlckRldGFpbHM6IEJyb3dzZXJEZXRhaWxzIHwgdW5kZWZpbmVkO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnJvd3Nlcih1c2VyQWdlbnQ/OiBzdHJpbmcsIGZvcmNlID0gdHJ1ZSk6IEJyb3dzZXJEZXRhaWxzIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCA/PyBuYXZpZ2F0b3IudXNlckFnZW50KS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYnJvd3NlckRldGFpbHMgPT09IHVuZGVmaW5lZCB8fCBmb3JjZSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBicm93c2Vyc0xpc3QuZmluZCgoeyB0ZXN0IH0pID0+IHRlc3QudGVzdCh1YSkpO1xuICAgIGJyb3dzZXJEZXRhaWxzID0gYnJvd3Nlcj8uZGVzY3JpYmUodWEpO1xuICB9XG4gIHJldHVybiBicm93c2VyRGV0YWlscztcbn1cblxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW1xuICB7XG4gICAgdGVzdDogL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ksXG4gICAgZGVzY3JpYmUodWE6IHN0cmluZykge1xuICAgICAgY29uc3QgYnJvd3NlcjogQnJvd3NlckRldGFpbHMgPSB7XG4gICAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgICBvczogdWEudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZnhpb3MnKSA/ICdpT1MnIDogdW5kZWZpbmVkLFxuICAgICAgICBvc1ZlcnNpb246IGdldE9TVmVyc2lvbih1YSksXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgfSxcbiAgfSxcbiAge1xuICAgIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXG4gICAgZGVzY3JpYmUodWE6IHN0cmluZykge1xuICAgICAgY29uc3QgYnJvd3NlcjogQnJvd3NlckRldGFpbHMgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWUnLFxuICAgICAgICB2ZXJzaW9uOiBnZXRNYXRjaCgvKD86Y2hyb21lfGNocm9taXVtfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLCB1YSksXG4gICAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjcmlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH0sXG4gIH0sXG4gIC8qIFNhZmFyaSAqL1xuICB7XG4gICAgdGVzdDogL3NhZmFyaXxhcHBsZXdlYmtpdC9pLFxuICAgIGRlc2NyaWJlKHVhOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IGJyb3dzZXI6IEJyb3dzZXJEZXRhaWxzID0ge1xuICAgICAgICBuYW1lOiAnU2FmYXJpJyxcbiAgICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goY29tbW9uVmVyc2lvbklkZW50aWZpZXIsIHVhKSxcbiAgICAgICAgb3M6IHVhLmluY2x1ZGVzKCdtb2JpbGUvJykgPyAnaU9TJyA6ICdtYWNPUycsXG4gICAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBicm93c2VyO1xuICAgIH0sXG4gIH0sXG5dO1xuXG5mdW5jdGlvbiBnZXRNYXRjaChleHA6IFJlZ0V4cCwgdWE6IHN0cmluZywgaWQgPSAxKSB7XG4gIGNvbnN0IG1hdGNoID0gdWEubWF0Y2goZXhwKTtcbiAgcmV0dXJuIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gaWQgJiYgbWF0Y2hbaWRdKSB8fCAnJztcbn1cblxuZnVuY3Rpb24gZ2V0T1NWZXJzaW9uKHVhOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHVhLmluY2x1ZGVzKCdtYWMgb3MnKVxuICAgID8gZ2V0TWF0Y2goL1xcKC4rPyhcXGQrX1xcZCsoOj9fXFxkKyk/KS8sIHVhLCAxKS5yZXBsYWNlKC9fL2csICcuJylcbiAgICA6IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IHZlcnNpb24gYXMgdiB9IGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gdjtcbmV4cG9ydCBjb25zdCBwcm90b2NvbFZlcnNpb24gPSAxNTtcbiIsIi8qKlxuICogVGltZXJzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnNcbiAqIHRoYXQgZW5zdXJlIHRoYXQgdGhleSBhcmUgZmlyZWQuIFRoZXNlIHNob3VsZCBiZSB1c2VkIHdoZW4gaXQgaXMgY3JpdGljYWxcbiAqIHRoYXQgdGhlIHRpbWVyIGZpcmVzIG9uIHRpbWUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyaXRpY2FsVGltZXJzIHtcbiAgc3RhdGljIHNldFRpbWVvdXQ6ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBzZXRUaW1lb3V0PikgPT4gUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gPSAoXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2Ygc2V0VGltZW91dD5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWltcGxpZWQtZXZhbFxuICApID0+IHNldFRpbWVvdXQoLi4uYXJncyk7XG5cbiAgc3RhdGljIHNldEludGVydmFsOiAoLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2Ygc2V0SW50ZXJ2YWw+KSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD4gPVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXG4gICAgKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIHNldEludGVydmFsPikgPT4gc2V0SW50ZXJ2YWwoLi4uYXJncyk7XG5cbiAgc3RhdGljIGNsZWFyVGltZW91dDogKFxuICAgIC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIGNsZWFyVGltZW91dD5cbiAgKSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBjbGVhclRpbWVvdXQ+ID0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIGNsZWFyVGltZW91dD4pID0+XG4gICAgY2xlYXJUaW1lb3V0KC4uLmFyZ3MpO1xuXG4gIHN0YXRpYyBjbGVhckludGVydmFsOiAoXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgY2xlYXJJbnRlcnZhbD5cbiAgKSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBjbGVhckludGVydmFsPiA9ICguLi5hcmdzOiBQYXJhbWV0ZXJzPHR5cGVvZiBjbGVhckludGVydmFsPikgPT5cbiAgICBjbGVhckludGVydmFsKC4uLmFyZ3MpO1xufVxuIiwiaW1wb3J0IHtcbiAgQXVkaW9UcmFja0ZlYXR1cmUsXG4gIFZpZGVvUXVhbGl0eSBhcyBQcm90b1F1YWxpdHksXG4gIFN0cmVhbVN0YXRlIGFzIFByb3RvU3RyZWFtU3RhdGUsXG4gIFRyYWNrU291cmNlLFxuICBUcmFja1R5cGUsXG59IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEV2ZW50RW1pdHRlciBmcm9tICd0eXBlZC1lbWl0dGVyJztcbmltcG9ydCB0eXBlIHsgU2lnbmFsQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCB0eXBlIFN0cnVjdHVyZWRMb2dnZXIsIGdldExvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzRmlyZUZveCwgaXNTYWZhcmksIGlzV2ViIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBUcmFja1Byb2Nlc3NvciB9IGZyb20gJy4vcHJvY2Vzc29yL3R5cGVzJztcbmltcG9ydCB7IGdldExvZ0NvbnRleHRGcm9tVHJhY2sgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSA9IDUwMDA7XG5cbi8vIGtlZXAgb2xkIGF1ZGlvIGVsZW1lbnRzIHdoZW4gZGV0YWNoZWQsIHdlIHdvdWxkIHJlLXVzZSB0aGVtIHNpbmNlIG9uIGlPU1xuLy8gU2FmYXJpIHRyYWNrcyB3aGljaCBhdWRpbyBlbGVtZW50cyBoYXZlIGJlZW4gXCJibGVzc2VkXCIgYnkgdGhlIHVzZXIuXG5jb25zdCByZWN5Y2xlZEVsZW1lbnRzOiBBcnJheTxIVE1MQXVkaW9FbGVtZW50PiA9IFtdO1xuXG5leHBvcnQgZW51bSBWaWRlb1F1YWxpdHkge1xuICBMT1cgPSBQcm90b1F1YWxpdHkuTE9XLFxuICBNRURJVU0gPSBQcm90b1F1YWxpdHkuTUVESVVNLFxuICBISUdIID0gUHJvdG9RdWFsaXR5LkhJR0gsXG59XG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJhY2s8XG4gIFRyYWNrS2luZCBleHRlbmRzIFRyYWNrLktpbmQgPSBUcmFjay5LaW5kLFxuPiBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRXZlbnRFbWl0dGVyPFRyYWNrRXZlbnRDYWxsYmFja3M+KSB7XG4gIHJlYWRvbmx5IGtpbmQ6IFRyYWNrS2luZDtcblxuICBhdHRhY2hlZEVsZW1lbnRzOiBIVE1MTWVkaWFFbGVtZW50W10gPSBbXTtcblxuICBpc011dGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgc291cmNlOiBUcmFjay5Tb3VyY2U7XG5cbiAgLyoqXG4gICAqIHNpZCBpcyBzZXQgYWZ0ZXIgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHNlcnZlciwgb3IgaWYgaXQncyBhIHJlbW90ZSB0cmFja1xuICAgKi9cbiAgc2lkPzogVHJhY2suU0lEO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1lZGlhU3RyZWFtPzogTWVkaWFTdHJlYW07XG5cbiAgLyoqXG4gICAqIGluZGljYXRlcyBjdXJyZW50IHN0YXRlIG9mIHN0cmVhbSwgaXQnbGwgaW5kaWNhdGUgYHBhdXNlZGAgaWYgdGhlIHRyYWNrXG4gICAqIGhhcyBiZWVuIHBhdXNlZCBieSBjb25nZXN0aW9uIGNvbnRyb2xsZXJcbiAgICovXG4gIHN0cmVhbVN0YXRlOiBUcmFjay5TdHJlYW1TdGF0ZSA9IFRyYWNrLlN0cmVhbVN0YXRlLkFjdGl2ZTtcblxuICAvKiogQGludGVybmFsICovXG4gIHJ0cFRpbWVzdGFtcDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIHByb3RlY3RlZCBfbWVkaWFTdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjaztcblxuICBwcm90ZWN0ZWQgX21lZGlhU3RyZWFtSUQ6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgaXNJbkJhY2tncm91bmQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGJhY2tncm91bmRUaW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGxvZ2dlckNvbnRleHRDYjogTG9nZ2VyT3B0aW9uc1snbG9nZ2VyQ29udGV4dENiJ107XG5cbiAgcHJvdGVjdGVkIHRpbWVTeW5jSGFuZGxlOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgcHJvdGVjdGVkIF9jdXJyZW50Qml0cmF0ZTogbnVtYmVyID0gMDtcblxuICBwcm90ZWN0ZWQgbW9uaXRvckludGVydmFsPzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIHByb3RlY3RlZCBsb2c6IFN0cnVjdHVyZWRMb2dnZXIgPSBsb2c7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAga2luZDogVHJhY2tLaW5kLFxuICAgIGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuVHJhY2spO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG5cbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhVHJhY2s7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1JRCA9IG1lZGlhVHJhY2suaWQ7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIGN1cnJlbnQgcmVjZWl2ZSBiaXRzIHBlciBzZWNvbmQgKi9cbiAgZ2V0IGN1cnJlbnRCaXRyYXRlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRCaXRyYXRlO1xuICB9XG5cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2s7XG4gIH1cblxuICBhYnN0cmFjdCBnZXQgaXNMb2NhbCgpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogdXNlZCBmb3Iga2VlcCBtZWRpYVN0cmVhbSdzIGZpcnN0IGlkLCBzaW5jZSBpdCdzIGlkIG1pZ2h0IGNoYW5nZVxuICAgKiBpZiB3ZSBkaXNhYmxlL2VuYWJsZSBhIHRyYWNrXG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1JRCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbUlEO1xuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYSBuZXcgSFRNTEF1ZGlvRWxlbWVudCBvciBIVE1MVmlkZW9FbGVtZW50LCBhdHRhY2hlcyB0byBpdCwgYW5kIHJldHVybnMgaXRcbiAgICovXG4gIGF0dGFjaCgpOiBIVE1MTWVkaWFFbGVtZW50O1xuXG4gIC8qKlxuICAgKiBhdHRhY2hlcyB0cmFjayB0byBhbiBleGlzdGluZyBIVE1MQXVkaW9FbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnRcbiAgICovXG4gIGF0dGFjaChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ/OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudCB7XG4gICAgbGV0IGVsZW1lbnRUeXBlID0gJ2F1ZGlvJztcbiAgICBpZiAodGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICBlbGVtZW50VHlwZSA9ICd2aWRlbyc7XG4gICAgfVxuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwICYmIHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgdGhpcy5hZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudFR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUucGFyZW50RWxlbWVudCA9PT0gbnVsbCAmJiAhZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBwb29sXG4gICAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5zcGxpY2UocmVjeWNsZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQgPSA8SFRNTE1lZGlhRWxlbWVudD5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSkge1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gZXZlbiBpZiB3ZSBiZWxpZXZlIGl0J3MgYWxyZWFkeSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCwgaXQncyBwb3NzaWJsZVxuICAgIC8vIHRoZSBlbGVtZW50J3Mgc3JjT2JqZWN0IHdhcyBzZXQgdG8gc29tZXRoaW5nIGVsc2Ugb3V0IG9mIGJhbmQuXG4gICAgLy8gd2UnbGwgd2FudCB0byByZS1hdHRhY2ggaXQgaW4gdGhhdCBjYXNlXG4gICAgYXR0YWNoVG9FbGVtZW50KHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG5cbiAgICAvLyBoYW5kbGUgYXV0byBwbGF5YmFjayBmYWlsdXJlc1xuICAgIGNvbnN0IGFsbE1lZGlhU3RyZWFtVHJhY2tzID0gKGVsZW1lbnQuc3JjT2JqZWN0IGFzIE1lZGlhU3RyZWFtKS5nZXRUcmFja3MoKTtcbiAgICBjb25zdCBoYXNBdWRpbyA9IGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUoKHRyKSA9PiB0ci5raW5kID09PSAnYXVkaW8nKTtcblxuICAgIC8vIG1hbnVhbGx5IHBsYXkgbWVkaWEgdG8gZGV0ZWN0IGF1dG8gcGxheWJhY2sgc3RhdHVzXG4gICAgZWxlbWVudFxuICAgICAgLnBsYXkoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGhhc0F1ZGlvID8gVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIC8vIGNvbW1vbmx5IHRyaWdnZXJlZCBieSBhbm90aGVyIGBwbGF5YCByZXF1ZXN0LCBvbmx5IGxvZyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgYCR7aGFzQXVkaW8gPyAnYXVkaW8nIDogJ3ZpZGVvJ30gcGxheWJhY2sgYWJvcnRlZCwgbGlrZWx5IGR1ZSB0byBuZXcgcGxheSByZXF1ZXN0YCxcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy53YXJuKGBjb3VsZCBub3QgcGxheWJhY2sgJHtoYXNBdWRpbyA/ICdhdWRpbycgOiAndmlkZW8nfWAsIGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGF1ZGlvIHBsYXliYWNrIGlzbid0IGFsbG93ZWQgbWFrZSBzdXJlIHdlIHN0aWxsIHBsYXkgYmFjayB0aGUgdmlkZW9cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGhhc0F1ZGlvICYmXG4gICAgICAgICAgZWxlbWVudCAmJlxuICAgICAgICAgIGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUoKHRyKSA9PiB0ci5raW5kID09PSAndmlkZW8nKSAmJlxuICAgICAgICAgIGUubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gY2F0Y2ggZm9yIFNhZmFyaSwgZXhjZWVkZWQgb3B0aW9ucyBhdCB0aGlzIHBvaW50IHRvIGF1dG9tYXRpY2FsbHkgcGxheSB0aGUgbWVkaWEgZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnRBdHRhY2hlZCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoZXMgZnJvbSBhbGwgYXR0YWNoZWQgZWxlbWVudHNcbiAgICovXG4gIGRldGFjaCgpOiBIVE1MTWVkaWFFbGVtZW50W107XG5cbiAgLyoqXG4gICAqIERldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcbiAgICogQHBhcmFtIGVsZW1lbnRcbiAgICovXG4gIGRldGFjaChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudDtcbiAgZGV0YWNoKGVsZW1lbnQ/OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudCB8IEhUTUxNZWRpYUVsZW1lbnRbXSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIGEgc2luZ2xlIGVsZW1lbnRcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXRhY2hlZDogSFRNTE1lZGlhRWxlbWVudFtdID0gW107XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWxtKSA9PiB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjaywgZWxtKTtcbiAgICAgICAgZGV0YWNoZWQucHVzaChlbG0pO1xuICAgICAgICB0aGlzLnJlY3ljbGVFbGVtZW50KGVsbSk7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVsZW1lbnREZXRhY2hlZCwgZWxtKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgYWxsIHRyYWNrc1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgICByZXR1cm4gZGV0YWNoZWQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZW5hYmxlKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBhYnN0cmFjdCBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50PzogU2lnbmFsQ2xpZW50KTogdm9pZDtcblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RvcE1vbml0b3IoKSB7XG4gICAgaWYgKHRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvckludGVydmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZVN5bmNIYW5kbGUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudGltZVN5bmNIYW5kbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlTG9nZ2VyT3B0aW9ucyhsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkge1xuICAgICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKTtcbiAgICB9XG4gICAgaWYgKGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiKSB7XG4gICAgICB0aGlzLmxvZ2dlckNvbnRleHRDYiA9IGxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVjeWNsZUVsZW1lbnQoZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIHJlLXVzZSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICBsZXQgc2hvdWxkQ2FjaGUgPSB0cnVlO1xuICAgICAgZWxlbWVudC5wYXVzZSgpO1xuICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGlmICghZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgc2hvdWxkQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmJhY2tncm91bmRUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5iYWNrZ3JvdW5kVGltZW91dCk7XG4gICAgfVxuICAgIC8vIGRlbGF5IGFwcCB2aXNpYmlsaXR5IHVwZGF0ZSBpZiBpdCBnb2VzIHRvIGhpZGRlblxuICAgIC8vIHVwZGF0ZSBpbW1lZGlhdGVseSBpZiBpdCBjb21lcyBiYWNrIHRvIGZvY3VzXG4gICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCksXG4gICAgICAgIEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVksXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCBhc3luYyBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJztcbiAgICBpZiAoIXRoaXMuaXNJbkJhY2tncm91bmQgJiYgdGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PlxuICAgICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbCkgPT5cbiAgICAgICAgICAgIGVsLnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgIC8qKiBjYXRjaCBjbGF1c2UgbmVjZXNzYXJ5IGZvciBTYWZhcmkgKi9cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICksXG4gICAgICAgIDAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF0dGFjaFRvRWxlbWVudCh0cmFjazogTWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCkge1xuICBsZXQgbWVkaWFTdHJlYW06IE1lZGlhU3RyZWFtO1xuICBpZiAoZWxlbWVudC5zcmNPYmplY3QgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSkge1xuICAgIG1lZGlhU3RyZWFtID0gZWxlbWVudC5zcmNPYmplY3Q7XG4gIH0gZWxzZSB7XG4gICAgbWVkaWFTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHRyYWNrIG1hdGNoZXMgZXhpc3RpbmcgdHJhY2tcbiAgbGV0IGV4aXN0aW5nVHJhY2tzOiBNZWRpYVN0cmVhbVRyYWNrW107XG4gIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICB9IGVsc2Uge1xuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgfVxuICBpZiAoIWV4aXN0aW5nVHJhY2tzLmluY2x1ZGVzKHRyYWNrKSkge1xuICAgIGV4aXN0aW5nVHJhY2tzLmZvckVhY2goKGV0KSA9PiB7XG4gICAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayhldCk7XG4gICAgfSk7XG4gICAgbWVkaWFTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICB9XG5cbiAgaWYgKCFpc1NhZmFyaSgpIHx8ICEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgLy8gd2hlbiBpbiBsb3cgcG93ZXIgbW9kZSAoYXBwbGllcyB0byBib3RoIG1hY09TIGFuZCBpT1MpLCBTYWZhcmkgd2lsbCBzaG93IGEgcGxheS9wYXVzZSBvdmVybGF5XG4gICAgLy8gd2hlbiBhIHZpZGVvIHN0YXJ0cyB0aGF0IGhhcyB0aGUgYGF1dG9wbGF5YCBhdHRyaWJ1dGUgaXMgc2V0LlxuICAgIC8vIHdlIHdvcmsgYXJvdW5kIHRoaXMgYnkgX25vdF8gc2V0dGluZyB0aGUgYXV0b3BsYXkgYXR0cmlidXRlIG9uIHNhZmFyaSBhbmQgaW5zdGVhZCBjYWxsIGBzZXRUaW1lb3V0KCgpID0+IGVsLnBsYXkoKSwwKWAgZnVydGhlciBkb3duXG4gICAgZWxlbWVudC5hdXRvcGxheSA9IHRydWU7XG4gIH1cbiAgLy8gSW4gY2FzZSB0aGVyZSBhcmUgbm8gYXVkaW8gdHJhY2tzIHByZXNlbnQgb24gdGhlIG1lZGlhc3RyZWFtLCB3ZSBzZXQgdGhlIGVsZW1lbnQgYXMgbXV0ZWQgdG8gZW5zdXJlIGF1dG9wbGF5IHdvcmtzXG4gIGVsZW1lbnQubXV0ZWQgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA9PT0gMDtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgZWxlbWVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gIH1cblxuICAvLyBhdm9pZCBmbGlja2VyXG4gIGlmIChlbGVtZW50LnNyY09iamVjdCAhPT0gbWVkaWFTdHJlYW0pIHtcbiAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIGlmICgoaXNTYWZhcmkoKSB8fCBpc0ZpcmVGb3goKSkgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgIC8vIEZpcmVmb3ggYWxzbyBoYXMgYSB0aW1pbmcgaXNzdWUgd2hlcmUgdmlkZW8gZG9lc24ndCBhY3R1YWxseSBnZXQgYXR0YWNoZWQgdW5sZXNzXG4gICAgICAvLyBwZXJmb3JtZWQgb3V0LW9mLWJhbmRcbiAgICAgIC8vIFNhZmFyaSAxNSBoYXMgYSBidWcgd2hlcmUgaW4gY2VydGFpbiBsYXlvdXRzLCB2aWRlbyBlbGVtZW50IHJlbmRlcnNcbiAgICAgIC8vIGJsYWNrIHVudGlsIHRoZSBwYWdlIGlzIHJlc2l6ZWQgb3Igb3RoZXIgY2hhbmdlcyB0YWtlIHBsYWNlLlxuICAgICAgLy8gUmVzZXR0aW5nIHRoZSBzcmMgdHJpZ2dlcnMgaXQgdG8gcmVuZGVyLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvNjkwNTIzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICAgICAgLy8gU2FmYXJpIDE1IHNvbWV0aW1lcyBmYWlscyB0byBzdGFydCBhIHZpZGVvXG4gICAgICAgIC8vIHdoZW4gdGhlIHdpbmRvdyBpcyBiYWNrZ3JvdW5kZWQgYmVmb3JlIHRoZSBmaXJzdCBmcmFtZSBpcyBkcmF3blxuICAgICAgICAvLyBtYW51YWxseSBjYWxsaW5nIHBsYXkgaGVyZSBzZWVtcyB0byBmaXggdGhhdFxuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyoqIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgfSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGFjaFRyYWNrKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgaWYgKG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBUcmFjayB7XG4gIGV4cG9ydCBlbnVtIEtpbmQge1xuICAgIEF1ZGlvID0gJ2F1ZGlvJyxcbiAgICBWaWRlbyA9ICd2aWRlbycsXG4gICAgVW5rbm93biA9ICd1bmtub3duJyxcbiAgfVxuICBleHBvcnQgdHlwZSBTSUQgPSBzdHJpbmc7XG4gIGV4cG9ydCBlbnVtIFNvdXJjZSB7XG4gICAgQ2FtZXJhID0gJ2NhbWVyYScsXG4gICAgTWljcm9waG9uZSA9ICdtaWNyb3Bob25lJyxcbiAgICBTY3JlZW5TaGFyZSA9ICdzY3JlZW5fc2hhcmUnLFxuICAgIFNjcmVlblNoYXJlQXVkaW8gPSAnc2NyZWVuX3NoYXJlX2F1ZGlvJyxcbiAgICBVbmtub3duID0gJ3Vua25vd24nLFxuICB9XG5cbiAgZXhwb3J0IGVudW0gU3RyZWFtU3RhdGUge1xuICAgIEFjdGl2ZSA9ICdhY3RpdmUnLFxuICAgIFBhdXNlZCA9ICdwYXVzZWQnLFxuICAgIFVua25vd24gPSAndW5rbm93bicsXG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIERpbWVuc2lvbnMge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGV4cG9ydCBmdW5jdGlvbiBraW5kVG9Qcm90byhrOiBLaW5kKTogVHJhY2tUeXBlIHtcbiAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgS2luZC5BdWRpbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5BVURJTztcbiAgICAgIGNhc2UgS2luZC5WaWRlbzpcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5WSURFTztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FIHRoaXMgd2FzIFVOUkVDT0dOSVpFRCBiZWZvcmVcbiAgICAgICAgcmV0dXJuIFRyYWNrVHlwZS5EQVRBO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGtpbmRGcm9tUHJvdG8odDogVHJhY2tUeXBlKTogS2luZCB8IHVuZGVmaW5lZCB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFRyYWNrVHlwZS5BVURJTzpcbiAgICAgICAgcmV0dXJuIEtpbmQuQXVkaW87XG4gICAgICBjYXNlIFRyYWNrVHlwZS5WSURFTzpcbiAgICAgICAgcmV0dXJuIEtpbmQuVmlkZW87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gS2luZC5Vbmtub3duO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNvdXJjZVRvUHJvdG8oczogU291cmNlKTogVHJhY2tTb3VyY2Uge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBTb3VyY2UuQ2FtZXJhOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuQ0FNRVJBO1xuICAgICAgY2FzZSBTb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU7XG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuVU5LTk9XTjtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzb3VyY2VGcm9tUHJvdG8oczogVHJhY2tTb3VyY2UpOiBTb3VyY2Uge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5DQU1FUkE6XG4gICAgICAgIHJldHVybiBTb3VyY2UuQ2FtZXJhO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5NSUNST1BIT05FOlxuICAgICAgICByZXR1cm4gU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPOlxuICAgICAgICByZXR1cm4gU291cmNlLlNjcmVlblNoYXJlQXVkaW87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU291cmNlLlVua25vd247XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBleHBvcnQgZnVuY3Rpb24gc3RyZWFtU3RhdGVGcm9tUHJvdG8oczogUHJvdG9TdHJlYW1TdGF0ZSk6IFN0cmVhbVN0YXRlIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgUHJvdG9TdHJlYW1TdGF0ZS5BQ1RJVkU6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZS5BY3RpdmU7XG4gICAgICBjYXNlIFByb3RvU3RyZWFtU3RhdGUuUEFVU0VEOlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUuUGF1c2VkO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFN0cmVhbVN0YXRlLlVua25vd247XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFRyYWNrRXZlbnRDYWxsYmFja3MgPSB7XG4gIG1lc3NhZ2U6ICgpID0+IHZvaWQ7XG4gIG11dGVkOiAodHJhY2s/OiBhbnkpID0+IHZvaWQ7XG4gIHVubXV0ZWQ6ICh0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgcmVzdGFydGVkOiAodHJhY2s/OiBhbnkpID0+IHZvaWQ7XG4gIGVuZGVkOiAodHJhY2s/OiBhbnkpID0+IHZvaWQ7XG4gIHVwZGF0ZVNldHRpbmdzOiAoKSA9PiB2b2lkO1xuICB1cGRhdGVTdWJzY3JpcHRpb246ICgpID0+IHZvaWQ7XG4gIGF1ZGlvUGxheWJhY2tTdGFydGVkOiAoKSA9PiB2b2lkO1xuICBhdWRpb1BsYXliYWNrRmFpbGVkOiAoZXJyb3I/OiBFcnJvcikgPT4gdm9pZDtcbiAgYXVkaW9TaWxlbmNlRGV0ZWN0ZWQ6ICgpID0+IHZvaWQ7XG4gIHZpc2liaWxpdHlDaGFuZ2VkOiAodmlzaWJsZTogYm9vbGVhbiwgdHJhY2s/OiBhbnkpID0+IHZvaWQ7XG4gIHZpZGVvRGltZW5zaW9uc0NoYW5nZWQ6IChkaW1lbnNpb25zOiBUcmFjay5EaW1lbnNpb25zLCB0cmFjaz86IGFueSkgPT4gdm9pZDtcbiAgdmlkZW9QbGF5YmFja1N0YXJ0ZWQ6ICgpID0+IHZvaWQ7XG4gIHZpZGVvUGxheWJhY2tGYWlsZWQ6IChlcnJvcj86IEVycm9yKSA9PiB2b2lkO1xuICBlbGVtZW50QXR0YWNoZWQ6IChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSA9PiB2b2lkO1xuICBlbGVtZW50RGV0YWNoZWQ6IChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSA9PiB2b2lkO1xuICB1cHN0cmVhbVBhdXNlZDogKHRyYWNrOiBhbnkpID0+IHZvaWQ7XG4gIHVwc3RyZWFtUmVzdW1lZDogKHRyYWNrOiBhbnkpID0+IHZvaWQ7XG4gIHRyYWNrUHJvY2Vzc29yVXBkYXRlOiAocHJvY2Vzc29yPzogVHJhY2tQcm9jZXNzb3I8VHJhY2suS2luZCwgYW55PikgPT4gdm9pZDtcbiAgYXVkaW9UcmFja0ZlYXR1cmVVcGRhdGU6ICh0cmFjazogYW55LCBmZWF0dXJlOiBBdWRpb1RyYWNrRmVhdHVyZSwgZW5hYmxlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgdGltZVN5bmNVcGRhdGU6ICh1cGRhdGU6IHsgdGltZXN0YW1wOiBudW1iZXI7IHJ0cFRpbWVzdGFtcDogbnVtYmVyIH0pID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUge1xuICBBdWRpb1Byb2Nlc3Nvck9wdGlvbnMsXG4gIFRyYWNrUHJvY2Vzc29yLFxuICBWaWRlb1Byb2Nlc3Nvck9wdGlvbnMsXG59IGZyb20gJy4vcHJvY2Vzc29yL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFja1B1Ymxpc2hEZWZhdWx0cyB7XG4gIC8qKlxuICAgKiBlbmNvZGluZyBwYXJhbWV0ZXJzIGZvciBjYW1lcmEgdHJhY2tcbiAgICovXG4gIHZpZGVvRW5jb2Rpbmc/OiBWaWRlb0VuY29kaW5nO1xuXG4gIC8qKlxuICAgKiBBZHZhbmNlZCBjb2RlY3MgKFZQOS9BVjEvSDI2NSkgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXIgY2xpZW50cy4gV2hlbiBiYWNrdXBDb2RlYyBpc1xuICAgKiBzZXQsIHdoZW4gYW4gaW5jb21wYXRpYmxlIGNsaWVudCBhdHRlbXB0cyB0byBzdWJzY3JpYmUgdG8gdGhlIHRyYWNrLCBMaXZlS2l0XG4gICAqIHdpbGwgYXV0b21hdGljYWxseSBwdWJsaXNoIGEgc2Vjb25kYXJ5IHRyYWNrIGVuY29kZWQgd2l0aCB0aGUgYmFja3VwIGNvZGVjLlxuICAgKlxuICAgKiBZb3UgY291bGQgY3VzdG9taXplIHNwZWNpZmljIGVuY29kaW5nIHBhcmFtZXRlcnMgb2YgdGhlIGJhY2t1cCB0cmFjayBieVxuICAgKiBleHBsaWNpdGx5IHNldHRpbmcgY29kZWMgYW5kIGVuY29kaW5nIGZpZWxkcy5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYHRydWVgXG4gICAqL1xuICBiYWNrdXBDb2RlYz86IHRydWUgfCBmYWxzZSB8IHsgY29kZWM6IEJhY2t1cFZpZGVvQ29kZWM7IGVuY29kaW5nPzogVmlkZW9FbmNvZGluZyB9O1xuXG4gIC8qKlxuICAgKiBXaGVuIGJhY2t1cCBjb2RlYyBpcyBlbmFibGVkLCB0aGVyZSBhcmUgdHdvIG9wdGlvbnMgdG8gZGVjaWRlIHdoZXRoZXIgdG9cbiAgICogc2VuZCB0aGUgcHJpbWFyeSBjb2RlYyBhdCB0aGUgc2FtZSB0aW1lOlxuICAgKiAgICogY29kZWMgcmVncmVzc2lvbjogcHVibGlzaGVyIHN0b3BzIHNlbmRpbmcgcHJpbWFyeSBjb2RlYyBhbmQgYWxsIHN1YnNjcmliZXJzXG4gICAqICAgICAgIHdpbGwgcmVjZWl2ZSBiYWNrdXAgY29kZWMgZXZlbiBpZiB0aGUgcHJpbWFyeSBjb2RlYyBpcyBzdXBwb3J0ZWQgb24gdGhlaXIgYnJvd3Nlci4gSXQgaXMgdGhlIGRlZmF1bHRcbiAgICogICAgICAgYmVoYXZpb3IgYW5kIHByb3ZpZGVzIG1heGltdW0gY29tcGF0aWJpbGl0eS4gSXQgYWxzbyByZWR1Y2VzIENQVVxuICAgKiAgICAgICBhbmQgYmFuZHdpZHRoIGNvbnN1bXB0aW9uIGZvciBwdWJsaXNoZXIuXG4gICAqICAgKiBtdWx0aS1jb2RlYyBzaW11bGNhc3Q6IHB1Ymxpc2hlciBlbmNvZGVzIGFuZCBzZW5kcyBib3RoIGNvZGVjcyBhdCBzYW1lIHRpbWUsXG4gICAqICAgICAgIHN1YnNjcmliZXJzIHdpbGwgZ2V0IG1vc3QgZWZmaWNpZW50IGNvZGVjLiBJdCB3aWxsIHByb3ZpZGUgbW9zdCBiYW5kd2lkdGhcbiAgICogICAgICAgZWZmaWNpZW5jeSwgZXNwZWNpYWxseSBpbiB0aGUgbGFyZ2UgMTpOIHJvb20gYnV0IHJlcXVpcmVzIG1vcmUgZGV2aWNlIHBlcmZvcm1hbmNlXG4gICAqICAgICAgIGFuZCBiYW5kd2lkdGggY29uc3VtcHRpb24gZm9yIHB1Ymxpc2hlci5cbiAgICovXG4gIGJhY2t1cENvZGVjUG9saWN5PzogQmFja3VwQ29kZWNQb2xpY3k7XG5cbiAgLyoqXG4gICAqIGVuY29kaW5nIHBhcmFtZXRlcnMgZm9yIHNjcmVlbiBzaGFyZSB0cmFja1xuICAgKi9cbiAgc2NyZWVuU2hhcmVFbmNvZGluZz86IFZpZGVvRW5jb2Rpbmc7XG5cbiAgLyoqXG4gICAqIGNvZGVjLCBkZWZhdWx0cyB0byB2cDg7IGZvciBzdmMgY29kZWNzLCBhdXRvIGVuYWJsZSB2cDhcbiAgICogYXMgYmFja3VwLiAoVEJEKVxuICAgKi9cbiAgdmlkZW9Db2RlYz86IFZpZGVvQ29kZWM7XG5cbiAgLyoqXG4gICAqIHdoaWNoIGF1ZGlvIHByZXNldCBzaG91bGQgYmUgdXNlZCBmb3IgcHVibGlzaGluZyAoYXVkaW8pIHRyYWNrc1xuICAgKiBkZWZhdWx0cyB0byBbW0F1ZGlvUHJlc2V0cy5tdXNpY11dXG4gICAqL1xuICBhdWRpb1ByZXNldD86IEF1ZGlvUHJlc2V0O1xuXG4gIC8qKlxuICAgKiBkdHggKERpc2NvbnRpbnVvdXMgVHJhbnNtaXNzaW9uIG9mIGF1ZGlvKSwgZW5hYmxlZCBieSBkZWZhdWx0IGZvciBtb25vIHRyYWNrcy5cbiAgICovXG4gIGR0eD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHJlZCAoUmVkdW5kYW50IEF1ZGlvIERhdGEpLCBlbmFibGVkIGJ5IGRlZmF1bHQgZm9yIG1vbm8gdHJhY2tzLlxuICAgKi9cbiAgcmVkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogcHVibGlzaCB0cmFjayBpbiBzdGVyZW8gbW9kZSAob3Igc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUpLiBkZWZhdWx0cyBkZXRlcm1pbmVkIGJ5IGNhcHR1cmUgY2hhbm5lbCBjb3VudC5cbiAgICovXG4gIGZvcmNlU3RlcmVvPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogdXNlIHNpbXVsY2FzdCwgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogV2hlbiB1c2luZyBzaW11bGNhc3QsIExpdmVLaXQgd2lsbCBwdWJsaXNoIHVwIHRvIHRocmVlIHZlcnNpb25zIG9mIHRoZSBzdHJlYW1cbiAgICogYXQgdmFyaW91cyByZXNvbHV0aW9ucy5cbiAgICovXG4gIHNpbXVsY2FzdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHNjYWxhYmlsaXR5IG1vZGUgZm9yIHN2YyBjb2RlY3MsIGRlZmF1bHRzIHRvICdMM1QzX0tFWScuXG4gICAqIGZvciBzdmMgY29kZWNzLCBzaW11bGNhc3QgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBzY2FsYWJpbGl0eU1vZGU/OiBTY2FsYWJpbGl0eU1vZGU7XG5cbiAgLyoqXG4gICAqIGRlZ3JhZGF0aW9uIHByZWZlcmVuY2VcbiAgICovXG4gIGRlZ3JhZGF0aW9uUHJlZmVyZW5jZT86IFJUQ0RlZ3JhZGF0aW9uUHJlZmVyZW5jZTtcblxuICAvKipcbiAgICogVXAgdG8gdHdvIGFkZGl0aW9uYWwgc2ltdWxjYXN0IGxheWVycyB0byBwdWJsaXNoIGluIGFkZGl0aW9uIHRvIHRoZSBvcmlnaW5hbFxuICAgKiBUcmFjay5cbiAgICogV2hlbiBsZWZ0IGJsYW5rLCBpdCBkZWZhdWx0cyB0byBoMTgwLCBoMzYwLlxuICAgKiBJZiBhIFNWQyBjb2RlYyBpcyB1c2VkIChWUDkgb3IgQVYxKSwgdGhpcyBmaWVsZCBoYXMgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBUbyBwdWJsaXNoIHRocmVlIHRvdGFsIGxheWVycywgeW91IHdvdWxkIHNwZWNpZnk6XG4gICAqIHtcbiAgICogICB2aWRlb0VuY29kaW5nOiB7Li4ufSwgLy8gZW5jb2Rpbmcgb2YgdGhlIHByaW1hcnkgbGF5ZXJcbiAgICogICB2aWRlb1NpbXVsY2FzdExheWVyczogW1xuICAgKiAgICAgVmlkZW9QcmVzZXRzLmg1NDAsXG4gICAqICAgICBWaWRlb1ByZXNldHMuaDIxNixcbiAgICogICBdLFxuICAgKiB9XG4gICAqL1xuICB2aWRlb1NpbXVsY2FzdExheWVycz86IEFycmF5PFZpZGVvUHJlc2V0PjtcblxuICAvKipcbiAgICogY3VzdG9tIHZpZGVvIHNpbXVsY2FzdCBsYXllcnMgZm9yIHNjcmVlbiB0cmFja3NcbiAgICogTm90ZTogdGhlIGxheWVycyBuZWVkIHRvIGJlIG9yZGVyZWQgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCBxdWFsaXR5XG4gICAqL1xuICBzY3JlZW5TaGFyZVNpbXVsY2FzdExheWVycz86IEFycmF5PFZpZGVvUHJlc2V0PjtcblxuICAvKipcbiAgICogRm9yIGxvY2FsIHRyYWNrcywgc3RvcCB0aGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrIHdoZW4gdGhlIHRyYWNrIGlzIG11dGVkIChvciBwYXVzZWQpXG4gICAqIG9uIHNvbWUgcGxhdGZvcm1zLCB0aGlzIG9wdGlvbiBpcyBuZWNlc3NhcnkgdG8gZGlzYWJsZSB0aGUgbWljcm9waG9uZSByZWNvcmRpbmcgaW5kaWNhdG9yLlxuICAgKiBOb3RlOiB3aGVuIHRoaXMgaXMgZW5hYmxlZCwgYW5kIEJUIGRldmljZXMgYXJlIGNvbm5lY3RlZCwgdGhleSB3aWxsIHRyYW5zaXRpb24gYmV0d2VlblxuICAgKiBwcm9maWxlcyAoZS5nLiBIRlAgdG8gQTJEUCkgYW5kIHRoZXJlIHdpbGwgYmUgYW4gYXVkaWJsZSBkaWZmZXJlbmNlIGluIHBsYXliYWNrLlxuICAgKlxuICAgKiBkZWZhdWx0cyB0byBmYWxzZVxuICAgKi9cbiAgc3RvcE1pY1RyYWNrT25NdXRlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHdoZW4gcHVibGlzaGluZyB0cmFja3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFja1B1Ymxpc2hPcHRpb25zIGV4dGVuZHMgVHJhY2tQdWJsaXNoRGVmYXVsdHMge1xuICAvKipcbiAgICogc2V0IGEgdHJhY2sgbmFtZVxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU291cmNlIG9mIHRyYWNrLCBjYW1lcmEsIG1pY3JvcGhvbmUsIG9yIHNjcmVlblxuICAgKi9cbiAgc291cmNlPzogVHJhY2suU291cmNlO1xuXG4gIC8qKlxuICAgKiBTZXQgc3RyZWFtIG5hbWUgZm9yIHRoZSB0cmFjay4gQXVkaW8gYW5kIHZpZGVvIHRyYWNrcyB3aXRoIHRoZSBzYW1lIHN0cmVhbSBuYW1lXG4gICAqIHdpbGwgYmUgcGxhY2VkIGluIHRoZSBzYW1lIGBNZWRpYVN0cmVhbWAgYW5kIG9mZmVyIGJldHRlciBzeW5jaHJvbml6YXRpb24uXG4gICAqIEJ5IGRlZmF1bHQsIGNhbWVyYSBhbmQgbWljcm9waG9uZSB3aWxsIGJlIHBsYWNlZCBpbiBhIHN0cmVhbTsgYXMgd291bGQgc2NyZWVuX3NoYXJlIGFuZCBzY3JlZW5fc2hhcmVfYXVkaW9cbiAgICovXG4gIHN0cmVhbT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMge1xuICAvKipcbiAgICogYXVkaW8gdHJhY2sgb3B0aW9ucywgdHJ1ZSB0byBjcmVhdGUgd2l0aCBkZWZhdWx0cy4gZmFsc2UgaWYgYXVkaW8gc2hvdWxkbid0IGJlIGNyZWF0ZWRcbiAgICogZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhdWRpbz86IGJvb2xlYW4gfCBBdWRpb0NhcHR1cmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiB2aWRlbyB0cmFjayBvcHRpb25zLCB0cnVlIHRvIGNyZWF0ZSB3aXRoIGRlZmF1bHRzLiBmYWxzZSBpZiB2aWRlbyBzaG91bGRuJ3QgYmUgY3JlYXRlZFxuICAgKiBkZWZhdWx0IHRydWVcbiAgICovXG4gIHZpZGVvPzogYm9vbGVhbiB8IFZpZGVvQ2FwdHVyZU9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9DYXB0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIENvbnN0cmFpbkRPTVN0cmluZyBvYmplY3Qgc3BlY2lmeWluZyBhIGRldmljZSBJRCBvciBhbiBhcnJheSBvZiBkZXZpY2VcbiAgICogSURzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIGRldmljZUlkPzogQ29uc3RyYWluRE9NU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhIGZhY2luZyBvciBhbiBhcnJheSBvZiBmYWNpbmdzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIGZhY2luZ01vZGU/OiAndXNlcicgfCAnZW52aXJvbm1lbnQnIHwgJ2xlZnQnIHwgJ3JpZ2h0JztcblxuICByZXNvbHV0aW9uPzogVmlkZW9SZXNvbHV0aW9uO1xuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplIHRoZSB0cmFjayB3aXRoIGEgZ2l2ZW4gcHJvY2Vzc29yXG4gICAqL1xuICBwcm9jZXNzb3I/OiBUcmFja1Byb2Nlc3NvcjxUcmFjay5LaW5kLlZpZGVvLCBWaWRlb1Byb2Nlc3Nvck9wdGlvbnM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMge1xuICAvKipcbiAgICogdHJ1ZSB0byBjYXB0dXJlIGF1ZGlvIHNoYXJlZC4gYnJvd3NlciBzdXBwb3J0IGZvciBhdWRpbyBjYXB0dXJpbmcgaW5cbiAgICogc2NyZWVuc2hhcmUgaXMgbGltaXRlZDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXREaXNwbGF5TWVkaWEjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAqL1xuICBhdWRpbz86IGJvb2xlYW4gfCBBdWRpb0NhcHR1cmVPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBvbmx5IGFsbG93cyBmb3IgJ3RydWUnIGFuZCBjaHJvbWUgYWxsb3dzIGZvciBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gYmUgcGFzc2VkIGluXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZG9jcy93ZWItcGxhdGZvcm0vc2NyZWVuLXNoYXJpbmctY29udHJvbHMvI2Rpc3BsYXlTdXJmYWNlXG4gICAqL1xuICB2aWRlbz86IHRydWUgfCB7IGRpc3BsYXlTdXJmYWNlPzogJ3dpbmRvdycgfCAnYnJvd3NlcicgfCAnbW9uaXRvcicgfTtcblxuICAvKipcbiAgICogY2FwdHVyZSByZXNvbHV0aW9uLCBkZWZhdWx0cyB0byAxMDgwIGZvciBhbGwgYnJvd3NlcnMgb3RoZXIgdGhhbiBTYWZhcmlcbiAgICogT24gU2FmYXJpIDE3LCBkZWZhdWx0IHJlc29sdXRpb24gaXMgbm90IGNhcHBlZCwgZHVlIHRvIGEgYnVnLCBzcGVjaWZ5aW5nXG4gICAqIGFueSByZXNvbHV0aW9uIGF0IGFsbCB3b3VsZCBsZWFkIHRvIGEgbG93LXJlc29sdXRpb24gY2FwdHVyZS5cbiAgICogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI2MzAxNVxuICAgKi9cbiAgcmVzb2x1dGlvbj86IFZpZGVvUmVzb2x1dGlvbjtcblxuICAvKiogYSBDYXB0dXJlQ29udHJvbGxlciBvYmplY3QgaW5zdGFuY2UgY29udGFpbmluZyBtZXRob2RzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZnVydGhlciBtYW5pcHVsYXRlIHRoZSBjYXB0dXJlIHNlc3Npb24gaWYgaW5jbHVkZWQuICovXG4gIGNvbnRyb2xsZXI/OiB1bmtub3duOyAvLyBUT0RPIHJlcGxhY2UgdHlwZSB3aXRoIENhcHR1cmVDb250cm9sbGVyIG9uY2UgaXQgbGFuZHMgaW4gVHlwZVNjcmlwdFxuXG4gIC8qKiBzcGVjaWZpZXMgd2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc2VsZWN0IHRoZSBjdXJyZW50IHRhYiBmb3IgY2FwdHVyZSAqL1xuICBzZWxmQnJvd3NlclN1cmZhY2U/OiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XG5cbiAgLyoqIHNwZWNpZmllcyB3aGV0aGVyIHRoZSBicm93c2VyIHNob3VsZCBkaXNwbGF5IGEgY29udHJvbCB0byBhbGxvdyB0aGUgdXNlciB0byBkeW5hbWljYWxseSBzd2l0Y2ggdGhlIHNoYXJlZCB0YWIgZHVyaW5nIHNjcmVlbi1zaGFyaW5nLiAqL1xuICBzdXJmYWNlU3dpdGNoaW5nPzogJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xuXG4gIC8qKiBzcGVjaWZpZXMgd2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgaW5jbHVkZSB0aGUgc3lzdGVtIGF1ZGlvIGFtb25nIHRoZSBwb3NzaWJsZSBhdWRpbyBzb3VyY2VzIG9mZmVyZWQgdG8gdGhlIHVzZXIgKi9cbiAgc3lzdGVtQXVkaW8/OiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XG5cbiAgLyoqIHNwZWNpZnkgdGhlIHR5cGUgb2YgY29udGVudCwgc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvbXN0LWNvbnRlbnQtaGludC8jdmlkZW8tY29udGVudC1oaW50cyAqL1xuICBjb250ZW50SGludD86ICdkZXRhaWwnIHwgJ3RleHQnIHwgJ21vdGlvbic7XG5cbiAgLyoqXG4gICAqIEV4cGVyaW1lbnRhbCBvcHRpb24gdG8gY29udHJvbCB3aGV0aGVyIHRoZSBhdWRpbyBwbGF5aW5nIGluIGEgdGFiIHdpbGwgY29udGludWUgdG8gYmUgcGxheWVkIG91dCBvZiBhIHVzZXInc1xuICAgKiBsb2NhbCBzcGVha2VycyB3aGVuIHRoZSB0YWIgaXMgY2FwdHVyZWQuXG4gICAqL1xuICBzdXBwcmVzc0xvY2FsQXVkaW9QbGF5YmFjaz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEV4cGVyaW1lbnRhbCBvcHRpb24gdG8gaW5zdHJ1Y3QgdGhlIGJyb3dzZXIgdG8gb2ZmZXIgdGhlIGN1cnJlbnQgdGFiIGFzIHRoZSBtb3N0IHByb21pbmVudCBjYXB0dXJlIHNvdXJjZVxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXREaXNwbGF5TWVkaWEjcHJlZmVyY3VycmVudHRhYlxuICAgKi9cbiAgcHJlZmVyQ3VycmVudFRhYj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9DYXB0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBzcGVjaWZpZXMgd2hldGhlciBhdXRvbWF0aWMgZ2FpbiBjb250cm9sIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICovXG4gIGF1dG9HYWluQ29udHJvbD86IENvbnN0cmFpbkJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHRoZSBjaGFubmVsIGNvdW50IG9yIHJhbmdlIG9mIGNoYW5uZWwgY291bnRzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZFxuICAgKi9cbiAgY2hhbm5lbENvdW50PzogQ29uc3RyYWluVUxvbmc7XG5cbiAgLyoqXG4gICAqIEEgQ29uc3RyYWluRE9NU3RyaW5nIG9iamVjdCBzcGVjaWZ5aW5nIGEgZGV2aWNlIElEIG9yIGFuIGFycmF5IG9mIGRldmljZVxuICAgKiBJRHMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgZGV2aWNlSWQ/OiBDb25zdHJhaW5ET01TdHJpbmc7XG5cbiAgLyoqXG4gICAqIHdoZXRoZXIgb3Igbm90IGVjaG8gY2FuY2VsbGF0aW9uIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICovXG4gIGVjaG9DYW5jZWxsYXRpb24/OiBDb25zdHJhaW5Cb29sZWFuO1xuXG4gIC8qKlxuICAgKiB0aGUgbGF0ZW5jeSBvciByYW5nZSBvZiBsYXRlbmNpZXMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgbGF0ZW5jeT86IENvbnN0cmFpbkRvdWJsZTtcblxuICAvKipcbiAgICogd2hldGhlciBub2lzZSBzdXBwcmVzc2lvbiBpcyBwcmVmZXJyZWQgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgbm9pc2VTdXBwcmVzc2lvbj86IENvbnN0cmFpbkJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICogYSBzdHJvbmdlciB2ZXJzaW9uIG9mICdub2lzZVN1cHByZXNzaW9uJywgYnJvd3NlciBzdXBwb3J0IGlzIG5vdCB3aWRlc3ByZWFkIHlldC5cbiAgICogSWYgdGhpcyBpcyBzZXQgKGFuZCBzdXBwb3J0ZWQpIHRoZSB2YWx1ZSBmb3IgJ25vaXNlU3VwcHJlc3Npb24nIHdpbGwgYmUgaWdub3JlZFxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tZWRpYWNhcHR1cmUtZXh0ZW5zaW9ucy8jdm9pY2Vpc29sYXRpb24tY29uc3RyYWludFxuICAgKi9cbiAgdm9pY2VJc29sYXRpb24/OiBDb25zdHJhaW5Cb29sZWFuO1xuXG4gIC8qKlxuICAgKiB0aGUgc2FtcGxlIHJhdGUgb3IgcmFuZ2Ugb2Ygc2FtcGxlIHJhdGVzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIHNhbXBsZVJhdGU/OiBDb25zdHJhaW5VTG9uZztcblxuICAvKipcbiAgICogc2FtcGxlIHNpemUgb3IgcmFuZ2Ugb2Ygc2FtcGxlIHNpemVzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZC5cbiAgICovXG4gIHNhbXBsZVNpemU/OiBDb25zdHJhaW5VTG9uZztcblxuICAvKipcbiAgICogaW5pdGlhbGl6ZSB0aGUgdHJhY2sgd2l0aCBhIGdpdmVuIHByb2Nlc3NvclxuICAgKi9cbiAgcHJvY2Vzc29yPzogVHJhY2tQcm9jZXNzb3I8VHJhY2suS2luZC5BdWRpbywgQXVkaW9Qcm9jZXNzb3JPcHRpb25zPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb091dHB1dE9wdGlvbnMge1xuICAvKipcbiAgICogZGV2aWNlSWQgdG8gb3V0cHV0IGF1ZGlvXG4gICAqXG4gICAqIE9ubHkgc3VwcG9ydGVkIG9uIGJyb3dzZXJzIHdoZXJlIGBzZXRTaW5rSWRgIGlzIGF2YWlsYWJsZVxuICAgKi9cbiAgZGV2aWNlSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9SZXNvbHV0aW9uIHtcbiAgd2lkdGg6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGZyYW1lUmF0ZT86IG51bWJlcjtcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9FbmNvZGluZyB7XG4gIG1heEJpdHJhdGU6IG51bWJlcjtcbiAgbWF4RnJhbWVyYXRlPzogbnVtYmVyO1xuICBwcmlvcml0eT86IFJUQ1ByaW9yaXR5VHlwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1ByZXNldE9wdGlvbnMge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXI7XG4gIG1heEJpdHJhdGU6IG51bWJlcjtcbiAgbWF4RnJhbWVyYXRlPzogbnVtYmVyO1xuICBwcmlvcml0eT86IFJUQ1ByaW9yaXR5VHlwZTtcbn1cblxuZXhwb3J0IGNsYXNzIFZpZGVvUHJlc2V0IHtcbiAgZW5jb2Rpbmc6IFZpZGVvRW5jb2Rpbmc7XG5cbiAgd2lkdGg6IG51bWJlcjtcblxuICBoZWlnaHQ6IG51bWJlcjtcblxuICBhc3BlY3RSYXRpbz86IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcih2aWRlb1ByZXNldE9wdGlvbnM6IFZpZGVvUHJlc2V0T3B0aW9ucyk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgbWF4Qml0cmF0ZTogbnVtYmVyLFxuICAgIG1heEZyYW1lcmF0ZT86IG51bWJlcixcbiAgICBwcmlvcml0eT86IFJUQ1ByaW9yaXR5VHlwZSxcbiAgKTtcbiAgY29uc3RydWN0b3IoXG4gICAgd2lkdGhPck9wdGlvbnM6IG51bWJlciB8IFZpZGVvUHJlc2V0T3B0aW9ucyxcbiAgICBoZWlnaHQ/OiBudW1iZXIsXG4gICAgbWF4Qml0cmF0ZT86IG51bWJlcixcbiAgICBtYXhGcmFtZXJhdGU/OiBudW1iZXIsXG4gICAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGUsXG4gICkge1xuICAgIGlmICh0eXBlb2Ygd2lkdGhPck9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGhPck9wdGlvbnMud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHdpZHRoT3JPcHRpb25zLmhlaWdodDtcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSB3aWR0aE9yT3B0aW9ucy5hc3BlY3RSYXRpbztcbiAgICAgIHRoaXMuZW5jb2RpbmcgPSB7XG4gICAgICAgIG1heEJpdHJhdGU6IHdpZHRoT3JPcHRpb25zLm1heEJpdHJhdGUsXG4gICAgICAgIG1heEZyYW1lcmF0ZTogd2lkdGhPck9wdGlvbnMubWF4RnJhbWVyYXRlLFxuICAgICAgICBwcmlvcml0eTogd2lkdGhPck9wdGlvbnMucHJpb3JpdHksXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgbWF4Qml0cmF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGhPck9wdGlvbnM7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSB3aWR0aE9yT3B0aW9ucyAvIGhlaWdodDtcbiAgICAgIHRoaXMuZW5jb2RpbmcgPSB7XG4gICAgICAgIG1heEJpdHJhdGUsXG4gICAgICAgIG1heEZyYW1lcmF0ZSxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCBvcHRpb25zOiBwcm92aWRlIGF0IGxlYXN0IHdpZHRoLCBoZWlnaHQgYW5kIG1heEJpdHJhdGUnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcmVzb2x1dGlvbigpOiBWaWRlb1Jlc29sdXRpb24ge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBmcmFtZVJhdGU6IHRoaXMuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgYXNwZWN0UmF0aW86IHRoaXMuYXNwZWN0UmF0aW8sXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvUHJlc2V0IHtcbiAgbWF4Qml0cmF0ZTogbnVtYmVyO1xuICBwcmlvcml0eT86IFJUQ1ByaW9yaXR5VHlwZTtcbn1cblxuY29uc3QgYmFja3VwQ29kZWNzID0gWyd2cDgnLCAnaDI2NCddIGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgdmlkZW9Db2RlY3MgPSBbJ3ZwOCcsICdoMjY0JywgJ3ZwOScsICdhdjEnXSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgVmlkZW9Db2RlYyA9ICh0eXBlb2YgdmlkZW9Db2RlY3MpW251bWJlcl07XG5cbmV4cG9ydCB0eXBlIEJhY2t1cFZpZGVvQ29kZWMgPSAodHlwZW9mIGJhY2t1cENvZGVjcylbbnVtYmVyXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFja3VwQ29kZWMoY29kZWM6IHN0cmluZyk6IGNvZGVjIGlzIEJhY2t1cFZpZGVvQ29kZWMge1xuICByZXR1cm4gISFiYWNrdXBDb2RlY3MuZmluZCgoYmFja3VwKSA9PiBiYWNrdXAgPT09IGNvZGVjKTtcbn1cblxuZXhwb3J0IGVudW0gQmFja3VwQ29kZWNQb2xpY3kge1xuICAvLyBjb2RlYyByZWdyZXNzaW9uIGlzIHByZWZlcnJlZCwgdGhlIHNmdSB3aWxsIHRyeSB0byByZWdyZXNzIGNvZGVjIGlmIHBvc3NpYmxlIGJ1dCBub3QgZ3VhcmFudGVlZFxuICBQUkVGRVJfUkVHUkVTU0lPTiA9IDAsXG4gIC8vIG11bHRpLWNvZGVjIHNpbXVsY2FzdCwgcHVibGlzaCBib3RoIHByaW1hcnkgYW5kIGJhY2t1cCBjb2RlYyBhdCB0aGUgc2FtZSB0aW1lXG4gIFNJTVVMQ0FTVCA9IDEsXG4gIC8vIGFsd2F5cyB1c2UgYmFja3VwIGNvZGVjIG9ubHlcbiAgUkVHUkVTU0lPTiA9IDIsXG59XG5cbi8qKlxuICogc2NhbGFiaWxpdHkgbW9kZXMgZm9yIHN2Yy5cbiAqL1xuZXhwb3J0IHR5cGUgU2NhbGFiaWxpdHlNb2RlID1cbiAgfCAnTDFUMSdcbiAgfCAnTDFUMidcbiAgfCAnTDFUMydcbiAgfCAnTDJUMSdcbiAgfCAnTDJUMWgnXG4gIHwgJ0wyVDFfS0VZJ1xuICB8ICdMMlQyJ1xuICB8ICdMMlQyaCdcbiAgfCAnTDJUMl9LRVknXG4gIHwgJ0wyVDMnXG4gIHwgJ0wyVDNoJ1xuICB8ICdMMlQzX0tFWSdcbiAgfCAnTDNUMSdcbiAgfCAnTDNUMWgnXG4gIHwgJ0wzVDFfS0VZJ1xuICB8ICdMM1QyJ1xuICB8ICdMM1QyaCdcbiAgfCAnTDNUMl9LRVknXG4gIHwgJ0wzVDMnXG4gIHwgJ0wzVDNoJ1xuICB8ICdMM1QzX0tFWSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXVkaW9QcmVzZXRzIHtcbiAgZXhwb3J0IGNvbnN0IHRlbGVwaG9uZTogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMTJfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3Qgc3BlZWNoOiBBdWRpb1ByZXNldCA9IHtcbiAgICBtYXhCaXRyYXRlOiAyNF8wMDAsXG4gIH07XG4gIGV4cG9ydCBjb25zdCBtdXNpYzogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogNDhfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3QgbXVzaWNTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDY0XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHk6IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDk2XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHlTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDEyOF8wMDAsXG4gIH07XG59XG5cbi8qKlxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb1ByZXNldHMgPSB7XG4gIGg5MDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgOTAsIDkwXzAwMCwgMjApLFxuICBoMTgwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAxODAsIDE2MF8wMDAsIDIwKSxcbiAgaDIxNjogbmV3IFZpZGVvUHJlc2V0KDM4NCwgMjE2LCAxODBfMDAwLCAyMCksXG4gIGgzNjA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgNDUwXzAwMCwgMjApLFxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA1NDAsIDgwMF8wMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMV83MDBfMDAwLCAzMCksXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgM18wMDBfMDAwLCAzMCksXG4gIGgxNDQwOiBuZXcgVmlkZW9QcmVzZXQoMjU2MCwgMTQ0MCwgNV8wMDBfMDAwLCAzMCksXG4gIGgyMTYwOiBuZXcgVmlkZW9QcmVzZXQoMzg0MCwgMjE2MCwgOF8wMDBfMDAwLCAzMCksXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEZvdXIgYnkgdGhyZWUgcHJlc2V0c1xuICovXG5leHBvcnQgY29uc3QgVmlkZW9QcmVzZXRzNDMgPSB7XG4gIGgxMjA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDEyMCwgNzBfMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgyNDAsIDE4MCwgMTI1XzAwMCwgMjApLFxuICBoMjQwOiBuZXcgVmlkZW9QcmVzZXQoMzIwLCAyNDAsIDE0MF8wMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDQ4MCwgMzYwLCAzMzBfMDAwLCAyMCksXG4gIGg0ODA6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDQ4MCwgNTAwXzAwMCwgMjApLFxuICBoNTQwOiBuZXcgVmlkZW9QcmVzZXQoNzIwLCA1NDAsIDYwMF8wMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNzIwLCAxXzMwMF8wMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxNDQwLCAxMDgwLCAyXzMwMF8wMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxNDQwLCAzXzgwMF8wMDAsIDMwKSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBTY3JlZW5TaGFyZVByZXNldHMgPSB7XG4gIGgzNjBmcHMzOiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDIwMF8wMDAsIDMsICdtZWRpdW0nKSxcbiAgaDM2MGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoNjQwLCAzNjAsIDQwMF8wMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHM1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCA4MDBfMDAwLCA1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMV81MDBfMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDJfMDAwXzAwMCwgMzAsICdtZWRpdW0nKSxcbiAgaDEwODBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDJfNTAwXzAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDEwODBmcHMzMDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDVfMDAwXzAwMCwgMzAsICdtZWRpdW0nKSxcbiAgLy8gb3JpZ2luYWwgcmVzb2x1dGlvbiwgd2l0aG91dCByZXNpemluZ1xuICBvcmlnaW5hbDogbmV3IFZpZGVvUHJlc2V0KDAsIDAsIDdfMDAwXzAwMCwgMzAsICdtZWRpdW0nKSxcbn0gYXMgY29uc3Q7XG4iLCJpbXBvcnQge1xuICBDaGF0TWVzc2FnZSBhcyBDaGF0TWVzc2FnZU1vZGVsLFxuICBDbGllbnRJbmZvLFxuICBDbGllbnRJbmZvX1NESyxcbiAgRGlzY29ubmVjdFJlYXNvbixcbiAgVHJhbnNjcmlwdGlvbiBhcyBUcmFuc2NyaXB0aW9uTW9kZWwsXG59IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB7IGdldEJyb3dzZXIgfSBmcm9tICcuLi91dGlscy9icm93c2VyUGFyc2VyJztcbmltcG9ydCB7IHByb3RvY29sVmVyc2lvbiwgdmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuaW1wb3J0IHsgdHlwZSBDb25uZWN0aW9uRXJyb3IsIENvbm5lY3Rpb25FcnJvclJlYXNvbiB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB0eXBlIExvY2FsUGFydGljaXBhbnQgZnJvbSAnLi9wYXJ0aWNpcGFudC9Mb2NhbFBhcnRpY2lwYW50JztcbmltcG9ydCB0eXBlIFBhcnRpY2lwYW50IGZyb20gJy4vcGFydGljaXBhbnQvUGFydGljaXBhbnQnO1xuaW1wb3J0IHR5cGUgUmVtb3RlUGFydGljaXBhbnQgZnJvbSAnLi9wYXJ0aWNpcGFudC9SZW1vdGVQYXJ0aWNpcGFudCc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi90aW1lcnMnO1xuaW1wb3J0IHR5cGUgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4vdHJhY2svTG9jYWxBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIExvY2FsVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbFRyYWNrJztcbmltcG9ydCB0eXBlIExvY2FsVHJhY2tQdWJsaWNhdGlvbiBmcm9tICcuL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgdHlwZSBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHR5cGUgUmVtb3RlQXVkaW9UcmFjayBmcm9tICcuL3RyYWNrL1JlbW90ZUF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgUmVtb3RlVHJhY2sgZnJvbSAnLi90cmFjay9SZW1vdGVUcmFjayc7XG5pbXBvcnQgdHlwZSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgdHlwZSBSZW1vdGVWaWRlb1RyYWNrIGZyb20gJy4vdHJhY2svUmVtb3RlVmlkZW9UcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vdHJhY2svVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFja1B1YmxpY2F0aW9uIH0gZnJvbSAnLi90cmFjay9UcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB7IHR5cGUgVmlkZW9Db2RlYywgdmlkZW9Db2RlY3MgfSBmcm9tICcuL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgZ2V0TmV3QXVkaW9Db250ZXh0IH0gZnJvbSAnLi90cmFjay91dGlscyc7XG5pbXBvcnQgdHlwZSB7IENoYXRNZXNzYWdlLCBMaXZlS2l0UmVhY3ROYXRpdmVJbmZvLCBUcmFuc2NyaXB0aW9uU2VnbWVudCB9IGZyb20gJy4vdHlwZXMnO1xuXG5jb25zdCBzZXBhcmF0b3IgPSAnfCc7XG5leHBvcnQgY29uc3QgZGRFeHRlbnNpb25VUkkgPVxuICAnaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1ydHAtc3BlYy8jZGVwZW5kZW5jeS1kZXNjcmlwdG9yLXJ0cC1oZWFkZXItZXh0ZW5zaW9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVucGFja1N0cmVhbUlkKHBhY2tlZDogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBwYXJ0cyA9IHBhY2tlZC5zcGxpdChzZXBhcmF0b3IpO1xuICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBbcGFydHNbMF0sIHBhY2tlZC5zdWJzdHIocGFydHNbMF0ubGVuZ3RoICsgMSldO1xuICB9XG4gIHJldHVybiBbcGFja2VkLCAnJ107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcChkdXJhdGlvbjogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHtcbiAgcmV0dXJuICdhZGRUcmFuc2NlaXZlcicgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNBZGRUcmFjaygpIHtcbiAgcmV0dXJuICdhZGRUcmFjaycgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNEeW5hY2FzdCgpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzQVYxKCk6IGJvb2xlYW4ge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgLy8gU2FmYXJpIDE3IG9uIGlQaG9uZTE0IHJlcG9ydHMgQVYxIGNhcGFiaWxpdHksIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBzdXBwb3J0IGl0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNBVjEgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vQVYxJykge1xuICAgICAgICBoYXNBVjEgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0FWMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzVlA5KCk6IGJvb2xlYW4ge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpcmVGb3goKSkge1xuICAgIC8vIHRlY2huaWNhbGx5IHNwZWFraW5nIEZpcmVGb3ggc3VwcG9ydHMgVlA5LCBidXQgU1ZDIHB1Ymxpc2hpbmcgaXMgYnJva2VuXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYzMzg3NlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKGJyb3dzZXI/LnZlcnNpb24gJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE2JykgPCAwKSB7XG4gICAgICAvLyBTYWZhcmkgMTYgYW5kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgVlA5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNWUDkgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vVlA5Jykge1xuICAgICAgICBoYXNWUDkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc1ZQOTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU1ZDQ29kZWMoY29kZWM/OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGNvZGVjID09PSAnYXYxJyB8fCBjb2RlYyA9PT0gJ3ZwOSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXBwb3J0c1NldFNpbmtJZChlbG0/OiBIVE1MTWVkaWFFbGVtZW50KTogYm9vbGVhbiB7XG4gIGlmICghZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFlbG0pIHtcbiAgICBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICB9XG4gIHJldHVybiAnc2V0U2lua0lkJyBpbiBlbG07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Jyb3dzZXJTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgUlRDUGVlckNvbm5lY3Rpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c1RyYW5zY2VpdmVyKCkgfHwgc3VwcG9ydHNBZGRUcmFjaygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlRm94KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ2V0QnJvd3NlcigpPy5uYW1lID09PSAnRmlyZWZveCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Nocm9taXVtQmFzZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRCcm93c2VyKCk/Lm5hbWUgPT09ICdDaHJvbWUnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRCcm93c2VyKCk/Lm5hbWUgPT09ICdTYWZhcmknO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkxNygpOiBib29sZWFuIHtcbiAgY29uc3QgYiA9IGdldEJyb3dzZXIoKTtcbiAgcmV0dXJuIGI/Lm5hbWUgPT09ICdTYWZhcmknICYmIGIudmVyc2lvbi5zdGFydHNXaXRoKCcxNy4nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlKCk6IGJvb2xlYW4ge1xuICBpZiAoIWlzV2ViKCkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYHVzZXJBZ2VudERhdGFgIGlzIG5vdCB5ZXQgcGFydCBvZiB0eXBlc2NyaXB0XG4gICAgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE/Lm1vYmlsZSA/P1xuICAgIC9UYWJsZXR8aVBhZHxNb2JpbGV8QW5kcm9pZHxCbGFja0JlcnJ5Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQoKSB7XG4gIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gIGNvbnN0IHN1cHBvcnRlZFNhZmFyaVZlcnNpb24gPSAnMTcuMic7IC8vIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjU3ODAzXG4gIGlmIChicm93c2VyKSB7XG4gICAgaWYgKGJyb3dzZXIubmFtZSAhPT0gJ1NhZmFyaScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBicm93c2VyLm9zID09PSAnaU9TJyAmJlxuICAgICAgYnJvd3Nlci5vc1ZlcnNpb24gJiZcbiAgICAgIGNvbXBhcmVWZXJzaW9ucyhzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uLCBicm93c2VyLm9zVmVyc2lvbikgPj0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGJyb3dzZXIubmFtZSA9PT0gJ1NhZmFyaScgJiZcbiAgICAgIGNvbXBhcmVWZXJzaW9ucyhzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uLCBicm93c2VyLnZlcnNpb24pID49IDBcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYigpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCk6IGJvb2xlYW4ge1xuICAvLyBuYXZpZ2F0b3IucHJvZHVjdCBpcyBkZXByZWNhdGVkIG9uIGJyb3dzZXJzLCBidXQgd2lsbCBiZSBzZXQgYXBwcm9wcmlhdGVseSBmb3IgcmVhY3QtbmF0aXZlLlxuICByZXR1cm4gbmF2aWdhdG9yLnByb2R1Y3QgPT0gJ1JlYWN0TmF0aXZlJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2xvdWQoc2VydmVyVXJsOiBVUkwpIHtcbiAgcmV0dXJuIChcbiAgICBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LmNsb3VkJykgfHwgc2VydmVyVXJsLmhvc3RuYW1lLmVuZHNXaXRoKCcubGl2ZWtpdC5ydW4nKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRMS1JlYWN0TmF0aXZlSW5mbygpOiBMaXZlS2l0UmVhY3ROYXRpdmVJbmZvIHwgdW5kZWZpbmVkIHtcbiAgLy8gZ2xvYmFsIGRlZmluZWQgb25seSBmb3IgUmVhY3ROYXRpdmUuXG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGdsb2JhbCAmJiBnbG9iYWwuTGl2ZUtpdFJlYWN0TmF0aXZlR2xvYmFsKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBnbG9iYWwuTGl2ZUtpdFJlYWN0TmF0aXZlR2xvYmFsIGFzIExpdmVLaXRSZWFjdE5hdGl2ZUluZm87XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVhY3ROYXRpdmVPcygpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoIWlzUmVhY3ROYXRpdmUoKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gIGlmIChpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ucGxhdGZvcm07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpOiBudW1iZXIge1xuICBpZiAoaXNXZWIoKSkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBsZXQgaW5mbyA9IGdldExLUmVhY3ROYXRpdmVJbmZvKCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjE6IHN0cmluZywgdjI6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KCcuJyk7XG4gIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGsgPSBNYXRoLm1pbihwYXJ0czEubGVuZ3RoLCBwYXJ0czIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICBjb25zdCBwMSA9IHBhcnNlSW50KHBhcnRzMVtpXSwgMTApO1xuICAgIGNvbnN0IHAyID0gcGFyc2VJbnQocGFydHMyW2ldLCAxMCk7XG4gICAgaWYgKHAxID4gcDIpIHJldHVybiAxO1xuICAgIGlmIChwMSA8IHAyKSByZXR1cm4gLTE7XG4gICAgaWYgKGkgPT09IGsgLSAxICYmIHAxID09PSBwMikgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHYxID09PSAnJyAmJiB2MiAhPT0gJycpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodjIgPT09ICcnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIHBhcnRzMS5sZW5ndGggPT0gcGFydHMyLmxlbmd0aCA/IDAgOiBwYXJ0czEubGVuZ3RoIDwgcGFydHMyLmxlbmd0aCA/IC0xIDogMTtcbn1cblxuZnVuY3Rpb24gcm9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXM6IFJlc2l6ZU9ic2VydmVyRW50cnlbXSkge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAoZW50cnkudGFyZ2V0IGFzIE9ic2VydmFibGVNZWRpYUVsZW1lbnQpLmhhbmRsZVJlc2l6ZShlbnRyeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW9EaXNwYXRjaENhbGxiYWNrKGVudHJpZXM6IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlbXSkge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAoZW50cnkudGFyZ2V0IGFzIE9ic2VydmFibGVNZWRpYUVsZW1lbnQpLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKGVudHJ5KTtcbiAgfVxufVxuXG5sZXQgcmVzaXplT2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyIHwgbnVsbCA9IG51bGw7XG5leHBvcnQgY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghcmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJvRGlzcGF0Y2hDYWxsYmFjayk7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn07XG5cbmxldCBpbnRlcnNlY3Rpb25PYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfCBudWxsID0gbnVsbDtcbmV4cG9ydCBjb25zdCBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlciA9ICgpID0+IHtcbiAgaWYgKCFpbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgIGludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGlvRGlzcGF0Y2hDYWxsYmFjaywge1xuICAgICAgcm9vdDogbnVsbCxcbiAgICAgIHJvb3RNYXJnaW46ICcwcHgnLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCBleHRlbmRzIEhUTUxNZWRpYUVsZW1lbnQge1xuICBoYW5kbGVSZXNpemU6IChlbnRyeTogUmVzaXplT2JzZXJ2ZXJFbnRyeSkgPT4gdm9pZDtcbiAgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQ6IChlbnRyeTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENsaWVudEluZm8oKTogQ2xpZW50SW5mbyB7XG4gIGNvbnN0IGluZm8gPSBuZXcgQ2xpZW50SW5mbyh7XG4gICAgc2RrOiBDbGllbnRJbmZvX1NESy5KUyxcbiAgICBwcm90b2NvbDogcHJvdG9jb2xWZXJzaW9uLFxuICAgIHZlcnNpb24sXG4gIH0pO1xuXG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBpbmZvLm9zID0gZ2V0UmVhY3ROYXRpdmVPcygpID8/ICcnO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG5sZXQgZW1wdHlWaWRlb1N0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW1wdHlWaWRlb1N0cmVhbVRyYWNrKCkge1xuICBpZiAoIWVtcHR5VmlkZW9TdHJlYW1UcmFjaykge1xuICAgIGVtcHR5VmlkZW9TdHJlYW1UcmFjayA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygpO1xuICB9XG4gIHJldHVybiBlbXB0eVZpZGVvU3RyZWFtVHJhY2suY2xvbmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjayhcbiAgd2lkdGg6IG51bWJlciA9IDE2LFxuICBoZWlnaHQ6IG51bWJlciA9IDE2LFxuICBlbmFibGVkOiBib29sZWFuID0gZmFsc2UsXG4gIHBhaW50Q29udGVudDogYm9vbGVhbiA9IGZhbHNlLFxuKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAvLyB0aGUgY2FudmFzIHNpemUgaXMgc2V0IHRvIDE2IGJ5IGRlZmF1bHQsIGJlY2F1c2UgZWxlY3Ryb24gYXBwcyBzZWVtIHRvIGZhaWwgd2l0aCBzbWFsbGVyIHZhbHVlc1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eD8uZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgaWYgKHBhaW50Q29udGVudCAmJiBjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDUwLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnZ3JleSc7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IGR1bW15U3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oKTtcbiAgY29uc3QgW2R1bW15VHJhY2tdID0gZHVtbXlTdHJlYW0uZ2V0VHJhY2tzKCk7XG4gIGlmICghZHVtbXlUcmFjaykge1xuICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgZ2V0IGVtcHR5IG1lZGlhIHN0cmVhbSB2aWRlbyB0cmFjaycpO1xuICB9XG4gIGR1bW15VHJhY2suZW5hYmxlZCA9IGVuYWJsZWQ7XG5cbiAgcmV0dXJuIGR1bW15VHJhY2s7XG59XG5cbmxldCBlbXB0eUF1ZGlvU3RyZWFtVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2sgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93ZWJydGMvd2FybS11cC13aXRoLXJlcGxhY2V0cmFjay9cbiAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgY29uc3Qgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgY29uc3QgZ2FpbiA9IGN0eC5jcmVhdGVHYWluKCk7XG4gICAgZ2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIDApO1xuICAgIGNvbnN0IGRzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW4pO1xuICAgIGdhaW4uY29ubmVjdChkc3QpO1xuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICBbZW1wdHlBdWRpb1N0cmVhbVRyYWNrXSA9IGRzdC5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIGF1ZGlvIHRyYWNrJyk7XG4gICAgfVxuICAgIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuXG5leHBvcnQgY2xhc3MgRnV0dXJlPFQ+IHtcbiAgcHJvbWlzZTogUHJvbWlzZTxUPjtcblxuICByZXNvbHZlPzogKGFyZzogVCkgPT4gdm9pZDtcblxuICByZWplY3Q/OiAoZTogYW55KSA9PiB2b2lkO1xuXG4gIG9uRmluYWxseT86ICgpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgZnV0dXJlQmFzZT86IChyZXNvbHZlOiAoYXJnOiBUKSA9PiB2b2lkLCByZWplY3Q6IChlOiBhbnkpID0+IHZvaWQpID0+IHZvaWQsXG4gICAgb25GaW5hbGx5PzogKCkgPT4gdm9pZCxcbiAgKSB7XG4gICAgdGhpcy5vbkZpbmFsbHkgPSBvbkZpbmFsbHk7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2U8VD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgaWYgKGZ1dHVyZUJhc2UpIHtcbiAgICAgICAgYXdhaXQgZnV0dXJlQmFzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy5vbkZpbmFsbHk/LigpKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBBdWRpb0FuYWx5c2VyT3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIElmIHNldCB0byB0cnVlLCB0aGUgYW5hbHlzZXIgd2lsbCB1c2UgYSBjbG9uZWQgdmVyc2lvbiBvZiB0aGUgdW5kZXJseWluZyBtZWRpYXN0cmVhbXRyYWNrLCB3aGljaCB3b24ndCBiZSBpbXBhY3RlZCBieSBtdXRpbmcgdGhlIHRyYWNrLlxuICAgKiBVc2VmdWwgZm9yIGxvY2FsIHRyYWNrcyB3aGVuIGltcGxlbWVudGluZyB0aGluZ3MgbGlrZSBcInNlZW1zIGxpa2UgeW91J3JlIG11dGVkLCBidXQgdHJ5aW5nIHRvIHNwZWFrXCIuXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlXG4gICAqL1xuICBjbG9uZVRyYWNrPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5hbHlzZXJOb2RlL2ZmdFNpemVcbiAgICovXG4gIGZmdFNpemU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuYWx5c2VyTm9kZS9zbW9vdGhpbmdUaW1lQ29uc3RhbnRcbiAgICovXG4gIHNtb290aGluZ1RpbWVDb25zdGFudD86IG51bWJlcjtcbiAgLyoqXG4gICAqIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5hbHlzZXJOb2RlL21pbkRlY2liZWxzXG4gICAqL1xuICBtaW5EZWNpYmVscz86IG51bWJlcjtcbiAgLyoqXG4gICAqIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5hbHlzZXJOb2RlL21heERlY2liZWxzXG4gICAqL1xuICBtYXhEZWNpYmVscz86IG51bWJlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhbmFseXNlciB3ZWIgYXVkaW8gbm9kZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBwcm92aWRlZCB0cmFjay5cbiAqIEFkZGl0aW9uYWxseSByZXR1cm5zIGEgY29udmVuaWVuY2UgbWV0aG9kIGBjYWxjdWxhdGVWb2x1bWVgIHRvIHBlcmZvcm0gaW5zdGFudCB2b2x1bWUgcmVhZGluZ3Mgb24gdGhhdCB0cmFjay5cbiAqIENhbGwgdGhlIHJldHVybmVkIGBjbGVhbnVwYCBmdW5jdGlvbiB0byBjbG9zZSB0aGUgYXVkaW9Db250ZXh0IHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmb3IgdGhlIGluc3RhbmNlIG9mIHRoaXMgaGVscGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdWRpb0FuYWx5c2VyKFxuICB0cmFjazogTG9jYWxBdWRpb1RyYWNrIHwgUmVtb3RlQXVkaW9UcmFjayxcbiAgb3B0aW9ucz86IEF1ZGlvQW5hbHlzZXJPcHRpb25zLFxuKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgY2xvbmVUcmFjazogZmFsc2UsXG4gICAgZmZ0U2l6ZTogMjA0OCxcbiAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IDAuOCxcbiAgICBtaW5EZWNpYmVsczogLTEwMCxcbiAgICBtYXhEZWNpYmVsczogLTgwLFxuICAgIC4uLm9wdGlvbnMsXG4gIH07XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xuXG4gIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpbyBDb250ZXh0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyJyk7XG4gIH1cblxuICBjb25zdCBzdHJlYW1UcmFjayA9IG9wdHMuY2xvbmVUcmFjayA/IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKSA6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2s7XG4gIGNvbnN0IG1lZGlhU3RyZWFtU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbc3RyZWFtVHJhY2tdKSk7XG4gIGNvbnN0IGFuYWx5c2VyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gIGFuYWx5c2VyLm1pbkRlY2liZWxzID0gb3B0cy5taW5EZWNpYmVscztcbiAgYW5hbHlzZXIubWF4RGVjaWJlbHMgPSBvcHRzLm1heERlY2liZWxzO1xuICBhbmFseXNlci5mZnRTaXplID0gb3B0cy5mZnRTaXplO1xuICBhbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSBvcHRzLnNtb290aGluZ1RpbWVDb25zdGFudDtcblxuICBtZWRpYVN0cmVhbVNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQpO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdHJhY2sgaW4gdGhlIHJhbmdlIGZyb20gMCB0byAxXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVWb2x1bWUgPSAoKSA9PiB7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoZGF0YUFycmF5KTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtcGxpdHVkZSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhhbXBsaXR1ZGUgLyAyNTUsIDIpO1xuICAgIH1cbiAgICBjb25zdCB2b2x1bWUgPSBNYXRoLnNxcnQoc3VtIC8gZGF0YUFycmF5Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZvbHVtZTtcbiAgfTtcblxuICBjb25zdCBjbGVhbnVwID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgIGlmIChvcHRzLmNsb25lVHJhY2spIHtcbiAgICAgIHN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgY2FsY3VsYXRlVm9sdW1lLCBhbmFseXNlciwgY2xlYW51cCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWaWRlb0NvZGVjKG1heWJlQ29kZWM6IHN0cmluZyk6IG1heWJlQ29kZWMgaXMgVmlkZW9Db2RlYyB7XG4gIHJldHVybiB2aWRlb0NvZGVjcy5pbmNsdWRlcyhtYXliZUNvZGVjIGFzIFZpZGVvQ29kZWMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwQ29uc3RyYWludChjb25zdHJhaW50OiBDb25zdHJhaW5ET01TdHJpbmcpOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwQ29uc3RyYWludChjb25zdHJhaW50OiBDb25zdHJhaW5VTG9uZyk6IG51bWJlcjtcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBDb25zdHJhaW50KGNvbnN0cmFpbnQ6IENvbnN0cmFpbkRPTVN0cmluZyB8IENvbnN0cmFpblVMb25nKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29uc3RyYWludCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQpKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRbMF07XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuZXhhY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmV4YWN0KSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3RbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmV4YWN0O1xuICB9XG4gIGlmIChjb25zdHJhaW50LmlkZWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludC5pZGVhbCkpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsWzBdO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludC5pZGVhbDtcbiAgfVxuICB0aHJvdyBFcnJvcignY291bGQgbm90IHVud3JhcCBjb25zdHJhaW50Jyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1dlYnNvY2tldFVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9eKGh0dHApLywgJ3dzJyk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvSHR0cFVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnd3MnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXih3cykvLCAnaHR0cCcpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzKFxuICB0cmFuc2NyaXB0aW9uOiBUcmFuc2NyaXB0aW9uTW9kZWwsXG4gIGZpcnN0UmVjZWl2ZWRUaW1lc01hcDogTWFwPHN0cmluZywgbnVtYmVyPixcbik6IFRyYW5zY3JpcHRpb25TZWdtZW50W10ge1xuICByZXR1cm4gdHJhbnNjcmlwdGlvbi5zZWdtZW50cy5tYXAoKHsgaWQsIHRleHQsIGxhbmd1YWdlLCBzdGFydFRpbWUsIGVuZFRpbWUsIGZpbmFsIH0pID0+IHtcbiAgICBjb25zdCBmaXJzdFJlY2VpdmVkVGltZSA9IGZpcnN0UmVjZWl2ZWRUaW1lc01hcC5nZXQoaWQpID8/IERhdGUubm93KCk7XG4gICAgY29uc3QgbGFzdFJlY2VpdmVkVGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmaXJzdFJlY2VpdmVkVGltZXNNYXAuZGVsZXRlKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RSZWNlaXZlZFRpbWVzTWFwLnNldChpZCwgZmlyc3RSZWNlaXZlZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICB0ZXh0LFxuICAgICAgc3RhcnRUaW1lOiBOdW1iZXIucGFyc2VJbnQoc3RhcnRUaW1lLnRvU3RyaW5nKCkpLFxuICAgICAgZW5kVGltZTogTnVtYmVyLnBhcnNlSW50KGVuZFRpbWUudG9TdHJpbmcoKSksXG4gICAgICBmaW5hbCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgZmlyc3RSZWNlaXZlZFRpbWUsXG4gICAgICBsYXN0UmVjZWl2ZWRUaW1lLFxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENoYXRNZXNzYWdlKG1zZzogQ2hhdE1lc3NhZ2VNb2RlbCk6IENoYXRNZXNzYWdlIHtcbiAgY29uc3QgeyBpZCwgdGltZXN0YW1wLCBtZXNzYWdlLCBlZGl0VGltZXN0YW1wIH0gPSBtc2c7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdGltZXN0YW1wOiBOdW1iZXIucGFyc2VJbnQodGltZXN0YW1wLnRvU3RyaW5nKCkpLFxuICAgIGVkaXRUaW1lc3RhbXA6IGVkaXRUaW1lc3RhbXAgPyBOdW1iZXIucGFyc2VJbnQoZWRpdFRpbWVzdGFtcC50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzY29ubmVjdFJlYXNvbkZyb21Db25uZWN0aW9uRXJyb3IoZTogQ29ubmVjdGlvbkVycm9yKSB7XG4gIHN3aXRjaCAoZS5yZWFzb24pIHtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3Q6XG4gICAgICByZXR1cm4gZS5jb250ZXh0IGFzIERpc2Nvbm5lY3RSZWFzb247XG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkOlxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uQ0xJRU5UX0lOSVRJQVRFRDtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkOlxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uVVNFUl9SRUpFQ1RFRDtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZTpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLkpPSU5fRkFJTFVSRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIERpc2Nvbm5lY3RSZWFzb24uVU5LTk9XTl9SRUFTT047XG4gIH1cbn1cblxuLyoqIGNvbnZlcnQgYmlnaW50cyB0byBudW1iZXJzIHByZXNlcnZpbmcgdW5kZWZpbmVkIHZhbHVlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpZ0ludFRvTnVtYmVyPFQgZXh0ZW5kcyBCaWdJbnQgfCB1bmRlZmluZWQ+KFxuICB2YWx1ZTogVCxcbik6IFQgZXh0ZW5kcyBCaWdJbnQgPyBudW1iZXIgOiB1bmRlZmluZWQge1xuICByZXR1cm4gKHZhbHVlICE9PSB1bmRlZmluZWQgPyBOdW1iZXIodmFsdWUpIDogdW5kZWZpbmVkKSBhcyBUIGV4dGVuZHMgQmlnSW50ID8gbnVtYmVyIDogdW5kZWZpbmVkO1xufVxuXG4vKiogY29udmVydCBudW1iZXJzIHRvIGJpZ2ludHMgcHJlc2VydmluZyB1bmRlZmluZWQgdmFsdWVzICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CaWdJbnQ8VCBleHRlbmRzIG51bWJlciB8IHVuZGVmaW5lZD4oXG4gIHZhbHVlOiBULFxuKTogVCBleHRlbmRzIG51bWJlciA/IGJpZ2ludCA6IHVuZGVmaW5lZCB7XG4gIHJldHVybiAodmFsdWUgIT09IHVuZGVmaW5lZCA/IEJpZ0ludCh2YWx1ZSkgOiB1bmRlZmluZWQpIGFzIFQgZXh0ZW5kcyBudW1iZXIgPyBiaWdpbnQgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVHJhY2sodHJhY2s6IFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayB8IHVuZGVmaW5lZCk6IHRyYWNrIGlzIExvY2FsVHJhY2sge1xuICByZXR1cm4gISF0cmFjayAmJiAhKHRyYWNrIGluc3RhbmNlb2YgTWVkaWFTdHJlYW1UcmFjaykgJiYgdHJhY2suaXNMb2NhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXVkaW9UcmFjayhcbiAgdHJhY2s6IFRyYWNrIHwgdW5kZWZpbmVkLFxuKTogdHJhY2sgaXMgTG9jYWxBdWRpb1RyYWNrIHwgUmVtb3RlQXVkaW9UcmFjayB7XG4gIHJldHVybiAhIXRyYWNrICYmIHRyYWNrLmtpbmQgPT0gVHJhY2suS2luZC5BdWRpbztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmlkZW9UcmFjayhcbiAgdHJhY2s6IFRyYWNrIHwgdW5kZWZpbmVkLFxuKTogdHJhY2sgaXMgTG9jYWxWaWRlb1RyYWNrIHwgUmVtb3RlVmlkZW9UcmFjayB7XG4gIHJldHVybiAhIXRyYWNrICYmIHRyYWNrLmtpbmQgPT0gVHJhY2suS2luZC5WaWRlbztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxWaWRlb1RyYWNrKFxuICB0cmFjazogVHJhY2sgfCBNZWRpYVN0cmVhbVRyYWNrIHwgdW5kZWZpbmVkLFxuKTogdHJhY2sgaXMgTG9jYWxWaWRlb1RyYWNrIHtcbiAgcmV0dXJuIGlzTG9jYWxUcmFjayh0cmFjaykgJiYgaXNWaWRlb1RyYWNrKHRyYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxBdWRpb1RyYWNrKFxuICB0cmFjazogVHJhY2sgfCBNZWRpYVN0cmVhbVRyYWNrIHwgdW5kZWZpbmVkLFxuKTogdHJhY2sgaXMgTG9jYWxBdWRpb1RyYWNrIHtcbiAgcmV0dXJuIGlzTG9jYWxUcmFjayh0cmFjaykgJiYgaXNBdWRpb1RyYWNrKHRyYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVtb3RlVHJhY2sodHJhY2s6IFRyYWNrIHwgdW5kZWZpbmVkKTogdHJhY2sgaXMgUmVtb3RlVHJhY2sge1xuICByZXR1cm4gISF0cmFjayAmJiAhdHJhY2suaXNMb2NhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVtb3RlUHViKHB1YjogVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCk6IHB1YiBpcyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIHtcbiAgcmV0dXJuICEhcHViICYmICFwdWIuaXNMb2NhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTG9jYWxQdWIocHViOiBUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkKTogcHViIGlzIExvY2FsVHJhY2tQdWJsaWNhdGlvbiB7XG4gIHJldHVybiAhIXB1YiAmJiAhcHViLmlzTG9jYWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlbW90ZVZpZGVvVHJhY2sodHJhY2s6IFRyYWNrIHwgdW5kZWZpbmVkKTogdHJhY2sgaXMgUmVtb3RlVmlkZW9UcmFjayB7XG4gIHJldHVybiBpc1JlbW90ZVRyYWNrKHRyYWNrKSAmJiBpc1ZpZGVvVHJhY2sodHJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFBhcnRpY2lwYW50KHA6IFBhcnRpY2lwYW50KTogcCBpcyBMb2NhbFBhcnRpY2lwYW50IHtcbiAgcmV0dXJuIHAuaXNMb2NhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVtb3RlUGFydGljaXBhbnQocDogUGFydGljaXBhbnQpOiBwIGlzIFJlbW90ZVBhcnRpY2lwYW50IHtcbiAgcmV0dXJuICFwLmlzTG9jYWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFV0Zjgoczogc3RyaW5nLCBuOiBudW1iZXIpOiBVaW50OEFycmF5W10ge1xuICBpZiAobiA8IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ24gbXVzdCBiZSBhdCBsZWFzdCA0IGR1ZSB0byB1dGY4IGVuY29kaW5nIHJ1bGVzJyk7XG4gIH1cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82MDQzNzk3XG4gIGNvbnN0IHJlc3VsdDogVWludDhBcnJheVtdID0gW107XG4gIGxldCBlbmNvZGVkID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpO1xuICB3aGlsZSAoZW5jb2RlZC5sZW5ndGggPiBuKSB7XG4gICAgbGV0IGsgPSBuO1xuICAgIHdoaWxlIChrID4gMCkge1xuICAgICAgY29uc3QgYnl0ZSA9IGVuY29kZWRba107XG4gICAgICBpZiAoYnl0ZSAhPT0gdW5kZWZpbmVkICYmIChieXRlICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBrLS07XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKGVuY29kZWQuc2xpY2UoMCwgaykpO1xuICAgIGVuY29kZWQgPSBlbmNvZGVkLnNsaWNlKGspO1xuICB9XG4gIGlmIChlbmNvZGVkLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQucHVzaChlbmNvZGVkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHsgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSwgVHJhY2tTb3VyY2UgfSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvUHJvY2Vzc29yT3B0aW9ucywgVHJhY2tQcm9jZXNzb3IsIFZpZGVvUHJvY2Vzc29yT3B0aW9ucyB9IGZyb20gJy4uLy4uJztcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJy4uLy4uL3V0aWxzL2Nsb25lRGVlcCc7XG5pbXBvcnQgeyBpc1NhZmFyaSwgc2xlZXAgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFja1B1YmxpY2F0aW9uIH0gZnJvbSAnLi9UcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB7XG4gIHR5cGUgQXVkaW9DYXB0dXJlT3B0aW9ucyxcbiAgdHlwZSBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIHR5cGUgU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbiAgdHlwZSBWaWRlb0NhcHR1cmVPcHRpb25zLFxuICB0eXBlIFZpZGVvQ29kZWMsXG59IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvVHJhY2sgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbnMoXG4gIG9wdGlvbnM/OiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMsXG4gIGF1ZGlvRGVmYXVsdHM/OiBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICB2aWRlb0RlZmF1bHRzPzogVmlkZW9DYXB0dXJlT3B0aW9ucyxcbik6IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyB7XG4gIGNvbnN0IHsgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IsIGF1ZGlvUHJvY2Vzc29yLCB2aWRlb1Byb2Nlc3NvciB9ID0gZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyhcbiAgICBvcHRpb25zID8/IHt9LFxuICApO1xuICBjb25zdCBkZWZhdWx0QXVkaW9Qcm9jZXNzb3IgPSBhdWRpb0RlZmF1bHRzPy5wcm9jZXNzb3I7XG4gIGNvbnN0IGRlZmF1bHRWaWRlb1Byb2Nlc3NvciA9IHZpZGVvRGVmYXVsdHM/LnByb2Nlc3NvcjtcbiAgY29uc3QgY2xvbmVkT3B0aW9uczogQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zID0gY2xvbmVEZWVwKG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yKSA/PyB7fTtcbiAgaWYgKGNsb25lZE9wdGlvbnMuYXVkaW8gPT09IHRydWUpIGNsb25lZE9wdGlvbnMuYXVkaW8gPSB7fTtcbiAgaWYgKGNsb25lZE9wdGlvbnMudmlkZW8gPT09IHRydWUpIGNsb25lZE9wdGlvbnMudmlkZW8gPSB7fTtcblxuICAvLyB1c2UgZGVmYXVsdHNcbiAgaWYgKGNsb25lZE9wdGlvbnMuYXVkaW8pIHtcbiAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyhcbiAgICAgIGNsb25lZE9wdGlvbnMuYXVkaW8gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICBhdWRpb0RlZmF1bHRzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICk7XG4gICAgY2xvbmVkT3B0aW9ucy5hdWRpby5kZXZpY2VJZCA/Pz0geyBpZGVhbDogJ2RlZmF1bHQnIH07XG4gICAgaWYgKGF1ZGlvUHJvY2Vzc29yIHx8IGRlZmF1bHRBdWRpb1Byb2Nlc3Nvcikge1xuICAgICAgY2xvbmVkT3B0aW9ucy5hdWRpby5wcm9jZXNzb3IgPSBhdWRpb1Byb2Nlc3NvciA/PyBkZWZhdWx0QXVkaW9Qcm9jZXNzb3I7XG4gICAgfVxuICB9XG4gIGlmIChjbG9uZWRPcHRpb25zLnZpZGVvKSB7XG4gICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcoXG4gICAgICBjbG9uZWRPcHRpb25zLnZpZGVvIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgdmlkZW9EZWZhdWx0cyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICApO1xuICAgIGNsb25lZE9wdGlvbnMudmlkZW8uZGV2aWNlSWQgPz89IHsgaWRlYWw6ICdkZWZhdWx0JyB9O1xuICAgIGlmICh2aWRlb1Byb2Nlc3NvciB8fCBkZWZhdWx0VmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIGNsb25lZE9wdGlvbnMudmlkZW8ucHJvY2Vzc29yID0gdmlkZW9Qcm9jZXNzb3IgPz8gZGVmYXVsdFZpZGVvUHJvY2Vzc29yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkT3B0aW9ucztcbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcoXG4gIG1haW5PYmplY3Q6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBvYmplY3RUb01lcmdlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgT2JqZWN0LmtleXMob2JqZWN0VG9NZXJnZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKG1haW5PYmplY3Rba2V5XSA9PT0gdW5kZWZpbmVkKSBtYWluT2JqZWN0W2tleV0gPSBvYmplY3RUb01lcmdlW2tleV07XG4gIH0pO1xuICByZXR1cm4gbWFpbk9iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cmFpbnRzRm9yT3B0aW9ucyhvcHRpb25zOiBDcmVhdGVMb2NhbFRyYWNrc09wdGlvbnMpOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzIHtcbiAgY29uc3QgY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7fTtcblxuICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgIC8vIGRlZmF1bHQgdmlkZW8gb3B0aW9uc1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHZpZGVvT3B0aW9uczogTWVkaWFUcmFja0NvbnN0cmFpbnRzID0ge307XG4gICAgICBjb25zdCB0YXJnZXQgPSB2aWRlb09wdGlvbnMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnZpZGVvIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdyZXNvbHV0aW9uJzpcbiAgICAgICAgICAgIC8vIGZsYXR0ZW4gVmlkZW9SZXNvbHV0aW9uIGZpZWxkc1xuICAgICAgICAgICAgbWVyZ2VPYmplY3RXaXRob3V0T3ZlcndyaXRpbmcodGFyZ2V0LCBzb3VyY2UucmVzb2x1dGlvbiBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHZpZGVvT3B0aW9ucztcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID8/PSB7IGlkZWFsOiAnZGVmYXVsdCcgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBvcHRpb25zLnZpZGVvID8geyBkZXZpY2VJZDogeyBpZGVhbDogJ2RlZmF1bHQnIH0gfSA6IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdHJhaW50cy52aWRlbyA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IG9wdGlvbnMuYXVkaW87XG4gICAgICBjb25zdHJhaW50cy5hdWRpby5kZXZpY2VJZCA/Pz0geyBpZGVhbDogJ2RlZmF1bHQnIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0geyBkZXZpY2VJZDogeyBpZGVhbDogJ2RlZmF1bHQnIH0gfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3RyYWludHMuYXVkaW8gPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyBzaWxlbmNlIG9uIGEgZ2l2ZW4gW1tUcmFja11dIGluc3RhbmNlLlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFjayBzZWVtcyB0byBiZSBlbnRpcmVseSBzaWxlbnQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlY3RTaWxlbmNlKHRyYWNrOiBBdWRpb1RyYWNrLCB0aW1lT2Zmc2V0ID0gMjAwKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGN0eCA9IGdldE5ld0F1ZGlvQ29udGV4dCgpO1xuICBpZiAoY3R4KSB7XG4gICAgY29uc3QgYW5hbHlzZXIgPSBjdHguY3JlYXRlQW5hbHlzZXIoKTtcbiAgICBhbmFseXNlci5mZnRTaXplID0gMjA0ODtcblxuICAgIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgY29uc3Qgc291cmNlID0gY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG5ldyBNZWRpYVN0cmVhbShbdHJhY2subWVkaWFTdHJlYW1UcmFja10pKTtcblxuICAgIHNvdXJjZS5jb25uZWN0KGFuYWx5c2VyKTtcbiAgICBhd2FpdCBzbGVlcCh0aW1lT2Zmc2V0KTtcbiAgICBhbmFseXNlci5nZXRCeXRlVGltZURvbWFpbkRhdGEoZGF0YUFycmF5KTtcbiAgICBjb25zdCBzb21lTm9pc2UgPSBkYXRhQXJyYXkuc29tZSgoc2FtcGxlKSA9PiBzYW1wbGUgIT09IDEyOCAmJiBzYW1wbGUgIT09IDApO1xuICAgIGN0eC5jbG9zZSgpO1xuICAgIHJldHVybiAhc29tZU5vaXNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ld0F1ZGlvQ29udGV4dCgpOiBBdWRpb0NvbnRleHQgfCB2b2lkIHtcbiAgY29uc3QgQXVkaW9Db250ZXh0ID1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCk7XG4gIGlmIChBdWRpb0NvbnRleHQpIHtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHsgbGF0ZW5jeUhpbnQ6ICdpbnRlcmFjdGl2ZScgfSk7XG4gICAgLy8gSWYgdGhlIGF1ZGlvIGNvbnRleHQgaXMgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHJlc3VtZSBpdCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgcGFnZVxuICAgIGlmIChcbiAgICAgIGF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiZcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB3aW5kb3cuZG9jdW1lbnQ/LmJvZHlcbiAgICApIHtcbiAgICAgIGNvbnN0IGhhbmRsZVJlc3VtZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgYXdhaXQgYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgdHJ5aW5nIHRvIGF1dG8tcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5Py5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVJlc3VtZSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVSZXN1bWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXVkaW9Db250ZXh0O1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBraW5kVG9Tb3VyY2Uoa2luZDogTWVkaWFEZXZpY2VLaW5kKSB7XG4gIGlmIChraW5kID09PSAnYXVkaW9pbnB1dCcpIHtcbiAgICByZXR1cm4gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3VyY2VUb0tpbmQoc291cmNlOiBUcmFjay5Tb3VyY2UpOiBNZWRpYURldmljZUtpbmQgfCB1bmRlZmluZWQge1xuICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkge1xuICAgIHJldHVybiAnYXVkaW9pbnB1dCc7XG4gIH0gZWxzZSBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgcmV0dXJuICd2aWRlb2lucHV0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKFxuICBvcHRpb25zOiBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zLFxuKTogRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyB7XG4gIGxldCB2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgfCBib29sZWFuID0gb3B0aW9ucy52aWRlbyA/PyB0cnVlO1xuICAvLyB0cmVhdCAwIGFzIHVuY2FwcGVkXG4gIGlmIChvcHRpb25zLnJlc29sdXRpb24gJiYgb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoID4gMCAmJiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0ID4gMCkge1xuICAgIHZpZGVvQ29uc3RyYWludHMgPSB0eXBlb2YgdmlkZW9Db25zdHJhaW50cyA9PT0gJ2Jvb2xlYW4nID8ge30gOiB2aWRlb0NvbnN0cmFpbnRzO1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAuLi52aWRlb0NvbnN0cmFpbnRzLFxuICAgICAgICB3aWR0aDogeyBtYXg6IG9wdGlvbnMucmVzb2x1dGlvbi53aWR0aCB9LFxuICAgICAgICBoZWlnaHQ6IHsgbWF4OiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0IH0sXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvQ29uc3RyYWludHMgPSB7XG4gICAgICAgIC4uLnZpZGVvQ29uc3RyYWludHMsXG4gICAgICAgIHdpZHRoOiB7IGlkZWFsOiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGggfSxcbiAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0IH0sXG4gICAgICAgIGZyYW1lUmF0ZTogb3B0aW9ucy5yZXNvbHV0aW9uLmZyYW1lUmF0ZSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhdWRpbzogb3B0aW9ucy5hdWRpbyA/PyBmYWxzZSxcbiAgICB2aWRlbzogdmlkZW9Db25zdHJhaW50cyxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHN1cHBvcnQgZm9yIGV4cGVyaW1lbnRhbCBkaXNwbGF5IG1lZGlhIGZlYXR1cmVzXG4gICAgY29udHJvbGxlcjogb3B0aW9ucy5jb250cm9sbGVyLFxuICAgIHNlbGZCcm93c2VyU3VyZmFjZTogb3B0aW9ucy5zZWxmQnJvd3NlclN1cmZhY2UsXG4gICAgc3VyZmFjZVN3aXRjaGluZzogb3B0aW9ucy5zdXJmYWNlU3dpdGNoaW5nLFxuICAgIHN5c3RlbUF1ZGlvOiBvcHRpb25zLnN5c3RlbUF1ZGlvLFxuICAgIHByZWZlckN1cnJlbnRUYWI6IG9wdGlvbnMucHJlZmVyQ3VycmVudFRhYixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKG1pbWVUeXBlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIG1pbWVUeXBlLnNwbGl0KCcvJylbMV0udG9Mb3dlckNhc2UoKSBhcyBWaWRlb0NvZGVjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm88VCBleHRlbmRzIFRyYWNrUHVibGljYXRpb24+KFxuICB0cmFja3M6IFRbXSxcbik6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2VbXSB7XG4gIGNvbnN0IGluZm9zOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlW10gPSBbXTtcbiAgdHJhY2tzLmZvckVhY2goKHRyYWNrOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgaWYgKHRyYWNrLnRyYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZm9zLnB1c2goXG4gICAgICAgIG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKHtcbiAgICAgICAgICBjaWQ6IHRyYWNrLnRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgICAgdHJhY2s6IHRyYWNrLnRyYWNrSW5mbyxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbmZvcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2s6IFRyYWNrIHwgVHJhY2tQdWJsaWNhdGlvbik6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgaWYgKCdtZWRpYVN0cmVhbVRyYWNrJyBpbiB0cmFjaykge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFja0lEOiB0cmFjay5zaWQsXG4gICAgICBzb3VyY2U6IHRyYWNrLnNvdXJjZSxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgZW5hYmxlZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5lbmFibGVkLFxuICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgIHN0cmVhbUlEOiB0cmFjay5tZWRpYVN0cmVhbUlELFxuICAgICAgc3RyZWFtVHJhY2tJRDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZCxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFja0lEOiB0cmFjay50cmFja1NpZCxcbiAgICAgIGVuYWJsZWQ6IHRyYWNrLmlzRW5hYmxlZCxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgdHJhY2tJbmZvOiB7XG4gICAgICAgIG1pbWVUeXBlOiB0cmFjay5taW1lVHlwZSxcbiAgICAgICAgbmFtZTogdHJhY2sudHJhY2tOYW1lLFxuICAgICAgICBlbmNyeXB0ZWQ6IHRyYWNrLmlzRW5jcnlwdGVkLFxuICAgICAgICBraW5kOiB0cmFjay5raW5kLFxuICAgICAgICBzb3VyY2U6IHRyYWNrLnNvdXJjZSxcbiAgICAgICAgLi4uKHRyYWNrLnRyYWNrID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjay50cmFjaykgOiB7fSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1cHBvcnRzU3luY2hyb25pemF0aW9uU291cmNlcygpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBSVENSdHBSZWNlaXZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2dldFN5bmNocm9uaXphdGlvblNvdXJjZXMnIGluIFJUQ1J0cFJlY2VpdmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMoXG4gIG9sZFZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB8IHVuZGVmaW5lZCxcbiAgbmV3VmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkLFxuKSB7XG4gIGlmIChvbGRWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9sZFZhbHVlcyA9IHt9O1xuICB9XG4gIGlmIChuZXdWYWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5ld1ZhbHVlcyA9IHt9O1xuICB9XG4gIGNvbnN0IGFsbEtleXMgPSBbLi4uT2JqZWN0LmtleXMobmV3VmFsdWVzKSwgLi4uT2JqZWN0LmtleXMob2xkVmFsdWVzKV07XG4gIGNvbnN0IGRpZmY6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBhbGxLZXlzKSB7XG4gICAgaWYgKG9sZFZhbHVlc1trZXldICE9PSBuZXdWYWx1ZXNba2V5XSkge1xuICAgICAgZGlmZltrZXldID0gbmV3VmFsdWVzW2tleV0gPz8gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpZmY7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnM6IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucykge1xuICBjb25zdCBuZXdPcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gIGxldCBhdWRpb1Byb2Nlc3NvcjogVHJhY2tQcm9jZXNzb3I8VHJhY2suS2luZC5BdWRpbywgQXVkaW9Qcm9jZXNzb3JPcHRpb25zPiB8IHVuZGVmaW5lZDtcbiAgbGV0IHZpZGVvUHJvY2Vzc29yOiBUcmFja1Byb2Nlc3NvcjxUcmFjay5LaW5kLlZpZGVvLCBWaWRlb1Byb2Nlc3Nvck9wdGlvbnM+IHwgdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgbmV3T3B0aW9ucy5hdWRpby5wcm9jZXNzb3IpIHtcbiAgICBhdWRpb1Byb2Nlc3NvciA9IG5ld09wdGlvbnMuYXVkaW8ucHJvY2Vzc29yO1xuICAgIG5ld09wdGlvbnMuYXVkaW8gPSB7IC4uLm5ld09wdGlvbnMuYXVkaW8sIHByb2Nlc3NvcjogdW5kZWZpbmVkIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0JyAmJiBuZXdPcHRpb25zLnZpZGVvLnByb2Nlc3Nvcikge1xuICAgIHZpZGVvUHJvY2Vzc29yID0gbmV3T3B0aW9ucy52aWRlby5wcm9jZXNzb3I7XG4gICAgbmV3T3B0aW9ucy52aWRlbyA9IHsgLi4ubmV3T3B0aW9ucy52aWRlbywgcHJvY2Vzc29yOiB1bmRlZmluZWQgfTtcbiAgfVxuXG4gIHJldHVybiB7IGF1ZGlvUHJvY2Vzc29yLCB2aWRlb1Byb2Nlc3Nvciwgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3I6IG5ld09wdGlvbnMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYWNrU291cmNlRnJvbVByb3RvKHNvdXJjZTogVHJhY2tTb3VyY2UpOiBUcmFjay5Tb3VyY2Uge1xuICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgY2FzZSBUcmFja1NvdXJjZS5NSUNST1BIT05FOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcbiAgICAgIHJldHVybiBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFbmNyeXB0aW9uX1R5cGUsIFRyYWNrSW5mbyB9IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEV2ZW50RW1pdHRlciBmcm9tICd0eXBlZC1lbWl0dGVyJztcbmltcG9ydCBsb2csIHsgTG9nTGV2ZWwsIHdvcmtlckxvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSBSVENFbmdpbmUgZnJvbSAnLi4vcm9vbS9SVENFbmdpbmUnO1xuaW1wb3J0IHR5cGUgUm9vbSBmcm9tICcuLi9yb29tL1Jvb20nO1xuaW1wb3J0IHsgQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vcm9vbS9Sb29tJztcbmltcG9ydCB7IERldmljZVVuc3VwcG9ydGVkRXJyb3IgfSBmcm9tICcuLi9yb29tL2Vycm9ycyc7XG5pbXBvcnQgeyBFbmdpbmVFdmVudCwgUGFydGljaXBhbnRFdmVudCwgUm9vbUV2ZW50IH0gZnJvbSAnLi4vcm9vbS9ldmVudHMnO1xuaW1wb3J0IHR5cGUgUmVtb3RlVHJhY2sgZnJvbSAnLi4vcm9vbS90cmFjay9SZW1vdGVUcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrIH0gZnJvbSAnLi4vcm9vbS90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFZpZGVvQ29kZWMgfSBmcm9tICcuLi9yb29tL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcgfSBmcm9tICcuLi9yb29tL3RyYWNrL3V0aWxzJztcbmltcG9ydCB7IGlzTG9jYWxUcmFjayB9IGZyb20gJy4uL3Jvb20vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBCYXNlS2V5UHJvdmlkZXIgfSBmcm9tICcuL0tleVByb3ZpZGVyJztcbmltcG9ydCB7IEUyRUVfRkxBRyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IHR5cGUgRTJFRU1hbmFnZXJDYWxsYmFja3MsIEVuY3J5cHRpb25FdmVudCwgS2V5UHJvdmlkZXJFdmVudCB9IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHtcbiAgRTJFRU1hbmFnZXJPcHRpb25zLFxuICBFMkVFV29ya2VyTWVzc2FnZSxcbiAgRW5hYmxlTWVzc2FnZSxcbiAgRW5jb2RlTWVzc2FnZSxcbiAgSW5pdE1lc3NhZ2UsXG4gIEtleUluZm8sXG4gIFJUUFZpZGVvTWFwTWVzc2FnZSxcbiAgUmF0Y2hldFJlcXVlc3RNZXNzYWdlLFxuICBSZW1vdmVUcmFuc2Zvcm1NZXNzYWdlLFxuICBTZXRLZXlNZXNzYWdlLFxuICBTaWZUcmFpbGVyTWVzc2FnZSxcbiAgVXBkYXRlQ29kZWNNZXNzYWdlLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGlzRTJFRVN1cHBvcnRlZCwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlRTJFRU1hbmFnZXIge1xuICBzZXR1cChyb29tOiBSb29tKTogdm9pZDtcbiAgc2V0dXBFbmdpbmUoZW5naW5lOiBSVENFbmdpbmUpOiB2b2lkO1xuICBzZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQ6IGJvb2xlYW4sIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZyk6IHZvaWQ7XG4gIHNldFNpZlRyYWlsZXIodHJhaWxlcjogVWludDhBcnJheSk6IHZvaWQ7XG4gIG9uPEUgZXh0ZW5kcyBrZXlvZiBFMkVFTWFuYWdlckNhbGxiYWNrcz4oZXZlbnQ6IEUsIGxpc3RlbmVyOiBFMkVFTWFuYWdlckNhbGxiYWNrc1tFXSk6IHRoaXM7XG59XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY2xhc3MgRTJFRU1hbmFnZXJcbiAgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxFMkVFTWFuYWdlckNhbGxiYWNrcz4pXG4gIGltcGxlbWVudHMgQmFzZUUyRUVNYW5hZ2VyXG57XG4gIHByb3RlY3RlZCB3b3JrZXI6IFdvcmtlcjtcblxuICBwcm90ZWN0ZWQgcm9vbT86IFJvb207XG5cbiAgcHJpdmF0ZSBlbmNyeXB0aW9uRW5hYmxlZDogYm9vbGVhbjtcblxuICBwcml2YXRlIGtleVByb3ZpZGVyOiBCYXNlS2V5UHJvdmlkZXI7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogRTJFRU1hbmFnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleVByb3ZpZGVyID0gb3B0aW9ucy5rZXlQcm92aWRlcjtcbiAgICB0aGlzLndvcmtlciA9IG9wdGlvbnMud29ya2VyO1xuICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwKHJvb206IFJvb20pIHtcbiAgICBpZiAoIWlzRTJFRVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcihcbiAgICAgICAgJ3RyaWVkIHRvIHNldHVwIGVuZC10by1lbmQgZW5jcnlwdGlvbiBvbiBhbiB1bnN1cHBvcnRlZCBicm93c2VyJyxcbiAgICAgICk7XG4gICAgfVxuICAgIGxvZy5pbmZvKCdzZXR0aW5nIHVwIGUyZWUnKTtcbiAgICBpZiAocm9vbSAhPT0gdGhpcy5yb29tKSB7XG4gICAgICB0aGlzLnJvb20gPSByb29tO1xuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIHRoaXMua2V5UHJvdmlkZXIpO1xuICAgICAgLy8gdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCcnKTtcbiAgICAgIGNvbnN0IG1zZzogSW5pdE1lc3NhZ2UgPSB7XG4gICAgICAgIGtpbmQ6ICdpbml0JyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGtleVByb3ZpZGVyT3B0aW9uczogdGhpcy5rZXlQcm92aWRlci5nZXRPcHRpb25zKCksXG4gICAgICAgICAgbG9nbGV2ZWw6IHdvcmtlckxvZ2dlci5nZXRMZXZlbCgpIGFzIExvZ0xldmVsLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICBsb2cuaW5mbyhgaW5pdGlhbGl6aW5nIHdvcmtlcmAsIHsgd29ya2VyOiB0aGlzLndvcmtlciB9KTtcbiAgICAgICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gdGhpcy5vbldvcmtlck1lc3NhZ2U7XG4gICAgICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSB0aGlzLm9uV29ya2VyRXJyb3I7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChlbmFibGVkOiBib29sZWFuLCBwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcpIHtcbiAgICBsb2cuZGVidWcoYHNldCBlMmVlIHRvICR7ZW5hYmxlZH0gZm9yIHBhcnRpY2lwYW50ICR7cGFydGljaXBhbnRJZGVudGl0eX1gKTtcbiAgICB0aGlzLnBvc3RFbmFibGUoZW5hYmxlZCwgcGFydGljaXBhbnRJZGVudGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRTaWZUcmFpbGVyKHRyYWlsZXI6IFVpbnQ4QXJyYXkpIHtcbiAgICBpZiAoIXRyYWlsZXIgfHwgdHJhaWxlci5sZW5ndGggPT09IDApIHtcbiAgICAgIGxvZy53YXJuKFwiaWdub3Jpbmcgc2VydmVyIHNlbnQgdHJhaWxlciBhcyBpdCdzIGVtcHR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvc3RTaWZUcmFpbGVyKHRyYWlsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25Xb3JrZXJNZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8RTJFRVdvcmtlck1lc3NhZ2U+KSA9PiB7XG4gICAgY29uc3QgeyBraW5kLCBkYXRhIH0gPSBldi5kYXRhO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBsb2cuZXJyb3IoZGF0YS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGRhdGEuZXJyb3IpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2luaXRBY2snOlxuICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaCgoa2V5SW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlbmFibGUnOlxuICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaCgoa2V5SW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkICE9PSBkYXRhLmVuYWJsZWQgJiZcbiAgICAgICAgICBkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkgPT09IHRoaXMucm9vbT8ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXG4gICAgICAgICAgICBFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCxcbiAgICAgICAgICAgIGRhdGEuZW5hYmxlZCxcbiAgICAgICAgICAgIHRoaXMucm9vbSEubG9jYWxQYXJ0aWNpcGFudCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQgPSBkYXRhLmVuYWJsZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnJvb20/LmdldFBhcnRpY2lwYW50QnlJZGVudGl0eShkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYGNvdWxkbid0IHNldCBlbmNyeXB0aW9uIHN0YXR1cywgcGFydGljaXBhbnQgbm90IGZvdW5kJHtkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHl9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZGF0YS5lbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyYXRjaGV0S2V5JzpcbiAgICAgICAgdGhpcy5rZXlQcm92aWRlci5lbWl0KEtleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkLCBkYXRhLm1hdGVyaWFsLCBkYXRhLmtleUluZGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBvbldvcmtlckVycm9yID0gKGV2OiBFcnJvckV2ZW50KSA9PiB7XG4gICAgbG9nLmVycm9yKCdlMmVlIHdvcmtlciBlbmNvdW50ZXJlZCBhbiBlcnJvcjonLCB7IGVycm9yOiBldi5lcnJvciB9KTtcbiAgICB0aGlzLmVtaXQoRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXYuZXJyb3IpO1xuICB9O1xuXG4gIHB1YmxpYyBzZXR1cEVuZ2luZShlbmdpbmU6IFJUQ0VuZ2luZSkge1xuICAgIGVuZ2luZS5vbihFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgKHJ0cE1hcCkgPT4ge1xuICAgICAgdGhpcy5wb3N0UlRQTWFwKHJ0cE1hcCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRXZlbnRMaXN0ZW5lcnMocm9vbTogUm9vbSwga2V5UHJvdmlkZXI6IEJhc2VLZXlQcm92aWRlcikge1xuICAgIHJvb20ub24oUm9vbUV2ZW50LlRyYWNrUHVibGlzaGVkLCAocHViLCBwYXJ0aWNpcGFudCkgPT5cbiAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChcbiAgICAgICAgcHViLnRyYWNrSW5mbyEuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsXG4gICAgICAgIHBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgKSxcbiAgICApO1xuICAgIHJvb21cbiAgICAgIC5vbihSb29tRXZlbnQuQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCwgKHN0YXRlKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAgIHJvb20ucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2goKHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKFxuICAgICAgICAgICAgICAgIHB1Yi50cmFja0luZm8hLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FLFxuICAgICAgICAgICAgICAgIHBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIF8sIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG1zZzogUmVtb3ZlVHJhbnNmb3JtTWVzc2FnZSA9IHtcbiAgICAgICAgICBraW5kOiAncmVtb3ZlVHJhbnNmb3JtJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgICAgIHRyYWNrSWQ6IHRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53b3JrZXI/LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9KVxuICAgICAgLm9uKFJvb21FdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHViLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICB0aGlzLnNldHVwRTJFRVJlY2VpdmVyKHRyYWNrLCBwYXJ0aWNpcGFudC5pZGVudGl0eSwgcHViLnRyYWNrSW5mbyk7XG4gICAgICB9KVxuICAgICAgLm9uKFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb20pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCByb29tIHRvIGJlIHByZXNlbnQgb24gc2lnbmFsIGNvbm5lY3RgKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaCgoa2V5SW5mbykgPT4ge1xuICAgICAgICAgIHRoaXMucG9zdEtleShrZXlJbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChcbiAgICAgICAgICB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pc0UyRUVFbmFibGVkLFxuICAgICAgICAgIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50Lm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgYXN5bmMgKHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICB0aGlzLnNldHVwRTJFRVNlbmRlcihwdWJsaWNhdGlvbi50cmFjayEsIHB1YmxpY2F0aW9uLnRyYWNrIS5zZW5kZXIhKTtcbiAgICB9KTtcblxuICAgIGtleVByb3ZpZGVyXG4gICAgICAub24oS2V5UHJvdmlkZXJFdmVudC5TZXRLZXksIChrZXlJbmZvKSA9PiB0aGlzLnBvc3RLZXkoa2V5SW5mbykpXG4gICAgICAub24oS2V5UHJvdmlkZXJFdmVudC5SYXRjaGV0UmVxdWVzdCwgKHBhcnRpY2lwYW50SWQsIGtleUluZGV4KSA9PlxuICAgICAgICB0aGlzLnBvc3RSYXRjaGV0UmVxdWVzdChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCksXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZGVudGl0eT86IHN0cmluZywga2V5SW5kZXg/OiBudW1iZXIpIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHJhdGNoZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2c6IFJhdGNoZXRSZXF1ZXN0TWVzc2FnZSA9IHtcbiAgICAgIGtpbmQ6ICdyYXRjaGV0UmVxdWVzdCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIGtleUluZGV4LFxuICAgICAgfSxcbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cblxuICBwcml2YXRlIHBvc3RLZXkoeyBrZXksIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4IH06IEtleUluZm8pIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBFcnJvcignY291bGQgbm90IHNldCBrZXksIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IG1zZzogU2V0S2V5TWVzc2FnZSA9IHtcbiAgICAgIGtpbmQ6ICdzZXRLZXknLFxuICAgICAgZGF0YToge1xuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBpc1B1Ymxpc2hlcjogcGFydGljaXBhbnRJZGVudGl0eSA9PT0gdGhpcy5yb29tPy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5LFxuICAgICAgICBrZXksXG4gICAgICAgIGtleUluZGV4LFxuICAgICAgfSxcbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cblxuICBwcml2YXRlIHBvc3RFbmFibGUoZW5hYmxlZDogYm9vbGVhbiwgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMud29ya2VyKSB7XG4gICAgICBjb25zdCBlbmFibGVNc2c6IEVuYWJsZU1lc3NhZ2UgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmFibGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKGVuYWJsZU1zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignZmFpbGVkIHRvIGVuYWJsZSBlMmVlLCB3b3JrZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwb3N0UlRQTWFwKG1hcDogTWFwPG51bWJlciwgVmlkZW9Db2RlYz4pIHtcbiAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIHdvcmtlciBpcyBtaXNzaW5nJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yb29tPy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IHJ0cCBtYXAsIGxvY2FsIHBhcnRpY2lwYW50IGlkZW50aXR5IGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnOiBSVFBWaWRlb01hcE1lc3NhZ2UgPSB7XG4gICAgICBraW5kOiAnc2V0UlRQTWFwJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWFwLFxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3N0U2lmVHJhaWxlcih0cmFpbGVyOiBVaW50OEFycmF5KSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IFNJRiB0cmFpbGVyLCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2c6IFNpZlRyYWlsZXJNZXNzYWdlID0ge1xuICAgICAga2luZDogJ3NldFNpZlRyYWlsZXInLFxuICAgICAgZGF0YToge1xuICAgICAgICB0cmFpbGVyLFxuICAgICAgfSxcbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRTJFRVJlY2VpdmVyKHRyYWNrOiBSZW1vdGVUcmFjaywgcmVtb3RlSWQ6IHN0cmluZywgdHJhY2tJbmZvPzogVHJhY2tJbmZvKSB7XG4gICAgaWYgKCF0cmFjay5yZWNlaXZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyYWNrSW5mbz8ubWltZVR5cGUgfHwgdHJhY2tJbmZvLm1pbWVUeXBlID09PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWltZVR5cGUgbWlzc2luZyBmcm9tIHRyYWNrSW5mbywgY2Fubm90IHNldCB1cCBFMkVFIGNyeXB0b3InKTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVSZWNlaXZlcihcbiAgICAgIHRyYWNrLnJlY2VpdmVyLFxuICAgICAgdHJhY2subWVkaWFTdHJlYW1JRCxcbiAgICAgIHJlbW90ZUlkLFxuICAgICAgdHJhY2sua2luZCA9PT0gJ3ZpZGVvJyA/IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHRyYWNrSW5mby5taW1lVHlwZSkgOiB1bmRlZmluZWQsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBFMkVFU2VuZGVyKHRyYWNrOiBUcmFjaywgc2VuZGVyOiBSVENSdHBTZW5kZXIpIHtcbiAgICBpZiAoIWlzTG9jYWxUcmFjayh0cmFjaykgfHwgIXNlbmRlcikge1xuICAgICAgaWYgKCFzZW5kZXIpIGxvZy53YXJuKCdlYXJseSByZXR1cm4gYmVjYXVzZSBzZW5kZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2subWVkaWFTdHJlYW1JRCwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwUmVjZWl2ZXJ9IGJ5IGNyZWF0aW5nIGEge0Bjb2RlIFRyYW5zZm9ybVN0cmVhbX0gd2hpY2ggd2lsbCBpbmplY3RcbiAgICogYSBmcmFtZSBkZWNvZGVyLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSZWNlaXZlcihcbiAgICByZWNlaXZlcjogUlRDUnRwUmVjZWl2ZXIsXG4gICAgdHJhY2tJZDogc3RyaW5nLFxuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZyxcbiAgICBjb2RlYz86IFZpZGVvQ29kZWMsXG4gICkge1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAga2luZDogJ2RlY29kZScsXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIHRyYWNrSWQsXG4gICAgICAgIGNvZGVjLFxuICAgICAgfTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJlY2VpdmVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoRTJFRV9GTEFHIGluIHJlY2VpdmVyICYmIGNvZGVjKSB7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIGNvZGVjXG4gICAgICAgIGNvbnN0IG1zZzogVXBkYXRlQ29kZWNNZXNzYWdlID0ge1xuICAgICAgICAgIGtpbmQ6ICd1cGRhdGVDb2RlYycsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsZXQgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtID0gcmVjZWl2ZXIud3JpdGFibGVTdHJlYW07XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsZXQgcmVhZGFibGU6IFJlYWRhYmxlU3RyZWFtID0gcmVjZWl2ZXIucmVhZGFibGVTdHJlYW07XG4gICAgICBpZiAoIXdyaXRhYmxlIHx8ICFyZWFkYWJsZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHJlY2VpdmVyU3RyZWFtcyA9IHJlY2VpdmVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVjZWl2ZXIud3JpdGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgIHdyaXRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLndyaXRhYmxlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICByZWFkYWJsZSA9IHJlY2VpdmVyU3RyZWFtcy5yZWFkYWJsZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbXNnOiBFbmNvZGVNZXNzYWdlID0ge1xuICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHJlYWRhYmxlU3RyZWFtOiByZWFkYWJsZSxcbiAgICAgICAgICB3cml0YWJsZVN0cmVhbTogd3JpdGFibGUsXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2tJZCxcbiAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZywgW3JlYWRhYmxlLCB3cml0YWJsZV0pO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZWNlaXZlcltFMkVFX0ZMQUddID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwU2VuZGVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XG4gICAqIGEgZnJhbWUgZW5jb2Rlci5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlU2VuZGVyKHNlbmRlcjogUlRDUnRwU2VuZGVyLCB0cmFja0lkOiBzdHJpbmcsIGNvZGVjPzogVmlkZW9Db2RlYykge1xuICAgIGlmIChFMkVFX0ZMQUcgaW4gc2VuZGVyIHx8ICF0aGlzLndvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5yb29tPy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5IHx8IHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID09PSAnJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdsb2NhbCBpZGVudGl0eSBuZWVkcyB0byBiZSBrbm93biBpbiBvcmRlciB0byBzZXQgdXAgZW5jcnlwdGVkIHNlbmRlcicpO1xuICAgIH1cblxuICAgIGlmIChpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpKSB7XG4gICAgICBsb2cuaW5mbygnaW5pdGlhbGl6ZSBzY3JpcHQgdHJhbnNmb3JtJyk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBraW5kOiAnZW5jb2RlJyxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgIHRyYWNrSWQsXG4gICAgICAgIGNvZGVjLFxuICAgICAgfTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHNlbmRlci50cmFuc2Zvcm0gPSBuZXcgUlRDUnRwU2NyaXB0VHJhbnNmb3JtKHRoaXMud29ya2VyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmluZm8oJ2luaXRpYWxpemUgZW5jb2RlZCBzdHJlYW1zJyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBzZW5kZXJTdHJlYW1zID0gc2VuZGVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICBjb25zdCBtc2c6IEVuY29kZU1lc3NhZ2UgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVhZGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMucmVhZGFibGUsXG4gICAgICAgICAgd3JpdGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMud3JpdGFibGUsXG4gICAgICAgICAgY29kZWMsXG4gICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtzZW5kZXJTdHJlYW1zLnJlYWRhYmxlLCBzZW5kZXJTdHJlYW1zLndyaXRhYmxlXSk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHNlbmRlcltFMkVFX0ZMQUddID0gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgaXNTYWZhcmkgfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgZGVmYXVsdElkID0gJ2RlZmF1bHQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZXZpY2VNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U/OiBEZXZpY2VNYW5hZ2VyO1xuXG4gIHN0YXRpYyBtZWRpYURldmljZUtpbmRzOiBNZWRpYURldmljZUtpbmRbXSA9IFsnYXVkaW9pbnB1dCcsICdhdWRpb291dHB1dCcsICd2aWRlb2lucHV0J107XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IERldmljZU1hbmFnZXIge1xuICAgIGlmICh0aGlzLmluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGV2aWNlTWFuYWdlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgfVxuXG4gIHN0YXRpYyB1c2VyTWVkaWFQcm9taXNlTWFwOiBNYXA8TWVkaWFEZXZpY2VLaW5kLCBQcm9taXNlPE1lZGlhU3RyZWFtPj4gPSBuZXcgTWFwKCk7XG5cbiAgcHJpdmF0ZSBfcHJldmlvdXNEZXZpY2VzOiBNZWRpYURldmljZUluZm9bXSA9IFtdO1xuXG4gIGdldCBwcmV2aW91c0RldmljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRGV2aWNlcztcbiAgfVxuXG4gIGFzeW5jIGdldERldmljZXMoXG4gICAga2luZD86IE1lZGlhRGV2aWNlS2luZCxcbiAgICByZXF1ZXN0UGVybWlzc2lvbnM6IGJvb2xlYW4gPSB0cnVlLFxuICApOiBQcm9taXNlPE1lZGlhRGV2aWNlSW5mb1tdPiB7XG4gICAgaWYgKERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcD8uc2l6ZSA+IDApIHtcbiAgICAgIGxvZy5kZWJ1ZygnYXdhaXRpbmcgZ2V0VXNlck1lZGlhIHByb21pc2UnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChraW5kKSB7XG4gICAgICAgICAgYXdhaXQgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmdldChraW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgbG9nLndhcm4oJ2Vycm9yIHdhaXRpbmcgZm9yIG1lZGlhIHBlcm1pc3NvbnMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcblxuICAgIGlmIChcbiAgICAgIHJlcXVlc3RQZXJtaXNzaW9ucyAmJlxuICAgICAgLy8gZm9yIHNhZmFyaSB3ZSBuZWVkIHRvIHNraXAgdGhpcyBjaGVjaywgYXMgb3RoZXJ3aXNlIGl0IHdpbGwgcmUtYWNxdWlyZSB1c2VyIG1lZGlhIGFuZCBmYWlsIG9uIGlPUyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc5MzYzXG4gICAgICAhKGlzU2FmYXJpKCkgJiYgdGhpcy5oYXNEZXZpY2VJblVzZShraW5kKSlcbiAgICApIHtcbiAgICAgIGNvbnN0IGlzRHVtbXlEZXZpY2VPckVtcHR5ID1cbiAgICAgICAgZGV2aWNlcy5maWx0ZXIoKGQpID0+IGQua2luZCA9PT0ga2luZCkubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIGRldmljZXMuc29tZSgoZGV2aWNlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9MYWJlbCA9IGRldmljZS5sYWJlbCA9PT0gJyc7XG4gICAgICAgICAgY29uc3QgaXNSZWxldmFudCA9IGtpbmQgPyBkZXZpY2Uua2luZCA9PT0ga2luZCA6IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG5vTGFiZWwgJiYgaXNSZWxldmFudDtcbiAgICAgICAgfSk7XG5cbiAgICAgIGlmIChpc0R1bW15RGV2aWNlT3JFbXB0eSkge1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uc1RvQWNxdWlyZSA9IHtcbiAgICAgICAgICB2aWRlbzoga2luZCAhPT0gJ2F1ZGlvaW5wdXQnICYmIGtpbmQgIT09ICdhdWRpb291dHB1dCcsXG4gICAgICAgICAgYXVkaW86IGtpbmQgIT09ICd2aWRlb2lucHV0JyAmJiB7IGRldmljZUlkOiB7IGlkZWFsOiAnZGVmYXVsdCcgfSB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShwZXJtaXNzaW9uc1RvQWNxdWlyZSk7XG4gICAgICAgIGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB7XG4gICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcHJldmlvdXNEZXZpY2VzID0gZGV2aWNlcztcblxuICAgIGlmIChraW5kKSB7XG4gICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoKGRldmljZSkgPT4gZGV2aWNlLmtpbmQgPT09IGtpbmQpO1xuICAgIH1cbiAgICByZXR1cm4gZGV2aWNlcztcbiAgfVxuXG4gIGFzeW5jIG5vcm1hbGl6ZURldmljZUlkKFxuICAgIGtpbmQ6IE1lZGlhRGV2aWNlS2luZCxcbiAgICBkZXZpY2VJZD86IHN0cmluZyxcbiAgICBncm91cElkPzogc3RyaW5nLFxuICApOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChkZXZpY2VJZCAhPT0gZGVmYXVsdElkKSB7XG4gICAgICByZXR1cm4gZGV2aWNlSWQ7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBhY3R1YWwgZGV2aWNlIGlkIGlmIGl0J3MgJ2RlZmF1bHQnOiBDaHJvbWUgcmV0dXJucyBpdCB3aGVuIG5vXG4gICAgLy8gZGV2aWNlIGhhcyBiZWVuIGNob3NlblxuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldERldmljZXMoa2luZCk7XG5cbiAgICBjb25zdCBkZWZhdWx0RGV2aWNlID0gZGV2aWNlcy5maW5kKChkKSA9PiBkLmRldmljZUlkID09PSBkZWZhdWx0SWQpO1xuXG4gICAgaWYgKCFkZWZhdWx0RGV2aWNlKSB7XG4gICAgICBsb2cud2FybignY291bGQgbm90IHJlbGlhYmx5IGRldGVybWluZSBkZWZhdWx0IGRldmljZScpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBkZXZpY2UgPSBkZXZpY2VzLmZpbmQoXG4gICAgICAoZCkgPT4gZC5kZXZpY2VJZCAhPT0gZGVmYXVsdElkICYmIGQuZ3JvdXBJZCA9PT0gKGdyb3VwSWQgPz8gZGVmYXVsdERldmljZS5ncm91cElkKSxcbiAgICApO1xuXG4gICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgIGxvZy53YXJuKCdjb3VsZCBub3QgcmVsaWFibHkgZGV0ZXJtaW5lIGRlZmF1bHQgZGV2aWNlJyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBkZXZpY2U/LmRldmljZUlkO1xuICB9XG5cbiAgcHJpdmF0ZSBoYXNEZXZpY2VJblVzZShraW5kPzogTWVkaWFEZXZpY2VLaW5kKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGtpbmRcbiAgICAgID8gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmhhcyhraW5kKVxuICAgICAgOiBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2l6ZSA+IDA7XG4gIH1cbn1cbiIsImltcG9ydCB7IE11dGV4IH0gZnJvbSAnQGxpdmVraXQvbXV0ZXgnO1xuXG50eXBlIFF1ZXVlVGFzazxUPiA9ICgpID0+IFByb21pc2VMaWtlPFQ+O1xuXG5lbnVtIFF1ZXVlVGFza1N0YXR1cyB7XG4gICdXQUlUSU5HJyxcbiAgJ1JVTk5JTkcnLFxuICAnQ09NUExFVEVEJyxcbn1cblxudHlwZSBRdWV1ZVRhc2tJbmZvID0ge1xuICBpZDogbnVtYmVyO1xuICBlbnF1ZXVlZEF0OiBudW1iZXI7XG4gIGV4ZWN1dGVkQXQ/OiBudW1iZXI7XG4gIHN0YXR1czogUXVldWVUYXNrU3RhdHVzO1xufTtcblxuZXhwb3J0IGNsYXNzIEFzeW5jUXVldWUge1xuICBwcml2YXRlIHBlbmRpbmdUYXNrczogTWFwPG51bWJlciwgUXVldWVUYXNrSW5mbz47XG5cbiAgcHJpdmF0ZSB0YXNrTXV0ZXg6IE11dGV4O1xuXG4gIHByaXZhdGUgbmV4dFRhc2tJbmRleDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudGFza011dGV4ID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5uZXh0VGFza0luZGV4ID0gMDtcbiAgfVxuXG4gIGFzeW5jIHJ1bjxUPih0YXNrOiBRdWV1ZVRhc2s8VD4pIHtcbiAgICBjb25zdCB0YXNrSW5mbzogUXVldWVUYXNrSW5mbyA9IHtcbiAgICAgIGlkOiB0aGlzLm5leHRUYXNrSW5kZXgrKyxcbiAgICAgIGVucXVldWVkQXQ6IERhdGUubm93KCksXG4gICAgICBzdGF0dXM6IFF1ZXVlVGFza1N0YXR1cy5XQUlUSU5HLFxuICAgIH07XG4gICAgdGhpcy5wZW5kaW5nVGFza3Muc2V0KHRhc2tJbmZvLmlkLCB0YXNrSW5mbyk7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy50YXNrTXV0ZXgubG9jaygpO1xuICAgIHRyeSB7XG4gICAgICB0YXNrSW5mby5leGVjdXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5SVU5OSU5HO1xuICAgICAgcmV0dXJuIGF3YWl0IHRhc2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFza0luZm8uc3RhdHVzID0gUXVldWVUYXNrU3RhdHVzLkNPTVBMRVRFRDtcbiAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZSh0YXNrSW5mby5pZCk7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5ydW4oYXN5bmMgKCkgPT4ge30pO1xuICB9XG5cbiAgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wZW5kaW5nVGFza3MudmFsdWVzKCkpO1xuICB9XG59XG4iLCJpbXBvcnQgeyB0b0h0dHBVcmwgfSBmcm9tICcuLi9yb29tL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJ0Y1VybCh1cmw6IHN0cmluZywgc2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHVybE9iai5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGFwcGVuZFVybFBhdGgodXJsT2JqLCAncnRjJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWYWxpZGF0ZVVybChydGNXc1VybDogc3RyaW5nKSB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9IdHRwVXJsKHJ0Y1dzVXJsKSk7XG4gIHJldHVybiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgJ3ZhbGlkYXRlJyk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVRyYWlsaW5nU2xhc2gocGF0aDogc3RyaW5nKSB7XG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgPyBwYXRoIDogYCR7cGF0aH0vYDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kVXJsUGF0aCh1cmxPYmo6IFVSTCwgcGF0aDogc3RyaW5nKSB7XG4gIHVybE9iai5wYXRobmFtZSA9IGAke2Vuc3VyZVRyYWlsaW5nU2xhc2godXJsT2JqLnBhdGhuYW1lKX0ke3BhdGh9YDtcbiAgcmV0dXJuIHVybE9iai50b1N0cmluZygpO1xufVxuIiwiaW1wb3J0IHsgTXV0ZXggfSBmcm9tICdAbGl2ZWtpdC9tdXRleCc7XG5pbXBvcnQge1xuICBBZGRUcmFja1JlcXVlc3QsXG4gIEF1ZGlvVHJhY2tGZWF0dXJlLFxuICBDbGllbnRJbmZvLFxuICBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSxcbiAgRGlzY29ubmVjdFJlYXNvbixcbiAgSm9pblJlc3BvbnNlLFxuICBMZWF2ZVJlcXVlc3QsXG4gIExlYXZlUmVxdWVzdF9BY3Rpb24sXG4gIE11dGVUcmFja1JlcXVlc3QsXG4gIFBhcnRpY2lwYW50SW5mbyxcbiAgUGluZyxcbiAgUmVjb25uZWN0UmVhc29uLFxuICBSZWNvbm5lY3RSZXNwb25zZSxcbiAgUmVxdWVzdFJlc3BvbnNlLFxuICBSb29tLFxuICBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIFNpZ25hbFJlcXVlc3QsXG4gIFNpZ25hbFJlc3BvbnNlLFxuICBTaWduYWxUYXJnZXQsXG4gIFNpbXVsYXRlU2NlbmFyaW8sXG4gIFNwZWFrZXJJbmZvLFxuICBTdHJlYW1TdGF0ZVVwZGF0ZSxcbiAgU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsXG4gIFN1YnNjcmlwdGlvblBlcm1pc3Npb24sXG4gIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXG4gIFN1YnNjcmlwdGlvblJlc3BvbnNlLFxuICBTeW5jU3RhdGUsXG4gIFRyYWNrUGVybWlzc2lvbixcbiAgVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcbiAgVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlLFxuICBUcmlja2xlUmVxdWVzdCxcbiAgVXBkYXRlTG9jYWxBdWRpb1RyYWNrLFxuICBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhLFxuICBVcGRhdGVTdWJzY3JpcHRpb24sXG4gIFVwZGF0ZVRyYWNrU2V0dGluZ3MsXG4gIFVwZGF0ZVZpZGVvTGF5ZXJzLFxuICBWaWRlb0xheWVyLFxuICBwcm90b0ludDY0LFxufSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24gfSBmcm9tICcuLi9yb29tL2Vycm9ycyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi4vcm9vbS90aW1lcnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vcm9vbS90eXBlcyc7XG5pbXBvcnQgeyBnZXRDbGllbnRJbmZvLCBpc1JlYWN0TmF0aXZlLCBzbGVlcCB9IGZyb20gJy4uL3Jvb20vdXRpbHMnO1xuaW1wb3J0IHsgQXN5bmNRdWV1ZSB9IGZyb20gJy4uL3V0aWxzL0FzeW5jUXVldWUnO1xuaW1wb3J0IHsgY3JlYXRlUnRjVXJsLCBjcmVhdGVWYWxpZGF0ZVVybCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vLyBpbnRlcm5hbCBvcHRpb25zXG5pbnRlcmZhY2UgQ29ubmVjdE9wdHMgZXh0ZW5kcyBTaWduYWxPcHRpb25zIHtcbiAgLyoqIGludGVybmFsICovXG4gIHJlY29ubmVjdD86IGJvb2xlYW47XG4gIC8qKiBpbnRlcm5hbCAqL1xuICByZWNvbm5lY3RSZWFzb24/OiBudW1iZXI7XG4gIC8qKiBpbnRlcm5hbCAqL1xuICBzaWQ/OiBzdHJpbmc7XG59XG5cbi8vIHB1YmxpYyBvcHRpb25zXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25hbE9wdGlvbnMge1xuICBhdXRvU3Vic2NyaWJlOiBib29sZWFuO1xuICBhZGFwdGl2ZVN0cmVhbT86IGJvb2xlYW47XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgZTJlZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHdlYnNvY2tldFRpbWVvdXQ6IG51bWJlcjtcbn1cblxudHlwZSBTaWduYWxNZXNzYWdlID0gU2lnbmFsUmVxdWVzdFsnbWVzc2FnZSddO1xuXG50eXBlIFNpZ25hbEtpbmQgPSBOb25OdWxsYWJsZTxTaWduYWxNZXNzYWdlPlsnY2FzZSddO1xuXG5jb25zdCBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFsczogQXJyYXk8U2lnbmFsS2luZD4gPSBbXG4gICdzeW5jU3RhdGUnLFxuICAndHJpY2tsZScsXG4gICdvZmZlcicsXG4gICdhbnN3ZXInLFxuICAnc2ltdWxhdGUnLFxuICAnbGVhdmUnLFxuXTtcblxuZnVuY3Rpb24gY2FuUGFzc1Rocm91Z2hRdWV1ZShyZXE6IFNpZ25hbE1lc3NhZ2UpOiBib29sZWFuIHtcbiAgY29uc3QgY2FuUGFzcyA9IHBhc3NUaHJvdWdoUXVldWVTaWduYWxzLmluZGV4T2YocmVxIS5jYXNlKSA+PSAwO1xuICBsb2cudHJhY2UoJ3JlcXVlc3QgYWxsb3dlZCB0byBieXBhc3MgcXVldWU6JywgeyBjYW5QYXNzLCByZXEgfSk7XG4gIHJldHVybiBjYW5QYXNzO1xufVxuXG5leHBvcnQgZW51bSBTaWduYWxDb25uZWN0aW9uU3RhdGUge1xuICBDT05ORUNUSU5HLFxuICBDT05ORUNURUQsXG4gIFJFQ09OTkVDVElORyxcbiAgRElTQ09OTkVDVElORyxcbiAgRElTQ09OTkVDVEVELFxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU2lnbmFsQ2xpZW50IHtcbiAgcmVxdWVzdFF1ZXVlOiBBc3luY1F1ZXVlO1xuXG4gIHF1ZXVlZFJlcXVlc3RzOiBBcnJheTwoKSA9PiBQcm9taXNlPHZvaWQ+PjtcblxuICB1c2VKU09OOiBib29sZWFuO1xuXG4gIC8qKiBzaWduYWwgcnR0IGluIG1pbGxpc2Vjb25kcyAqL1xuICBydHQ6IG51bWJlciA9IDA7XG5cbiAgLyoqIHNpbXVsYXRlIHNpZ25hbGluZyBsYXRlbmN5IGJ5IGRlbGF5aW5nIG1lc3NhZ2VzICovXG4gIHNpZ25hbExhdGVuY3k/OiBudW1iZXI7XG5cbiAgb25DbG9zZT86IChyZWFzb246IHN0cmluZykgPT4gdm9pZDtcblxuICBvbkFuc3dlcj86IChzZDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkgPT4gdm9pZDtcblxuICBvbk9mZmVyPzogKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSA9PiB2b2lkO1xuXG4gIC8vIHdoZW4gYSBuZXcgSUNFIGNhbmRpZGF0ZSBpcyBtYWRlIGF2YWlsYWJsZVxuICBvblRyaWNrbGU/OiAoc2Q6IFJUQ0ljZUNhbmRpZGF0ZUluaXQsIHRhcmdldDogU2lnbmFsVGFyZ2V0KSA9PiB2b2lkO1xuXG4gIG9uUGFydGljaXBhbnRVcGRhdGU/OiAodXBkYXRlczogUGFydGljaXBhbnRJbmZvW10pID0+IHZvaWQ7XG5cbiAgb25Mb2NhbFRyYWNrUHVibGlzaGVkPzogKHJlczogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSkgPT4gdm9pZDtcblxuICBvbk5lZ290aWF0ZVJlcXVlc3RlZD86ICgpID0+IHZvaWQ7XG5cbiAgb25TcGVha2Vyc0NoYW5nZWQ/OiAocmVzOiBTcGVha2VySW5mb1tdKSA9PiB2b2lkO1xuXG4gIG9uUmVtb3RlTXV0ZUNoYW5nZWQ/OiAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG5cbiAgb25Sb29tVXBkYXRlPzogKHJvb206IFJvb20pID0+IHZvaWQ7XG5cbiAgb25Db25uZWN0aW9uUXVhbGl0eT86ICh1cGRhdGU6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKSA9PiB2b2lkO1xuXG4gIG9uU3RyZWFtU3RhdGVVcGRhdGU/OiAodXBkYXRlOiBTdHJlYW1TdGF0ZVVwZGF0ZSkgPT4gdm9pZDtcblxuICBvblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlPzogKHVwZGF0ZTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpID0+IHZvaWQ7XG5cbiAgb25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlPzogKHVwZGF0ZTogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkgPT4gdm9pZDtcblxuICBvblN1YnNjcmlwdGlvbkVycm9yPzogKHVwZGF0ZTogU3Vic2NyaXB0aW9uUmVzcG9uc2UpID0+IHZvaWQ7XG5cbiAgb25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQ/OiAocmVzOiBUcmFja1VucHVibGlzaGVkUmVzcG9uc2UpID0+IHZvaWQ7XG5cbiAgb25Ub2tlblJlZnJlc2g/OiAodG9rZW46IHN0cmluZykgPT4gdm9pZDtcblxuICBvbkxlYXZlPzogKGxlYXZlOiBMZWF2ZVJlcXVlc3QpID0+IHZvaWQ7XG5cbiAgb25SZXF1ZXN0UmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlcXVlc3RSZXNwb25zZSkgPT4gdm9pZDtcblxuICBvbkxvY2FsVHJhY2tTdWJzY3JpYmVkPzogKHRyYWNrU2lkOiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgY29ubmVjdE9wdGlvbnM/OiBDb25uZWN0T3B0cztcblxuICB3cz86IFdlYlNvY2tldDtcblxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG5cbiAgZ2V0IGlzRGlzY29ubmVjdGVkKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TmV4dFJlcXVlc3RJZCgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgKz0gMTtcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdElkO1xuICB9XG5cbiAgcHJpdmF0ZSBvcHRpb25zPzogU2lnbmFsT3B0aW9ucztcblxuICBwcml2YXRlIHBpbmdUaW1lb3V0OiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHBpbmdUaW1lb3V0RHVyYXRpb246IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHBpbmdJbnRlcnZhbER1cmF0aW9uOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBwaW5nSW50ZXJ2YWw6IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGNsb3NpbmdMb2NrOiBNdXRleDtcblxuICBwcml2YXRlIHN0YXRlOiBTaWduYWxDb25uZWN0aW9uU3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuXG4gIHByaXZhdGUgY29ubmVjdGlvbkxvY2s6IE11dGV4O1xuXG4gIHByaXZhdGUgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyQ29udGV4dENiPzogTG9nZ2VyT3B0aW9uc1snbG9nZ2VyQ29udGV4dENiJ107XG5cbiAgcHJpdmF0ZSBfcmVxdWVzdElkID0gMDtcblxuICBjb25zdHJ1Y3Rvcih1c2VKU09OOiBib29sZWFuID0gZmFsc2UsIGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5TaWduYWwpO1xuICAgIHRoaXMubG9nZ2VyQ29udGV4dENiID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I7XG4gICAgdGhpcy51c2VKU09OID0gdXNlSlNPTjtcbiAgICB0aGlzLnJlcXVlc3RRdWV1ZSA9IG5ldyBBc3luY1F1ZXVlKCk7XG4gICAgdGhpcy5xdWV1ZWRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuY2xvc2luZ0xvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Mb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gIH1cblxuICBwcml2YXRlIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmxvZ2dlckNvbnRleHRDYj8uKCkgPz8ge307XG4gIH1cblxuICBhc3luYyBqb2luKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgb3B0czogU2lnbmFsT3B0aW9ucyxcbiAgICBhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsLFxuICApOiBQcm9taXNlPEpvaW5SZXNwb25zZT4ge1xuICAgIC8vIGR1cmluZyBhIGZ1bGwgcmVjb25uZWN0LCB3ZSdkIHdhbnQgdG8gc3RhcnQgdGhlIHNlcXVlbmNlIGV2ZW4gaWYgY3VycmVudGx5XG4gICAgLy8gY29ubmVjdGVkXG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNUSU5HO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKTtcbiAgICByZXR1cm4gcmVzIGFzIEpvaW5SZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIHJlY29ubmVjdChcbiAgICB1cmw6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIHNpZD86IHN0cmluZyxcbiAgICByZWFzb24/OiBSZWNvbm5lY3RSZWFzb24sXG4gICk6IFByb21pc2U8UmVjb25uZWN0UmVzcG9uc2UgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucykge1xuICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgJ2F0dGVtcHRlZCB0byByZWNvbm5lY3Qgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBiZWluZyBzZXQsIGlnbm9yaW5nJyxcbiAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkc7XG4gICAgLy8gY2xlYXIgcGluZyBpbnRlcnZhbCBhbmQgcmVzdGFydCBpdCBvbmNlIHJlY29ubmVjdGVkXG4gICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgIHNpZCxcbiAgICAgIHJlY29ubmVjdFJlYXNvbjogcmVhc29uLFxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBwcml2YXRlIGNvbm5lY3QoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBvcHRzOiBDb25uZWN0T3B0cyxcbiAgICBhYm9ydFNpZ25hbD86IEFib3J0U2lnbmFsLFxuICApOiBQcm9taXNlPEpvaW5SZXNwb25zZSB8IFJlY29ubmVjdFJlc3BvbnNlIHwgdW5kZWZpbmVkPiB7XG4gICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdHM7XG4gICAgY29uc3QgY2xpZW50SW5mbyA9IGdldENsaWVudEluZm8oKTtcbiAgICBjb25zdCBwYXJhbXMgPSBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBjbGllbnRJbmZvLCBvcHRzKTtcbiAgICBjb25zdCBydGNVcmwgPSBjcmVhdGVSdGNVcmwodXJsLCBwYXJhbXMpO1xuICAgIGNvbnN0IHZhbGlkYXRlVXJsID0gY3JlYXRlVmFsaWRhdGVVcmwocnRjVXJsKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxKb2luUmVzcG9uc2UgfCBSZWNvbm5lY3RSZXNwb25zZSB8IHVuZGVmaW5lZD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkIChzaWduYWwpJyxcbiAgICAgICAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB3c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgICAgICAgJ3Jvb20gY29ubmVjdGlvbiBoYXMgdGltZWQgb3V0IChzaWduYWwpJyxcbiAgICAgICAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuICAgICAgICB9LCBvcHRzLndlYnNvY2tldFRpbWVvdXQpO1xuXG4gICAgICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGFib3J0U2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIGNvbnN0IHJlZGFjdGVkVXJsID0gbmV3IFVSTChydGNVcmwpO1xuICAgICAgICBpZiAocmVkYWN0ZWRVcmwuc2VhcmNoUGFyYW1zLmhhcygnYWNjZXNzX3Rva2VuJykpIHtcbiAgICAgICAgICByZWRhY3RlZFVybC5zZWFyY2hQYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCAnPHJlZGFjdGVkPicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKGBjb25uZWN0aW5nIHRvICR7cmVkYWN0ZWRVcmx9YCwge1xuICAgICAgICAgIHJlY29ubmVjdDogb3B0cy5yZWNvbm5lY3QsXG4gICAgICAgICAgcmVjb25uZWN0UmVhc29uOiBvcHRzLnJlY29ubmVjdFJlYXNvbixcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHJ0Y1VybCk7XG4gICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdzVGltZW91dCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gYXN5bmMgKGV2OiBFdmVudCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKHZhbGlkYXRlVXJsKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzLnRvRml4ZWQoMCkuc3RhcnRzV2l0aCgnNCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgcmVzcC50ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IobXNnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCwgcmVzcC5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgRW5jb3VudGVyZWQgdW5rbm93biB3ZWJzb2NrZXQgZXJyb3IgZHVyaW5nIGNvbm5lY3Rpb246ICR7ZXYudG9TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgcmVzcC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnc2VydmVyIHdhcyBub3QgcmVhY2hhYmxlJyxcbiAgICAgICAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5TZXJ2ZXJVbnJlYWNoYWJsZSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlciBlcnJvcnMsIGhhbmRsZVxuICAgICAgICAgIHRoaXMuaGFuZGxlV1NFcnJvcihldik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBhc3luYyAoZXY6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgIC8vIG5vdCBjb25zaWRlcmVkIGNvbm5lY3RlZCB1bnRpbCBKb2luUmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgICBsZXQgcmVzcDogU2lnbmFsUmVzcG9uc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBldi5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZXYuZGF0YSk7XG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUpzb24oanNvbiwgeyBpZ25vcmVVbmtub3duRmllbGRzOiB0cnVlIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXYuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICByZXNwID0gU2lnbmFsUmVzcG9uc2UuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShldi5kYXRhKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKFxuICAgICAgICAgICAgICBgY291bGQgbm90IGRlY29kZSB3ZWJzb2NrZXQgbWVzc2FnZTogJHt0eXBlb2YgZXYuZGF0YX1gLFxuICAgICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICBsZXQgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBqb2luIG1lc3NhZ2Ugb25seVxuICAgICAgICAgICAgaWYgKHJlc3AubWVzc2FnZT8uY2FzZSA9PT0gJ2pvaW4nKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEO1xuICAgICAgICAgICAgICBhYm9ydFNpZ25hbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPSByZXNwLm1lc3NhZ2UudmFsdWUucGluZ1RpbWVvdXQ7XG4gICAgICAgICAgICAgIHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24gPSByZXNwLm1lc3NhZ2UudmFsdWUucGluZ0ludGVydmFsO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gJiYgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwaW5nIGNvbmZpZycsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgIGludGVydmFsOiB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKHJlc3AubWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HICYmXG4gICAgICAgICAgICAgIHJlc3AubWVzc2FnZS5jYXNlICE9PSAnbGVhdmUnXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gaW4gcmVjb25uZWN0aW5nLCBhbnkgbWVzc2FnZSByZWNlaXZlZCBtZWFucyBzaWduYWwgcmVjb25uZWN0ZWRcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQ7XG4gICAgICAgICAgICAgIGFib3J0U2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhcnRQaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3AubWVzc2FnZT8uY2FzZSA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3AubWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXG4gICAgICAgICAgICAgICAgICAnZGVjbGFyaW5nIHNpZ25hbCByZWNvbm5lY3RlZCB3aXRob3V0IHJlY29ubmVjdCByZXNwb25zZSByZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uICYmIHJlc3AubWVzc2FnZS5jYXNlID09PSAnbGVhdmUnKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgJ1JlY2VpdmVkIGxlYXZlIHJlcXVlc3Qgd2hpbGUgdHJ5aW5nIHRvIChyZSljb25uZWN0JyxcbiAgICAgICAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICByZXNwLm1lc3NhZ2UudmFsdWUucmVhc29uLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLnJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAvLyBub24tcmVjb25uZWN0IGNhc2UsIHNob3VsZCByZWNlaXZlIGpvaW4gcmVzcG9uc2UgZmlyc3RcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgZGlkIG5vdCByZWNlaXZlIGpvaW4gcmVzcG9uc2UsIGdvdCAke3Jlc3AubWVzc2FnZT8uY2FzZX0gaW5zdGVhZGAsXG4gICAgICAgICAgICAgICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcixcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaG91bGRQcm9jZXNzTWVzc2FnZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAodGhpcy5zaWduYWxMYXRlbmN5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVTaWduYWxSZXNwb25zZShyZXNwKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoZXY6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgICAgICAgICAnV2Vic29ja2V0IGdvdCBjbG9zZWQgZHVyaW5nIGEgKHJlKWNvbm5lY3Rpb24gYXR0ZW1wdCcsXG4gICAgICAgICAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubG9nLndhcm4oYHdlYnNvY2tldCBjbG9zZWRgLCB7XG4gICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICByZWFzb246IGV2LnJlYXNvbixcbiAgICAgICAgICAgIGNvZGU6IGV2LmNvZGUsXG4gICAgICAgICAgICB3YXNDbGVhbjogZXYud2FzQ2xlYW4sXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmhhbmRsZU9uQ2xvc2UoZXYucmVhc29uKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZXNldENhbGxiYWNrcyA9ICgpID0+IHtcbiAgICB0aGlzLm9uQW5zd2VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25MZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25OZWdvdGlhdGVSZXF1ZXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbk9mZmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRva2VuUmVmcmVzaCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpY2tsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uQ2xvc2UgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgYXN5bmMgY2xvc2UodXBkYXRlU3RhdGU6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5jbG9zaW5nTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY2xlYXJQaW5nSW50ZXJ2YWwoKTtcbiAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RJTkc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy53cykge1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gbnVsbDtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbnVsbDtcblxuICAgICAgICAvLyBjYWxsaW5nIGB3cy5jbG9zZSgpYCBvbmx5IHN0YXJ0cyB0aGUgY2xvc2luZyBoYW5kc2hha2UgKENMT1NJTkcgc3RhdGUpLCBwcmVmZXIgdG8gd2FpdCB1bnRpbCBzdGF0ZSBpcyBhY3R1YWxseSBDTE9TRURcbiAgICAgICAgY29uc3QgY2xvc2VQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy53cy5yZWFkeVN0YXRlIDwgdGhpcy53cy5DTE9TSU5HKSB7XG4gICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgIC8vIDI1MG1zIGdyYWNlIHBlcmlvZCBmb3Igd3MgdG8gY2xvc2UgZ3JhY2VmdWxseVxuICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbY2xvc2VQcm9taXNlLCBzbGVlcCgyNTApXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgICAgfVxuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhbCBvZmZlciBhZnRlciBqb2luaW5nXG4gIHNlbmRPZmZlcihvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIG9mZmVyJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIG9mZmVyU2RwOiBvZmZlci5zZHAgfSk7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnb2ZmZXInLFxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gYW5zd2VyIGEgc2VydmVyLWluaXRpYXRlZCBvZmZlclxuICBzZW5kQW5zd2VyKGFuc3dlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGFuc3dlcicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBhbnN3ZXJTZHA6IGFuc3dlci5zZHAgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2Fuc3dlcicsXG4gICAgICB2YWx1ZTogdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihhbnN3ZXIpLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZUluaXQsIHRhcmdldDogU2lnbmFsVGFyZ2V0KSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgaWNlIGNhbmRpZGF0ZScsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBjYW5kaWRhdGUgfSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyaWNrbGUnLFxuICAgICAgdmFsdWU6IG5ldyBUcmlja2xlUmVxdWVzdCh7XG4gICAgICAgIGNhbmRpZGF0ZUluaXQ6IEpTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZSksXG4gICAgICAgIHRhcmdldCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZE11dGVUcmFjayh0cmFja1NpZDogc3RyaW5nLCBtdXRlZDogYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdtdXRlJyxcbiAgICAgIHZhbHVlOiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCh7XG4gICAgICAgIHNpZDogdHJhY2tTaWQsXG4gICAgICAgIG11dGVkLFxuICAgICAgfSksXG4gICAgfSk7XG4gIH1cblxuICBzZW5kQWRkVHJhY2socmVxOiBBZGRUcmFja1JlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnYWRkVHJhY2snLFxuICAgICAgdmFsdWU6IHJlcSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKFxuICAgIG1ldGFkYXRhOiBzdHJpbmcsXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5nZXROZXh0UmVxdWVzdElkKCk7XG4gICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlTWV0YWRhdGEnLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhKHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgIH0pLFxuICAgIH0pO1xuICAgIHJldHVybiByZXF1ZXN0SWQ7XG4gIH1cblxuICBzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5nczogVXBkYXRlVHJhY2tTZXR0aW5ncykge1xuICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyYWNrU2V0dGluZycsXG4gICAgICB2YWx1ZTogc2V0dGluZ3MsXG4gICAgfSk7XG4gIH1cblxuICBzZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1YjogVXBkYXRlU3Vic2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3N1YnNjcmlwdGlvbicsXG4gICAgICB2YWx1ZTogc3ViLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZFN5bmNTdGF0ZShzeW5jOiBTeW5jU3RhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3luY1N0YXRlJyxcbiAgICAgIHZhbHVlOiBzeW5jLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZFVwZGF0ZVZpZGVvTGF5ZXJzKHRyYWNrU2lkOiBzdHJpbmcsIGxheWVyczogVmlkZW9MYXllcltdKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3VwZGF0ZUxheWVycycsXG4gICAgICB2YWx1ZTogbmV3IFVwZGF0ZVZpZGVvTGF5ZXJzKHtcbiAgICAgICAgdHJhY2tTaWQsXG4gICAgICAgIGxheWVycyxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKGFsbFBhcnRpY2lwYW50czogYm9vbGVhbiwgdHJhY2tQZXJtaXNzaW9uczogVHJhY2tQZXJtaXNzaW9uW10pIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uUGVybWlzc2lvbicsXG4gICAgICB2YWx1ZTogbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oe1xuICAgICAgICBhbGxQYXJ0aWNpcGFudHMsXG4gICAgICAgIHRyYWNrUGVybWlzc2lvbnMsXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRTaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvOiBTaW11bGF0ZVNjZW5hcmlvKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3NpbXVsYXRlJyxcbiAgICAgIHZhbHVlOiBzY2VuYXJpbyxcbiAgICB9KTtcbiAgfVxuXG4gIHNlbmRQaW5nKCkge1xuICAgIC8qKiBzZW5kIGJvdGggb2YgcGluZyBhbmQgcGluZ1JlcSBmb3IgY29tcGF0aWJpbGl0eSB0byBvbGQgYW5kIG5ldyBzZXJ2ZXIgKi9cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICAgIGNhc2U6ICdwaW5nJyxcbiAgICAgICAgdmFsdWU6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXG4gICAgICB9KSxcbiAgICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgICBjYXNlOiAncGluZ1JlcScsXG4gICAgICAgIHZhbHVlOiBuZXcgUGluZyh7XG4gICAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpLFxuICAgICAgICAgIHJ0dDogcHJvdG9JbnQ2NC5wYXJzZSh0aGlzLnJ0dCksXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgXSk7XG4gIH1cblxuICBzZW5kVXBkYXRlTG9jYWxBdWRpb1RyYWNrKHRyYWNrU2lkOiBzdHJpbmcsIGZlYXR1cmVzOiBBdWRpb1RyYWNrRmVhdHVyZVtdKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3VwZGF0ZUF1ZGlvVHJhY2snLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVMb2NhbEF1ZGlvVHJhY2soeyB0cmFja1NpZCwgZmVhdHVyZXMgfSksXG4gICAgfSk7XG4gIH1cblxuICBzZW5kTGVhdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ2xlYXZlJyxcbiAgICAgIHZhbHVlOiBuZXcgTGVhdmVSZXF1ZXN0KHtcbiAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXG4gICAgICAgIC8vIHNlcnZlciBkb2Vzbid0IHByb2Nlc3MgdGhpcyBmaWVsZCwga2VlcGluZyBpdCBoZXJlIHRvIGluZGljYXRlIHRoZSBpbnRlbnQgb2YgYSBmdWxsIGRpc2Nvbm5lY3RcbiAgICAgICAgYWN0aW9uOiBMZWF2ZVJlcXVlc3RfQWN0aW9uLkRJU0NPTk5FQ1QsXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRSZXF1ZXN0KG1lc3NhZ2U6IFNpZ25hbE1lc3NhZ2UsIGZyb21RdWV1ZTogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgLy8gY2FwdHVyZSBhbGwgcmVxdWVzdHMgd2hpbGUgcmVjb25uZWN0aW5nIGFuZCBwdXQgdGhlbSBpbiBhIHF1ZXVlXG4gICAgLy8gdW5sZXNzIHRoZSByZXF1ZXN0IG9yaWdpbmF0ZXMgZnJvbSB0aGUgcXVldWUsIHRoZW4gZG9uJ3QgZW5xdWV1ZSBhZ2FpblxuICAgIGNvbnN0IGNhblF1ZXVlID0gIWZyb21RdWV1ZSAmJiAhY2FuUGFzc1Rocm91Z2hRdWV1ZShtZXNzYWdlKTtcbiAgICBpZiAoY2FuUXVldWUgJiYgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORykge1xuICAgICAgdGhpcy5xdWV1ZWRSZXF1ZXN0cy5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUmVxdWVzdChtZXNzYWdlLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgcHJldmlvdXNseSBxdWV1ZWQgcmVxdWVzdHMgYXJlIGJlaW5nIHNlbnQgZmlyc3RcbiAgICBpZiAoIWZyb21RdWV1ZSkge1xuICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0UXVldWUuZmx1c2goKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2lnbmFsTGF0ZW5jeSkge1xuICAgICAgYXdhaXQgc2xlZXAodGhpcy5zaWduYWxMYXRlbmN5KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLndzIHx8IHRoaXMud3MucmVhZHlTdGF0ZSAhPT0gdGhpcy53cy5PUEVOKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihcbiAgICAgICAgYGNhbm5vdCBzZW5kIHNpZ25hbCByZXF1ZXN0IGJlZm9yZSBjb25uZWN0ZWQsIHR5cGU6ICR7bWVzc2FnZT8uY2FzZX1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXEgPSBuZXcgU2lnbmFsUmVxdWVzdCh7IG1lc3NhZ2UgfSk7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMudXNlSlNPTikge1xuICAgICAgICB0aGlzLndzLnNlbmQocmVxLnRvSnNvblN0cmluZygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud3Muc2VuZChyZXEudG9CaW5hcnkoKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHNlbmRpbmcgc2lnbmFsIG1lc3NhZ2UnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTaWduYWxSZXNwb25zZShyZXM6IFNpZ25hbFJlc3BvbnNlKSB7XG4gICAgY29uc3QgbXNnID0gcmVzLm1lc3NhZ2U7XG4gICAgaWYgKG1zZyA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnN1cHBvcnRlZCBtZXNzYWdlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcGluZ0hhbmRsZWQgPSBmYWxzZTtcbiAgICBpZiAobXNnLmNhc2UgPT09ICdhbnN3ZXInKSB7XG4gICAgICBjb25zdCBzZCA9IGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihtc2cudmFsdWUpO1xuICAgICAgaWYgKHRoaXMub25BbnN3ZXIpIHtcbiAgICAgICAgdGhpcy5vbkFuc3dlcihzZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ29mZmVyJykge1xuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm9uT2ZmZXIpIHtcbiAgICAgICAgdGhpcy5vbk9mZmVyKHNkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJpY2tsZScpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZTogUlRDSWNlQ2FuZGlkYXRlSW5pdCA9IEpTT04ucGFyc2UobXNnLnZhbHVlLmNhbmRpZGF0ZUluaXQhKTtcbiAgICAgIGlmICh0aGlzLm9uVHJpY2tsZSkge1xuICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy52YWx1ZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd1cGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZShtc2cudmFsdWUucGFydGljaXBhbnRzID8/IFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tQdWJsaXNoZWQnKSB7XG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpIHtcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3BlYWtlcnNDaGFuZ2VkJykge1xuICAgICAgaWYgKHRoaXMub25TcGVha2Vyc0NoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblNwZWFrZXJzQ2hhbmdlZChtc2cudmFsdWUuc3BlYWtlcnMgPz8gW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdsZWF2ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uTGVhdmUpIHtcbiAgICAgICAgdGhpcy5vbkxlYXZlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ211dGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25SZW1vdGVNdXRlQ2hhbmdlZChtc2cudmFsdWUuc2lkLCBtc2cudmFsdWUubXV0ZWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyb29tVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25Sb29tVXBkYXRlICYmIG1zZy52YWx1ZS5yb29tKSB7XG4gICAgICAgIHRoaXMub25Sb29tVXBkYXRlKG1zZy52YWx1ZS5yb29tKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnY29ubmVjdGlvblF1YWxpdHknKSB7XG4gICAgICBpZiAodGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KSB7XG4gICAgICAgIHRoaXMub25Db25uZWN0aW9uUXVhbGl0eShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdHJlYW1TdGF0ZVVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5vblN0cmVhbVN0YXRlVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmliZWRRdWFsaXR5VXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyZWZyZXNoVG9rZW4nKSB7XG4gICAgICBpZiAodGhpcy5vblRva2VuUmVmcmVzaCkge1xuICAgICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrVW5wdWJsaXNoZWQnKSB7XG4gICAgICBpZiAodGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkge1xuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N1YnNjcmlwdGlvblJlc3BvbnNlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICB0aGlzLm9uU3Vic2NyaXB0aW9uRXJyb3IobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncG9uZycpIHtcbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAncG9uZ1Jlc3AnKSB7XG4gICAgICB0aGlzLnJ0dCA9IERhdGUubm93KCkgLSBOdW1iZXIucGFyc2VJbnQobXNnLnZhbHVlLmxhc3RQaW5nVGltZXN0YW1wLnRvU3RyaW5nKCkpO1xuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgICBwaW5nSGFuZGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlcXVlc3RSZXNwb25zZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUmVxdWVzdFJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMub25SZXF1ZXN0UmVzcG9uc2UobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tTdWJzY3JpYmVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrU3Vic2NyaWJlZCkge1xuICAgICAgICB0aGlzLm9uTG9jYWxUcmFja1N1YnNjcmliZWQobXNnLnZhbHVlLnRyYWNrU2lkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vuc3VwcG9ydGVkIG1lc3NhZ2UnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgbXNnQ2FzZTogbXNnLmNhc2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFwaW5nSGFuZGxlZCkge1xuICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgfVxuICB9XG5cbiAgc2V0UmVjb25uZWN0ZWQoKSB7XG4gICAgd2hpbGUgKHRoaXMucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxID0gdGhpcy5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5ydW4ocmVxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZU9uQ2xvc2UocmVhc29uOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRCkgcmV0dXJuO1xuICAgIGNvbnN0IG9uQ2xvc2VDYWxsYmFjayA9IHRoaXMub25DbG9zZTtcbiAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gICAgdGhpcy5sb2cuZGVidWcoYHdlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZDogJHtyZWFzb259YCwgeyAuLi50aGlzLmxvZ0NvbnRleHQsIHJlYXNvbiB9KTtcbiAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XG4gICAgICBvbkNsb3NlQ2FsbGJhY2socmVhc29uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVdTRXJyb3IoZXY6IEV2ZW50KSB7XG4gICAgdGhpcy5sb2cuZXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZXYgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBwaW5nIHRpbWVvdXQgYW5kIHN0YXJ0cyBhIG5ldyB0aW1lb3V0LlxuICAgKiBDYWxsIHRoaXMgYWZ0ZXIgcmVjZWl2aW5nIGEgcG9uZyBtZXNzYWdlXG4gICAqL1xuICBwcml2YXRlIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3BpbmcgdGltZW91dCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5waW5nVGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgYHBpbmcgdGltZW91dCB0cmlnZ2VyZWQuIGxhc3QgcG9uZyByZWNlaXZlZCBhdDogJHtuZXcgRGF0ZShcbiAgICAgICAgICBEYXRlLm5vdygpIC0gdGhpcy5waW5nVGltZW91dER1cmF0aW9uISAqIDEwMDAsXG4gICAgICAgICkudG9VVENTdHJpbmcoKX1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgICB9LCB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgcGluZyB0aW1lb3V0IChkb2VzIG5vdCBzdGFydCBhIG5ldyB0aW1lb3V0KVxuICAgKi9cbiAgcHJpdmF0ZSBjbGVhclBpbmdUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnBpbmdUaW1lb3V0KSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG4gICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKCF0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdwaW5nIGludGVydmFsIGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnQgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5waW5nSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnNlbmRQaW5nKCk7XG4gICAgfSwgdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbiAqIDEwMDApO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygnY2xlYXJpbmcgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMucGluZ0ludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHNkOiBTZXNzaW9uRGVzY3JpcHRpb24pOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0IHtcbiAgY29uc3QgcnNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0ID0ge1xuICAgIHR5cGU6ICdvZmZlcicsXG4gICAgc2RwOiBzZC5zZHAsXG4gIH07XG4gIHN3aXRjaCAoc2QudHlwZSkge1xuICAgIGNhc2UgJ2Fuc3dlcic6XG4gICAgY2FzZSAnb2ZmZXInOlxuICAgIGNhc2UgJ3ByYW5zd2VyJzpcbiAgICBjYXNlICdyb2xsYmFjayc6XG4gICAgICByc2QudHlwZSA9IHNkLnR5cGU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJzZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oXG4gIHJzZDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHwgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCxcbik6IFNlc3Npb25EZXNjcmlwdGlvbiB7XG4gIGNvbnN0IHNkID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgc2RwOiByc2Quc2RwISxcbiAgICB0eXBlOiByc2QudHlwZSEsXG4gIH0pO1xuICByZXR1cm4gc2Q7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb25QYXJhbXMoXG4gIHRva2VuOiBzdHJpbmcsXG4gIGluZm86IENsaWVudEluZm8sXG4gIG9wdHM6IENvbm5lY3RPcHRzLFxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBwYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCB0b2tlbik7XG5cbiAgLy8gb3B0c1xuICBpZiAob3B0cy5yZWNvbm5lY3QpIHtcbiAgICBwYXJhbXMuc2V0KCdyZWNvbm5lY3QnLCAnMScpO1xuICAgIGlmIChvcHRzLnNpZCkge1xuICAgICAgcGFyYW1zLnNldCgnc2lkJywgb3B0cy5zaWQpO1xuICAgIH1cbiAgfVxuXG4gIHBhcmFtcy5zZXQoJ2F1dG9fc3Vic2NyaWJlJywgb3B0cy5hdXRvU3Vic2NyaWJlID8gJzEnIDogJzAnKTtcblxuICAvLyBDbGllbnRJbmZvXG4gIHBhcmFtcy5zZXQoJ3NkaycsIGlzUmVhY3ROYXRpdmUoKSA/ICdyZWFjdG5hdGl2ZScgOiAnanMnKTtcbiAgcGFyYW1zLnNldCgndmVyc2lvbicsIGluZm8udmVyc2lvbiEpO1xuICBwYXJhbXMuc2V0KCdwcm90b2NvbCcsIGluZm8ucHJvdG9jb2whLnRvU3RyaW5nKCkpO1xuICBpZiAoaW5mby5kZXZpY2VNb2RlbCkge1xuICAgIHBhcmFtcy5zZXQoJ2RldmljZV9tb2RlbCcsIGluZm8uZGV2aWNlTW9kZWwpO1xuICB9XG4gIGlmIChpbmZvLm9zKSB7XG4gICAgcGFyYW1zLnNldCgnb3MnLCBpbmZvLm9zKTtcbiAgfVxuICBpZiAoaW5mby5vc1ZlcnNpb24pIHtcbiAgICBwYXJhbXMuc2V0KCdvc192ZXJzaW9uJywgaW5mby5vc1ZlcnNpb24pO1xuICB9XG4gIGlmIChpbmZvLmJyb3dzZXIpIHtcbiAgICBwYXJhbXMuc2V0KCdicm93c2VyJywgaW5mby5icm93c2VyKTtcbiAgfVxuICBpZiAoaW5mby5icm93c2VyVmVyc2lvbikge1xuICAgIHBhcmFtcy5zZXQoJ2Jyb3dzZXJfdmVyc2lvbicsIGluZm8uYnJvd3NlclZlcnNpb24pO1xuICB9XG5cbiAgaWYgKG9wdHMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICBwYXJhbXMuc2V0KCdhZGFwdGl2ZV9zdHJlYW0nLCAnMScpO1xuICB9XG5cbiAgaWYgKG9wdHMucmVjb25uZWN0UmVhc29uKSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0X3JlYXNvbicsIG9wdHMucmVjb25uZWN0UmVhc29uLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAobmF2aWdhdG9yLmNvbm5lY3Rpb24/LnR5cGUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGFyYW1zLnNldCgnbmV0d29yaycsIG5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cbiIsInZhciBncmFtbWFyID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIHY6IFt7XG4gICAgbmFtZTogJ3ZlcnNpb24nLFxuICAgIHJlZzogL14oXFxkKikkL1xuICB9XSxcbiAgbzogW3tcbiAgICAvLyBvPS0gMjA1MTggMCBJTiBJUDQgMjAzLjAuMTEzLjFcbiAgICAvLyBOQjogc2Vzc2lvbklkIHdpbGwgYmUgYSBTdHJpbmcgaW4gbW9zdCBjYXNlcyBiZWNhdXNlIGl0IGlzIGh1Z2VcbiAgICBuYW1lOiAnb3JpZ2luJyxcbiAgICByZWc6IC9eKFxcUyopIChcXGQqKSAoXFxkKikgKFxcUyopIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd1c2VybmFtZScsICdzZXNzaW9uSWQnLCAnc2Vzc2lvblZlcnNpb24nLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgZm9ybWF0OiAnJXMgJXMgJWQgJXMgSVAlZCAlcydcbiAgfV0sXG4gIC8vIGRlZmF1bHQgcGFyc2luZyBvZiB0aGVzZSBvbmx5ICh0aG91Z2ggc29tZSBvZiB0aGVzZSBmZWVsIG91dGRhdGVkKVxuICBzOiBbeyBuYW1lOiAnbmFtZScgfV0sXG4gIGk6IFt7IG5hbWU6ICdkZXNjcmlwdGlvbicgfV0sXG4gIHU6IFt7IG5hbWU6ICd1cmknIH1dLFxuICBlOiBbeyBuYW1lOiAnZW1haWwnIH1dLFxuICBwOiBbeyBuYW1lOiAncGhvbmUnIH1dLFxuICB6OiBbeyBuYW1lOiAndGltZXpvbmVzJyB9XSwgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFjdHVhbGx5IGJlIHBhcnNlZCBwcm9wZXJseS4uLlxuICByOiBbeyBuYW1lOiAncmVwZWF0cycgfV0sICAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFsc28gYmUgcGFyc2VkIHByb3Blcmx5XG4gIC8vIGs6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcbiAgdDogW3tcbiAgICAvLyB0PTAgMFxuICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgIHJlZzogL14oXFxkKikgKFxcZCopLyxcbiAgICBuYW1lczogWydzdGFydCcsICdzdG9wJ10sXG4gICAgZm9ybWF0OiAnJWQgJWQnXG4gIH1dLFxuICBjOiBbe1xuICAgIC8vIGM9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxuICAgIG5hbWU6ICdjb25uZWN0aW9uJyxcbiAgICByZWc6IC9eSU4gSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcbiAgICBmb3JtYXQ6ICdJTiBJUCVkICVzJ1xuICB9XSxcbiAgYjogW3tcbiAgICAvLyBiPUFTOjQwMDBcbiAgICBwdXNoOiAnYmFuZHdpZHRoJyxcbiAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXG4gICAgbmFtZXM6IFsndHlwZScsICdsaW1pdCddLFxuICAgIGZvcm1hdDogJyVzOiVzJ1xuICB9XSxcbiAgbTogW3tcbiAgICAvLyBtPXZpZGVvIDUxNzQ0IFJUUC9BVlAgMTI2IDk3IDk4IDM0IDMxXG4gICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxuICAgIC8vIFRPRE86IHJ0cC9mbXRwIHNob3VsZCBiZSBmaWx0ZXJlZCBieSB0aGUgcGF5bG9hZHMgZm91bmQgaGVyZT9cbiAgICByZWc6IC9eKFxcdyopIChcXGQqKSAoW1xcdy9dKikoPzogKC4qKSk/LyxcbiAgICBuYW1lczogWyd0eXBlJywgJ3BvcnQnLCAncHJvdG9jb2wnLCAncGF5bG9hZHMnXSxcbiAgICBmb3JtYXQ6ICclcyAlZCAlcyAlcydcbiAgfV0sXG4gIGE6IFtcbiAgICB7XG4gICAgICAvLyBhPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXG4gICAgICBwdXNoOiAncnRwJyxcbiAgICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtLl0qKSg/OlxccypcXC8oXFxkKikoPzpcXHMqXFwvKFxcUyopKT8pPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvZGVjJywgJ3JhdGUnLCAnZW5jb2RpbmcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLmVuY29kaW5nKVxuICAgICAgICAgID8gJ3J0cG1hcDolZCAlcy8lcy8lcydcbiAgICAgICAgICA6IG8ucmF0ZVxuICAgICAgICAgICAgPyAncnRwbWFwOiVkICVzLyVzJ1xuICAgICAgICAgICAgOiAncnRwbWFwOiVkICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Zm10cDoxMDggcHJvZmlsZS1sZXZlbC1pZD0yNDtvYmplY3Q9MjM7Yml0cmF0ZT02NDAwMFxuICAgICAgLy8gYT1mbXRwOjExMSBtaW5wdGltZT0xMDsgdXNlaW5iYW5kZmVjPTFcbiAgICAgIHB1c2g6ICdmbXRwJyxcbiAgICAgIHJlZzogL15mbXRwOihcXGQqKSAoW1xcU3wgXSopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29uZmlnJ10sXG4gICAgICBmb3JtYXQ6ICdmbXRwOiVkICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb250cm9sOnN0cmVhbWlkPTBcbiAgICAgIG5hbWU6ICdjb250cm9sJyxcbiAgICAgIHJlZzogL15jb250cm9sOiguKikvLFxuICAgICAgZm9ybWF0OiAnY29udHJvbDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcDo2NTE3OSBJTiBJUDQgMTkzLjg0Ljc3LjE5NFxuICAgICAgbmFtZTogJ3J0Y3AnLFxuICAgICAgcmVnOiAvXnJ0Y3A6KFxcZCopKD86IChcXFMqKSBJUChcXGQpIChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BvcnQnLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5hZGRyZXNzICE9IG51bGwpXG4gICAgICAgICAgPyAncnRjcDolZCAlcyBJUCVkICVzJ1xuICAgICAgICAgIDogJ3J0Y3A6JWQnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLWZiOjk4IHRyci1pbnQgMTAwXG4gICAgICBwdXNoOiAncnRjcEZiVHJySW50JyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgdHJyLWludCAoXFxkKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAncnRjcC1mYjolcyB0cnItaW50ICVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICAgICAgcHVzaDogJ3J0Y3BGYicsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIChbXFx3LV9dKikoPzogKFtcXHctX10qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndHlwZScsICdzdWJ0eXBlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5zdWJ0eXBlICE9IG51bGwpXG4gICAgICAgICAgPyAncnRjcC1mYjolcyAlcyAlcydcbiAgICAgICAgICA6ICdydGNwLWZiOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuICAgICAgLy8gYT1leHRtYXA6MS9yZWN2b25seSBVUkktZ3BzLXN0cmluZ1xuICAgICAgLy8gYT1leHRtYXA6MyB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNtcHRlLXRjIDI1QDYwMC8yNFxuICAgICAgcHVzaDogJ2V4dCcsXG4gICAgICByZWc6IC9eZXh0bWFwOihcXGQrKSg/OlxcLyhcXHcrKSk/KD86ICh1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0KSk/IChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWyd2YWx1ZScsICdkaXJlY3Rpb24nLCAnZW5jcnlwdC11cmknLCAndXJpJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICdleHRtYXA6JWQnICtcbiAgICAgICAgICAoby5kaXJlY3Rpb24gPyAnLyVzJyA6ICcldicpICtcbiAgICAgICAgICAob1snZW5jcnlwdC11cmknXSA/ICcgJXMnIDogJyV2JykgK1xuICAgICAgICAgICcgJXMnICtcbiAgICAgICAgICAoby5jb25maWcgPyAnICVzJyA6ICcnKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1leHRtYXAtYWxsb3ctbWl4ZWRcbiAgICAgIG5hbWU6ICdleHRtYXBBbGxvd01peGVkJyxcbiAgICAgIHJlZzogL14oZXh0bWFwLWFsbG93LW1peGVkKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y3J5cHRvOjEgQUVTX0NNXzEyOF9ITUFDX1NIQTFfODAgaW5saW5lOlBTMXVRQ1ZlZUNGQ2FuVm1jamtwUHl3ak5XaGNZRDBtWFh0eGFWQlJ8Ml4yMHwxOjMyXG4gICAgICBwdXNoOiAnY3J5cHRvJyxcbiAgICAgIHJlZzogL15jcnlwdG86KFxcZCopIChbXFx3X10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnc3VpdGUnLCAnY29uZmlnJywgJ3Nlc3Npb25Db25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnNlc3Npb25Db25maWcgIT0gbnVsbClcbiAgICAgICAgICA/ICdjcnlwdG86JWQgJXMgJXMgJXMnXG4gICAgICAgICAgOiAnY3J5cHRvOiVkICVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2V0dXA6YWN0cGFzc1xuICAgICAgbmFtZTogJ3NldHVwJyxcbiAgICAgIHJlZzogL15zZXR1cDooXFx3KikvLFxuICAgICAgZm9ybWF0OiAnc2V0dXA6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbm5lY3Rpb246bmV3XG4gICAgICBuYW1lOiAnY29ubmVjdGlvblR5cGUnLFxuICAgICAgcmVnOiAvXmNvbm5lY3Rpb246KG5ld3xleGlzdGluZykvLFxuICAgICAgZm9ybWF0OiAnY29ubmVjdGlvbjolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bWlkOjFcbiAgICAgIG5hbWU6ICdtaWQnLFxuICAgICAgcmVnOiAvXm1pZDooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAnbWlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1tc2lkOjBjOGIwNjRkLWQ4MDctNDNiNC1iNDM0LWY5MmE4ODlkODU4NyA5ODE3ODY4NS1kNDA5LTQ2ZTAtOGUxNi03ZWYwZGIwZGI2NGFcbiAgICAgIG5hbWU6ICdtc2lkJyxcbiAgICAgIHJlZzogL15tc2lkOiguKikvLFxuICAgICAgZm9ybWF0OiAnbXNpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cHRpbWU6MjBcbiAgICAgIG5hbWU6ICdwdGltZScsXG4gICAgICByZWc6IC9ecHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ3B0aW1lOiVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1tYXhwdGltZTo2MFxuICAgICAgbmFtZTogJ21heHB0aW1lJyxcbiAgICAgIHJlZzogL15tYXhwdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgICAgZm9ybWF0OiAnbWF4cHRpbWU6JWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNlbmRyZWN2XG4gICAgICBuYW1lOiAnZGlyZWN0aW9uJyxcbiAgICAgIHJlZzogL14oc2VuZHJlY3Z8cmVjdm9ubHl8c2VuZG9ubHl8aW5hY3RpdmUpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2UtbGl0ZVxuICAgICAgbmFtZTogJ2ljZWxpdGUnLFxuICAgICAgcmVnOiAvXihpY2UtbGl0ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS11ZnJhZzpGN2dJXG4gICAgICBuYW1lOiAnaWNlVWZyYWcnLFxuICAgICAgcmVnOiAvXmljZS11ZnJhZzooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXVmcmFnOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2UtcHdkOng5Y21sL1l6aWNoVjIrWGxoaU11OGdcbiAgICAgIG5hbWU6ICdpY2VQd2QnLFxuICAgICAgcmVnOiAvXmljZS1wd2Q6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1wd2Q6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZpbmdlcnByaW50OlNIQS0xIDAwOjExOjIyOjMzOjQ0OjU1OjY2Ojc3Ojg4Ojk5OkFBOkJCOkNDOkREOkVFOkZGOjAwOjExOjIyOjMzXG4gICAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxuICAgICAgcmVnOiAvXmZpbmdlcnByaW50OihcXFMqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdoYXNoJ10sXG4gICAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjAgMSBVRFAgMjExMzY2NzMyNyAyMDMuMC4xMTMuMSA1NDQwMCB0eXAgaG9zdFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MTE2Mjg3NTA4MSAxIHVkcCAyMTEzOTM3MTUxIDE5Mi4xNjguMzQuNzUgNjAwMTcgdHlwIGhvc3QgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB1ZHAgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZToyMjk4MTU2MjAgMSB0Y3AgMTUxODI4MDQ0NyAxOTIuMTY4LjE1MC4xOSA2MDAxNyB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHRjcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgdGNwdHlwZSBwYXNzaXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICBwdXNoOidjYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL15jYW5kaWRhdGU6KFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgdHlwIChcXFMqKSg/OiByYWRkciAoXFxTKikgcnBvcnQgKFxcZCopKT8oPzogdGNwdHlwZSAoXFxTKikpPyg/OiBnZW5lcmF0aW9uIChcXGQqKSk/KD86IG5ldHdvcmstaWQgKFxcZCopKT8oPzogbmV0d29yay1jb3N0IChcXGQqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2ZvdW5kYXRpb24nLCAnY29tcG9uZW50JywgJ3RyYW5zcG9ydCcsICdwcmlvcml0eScsICdpcCcsICdwb3J0JywgJ3R5cGUnLCAncmFkZHInLCAncnBvcnQnLCAndGNwdHlwZScsICdnZW5lcmF0aW9uJywgJ25ldHdvcmstaWQnLCAnbmV0d29yay1jb3N0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnY2FuZGlkYXRlOiVzICVkICVzICVkICVzICVkIHR5cCAlcyc7XG5cbiAgICAgICAgc3RyICs9IChvLnJhZGRyICE9IG51bGwpID8gJyByYWRkciAlcyBycG9ydCAlZCcgOiAnJXYldic7XG5cbiAgICAgICAgLy8gTkI6IGNhbmRpZGF0ZSBoYXMgdGhyZWUgb3B0aW9uYWwgY2h1bmtzLCBzbyAldm9pZCBtaWRkbGVzIG9uZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgc3RyICs9IChvLnRjcHR5cGUgIT0gbnVsbCkgPyAnIHRjcHR5cGUgJXMnIDogJyV2JztcblxuICAgICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyBnZW5lcmF0aW9uICVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSAob1snbmV0d29yay1pZCddICE9IG51bGwpID8gJyBuZXR3b3JrLWlkICVkJyA6ICcldic7XG4gICAgICAgIHN0ciArPSAob1snbmV0d29yay1jb3N0J10gIT0gbnVsbCkgPyAnIG5ldHdvcmstY29zdCAlZCcgOiAnJXYnO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1lbmQtb2YtY2FuZGlkYXRlcyAoa2VlcCBhZnRlciB0aGUgY2FuZGlkYXRlcyBsaW5lIGZvciByZWFkYWJpbGl0eSlcbiAgICAgIG5hbWU6ICdlbmRPZkNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXihlbmQtb2YtY2FuZGlkYXRlcykvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJlbW90ZS1jYW5kaWRhdGVzOjEgMjAzLjAuMTEzLjEgNTQ0MDAgMiAyMDMuMC4xMTMuMSA1NDQwMSAuLi5cbiAgICAgIG5hbWU6ICdyZW1vdGVDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL15yZW1vdGUtY2FuZGlkYXRlczooLiopLyxcbiAgICAgIGZvcm1hdDogJ3JlbW90ZS1jYW5kaWRhdGVzOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2Utb3B0aW9uczpnb29nbGUtaWNlXG4gICAgICBuYW1lOiAnaWNlT3B0aW9ucycsXG4gICAgICByZWc6IC9eaWNlLW9wdGlvbnM6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1vcHRpb25zOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zc3JjOjI1NjYxMDc1NjkgY25hbWU6dDlZVThNMVV4VEY4WTFBMVxuICAgICAgcHVzaDogJ3NzcmNzJyxcbiAgICAgIHJlZzogL15zc3JjOihcXGQqKSAoW1xcd18tXSopKD86OiguKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdhdHRyaWJ1dGUnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdzc3JjOiVkJztcbiAgICAgICAgaWYgKG8uYXR0cmlidXRlICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyAlcyc7XG4gICAgICAgICAgaWYgKG8udmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9ICc6JXMnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQyAxIDJcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMtRlIgMzAwNDM2NDE5NSAxMDgwNzcyMjQxXG4gICAgICBwdXNoOiAnc3NyY0dyb3VwcycsXG4gICAgICAvLyB0b2tlbi1jaGFyID0gJXgyMSAvICV4MjMtMjcgLyAleDJBLTJCIC8gJXgyRC0yRSAvICV4MzAtMzkgLyAleDQxLTVBIC8gJXg1RS03RVxuICAgICAgcmVnOiAvXnNzcmMtZ3JvdXA6KFtcXHgyMVxceDIzXFx4MjRcXHgyNVxceDI2XFx4MjdcXHgyQVxceDJCXFx4MkRcXHgyRVxcd10qKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljcycsICdzc3JjcyddLFxuICAgICAgZm9ybWF0OiAnc3NyYy1ncm91cDolcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bXNpZC1zZW1hbnRpYzogV01TIEp2bGFtNVgzU1gxT1A2cG4yMHpXb2d2YUtKejVIamY5T25sVlxuICAgICAgbmFtZTogJ21zaWRTZW1hbnRpYycsXG4gICAgICByZWc6IC9ebXNpZC1zZW1hbnRpYzpcXHM/KFxcdyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpYycsICd0b2tlbiddLFxuICAgICAgZm9ybWF0OiAnbXNpZC1zZW1hbnRpYzogJXMgJXMnIC8vIHNwYWNlIGFmdGVyICc6JyBpcyBub3QgYWNjaWRlbnRhbFxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ncm91cDpCVU5ETEUgYXVkaW8gdmlkZW9cbiAgICAgIHB1c2g6ICdncm91cHMnLFxuICAgICAgcmVnOiAvXmdyb3VwOihcXHcqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnbWlkcyddLFxuICAgICAgZm9ybWF0OiAnZ3JvdXA6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtbXV4XG4gICAgICBuYW1lOiAncnRjcE11eCcsXG4gICAgICByZWc6IC9eKHJ0Y3AtbXV4KS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1yc2l6ZVxuICAgICAgbmFtZTogJ3J0Y3BSc2l6ZScsXG4gICAgICByZWc6IC9eKHJ0Y3AtcnNpemUpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zY3RwbWFwOjUwMDAgd2VicnRjLWRhdGFjaGFubmVsIDEwMjRcbiAgICAgIG5hbWU6ICdzY3RwbWFwJyxcbiAgICAgIHJlZzogL15zY3RwbWFwOihbXFx3Xy9dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3NjdHBtYXBOdW1iZXInLCAnYXBwJywgJ21heE1lc3NhZ2VTaXplJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5tYXhNZXNzYWdlU2l6ZSAhPSBudWxsKVxuICAgICAgICAgID8gJ3NjdHBtYXA6JXMgJXMgJXMnXG4gICAgICAgICAgOiAnc2N0cG1hcDolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZVxuICAgICAgbmFtZTogJ3hHb29nbGVGbGFnJyxcbiAgICAgIHJlZzogL154LWdvb2dsZS1mbGFnOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICd4LWdvb2dsZS1mbGFnOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcbiAgICAgIHB1c2g6ICdyaWRzJyxcbiAgICAgIHJlZzogL15yaWQ6KFtcXGRcXHddKykgKFxcdyspKD86IChbXFxTfCBdKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5wYXJhbXMpID8gJ3JpZDolcyAlcyAlcycgOiAncmlkOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3IHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF0gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgICAvLyBhPWltYWdlYXR0cjoqIHNlbmQgW3g9ODAwLHk9NjQwXSByZWN2ICpcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjEwMCByZWN2IFt4PTMyMCx5PTI0MF1cbiAgICAgIHB1c2g6ICdpbWFnZWF0dHJzJyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgICAgLy8gYT1pbWFnZWF0dHI6OTdcbiAgICAgICAgJ15pbWFnZWF0dHI6KFxcXFxkK3xcXFxcKiknICtcbiAgICAgICAgLy8gc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXVxuICAgICAgICAnW1xcXFxzXFxcXHRdKyhzZW5kfHJlY3YpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKiknICtcbiAgICAgICAgLy8gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgICAgICcoPzpbXFxcXHNcXFxcdF0rKHJlY3Z8c2VuZClbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKSk/J1xuICAgICAgKSxcbiAgICAgIG5hbWVzOiBbJ3B0JywgJ2RpcjEnLCAnYXR0cnMxJywgJ2RpcjInLCAnYXR0cnMyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnNlbmQgMSwyLDM7fjQsfjUgcmVjdiA2O343LH44XG4gICAgICAvLyBhPXNpbXVsY2FzdDpyZWN2IDE7NCw1IHNlbmQgNjs3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0JyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgICAgLy8gYT1zaW11bGNhc3Q6XG4gICAgICAgICdec2ltdWxjYXN0OicgK1xuICAgICAgICAvLyBzZW5kIDEsMiwzO340LH41XG4gICAgICAgICcoc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKScgK1xuICAgICAgICAvLyBzcGFjZSArIHJlY3YgNjt+Nyx+OFxuICAgICAgICAnKD86XFxcXHM/KHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKykpPycgK1xuICAgICAgICAvLyBlbmRcbiAgICAgICAgJyQnXG4gICAgICApLFxuICAgICAgbmFtZXM6IFsnZGlyMScsICdsaXN0MScsICdkaXIyJywgJ2xpc3QyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnc2ltdWxjYXN0OiVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIG9sZCBzaW11bGNhc3QgZHJhZnQgMDMgKGltcGxlbWVudGVkIGJ5IEZpcmVmb3gpXG4gICAgICAvLyAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zZHAtc2ltdWxjYXN0LTAzXG4gICAgICAvLyBhPXNpbXVsY2FzdDogcmVjdiBwdD05Nzs5OCBzZW5kIHB0PTk3XG4gICAgICAvLyBhPXNpbXVsY2FzdDogc2VuZCByaWQ9NTs2OzcgcGF1c2VkPTYsN1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdF8wMycsXG4gICAgICByZWc6IC9ec2ltdWxjYXN0OltcXHNcXHRdKyhbXFxTK1xcc1xcdF0rKSQvLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3NpbXVsY2FzdDogJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyNVxuICAgICAgLy8gYT1mcmFtZXJhdGU6MjkuOTdcbiAgICAgIG5hbWU6ICdmcmFtZXJhdGUnLFxuICAgICAgcmVnOiAvXmZyYW1lcmF0ZTooXFxkKyg/OiR8XFwuXFxkKykpLyxcbiAgICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQzQ1NzBcbiAgICAgIC8vIGE9c291cmNlLWZpbHRlcjogaW5jbCBJTiBJUDQgMjM5LjUuMi4zMSAxMC4xLjE1LjVcbiAgICAgIG5hbWU6ICdzb3VyY2VGaWx0ZXInLFxuICAgICAgcmVnOiAvXnNvdXJjZS1maWx0ZXI6ICooZXhjbHxpbmNsKSAoXFxTKikgKElQNHxJUDZ8XFwqKSAoXFxTKikgKC4qKS8sXG4gICAgICBuYW1lczogWydmaWx0ZXJNb2RlJywgJ25ldFR5cGUnLCAnYWRkcmVzc1R5cGVzJywgJ2Rlc3RBZGRyZXNzJywgJ3NyY0xpc3QnXSxcbiAgICAgIGZvcm1hdDogJ3NvdXJjZS1maWx0ZXI6ICVzICVzICVzICVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1idW5kbGUtb25seVxuICAgICAgbmFtZTogJ2J1bmRsZU9ubHknLFxuICAgICAgcmVnOiAvXihidW5kbGUtb25seSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWxhYmVsOjFcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICByZWc6IC9ebGFiZWw6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdsYWJlbDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNVxuICAgICAgbmFtZTogJ3NjdHBQb3J0JyxcbiAgICAgIHJlZzogL15zY3RwLXBvcnQ6KFxcZCspJC8sXG4gICAgICBmb3JtYXQ6ICdzY3RwLXBvcnQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTZcbiAgICAgIG5hbWU6ICdtYXhNZXNzYWdlU2l6ZScsXG4gICAgICByZWc6IC9ebWF4LW1lc3NhZ2Utc2l6ZTooXFxkKykkLyxcbiAgICAgIGZvcm1hdDogJ21heC1tZXNzYWdlLXNpemU6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPXRzLXJlZmNsazpwdHA9SUVFRTE1ODgtMjAwODozOS1BNy05NC1GRi1GRS0wNy1DQi1EMDozN1xuICAgICAgcHVzaDondHNSZWZDbG9ja3MnLFxuICAgICAgcmVnOiAvXnRzLXJlZmNsazooW15cXHM9XSopKD86PShcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2Nsa3NyYycsICdjbGtzcmNFeHQnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICd0cy1yZWZjbGs6JXMnICsgKG8uY2xrc3JjRXh0ICE9IG51bGwgPyAnPSVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQzcyNzNcbiAgICAgIC8vIGE9bWVkaWFjbGs6ZGlyZWN0PTk2MzIxNDQyNFxuICAgICAgbmFtZTonbWVkaWFDbGsnLFxuICAgICAgcmVnOiAvXm1lZGlhY2xrOig/OmlkPShcXFMqKSk/ICooW15cXHM9XSopKD86PShcXFMqKSk/KD86ICpyYXRlPShcXGQrKVxcLyhcXGQrKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21lZGlhQ2xvY2tOYW1lJywgJ21lZGlhQ2xvY2tWYWx1ZScsICdyYXRlTnVtZXJhdG9yJywgJ3JhdGVEZW5vbWluYXRvciddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ21lZGlhY2xrOic7XG4gICAgICAgIHN0ciArPSAoby5pZCAhPSBudWxsID8gJ2lkPSVzICVzJyA6ICcldiVzJyk7XG4gICAgICAgIHN0ciArPSAoby5tZWRpYUNsb2NrVmFsdWUgIT0gbnVsbCA/ICc9JXMnIDogJycpO1xuICAgICAgICBzdHIgKz0gKG8ucmF0ZU51bWVyYXRvciAhPSBudWxsID8gJyByYXRlPSVzJyA6ICcnKTtcbiAgICAgICAgc3RyICs9IChvLnJhdGVEZW5vbWluYXRvciAhPSBudWxsID8gJy8lcycgOiAnJyk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWtleXdkczprZXl3b3Jkc1xuICAgICAgbmFtZTogJ2tleXdvcmRzJyxcbiAgICAgIHJlZzogL15rZXl3ZHM6KC4rKSQvLFxuICAgICAgZm9ybWF0OiAna2V5d2RzOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb250ZW50Om1haW5cbiAgICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICAgIHJlZzogL15jb250ZW50OiguKykvLFxuICAgICAgZm9ybWF0OiAnY29udGVudDolcydcbiAgICB9LFxuICAgIC8vIEJGQ1AgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODNcbiAgICB7XG4gICAgICAvLyBhPWZsb29yY3RybDpjLXNcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JDdHJsJyxcbiAgICAgIHJlZzogL15mbG9vcmN0cmw6KGMtb25seXxzLW9ubHl8Yy1zKS8sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmN0cmw6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbmZpZDoxXG4gICAgICBuYW1lOiAnYmZjcENvbmZJZCcsXG4gICAgICByZWc6IC9eY29uZmlkOihcXGQrKS8sXG4gICAgICBmb3JtYXQ6ICdjb25maWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXVzZXJpZDoxXG4gICAgICBuYW1lOiAnYmZjcFVzZXJJZCcsXG4gICAgICByZWc6IC9edXNlcmlkOihcXGQrKS8sXG4gICAgICBmb3JtYXQ6ICd1c2VyaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZsb29yaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BGbG9vcklkJyxcbiAgICAgIHJlZzogL15mbG9vcmlkOiguKykgKD86bS1zdHJlYW18bXN0cm0pOiguKykvLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbVN0cmVhbSddLFxuICAgICAgZm9ybWF0OiAnZmxvb3JpZDolcyBtc3RybTolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGFueSBhPSB0aGF0IHdlIGRvbid0IHVuZGVyc3RhbmQgaXMga2VwdCB2ZXJiYXRpbSBvbiBtZWRpYS5pbnZhbGlkXG4gICAgICBwdXNoOiAnaW52YWxpZCcsXG4gICAgICBuYW1lczogWyd2YWx1ZSddXG4gICAgfVxuICBdXG59O1xuXG4vLyBzZXQgc2Vuc2libGUgZGVmYXVsdHMgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBncmFtbWFyIHdpdGggYm9yaW5nIGRldGFpbHNcbk9iamVjdC5rZXlzKGdyYW1tYXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICB2YXIgb2JqcyA9IGdyYW1tYXJba2V5XTtcbiAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iai5yZWcpIHtcbiAgICAgIG9iai5yZWcgPSAvKC4qKS87XG4gICAgfVxuICAgIGlmICghb2JqLmZvcm1hdCkge1xuICAgICAgb2JqLmZvcm1hdCA9ICclcyc7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwidmFyIHRvSW50SWZJbnQgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gU3RyaW5nKE51bWJlcih2KSkgPT09IHYgPyBOdW1iZXIodikgOiB2O1xufTtcblxudmFyIGF0dGFjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2gsIGxvY2F0aW9uLCBuYW1lcywgcmF3TmFtZSkge1xuICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICBsb2NhdGlvbltyYXdOYW1lXSA9IHRvSW50SWZJbnQobWF0Y2hbMV0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChtYXRjaFtpKzFdICE9IG51bGwpIHtcbiAgICAgICAgbG9jYXRpb25bbmFtZXNbaV1dID0gdG9JbnRJZkludChtYXRjaFtpKzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gIHZhciBuZWVkc0JsYW5rID0gb2JqLm5hbWUgJiYgb2JqLm5hbWVzO1xuICBpZiAob2JqLnB1c2ggJiYgIWxvY2F0aW9uW29iai5wdXNoXSkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICB9XG4gIGVsc2UgaWYgKG5lZWRzQmxhbmsgJiYgIWxvY2F0aW9uW29iai5uYW1lXSkge1xuICAgIGxvY2F0aW9uW29iai5uYW1lXSA9IHt9O1xuICB9XG4gIHZhciBrZXlMb2NhdGlvbiA9IG9iai5wdXNoID9cbiAgICB7fSA6ICAvLyBibGFuayBvYmplY3QgdGhhdCB3aWxsIGJlIHB1c2hlZFxuICAgIG5lZWRzQmxhbmsgPyBsb2NhdGlvbltvYmoubmFtZV0gOiBsb2NhdGlvbjsgLy8gb3RoZXJ3aXNlLCBuYW1lZCBsb2NhdGlvbiBvciByb290XG5cbiAgYXR0YWNoUHJvcGVydGllcyhjb250ZW50Lm1hdGNoKG9iai5yZWcpLCBrZXlMb2NhdGlvbiwgb2JqLm5hbWVzLCBvYmoubmFtZSk7XG5cbiAgaWYgKG9iai5wdXNoKSB7XG4gICAgbG9jYXRpb25bb2JqLnB1c2hdLnB1c2goa2V5TG9jYXRpb24pO1xuICB9XG59O1xuXG52YXIgZ3JhbW1hciA9IHJlcXVpcmUoJy4vZ3JhbW1hcicpO1xudmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2RwKSB7XG4gIHZhciBzZXNzaW9uID0ge31cbiAgICAsIG1lZGlhID0gW11cbiAgICAsIGxvY2F0aW9uID0gc2Vzc2lvbjsgLy8gcG9pbnRzIGF0IHdoZXJlIHByb3BlcnRpZXMgZ28gdW5kZXIgKG9uZSBvZiB0aGUgYWJvdmUpXG5cbiAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5maWx0ZXIodmFsaWRMaW5lKS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIHR5cGUgPSBsWzBdO1xuICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICBpZiAodHlwZSA9PT0gJ20nKSB7XG4gICAgICBtZWRpYS5wdXNoKHtydHA6IFtdLCBmbXRwOiBbXX0pO1xuICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGgtMV07IC8vIHBvaW50IGF0IGxhdGVzdCBtZWRpYSBsaW5lXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgaWYgKG9iai5yZWcudGVzdChjb250ZW50KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBzZXNzaW9uLm1lZGlhID0gbWVkaWE7IC8vIGxpbmsgaXQgdXBcbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG52YXIgcGFyYW1SZWR1Y2VyID0gZnVuY3Rpb24gKGFjYywgZXhwcikge1xuICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gIGlmIChzLmxlbmd0aCA9PT0gMikge1xuICAgIGFjY1tzWzBdXSA9IHRvSW50SWZJbnQoc1sxXSk7XG4gIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgYWNjW3NbMF1dID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhY2M7XG59O1xuXG5leHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC87XFxzPy8pLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbn07XG5cbi8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gYWxpYXMgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4wXG5leHBvcnRzLnBhcnNlRm10cENvbmZpZyA9IGV4cG9ydHMucGFyc2VQYXJhbXM7XG5cbmV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG59O1xuXG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcgJykubWFwKHRvSW50SWZJbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgIGNvbXBvbmVudDogcGFydHNbaV0sXG4gICAgICBpcDogcGFydHNbaSArIDFdLFxuICAgICAgcG9ydDogcGFydHNbaSArIDJdXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uc3Vic3RyaW5nKDEsIGl0ZW0ubGVuZ3RoLTEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICByZXR1cm4gc3RyZWFtLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIHZhciBzY2lkLCBwYXVzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NpZDogc2NpZCxcbiAgICAgICAgcGF1c2VkOiBwYXVzZWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsInZhciBncmFtbWFyID0gcmVxdWlyZSgnLi9ncmFtbWFyJyk7XG5cbi8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgIH1cbiAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICBpICs9IDE7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgY2FzZSAnJSUnOlxuICAgICAgcmV0dXJuICclJztcbiAgICBjYXNlICclcyc6XG4gICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgY2FzZSAnJWQnOlxuICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgIGNhc2UgJyV2JzpcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0pO1xuICAvLyBOQjogd2UgZGlzY2FyZCBleGNlc3MgYXJndW1lbnRzIC0gdGhleSBhcmUgdHlwaWNhbGx5IHVuZGVmaW5lZCBmcm9tIG1ha2VMaW5lXG59O1xuXG52YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICB2YXIgc3RyID0gb2JqLmZvcm1hdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID9cbiAgICAob2JqLmZvcm1hdChvYmoucHVzaCA/IGxvY2F0aW9uIDogbG9jYXRpb25bb2JqLm5hbWVdKSkgOlxuICAgIG9iai5mb3JtYXQ7XG5cbiAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gIGlmIChvYmoubmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufTtcblxuLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcbnZhciBkZWZhdWx0T3V0ZXJPcmRlciA9IFtcbiAgJ3YnLCAnbycsICdzJywgJ2knLFxuICAndScsICdlJywgJ3AnLCAnYycsXG4gICdiJywgJ3QnLCAncicsICd6JywgJ2EnXG5dO1xudmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcbiAgICBzZXNzaW9uLnZlcnNpb24gPSAwOyAvLyAndj0wJyBtdXN0IGJlIHRoZXJlIChvbmx5IGRlZmluZWQgdmVyc2lvbiBhdG0pXG4gIH1cbiAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi5uYW1lID0gJyAnOyAvLyAncz0gJyBtdXN0IGJlIHRoZXJlIGlmIG5vIG1lYW5pbmdmdWwgbmFtZSBzZXRcbiAgfVxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgaWYgKG1MaW5lLnBheWxvYWRzID09IG51bGwpIHtcbiAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gIHZhciBzZHAgPSBbXTtcblxuICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xuXG4gICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZHAuam9pbignXFxyXFxuJykgKyAnXFxyXFxuJztcbn07XG4iLCJ2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciB3cml0ZXIgPSByZXF1aXJlKCcuL3dyaXRlcicpO1xudmFyIGdyYW1tYXIgPSByZXF1aXJlKCcuL2dyYW1tYXInKTtcblxuZXhwb3J0cy5ncmFtbWFyID0gZ3JhbW1hcjtcbmV4cG9ydHMud3JpdGUgPSB3cml0ZXI7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VyLnBhcnNlO1xuZXhwb3J0cy5wYXJzZVBhcmFtcyA9IHBhcnNlci5wYXJzZVBhcmFtcztcbmV4cG9ydHMucGFyc2VGbXRwQ29uZmlnID0gcGFyc2VyLnBhcnNlRm10cENvbmZpZzsgLy8gQWxpYXMgb2YgcGFyc2VQYXJhbXMoKS5cbmV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IHBhcnNlci5wYXJzZVBheWxvYWRzO1xuZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBwYXJzZXIucGFyc2VSZW1vdGVDYW5kaWRhdGVzO1xuZXhwb3J0cy5wYXJzZUltYWdlQXR0cmlidXRlcyA9IHBhcnNlci5wYXJzZUltYWdlQXR0cmlidXRlcztcbmV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gcGFyc2VyLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdDtcbiIsImZ1bmN0aW9uIHIocixlLG4pe3ZhciBpLHQsbzt2b2lkIDA9PT1lJiYoZT01MCksdm9pZCAwPT09biYmKG49e30pO3ZhciBhPW51bGwhPShpPW4uaXNJbW1lZGlhdGUpJiZpLHU9bnVsbCE9KHQ9bi5jYWxsYmFjaykmJnQsYz1uLm1heFdhaXQsdj1EYXRlLm5vdygpLGw9W107ZnVuY3Rpb24gZigpe2lmKHZvaWQgMCE9PWMpe3ZhciByPURhdGUubm93KCktdjtpZihyK2U+PWMpcmV0dXJuIGMtcn1yZXR1cm4gZX12YXIgZD1mdW5jdGlvbigpe3ZhciBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxuPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGksdCl7dmFyIGM9YSYmdm9pZCAwPT09bztpZih2b2lkIDAhPT1vJiZjbGVhclRpbWVvdXQobyksbz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYobz12b2lkIDAsdj1EYXRlLm5vdygpLCFhKXt2YXIgaT1yLmFwcGx5KG4sZSk7dSYmdShpKSxsLmZvckVhY2goZnVuY3Rpb24ocil7cmV0dXJuKDAsci5yZXNvbHZlKShpKX0pLGw9W119fSxmKCkpLGMpe3ZhciBkPXIuYXBwbHkobixlKTtyZXR1cm4gdSYmdShkKSxpKGQpfWwucHVzaCh7cmVzb2x2ZTppLHJlamVjdDp0fSl9KX07cmV0dXJuIGQuY2FuY2VsPWZ1bmN0aW9uKHIpe3ZvaWQgMCE9PW8mJmNsZWFyVGltZW91dChvKSxsLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuKDAsZS5yZWplY3QpKHIpfSksbD1bXX0sZH1leHBvcnR7ciBhcyBkZWJvdW5jZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBNZWRpYURlc2NyaXB0aW9uLCBTZXNzaW9uRGVzY3JpcHRpb24gfSBmcm9tICdzZHAtdHJhbnNmb3JtJztcbmltcG9ydCB7IHBhcnNlLCB3cml0ZSB9IGZyb20gJ3NkcC10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICd0cy1kZWJvdW5jZSc7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgTmVnb3RpYXRpb25FcnJvciwgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZGRFeHRlbnNpb25VUkksIGlzU1ZDQ29kZWMgfSBmcm9tICcuL3V0aWxzJztcblxuLyoqIEBpbnRlcm5hbCAqL1xuaW50ZXJmYWNlIFRyYWNrQml0cmF0ZUluZm8ge1xuICBjaWQ/OiBzdHJpbmc7XG4gIHRyYW5zY2VpdmVyPzogUlRDUnRwVHJhbnNjZWl2ZXI7XG4gIGNvZGVjOiBzdHJpbmc7XG4gIG1heGJyOiBudW1iZXI7XG59XG5cbi8qIFRoZSBzdmMgY29kZWMgKGF2MS92cDkpIHdvdWxkIHVzZSBhIHZlcnkgbG93IGJpdHJhdGUgYXQgdGhlIGJlZ2luaW5nIGFuZFxuaW5jcmVhc2Ugc2xvd2x5IGJ5IHRoZSBiYW5kd2lkdGggZXN0aW1hdG9yIHVudGlsIGl0IHJlYWNoIHRoZSB0YXJnZXQgYml0cmF0ZS4gVGhlXG5wcm9jZXNzIGNvbW1vbmx5IGNvc3QgbW9yZSB0aGFuIDEwIHNlY29uZHMgY2F1c2Ugc3Vic2NyaWJlciB3aWxsIGdldCBibHVyIHZpZGVvIGF0XG50aGUgZmlyc3QgZmV3IHNlY29uZHMuIFNvIHdlIHVzZSBhIDcwJSBvZiB0YXJnZXQgYml0cmF0ZSBoZXJlIGFzIHRoZSBzdGFydCBiaXRyYXRlIHRvXG5lbGltaW5hdGUgdGhpcyBpc3N1ZS5cbiovXG5jb25zdCBzdGFydEJpdHJhdGVGb3JTVkMgPSAwLjc7XG5cbmNvbnN0IGRlYm91bmNlSW50ZXJ2YWwgPSAyMDtcblxuZXhwb3J0IGNvbnN0IFBDRXZlbnRzID0ge1xuICBOZWdvdGlhdGlvblN0YXJ0ZWQ6ICduZWdvdGlhdGlvblN0YXJ0ZWQnLFxuICBOZWdvdGlhdGlvbkNvbXBsZXRlOiAnbmVnb3RpYXRpb25Db21wbGV0ZScsXG4gIFJUUFZpZGVvUGF5bG9hZFR5cGVzOiAncnRwVmlkZW9QYXlsb2FkVHlwZXMnLFxufSBhcyBjb25zdDtcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUENUcmFuc3BvcnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIF9wYzogUlRDUGVlckNvbm5lY3Rpb24gfCBudWxsO1xuXG4gIHByaXZhdGUgZ2V0IHBjKCkge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGM7XG4gIH1cblxuICBwcml2YXRlIGNvbmZpZz86IFJUQ0NvbmZpZ3VyYXRpb247XG5cbiAgcHJpdmF0ZSBsb2cgPSBsb2c7XG5cbiAgcHJpdmF0ZSBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zO1xuXG4gIHByaXZhdGUgZGRFeHRJRCA9IDA7XG5cbiAgcGVuZGluZ0NhbmRpZGF0ZXM6IFJUQ0ljZUNhbmRpZGF0ZUluaXRbXSA9IFtdO1xuXG4gIHJlc3RhcnRpbmdJY2U6IGJvb2xlYW4gPSBmYWxzZTtcblxuICByZW5lZ290aWF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHRyYWNrQml0cmF0ZXM6IFRyYWNrQml0cmF0ZUluZm9bXSA9IFtdO1xuXG4gIHJlbW90ZVN0ZXJlb01pZHM6IHN0cmluZ1tdID0gW107XG5cbiAgcmVtb3RlTmFja01pZHM6IHN0cmluZ1tdID0gW107XG5cbiAgb25PZmZlcj86IChvZmZlcjogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkgPT4gdm9pZDtcblxuICBvbkljZUNhbmRpZGF0ZT86IChjYW5kaWRhdGU6IFJUQ0ljZUNhbmRpZGF0ZSkgPT4gdm9pZDtcblxuICBvbkljZUNhbmRpZGF0ZUVycm9yPzogKGV2OiBFdmVudCkgPT4gdm9pZDtcblxuICBvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZT86IChzdGF0ZTogUlRDUGVlckNvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZDtcblxuICBvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZT86IChzdGF0ZTogUlRDSWNlQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkO1xuXG4gIG9uU2lnbmFsaW5nU3RhdGVjaGFuZ2U/OiAoc3RhdGU6IFJUQ1NpZ25hbGluZ1N0YXRlKSA9PiB2b2lkO1xuXG4gIG9uRGF0YUNoYW5uZWw/OiAoZXY6IFJUQ0RhdGFDaGFubmVsRXZlbnQpID0+IHZvaWQ7XG5cbiAgb25UcmFjaz86IChldjogUlRDVHJhY2tFdmVudCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBSVENDb25maWd1cmF0aW9uLCBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5QQ1RyYW5zcG9ydCk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0gbG9nZ2VyT3B0aW9ucztcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLl9wYyA9IHRoaXMuY3JlYXRlUEMoKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUEMoKSB7XG4gICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24odGhpcy5jb25maWcpO1xuXG4gICAgcGMub25pY2VjYW5kaWRhdGUgPSAoZXYpID0+IHtcbiAgICAgIGlmICghZXYuY2FuZGlkYXRlKSByZXR1cm47XG4gICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlPy4oZXYuY2FuZGlkYXRlKTtcbiAgICB9O1xuICAgIHBjLm9uaWNlY2FuZGlkYXRlZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcj8uKGV2KTtcbiAgICB9O1xuXG4gICAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPy4ocGMuaWNlQ29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuXG4gICAgcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHRoaXMub25TaWduYWxpbmdTdGF0ZWNoYW5nZT8uKHBjLnNpZ25hbGluZ1N0YXRlKTtcbiAgICB9O1xuXG4gICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlPy4ocGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICB9O1xuICAgIHBjLm9uZGF0YWNoYW5uZWwgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25EYXRhQ2hhbm5lbD8uKGV2KTtcbiAgICB9O1xuICAgIHBjLm9udHJhY2sgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25UcmFjaz8uKGV2KTtcbiAgICB9O1xuICAgIHJldHVybiBwYztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMubG9nZ2VyT3B0aW9ucy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgIH07XG4gIH1cblxuICBnZXQgaXNJQ0VDb25uZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX3BjICE9PSBudWxsICYmXG4gICAgICAodGhpcy5wYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29tcGxldGVkJylcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZTogUlRDSWNlQ2FuZGlkYXRlSW5pdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uICYmICF0aGlzLnJlc3RhcnRpbmdJY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgfVxuXG4gIGFzeW5jIHNldFJlbW90ZURlc2NyaXB0aW9uKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgbGV0IG11bmdlZFNEUDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIGlmIChzZC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICBsZXQgeyBzdGVyZW9NaWRzLCBuYWNrTWlkcyB9ID0gZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLnJlbW90ZVN0ZXJlb01pZHMgPSBzdGVyZW9NaWRzO1xuICAgICAgdGhpcy5yZW1vdGVOYWNrTWlkcyA9IG5hY2tNaWRzO1xuICAgIH0gZWxzZSBpZiAoc2QudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKHNkLnNkcCA/PyAnJyk7XG4gICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAvLyBtdW5nIHNkcCBmb3Igb3B1cyBiaXRyYXRlIHNldHRpbmdzXG4gICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUoKHRyYWNrYnIpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIGlmICghdHJhY2tici50cmFuc2NlaXZlciB8fCBtZWRpYS5taWQgIT0gdHJhY2tici50cmFuc2NlaXZlci5taWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY29kZWNQYXlsb2FkID0gMDtcbiAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKChydHApOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjb2RlY1BheWxvYWQgPSBydHAucGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZtdHBGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbXRwIG9mIG1lZGlhLmZtdHApIHtcbiAgICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgZm10cC5jb25maWcgPSBmbXRwLmNvbmZpZ1xuICAgICAgICAgICAgICAgICAgLnNwbGl0KCc7JylcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGF0dHIpID0+ICFhdHRyLmluY2x1ZGVzKCdtYXhhdmVyYWdlYml0cmF0ZScpKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tici5tYXhiciA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGA7bWF4YXZlcmFnZWJpdHJhdGU9JHt0cmFja2JyLm1heGJyICogMTAwMH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbXRwRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm10cEZvdW5kKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgIG1lZGlhLmZtdHAucHVzaCh7XG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlY1BheWxvYWQsXG4gICAgICAgICAgICAgICAgICBjb25maWc6IGBtYXhhdmVyYWdlYml0cmF0ZT0ke3RyYWNrYnIubWF4YnIgKiAxMDAwfWAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbXVuZ2VkU0RQID0gd3JpdGUoc2RwUGFyc2VkKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zZXRNdW5nZWRTRFAoc2QsIG11bmdlZFNEUCwgdHJ1ZSk7XG5cbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICB9KTtcbiAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzID0gW107XG4gICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5yZW5lZ290aWF0ZSkge1xuICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IGZhbHNlO1xuICAgICAgYXdhaXQgdGhpcy5jcmVhdGVBbmRTZW5kT2ZmZXIoKTtcbiAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSk7XG4gICAgICBpZiAoc2Quc2RwKSB7XG4gICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IHBhcnNlKHNkLnNkcCk7XG4gICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKChtZWRpYSkgPT4ge1xuICAgICAgICAgIGlmIChtZWRpYS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsIG1lZGlhLnJ0cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBkZWJvdW5jZWQgbmVnb3RpYXRlIGludGVyZmFjZVxuICBuZWdvdGlhdGUgPSBkZWJvdW5jZShhc3luYyAob25FcnJvcj86IChlOiBFcnJvcikgPT4gdm9pZCkgPT4ge1xuICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvblN0YXJ0ZWQpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZUFuZFNlbmRPZmZlcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgZGVib3VuY2VJbnRlcnZhbCk7XG5cbiAgYXN5bmMgY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnM/OiBSVENPZmZlck9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5vbk9mZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uaWNlUmVzdGFydCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgSUNFJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BjICYmIHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1sb2NhbC1vZmZlcicpIHtcbiAgICAgIC8vIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSBwZWVyIHRvIGFjY2VwdCBvdXIgb2ZmZXIsIHNvIHdlJ2xsIGp1c3Qgd2FpdFxuICAgICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWRcbiAgICAgIGNvbnN0IGN1cnJlbnRTRCA9IHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uO1xuICAgICAgaWYgKG9wdGlvbnM/LmljZVJlc3RhcnQgJiYgY3VycmVudFNEKSB7XG4gICAgICAgIC8vIFRPRE86IGhhbmRsZSB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAvLyB0aGUgYmVzdCB0aGluZyB0byBkbyBpcyB0byByZWNyZWF0ZSB0aGUgcGVlcmNvbm5lY3Rpb25cbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oY3VycmVudFNEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZWdvdGlhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5fcGMgfHwgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgY3JlYXRlT2ZmZXIgd2l0aCBjbG9zZWQgcGVlciBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhY3R1YWxseSBuZWdvdGlhdGVcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc3RhcnRpbmcgdG8gbmVnb3RpYXRlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgdGhpcy5sb2cuZGVidWcoJ29yaWdpbmFsIG9mZmVyJywgeyBzZHA6IG9mZmVyLnNkcCwgLi4udGhpcy5sb2dDb250ZXh0IH0pO1xuXG4gICAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2Uob2ZmZXIuc2RwID8/ICcnKTtcbiAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICAgIGVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbihtZWRpYSk7XG4gICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIFtdLCBbXSk7XG4gICAgICB9IGVsc2UgaWYgKG1lZGlhLnR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUoKHRyYWNrYnIpOiBib29sZWFuID0+IHtcbiAgICAgICAgICBpZiAoIW1lZGlhLm1zaWQgfHwgIXRyYWNrYnIuY2lkIHx8ICFtZWRpYS5tc2lkLmluY2x1ZGVzKHRyYWNrYnIuY2lkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBjb2RlY1BheWxvYWQgPSAwO1xuICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKChydHApOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIGlmIChydHAuY29kZWMudG9VcHBlckNhc2UoKSA9PT0gdHJhY2tici5jb2RlYy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1NWQ0NvZGVjKHRyYWNrYnIuY29kZWMpKSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMobWVkaWEsIHNkcFBhcnNlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVE9ETzogYXYxIHNsb3cgc3RhcnRpbmcgaXNzdWUgYWxyZWFkeSBmaXhlZCBpbiBjaHJvbWUgMTI0LCBjbGVhbiB0aGlzIGFmdGVyIHNvbWUgdmVyc2lvbnNcbiAgICAgICAgICAvLyBtdW5nIHNkcCBmb3IgYXYxIGJpdHJhdGUgc2V0dGluZyB0aGF0IGNhbid0IGFwcGx5IGJ5IHNlbmRFbmNvZGluZ1xuICAgICAgICAgIGlmICh0cmFja2JyLmNvZGVjICE9PSAnYXYxJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc3RhcnRCaXRyYXRlID0gTWF0aC5yb3VuZCh0cmFja2JyLm1heGJyICogc3RhcnRCaXRyYXRlRm9yU1ZDKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICBpZiAoZm10cC5wYXlsb2FkID09PSBjb2RlY1BheWxvYWQpIHtcbiAgICAgICAgICAgICAgLy8gaWYgYW5vdGhlciB0cmFjaydzIGZtdHAgYWxyZWFkeSBpcyBzZXQsIHdlIGNhbm5vdCBvdmVycmlkZSB0aGUgYml0cmF0ZVxuICAgICAgICAgICAgICAvLyB0aGlzIGhhcyB0aGUgdW5mb3J0dW5hdGUgY29uc2VxdWVuY2Ugb2YgYmVpbmcgZm9yY2VkIHRvIHVzZSB0aGVcbiAgICAgICAgICAgICAgLy8gaW5pdGlhbCB0cmFjaydzIGJpdHJhdGUgZm9yIGFsbCB0cmFja3NcbiAgICAgICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygneC1nb29nbGUtc3RhcnQtYml0cmF0ZScpKSB7XG4gICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gYDt4LWdvb2dsZS1zdGFydC1iaXRyYXRlPSR7c3RhcnRCaXRyYXRlfWA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGF3YWl0IHRoaXMuc2V0TXVuZ2VkU0RQKG9mZmVyLCB3cml0ZShzZHBQYXJzZWQpKTtcbiAgICB0aGlzLm9uT2ZmZXIob2ZmZXIpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQW5kU2V0QW5zd2VyKCk6IFByb21pc2U8UlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdD4ge1xuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMucGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgY29uc3Qgc2RwUGFyc2VkID0gcGFyc2UoYW5zd2VyLnNkcCA/PyAnJyk7XG4gICAgc2RwUGFyc2VkLm1lZGlhLmZvckVhY2goKG1lZGlhKSA9PiB7XG4gICAgICBlbnN1cmVJUEFkZHJNYXRjaFZlcnNpb24obWVkaWEpO1xuICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCB0aGlzLnJlbW90ZVN0ZXJlb01pZHMsIHRoaXMucmVtb3RlTmFja01pZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc2V0TXVuZ2VkU0RQKGFuc3dlciwgd3JpdGUoc2RwUGFyc2VkKSk7XG4gICAgcmV0dXJuIGFuc3dlcjtcbiAgfVxuXG4gIGNyZWF0ZURhdGFDaGFubmVsKGxhYmVsOiBzdHJpbmcsIGRhdGFDaGFubmVsRGljdDogUlRDRGF0YUNoYW5uZWxJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cblxuICBhZGRUcmFuc2NlaXZlcihtZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQ6IFJUQ1J0cFRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBjLmFkZFRyYW5zY2VpdmVyKG1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gIH1cblxuICBhZGRUcmFjayh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBhZGQgdHJhY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuXG4gIHNldFRyYWNrQ29kZWNCaXRyYXRlKGluZm86IFRyYWNrQml0cmF0ZUluZm8pIHtcbiAgICB0aGlzLnRyYWNrQml0cmF0ZXMucHVzaChpbmZvKTtcbiAgfVxuXG4gIHNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnOiBSVENDb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGNvbmZpZ3VyZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGM/LnNldENvbmZpZ3VyYXRpb24ocnRjQ29uZmlnKTtcbiAgfVxuXG4gIGNhblJlbW92ZVRyYWNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuX3BjPy5yZW1vdmVUcmFjaztcbiAgfVxuXG4gIHJlbW92ZVRyYWNrKHNlbmRlcjogUlRDUnRwU2VuZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG5cbiAgZ2V0Q29ubmVjdGlvblN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8uY29ubmVjdGlvblN0YXRlID8/ICdjbG9zZWQnO1xuICB9XG5cbiAgZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8uaWNlQ29ubmVjdGlvblN0YXRlID8/ICdjbG9zZWQnO1xuICB9XG5cbiAgZ2V0U2lnbmFsbGluZ1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8uc2lnbmFsaW5nU3RhdGUgPz8gJ2Nsb3NlZCc7XG4gIH1cblxuICBnZXRUcmFuc2NlaXZlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5nZXRUcmFuc2NlaXZlcnMoKSA/PyBbXTtcbiAgfVxuXG4gIGdldFNlbmRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjPy5nZXRTZW5kZXJzKCkgPz8gW107XG4gIH1cblxuICBnZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wYz8ubG9jYWxEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIGdldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBjPy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKCk7XG4gIH1cblxuICBhc3luYyBnZXRDb25uZWN0ZWRBZGRyZXNzKCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSAnJztcbiAgICBjb25zdCBjYW5kaWRhdGVQYWlycyA9IG5ldyBNYXA8c3RyaW5nLCBSVENJY2VDYW5kaWRhdGVQYWlyU3RhdHM+KCk7XG4gICAgLy8gaWQgLT4gY2FuZGlkYXRlIGlwXG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgY29uc3Qgc3RhdHM6IFJUQ1N0YXRzUmVwb3J0ID0gYXdhaXQgdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBzd2l0Y2ggKHYudHlwZSkge1xuICAgICAgICBjYXNlICd0cmFuc3BvcnQnOlxuICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2FuZGlkYXRlLXBhaXInOlxuICAgICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCA9PT0gJycgJiYgdi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW5kaWRhdGVQYWlycy5zZXQodi5pZCwgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlbW90ZS1jYW5kaWRhdGUnOlxuICAgICAgICAgIGNhbmRpZGF0ZXMuc2V0KHYuaWQsIGAke3YuYWRkcmVzc306JHt2LnBvcnR9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZElEID0gY2FuZGlkYXRlUGFpcnMuZ2V0KHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkKT8ucmVtb3RlQ2FuZGlkYXRlSWQ7XG4gICAgaWYgKHNlbGVjdGVkSUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmRpZGF0ZXMuZ2V0KHNlbGVjdGVkSUQpO1xuICB9XG5cbiAgY2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgIHRoaXMuX3BjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMub25kYXRhY2hhbm5lbCA9IG51bGw7XG4gICAgdGhpcy5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG4gICAgdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMub25pY2VjYW5kaWRhdGUgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9udHJhY2sgPSBudWxsO1xuICAgIHRoaXMuX3BjLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fcGMgPSBudWxsO1xuICB9O1xuXG4gIHByaXZhdGUgYXN5bmMgc2V0TXVuZ2VkU0RQKHNkOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0LCBtdW5nZWQ/OiBzdHJpbmcsIHJlbW90ZT86IGJvb2xlYW4pIHtcbiAgICBpZiAobXVuZ2VkKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbFNkcCA9IHNkLnNkcDtcbiAgICAgIHNkLnNkcCA9IG11bmdlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICAgIGBzZXR0aW5nIG11bmdlZCAke3JlbW90ZSA/ICdyZW1vdGUnIDogJ2xvY2FsJ30gZGVzY3JpcHRpb25gLFxuICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJlbW90ZSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihzZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKGBub3QgYWJsZSB0byBzZXQgJHtzZC50eXBlfSwgZmFsbGluZyBiYWNrIHRvIHVubW9kaWZpZWQgc2RwYCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICBzZHA6IG11bmdlZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHNkLnNkcCA9IG9yaWdpbmFsU2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAocmVtb3RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsZXQgbXNnID0gJ3Vua25vd24gZXJyb3InO1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBtc2cgPSBlLm1lc3NhZ2U7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBtc2cgPSBlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWVsZHM6IGFueSA9IHtcbiAgICAgICAgZXJyb3I6IG1zZyxcbiAgICAgICAgc2RwOiBzZC5zZHAsXG4gICAgICB9O1xuICAgICAgaWYgKCFyZW1vdGUgJiYgdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbikge1xuICAgICAgICBmaWVsZHMucmVtb3RlU2RwID0gdGhpcy5wYy5yZW1vdGVEZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmVycm9yKGB1bmFibGUgdG8gc2V0ICR7c2QudHlwZX1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZmllbGRzIH0pO1xuICAgICAgdGhyb3cgbmV3IE5lZ290aWF0aW9uRXJyb3IobXNnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuc3VyZVZpZGVvRERFeHRlbnNpb25Gb3JTVkMoXG4gICAgbWVkaWE6IHtcbiAgICAgIHR5cGU6IHN0cmluZztcbiAgICAgIHBvcnQ6IG51bWJlcjtcbiAgICAgIHByb3RvY29sOiBzdHJpbmc7XG4gICAgICBwYXlsb2Fkcz86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9ICYgTWVkaWFEZXNjcmlwdGlvbixcbiAgICBzZHA6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgKSB7XG4gICAgY29uc3QgZGRGb3VuZCA9IG1lZGlhLmV4dD8uc29tZSgoZXh0KTogYm9vbGVhbiA9PiB7XG4gICAgICBpZiAoZXh0LnVyaSA9PT0gZGRFeHRlbnNpb25VUkkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBpZiAoIWRkRm91bmQpIHtcbiAgICAgIGlmICh0aGlzLmRkRXh0SUQgPT09IDApIHtcbiAgICAgICAgbGV0IG1heElEID0gMDtcbiAgICAgICAgc2RwLm1lZGlhLmZvckVhY2goKG0pID0+IHtcbiAgICAgICAgICBpZiAobS50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG0uZXh0Py5mb3JFYWNoKChleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChleHQudmFsdWUgPiBtYXhJRCkge1xuICAgICAgICAgICAgICBtYXhJRCA9IGV4dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGRFeHRJRCA9IG1heElEICsgMTtcbiAgICAgIH1cbiAgICAgIG1lZGlhLmV4dD8ucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRkRXh0SUQsXG4gICAgICAgIHVyaTogZGRFeHRlbnNpb25VUkksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKFxuICBtZWRpYToge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBwb3J0OiBudW1iZXI7XG4gICAgcHJvdG9jb2w6IHN0cmluZztcbiAgICBwYXlsb2Fkcz86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfSAmIE1lZGlhRGVzY3JpcHRpb24sXG4gIHN0ZXJlb01pZHM6IHN0cmluZ1tdLFxuICBuYWNrTWlkczogc3RyaW5nW10sXG4pIHtcbiAgLy8gZm91bmQgb3B1cyBjb2RlYyB0byBhZGQgbmFjayBmYlxuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBtZWRpYS5ydHAuc29tZSgocnRwKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG5cbiAgLy8gYWRkIG5hY2sgcnRjcGZiIGlmIG5vdCBleGlzdFxuICBpZiAob3B1c1BheWxvYWQgPiAwKSB7XG4gICAgaWYgKCFtZWRpYS5ydGNwRmIpIHtcbiAgICAgIG1lZGlhLnJ0Y3BGYiA9IFtdO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG5hY2tNaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCEpICYmXG4gICAgICAhbWVkaWEucnRjcEZiLnNvbWUoKGZiKSA9PiBmYi5wYXlsb2FkID09PSBvcHVzUGF5bG9hZCAmJiBmYi50eXBlID09PSAnbmFjaycpXG4gICAgKSB7XG4gICAgICBtZWRpYS5ydGNwRmIucHVzaCh7XG4gICAgICAgIHBheWxvYWQ6IG9wdXNQYXlsb2FkLFxuICAgICAgICB0eXBlOiAnbmFjaycsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcmVvTWlkcy5pbmNsdWRlcyhtZWRpYS5taWQhKSkge1xuICAgICAgbWVkaWEuZm10cC5zb21lKChmbXRwKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKCFmbXRwLmNvbmZpZy5pbmNsdWRlcygnc3RlcmVvPTEnKSkge1xuICAgICAgICAgICAgZm10cC5jb25maWcgKz0gJztzdGVyZW89MSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KToge1xuICBzdGVyZW9NaWRzOiBzdHJpbmdbXTtcbiAgbmFja01pZHM6IHN0cmluZ1tdO1xufSB7XG4gIGNvbnN0IHN0ZXJlb01pZHM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IG5hY2tNaWRzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBzZHBQYXJzZWQgPSBwYXJzZShvZmZlci5zZHAgPz8gJycpO1xuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaCgobWVkaWEpID0+IHtcbiAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgbWVkaWEucnRwLnNvbWUoKHJ0cCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBpZiAocnRwLmNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWVkaWEucnRjcEZiPy5zb21lKChmYikgPT4gZmIucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQgJiYgZmIudHlwZSA9PT0gJ25hY2snKSkge1xuICAgICAgICBuYWNrTWlkcy5wdXNoKG1lZGlhLm1pZCEpO1xuICAgICAgfVxuXG4gICAgICBtZWRpYS5mbXRwLnNvbWUoKGZtdHApOiBib29sZWFuID0+IHtcbiAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQpIHtcbiAgICAgICAgICBpZiAoZm10cC5jb25maWcuaW5jbHVkZXMoJ3Nwcm9wLXN0ZXJlbz0xJykpIHtcbiAgICAgICAgICAgIHN0ZXJlb01pZHMucHVzaChtZWRpYS5taWQhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgc3RlcmVvTWlkcywgbmFja01pZHMgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhOiBNZWRpYURlc2NyaXB0aW9uKSB7XG4gIC8vIENocm9tZSBjb3VsZCBnZW5lcmF0ZSBzZHAgd2l0aCBjID0gSU4gSVA0IDxpcHY2IGFkZHI+XG4gIC8vIGluIGVkZ2UgY2FzZSBhbmQgcmV0dXJuIGVycm9yIHdoZW4gc2V0IHNkcC5UaGlzIGlzIG5vdCBhXG4gIC8vIHNkayBlcnJvciBidXQgY29ycmVjdCBpdCBpZiB0aGUgaXNzdWUgZGV0ZWN0ZWQuXG4gIGlmIChtZWRpYS5jb25uZWN0aW9uKSB7XG4gICAgY29uc3QgaXNWNiA9IG1lZGlhLmNvbm5lY3Rpb24uaXAuaW5kZXhPZignOicpID49IDA7XG4gICAgaWYgKChtZWRpYS5jb25uZWN0aW9uLnZlcnNpb24gPT09IDQgJiYgaXNWNikgfHwgKG1lZGlhLmNvbm5lY3Rpb24udmVyc2lvbiA9PT0gNiAmJiAhaXNWNikpIHtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIGR1bW15IGFkZHJlc3NcbiAgICAgIG1lZGlhLmNvbm5lY3Rpb24uaXAgPSAnMC4wLjAuMCc7XG4gICAgICBtZWRpYS5jb25uZWN0aW9uLnZlcnNpb24gPSA0O1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucywgSW50ZXJuYWxSb29tT3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMnO1xuaW1wb3J0IERlZmF1bHRSZWNvbm5lY3RQb2xpY3kgZnJvbSAnLi9EZWZhdWx0UmVjb25uZWN0UG9saWN5JztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9DYXB0dXJlT3B0aW9ucyxcbiAgVHJhY2tQdWJsaXNoRGVmYXVsdHMsXG4gIFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG59IGZyb20gJy4vdHJhY2svb3B0aW9ucyc7XG5pbXBvcnQgeyBBdWRpb1ByZXNldHMsIFNjcmVlblNoYXJlUHJlc2V0cywgVmlkZW9QcmVzZXRzIH0gZnJvbSAnLi90cmFjay9vcHRpb25zJztcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRWaWRlb0NvZGVjID0gJ3ZwOCc7XG5cbmV4cG9ydCBjb25zdCBwdWJsaXNoRGVmYXVsdHM6IFRyYWNrUHVibGlzaERlZmF1bHRzID0ge1xuICBhdWRpb1ByZXNldDogQXVkaW9QcmVzZXRzLm11c2ljLFxuICBkdHg6IHRydWUsXG4gIHJlZDogdHJ1ZSxcbiAgZm9yY2VTdGVyZW86IGZhbHNlLFxuICBzaW11bGNhc3Q6IHRydWUsXG4gIHNjcmVlblNoYXJlRW5jb2Rpbmc6IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczE1LmVuY29kaW5nLFxuICBzdG9wTWljVHJhY2tPbk11dGU6IGZhbHNlLFxuICB2aWRlb0NvZGVjOiBkZWZhdWx0VmlkZW9Db2RlYyxcbiAgYmFja3VwQ29kZWM6IHRydWUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgYXVkaW9EZWZhdWx0czogQXVkaW9DYXB0dXJlT3B0aW9ucyA9IHtcbiAgZGV2aWNlSWQ6IHsgaWRlYWw6ICdkZWZhdWx0JyB9LFxuICBhdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gIGVjaG9DYW5jZWxsYXRpb246IHRydWUsXG4gIG5vaXNlU3VwcHJlc3Npb246IHRydWUsXG4gIHZvaWNlSXNvbGF0aW9uOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IHZpZGVvRGVmYXVsdHM6IFZpZGVvQ2FwdHVyZU9wdGlvbnMgPSB7XG4gIGRldmljZUlkOiB7IGlkZWFsOiAnZGVmYXVsdCcgfSxcbiAgcmVzb2x1dGlvbjogVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvbixcbn07XG5cbmV4cG9ydCBjb25zdCByb29tT3B0aW9uRGVmYXVsdHM6IEludGVybmFsUm9vbU9wdGlvbnMgPSB7XG4gIGFkYXB0aXZlU3RyZWFtOiBmYWxzZSxcbiAgZHluYWNhc3Q6IGZhbHNlLFxuICBzdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoOiB0cnVlLFxuICByZWNvbm5lY3RQb2xpY3k6IG5ldyBEZWZhdWx0UmVjb25uZWN0UG9saWN5KCksXG4gIGRpc2Nvbm5lY3RPblBhZ2VMZWF2ZTogdHJ1ZSxcbiAgd2ViQXVkaW9NaXg6IGZhbHNlLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHM6IEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zID0ge1xuICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICBtYXhSZXRyaWVzOiAxLFxuICBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IDE1XzAwMCxcbiAgd2Vic29ja2V0VGltZW91dDogMTVfMDAwLFxufSBhcyBjb25zdDtcbiIsImltcG9ydCB7IE11dGV4IH0gZnJvbSAnQGxpdmVraXQvbXV0ZXgnO1xuaW1wb3J0IHsgU2lnbmFsVGFyZ2V0IH0gZnJvbSAnQGxpdmVraXQvcHJvdG9jb2wnO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgZ2V0TG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCBQQ1RyYW5zcG9ydCwgeyBQQ0V2ZW50cyB9IGZyb20gJy4vUENUcmFuc3BvcnQnO1xuaW1wb3J0IHsgcm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMnO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24gfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi90aW1lcnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZW51bSBQQ1RyYW5zcG9ydFN0YXRlIHtcbiAgTkVXLFxuICBDT05ORUNUSU5HLFxuICBDT05ORUNURUQsXG4gIEZBSUxFRCxcbiAgQ0xPU0lORyxcbiAgQ0xPU0VELFxufVxuXG5leHBvcnQgY2xhc3MgUENUcmFuc3BvcnRNYW5hZ2VyIHtcbiAgcHVibGljIHB1Ymxpc2hlcjogUENUcmFuc3BvcnQ7XG5cbiAgcHVibGljIHN1YnNjcmliZXI6IFBDVHJhbnNwb3J0O1xuXG4gIHB1YmxpYyBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IG51bWJlciA9IHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuXG4gIHB1YmxpYyBnZXQgbmVlZHNQdWJsaXNoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG5lZWRzU3Vic2NyaWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuXG4gIHB1YmxpYyBvblN0YXRlQ2hhbmdlPzogKFxuICAgIHN0YXRlOiBQQ1RyYW5zcG9ydFN0YXRlLFxuICAgIHB1YlN0YXRlOiBSVENQZWVyQ29ubmVjdGlvblN0YXRlLFxuICAgIHN1YlN0YXRlOiBSVENQZWVyQ29ubmVjdGlvblN0YXRlLFxuICApID0+IHZvaWQ7XG5cbiAgcHVibGljIG9uSWNlQ2FuZGlkYXRlPzogKGV2OiBSVENJY2VDYW5kaWRhdGUsIHRhcmdldDogU2lnbmFsVGFyZ2V0KSA9PiB2b2lkO1xuXG4gIHB1YmxpYyBvbkRhdGFDaGFubmVsPzogKGV2OiBSVENEYXRhQ2hhbm5lbEV2ZW50KSA9PiB2b2lkO1xuXG4gIHB1YmxpYyBvblRyYWNrPzogKGV2OiBSVENUcmFja0V2ZW50KSA9PiB2b2lkO1xuXG4gIHB1YmxpYyBvblB1Ymxpc2hlck9mZmVyPzogKG9mZmVyOiBSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KSA9PiB2b2lkO1xuXG4gIHByaXZhdGUgaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBpc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBzdGF0ZTogUENUcmFuc3BvcnRTdGF0ZTtcblxuICBwcml2YXRlIGNvbm5lY3Rpb25Mb2NrOiBNdXRleDtcblxuICBwcml2YXRlIHJlbW90ZU9mZmVyTG9jazogTXV0ZXg7XG5cbiAgcHJpdmF0ZSBsb2cgPSBsb2c7XG5cbiAgcHJpdmF0ZSBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJ0Y0NvbmZpZzogUlRDQ29uZmlndXJhdGlvbixcbiAgICBzdWJzY3JpYmVyUHJpbWFyeTogYm9vbGVhbixcbiAgICBsb2dnZXJPcHRpb25zOiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcihsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuUENNYW5hZ2VyKTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuXG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9ICFzdWJzY3JpYmVyUHJpbWFyeTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHN1YnNjcmliZXJQcmltYXJ5O1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5zdWJzY3JpYmVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgbG9nZ2VyT3B0aW9ucyk7XG5cbiAgICB0aGlzLnB1Ymxpc2hlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vblNpZ25hbGluZ1N0YXRlY2hhbmdlID0gdGhpcy51cGRhdGVTdGF0ZTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDYW5kaWRhdGUgPSAoY2FuZGlkYXRlKSA9PiB7XG4gICAgICB0aGlzLm9uSWNlQ2FuZGlkYXRlPy4oY2FuZGlkYXRlLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkljZUNhbmRpZGF0ZSA9IChjYW5kaWRhdGUpID0+IHtcbiAgICAgIHRoaXMub25JY2VDYW5kaWRhdGU/LihjYW5kaWRhdGUsIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICB9O1xuICAgIC8vIGluIHN1YnNjcmliZXIgcHJpbWFyeSBtb2RlLCBzZXJ2ZXIgc2lkZSBvcGVucyBzdWIgZGF0YSBjaGFubmVscy5cbiAgICB0aGlzLnN1YnNjcmliZXIub25EYXRhQ2hhbm5lbCA9IChldikgPT4ge1xuICAgICAgdGhpcy5vbkRhdGFDaGFubmVsPy4oZXYpO1xuICAgIH07XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uVHJhY2sgPSAoZXYpID0+IHtcbiAgICAgIHRoaXMub25UcmFjaz8uKGV2KTtcbiAgICB9O1xuICAgIHRoaXMucHVibGlzaGVyLm9uT2ZmZXIgPSAob2ZmZXIpID0+IHtcbiAgICAgIHRoaXMub25QdWJsaXNoZXJPZmZlcj8uKG9mZmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuTkVXO1xuXG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMucmVtb3RlT2ZmZXJMb2NrID0gbmV3IE11dGV4KCk7XG4gIH1cblxuICBwcml2YXRlIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmxvZ2dlck9wdGlvbnMubG9nZ2VyQ29udGV4dENiPy4oKSxcbiAgICB9O1xuICB9XG5cbiAgcmVxdWlyZVB1Ymxpc2hlcihyZXF1aXJlID0gdHJ1ZSkge1xuICAgIHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuXG4gIHJlcXVpcmVTdWJzY3JpYmVyKHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgdGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQgPSByZXF1aXJlO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuXG4gIGNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlcihvcHRpb25zPzogUlRDT2ZmZXJPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZUFuZFNlbmRPZmZlcihvcHRpb25zKTtcbiAgfVxuXG4gIHNldFB1Ymxpc2hlckFuc3dlcihzZDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gIH1cblxuICByZW1vdmVUcmFjayhzZW5kZXI6IFJUQ1J0cFNlbmRlcikge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMucHVibGlzaGVyICYmIHRoaXMucHVibGlzaGVyLmdldFNpZ25hbGxpbmdTdGF0ZSgpICE9PSAnY2xvc2VkJykge1xuICAgICAgY29uc3QgcHVibGlzaGVyID0gdGhpcy5wdWJsaXNoZXI7XG4gICAgICBmb3IgKGNvbnN0IHNlbmRlciBvZiBwdWJsaXNoZXIuZ2V0U2VuZGVycygpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVE9ETzogcmVhY3QtbmF0aXZlLXdlYnJ0YyBkb2Vzbid0IGhhdmUgcmVtb3ZlVHJhY2sgeWV0LlxuICAgICAgICAgIGlmIChwdWJsaXNoZXIuY2FuUmVtb3ZlVHJhY2soKSkge1xuICAgICAgICAgICAgcHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHJlbW92ZVRyYWNrJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBlIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnB1Ymxpc2hlci5jbG9zZSgpLCB0aGlzLnN1YnNjcmliZXIuY2xvc2UoKV0pO1xuICAgIHRoaXMudXBkYXRlU3RhdGUoKTtcbiAgfVxuXG4gIGFzeW5jIHRyaWdnZXJJY2VSZXN0YXJ0KCkge1xuICAgIHRoaXMuc3Vic2NyaWJlci5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAvLyBvbmx5IHJlc3RhcnQgcHVibGlzaGVyIGlmIGl0J3MgbmVlZGVkXG4gICAgaWYgKHRoaXMubmVlZHNQdWJsaXNoZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBhZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlOiBSVENJY2VDYW5kaWRhdGVJbml0LCB0YXJnZXQ6IFNpZ25hbFRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcbiAgICAgIGF3YWl0IHRoaXMucHVibGlzaGVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgb2ZmZXInLCB7XG4gICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICBSVENTZHBUeXBlOiBzZC50eXBlLFxuICAgICAgc2RwOiBzZC5zZHAsXG4gICAgICBzaWduYWxpbmdTdGF0ZTogdGhpcy5zdWJzY3JpYmVyLmdldFNpZ25hbGxpbmdTdGF0ZSgpLnRvU3RyaW5nKCksXG4gICAgfSk7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5yZW1vdGVPZmZlckxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnN1YnNjcmliZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuXG4gICAgICAvLyBhbnN3ZXIgdGhlIG9mZmVyXG4gICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLnN1YnNjcmliZXIuY3JlYXRlQW5kU2V0QW5zd2VyKCk7XG4gICAgICByZXR1cm4gYW5zd2VyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZzogUlRDQ29uZmlndXJhdGlvbiwgaWNlUmVzdGFydD86IGJvb2xlYW4pIHtcbiAgICB0aGlzLnB1Ymxpc2hlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgdGhpcy5zdWJzY3JpYmVyLnNldENvbmZpZ3VyYXRpb24oY29uZmlnKTtcbiAgICBpZiAoaWNlUmVzdGFydCkge1xuICAgICAgdGhpcy50cmlnZ2VySWNlUmVzdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXI/OiBBYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQ/OiBudW1iZXIpIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICB0cnkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkICYmXG4gICAgICAgIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY29ubmVjdGVkJyAmJlxuICAgICAgICB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RpbmcnXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ25lZ290aWF0aW9uIHJlcXVpcmVkLCBzdGFydCBuZWdvdGlhdGluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMucHVibGlzaGVyLm5lZ290aWF0ZSgpO1xuICAgICAgfVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzPy5tYXAoKHRyYW5zcG9ydCkgPT5cbiAgICAgICAgICB0aGlzLmVuc3VyZVRyYW5zcG9ydENvbm5lY3RlZCh0cmFuc3BvcnQsIGFib3J0Q29udHJvbGxlciwgdGltZW91dCksXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBuZWdvdGlhdGUoYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgbmVnb3RpYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdCgnbmVnb3RpYXRpb24gdGltZWQgb3V0Jyk7XG4gICAgICB9LCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XG5cbiAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG5lZ290aWF0aW9uVGltZW91dCk7XG4gICAgICAgIHJlamVjdCgnbmVnb3RpYXRpb24gYWJvcnRlZCcpO1xuICAgICAgfTtcblxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uU3RhcnRlZCwgKCkgPT4ge1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVibGlzaGVyLm9uY2UoUENFdmVudHMuTmVnb3RpYXRpb25Db21wbGV0ZSwgKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKChlKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQ6IFJUQ1J0cFRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFuc2NlaXZlcih0cmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuXG4gIGFkZFB1Ymxpc2hlclRyYWNrKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuXG4gIGNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxhYmVsOiBzdHJpbmcsIGRhdGFDaGFubmVsRGljdDogUlRDRGF0YUNoYW5uZWxJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBkYXRhQ2hhbm5lbERpY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHJlcXVpcmVkIHRyYW5zcG9ydCdzIGFkZHJlc3MgaWYgbm8gZXhwbGljaXQgdGFyZ2V0IGlzIHNwZWNpZmllZFxuICAgKi9cbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcyh0YXJnZXQ/OiBTaWduYWxUYXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUikge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzWzBdLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHJlcXVpcmVkVHJhbnNwb3J0cygpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzOiBQQ1RyYW5zcG9ydFtdID0gW107XG4gICAgaWYgKHRoaXMuaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnB1Ymxpc2hlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCkge1xuICAgICAgdHJhbnNwb3J0cy5wdXNoKHRoaXMuc3Vic2NyaWJlcik7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZXMgPSB0aGlzLnJlcXVpcmVkVHJhbnNwb3J0cy5tYXAoKHRyKSA9PiB0ci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XG4gICAgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoKHN0KSA9PiBzdCA9PT0gJ2Nvbm5lY3RlZCcpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQ7XG4gICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoKHN0KSA9PiBzdCA9PT0gJ2ZhaWxlZCcpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQ7XG4gICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoKHN0KSA9PiBzdCA9PT0gJ2Nvbm5lY3RpbmcnKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVElORztcbiAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZXMuZXZlcnkoKHN0KSA9PiBzdCA9PT0gJ2Nsb3NlZCcpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TRUQ7XG4gICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoKHN0KSA9PiBzdCA9PT0gJ2Nsb3NlZCcpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5DTE9TSU5HO1xuICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeSgoc3QpID0+IHN0ID09PSAnbmV3JykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXG4gICAgICAgIGBwYyBzdGF0ZSBjaGFuZ2U6IGZyb20gJHtQQ1RyYW5zcG9ydFN0YXRlW3ByZXZpb3VzU3RhdGVdfSB0byAke1xuICAgICAgICAgIFBDVHJhbnNwb3J0U3RhdGVbdGhpcy5zdGF0ZV1cbiAgICAgICAgfWAsXG4gICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICk7XG4gICAgICB0aGlzLm9uU3RhdGVDaGFuZ2U/LihcbiAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCksXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5nZXRDb25uZWN0aW9uU3RhdGUoKSxcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgYXN5bmMgZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKFxuICAgIHBjVHJhbnNwb3J0OiBQQ1RyYW5zcG9ydCxcbiAgICBhYm9ydENvbnRyb2xsZXI/OiBBYm9ydENvbnRyb2xsZXIsXG4gICAgdGltZW91dDogbnVtYmVyID0gdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQsXG4gICkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25TdGF0ZSA9IHBjVHJhbnNwb3J0LmdldENvbm5lY3Rpb25TdGF0ZSgpO1xuICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgdHJhbnNwb3J0IGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuXG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgJ3Jvb20gY29ubmVjdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQnLFxuICAgICAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXI/LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0SGFuZGxlcigpO1xuICAgICAgfVxuICAgICAgYWJvcnRDb250cm9sbGVyPy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuXG4gICAgICBjb25zdCBjb25uZWN0VGltZW91dCA9IENyaXRpY2FsVGltZXJzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXI/LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgJ2NvdWxkIG5vdCBlc3RhYmxpc2ggcGMgY29ubmVjdGlvbicsXG4gICAgICAgICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcixcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfSwgdGltZW91dCk7XG5cbiAgICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICBhd2FpdCBzbGVlcCg1MCk7IC8vIEZJWE1FIHdlIHNob3VsZG4ndCByZWx5IG9uIGBzbGVlcGAgaW4gdGhlIGNvbm5lY3Rpb24gcGF0aHMsIGFzIGl0IGludm9rZXMgYHNldFRpbWVvdXRgIHdoaWNoIGNhbiBiZSBkcmFzdGljYWxseSB0aHJvdHRsZWQgYnkgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlcj8uc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgICAncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCcsXG4gICAgICAgICAgICAgIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhclRpbWVvdXQoY29ubmVjdFRpbWVvdXQpO1xuICAgICAgYWJvcnRDb250cm9sbGVyPy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBTUERYLUZpbGVDb3B5cmlnaHRUZXh0OiAyMDI0IExpdmVLaXQsIEluYy5cbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuaW1wb3J0IHsgUnBjRXJyb3IgYXMgUnBjRXJyb3JfUHJvdG8gfSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5cbi8qKiBQYXJhbWV0ZXJzIGZvciBpbml0aWF0aW5nIGFuIFJQQyBjYWxsICovXG5leHBvcnQgaW50ZXJmYWNlIFBlcmZvcm1ScGNQYXJhbXMge1xuICAvKiogVGhlIGBpZGVudGl0eWAgb2YgdGhlIGRlc3RpbmF0aW9uIHBhcnRpY2lwYW50ICovXG4gIGRlc3RpbmF0aW9uSWRlbnRpdHk6IHN0cmluZztcbiAgLyoqIFRoZSBtZXRob2QgbmFtZSB0byBjYWxsICovXG4gIG1ldGhvZDogc3RyaW5nO1xuICAvKiogVGhlIG1ldGhvZCBwYXlsb2FkICovXG4gIHBheWxvYWQ6IHN0cmluZztcbiAgLyoqIFRpbWVvdXQgZm9yIHJlY2VpdmluZyBhIHJlc3BvbnNlIGFmdGVyIGluaXRpYWwgY29ubmVjdGlvbiAobWlsbGlzZWNvbmRzKS4gRGVmYXVsdDogMTAwMDAgKi9cbiAgcmVzcG9uc2VUaW1lb3V0PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIERhdGEgcGFzc2VkIHRvIG1ldGhvZCBoYW5kbGVyIGZvciBpbmNvbWluZyBSUEMgaW52b2NhdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBScGNJbnZvY2F0aW9uRGF0YSB7XG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIHJlcXVlc3QgSUQuIFdpbGwgbWF0Y2ggYXQgYm90aCBzaWRlcyBvZiB0aGUgY2FsbCwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgb3IgbG9nZ2luZy5cbiAgICovXG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdW5pcXVlIHBhcnRpY2lwYW50IGlkZW50aXR5IG9mIHRoZSBjYWxsZXIuXG4gICAqL1xuICBjYWxsZXJJZGVudGl0eTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcGF5bG9hZCBvZiB0aGUgcmVxdWVzdC4gVXNlci1kZWZpbmFibGUgZm9ybWF0LCB0eXBpY2FsbHkgSlNPTi5cbiAgICovXG4gIHBheWxvYWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gdGltZSB0aGUgY2FsbGVyIHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZS5cbiAgICovXG4gIHJlc3BvbnNlVGltZW91dDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFNwZWNpYWxpemVkIGVycm9yIGhhbmRsaW5nIGZvciBSUEMgbWV0aG9kcy5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyB0eXBlLCB3aGVuIHRocm93biBpbiBhIG1ldGhvZCBoYW5kbGVyLCB3aWxsIGhhdmUgdGhlaXIgYG1lc3NhZ2VgXG4gKiBzZXJpYWxpemVkIGFuZCBzZW50IGFjcm9zcyB0aGUgd2lyZS4gVGhlIHNlbmRlciB3aWxsIHJlY2VpdmUgYW4gZXF1aXZhbGVudCBlcnJvciBvbiB0aGUgb3RoZXIgc2lkZS5cbiAqXG4gKiBCdWlsdC1pbiB0eXBlcyBhcmUgaW5jbHVkZWQgYnV0IGRldmVsb3BlcnMgbWF5IHVzZSBhbnkgc3RyaW5nLCB3aXRoIGEgbWF4IGxlbmd0aCBvZiAyNTYgYnl0ZXMuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJwY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBzdGF0aWMgTUFYX01FU1NBR0VfQllURVMgPSAyNTY7XG5cbiAgc3RhdGljIE1BWF9EQVRBX0JZVEVTID0gMTUzNjA7IC8vIDE1IEtCXG5cbiAgY29kZTogbnVtYmVyO1xuXG4gIGRhdGE/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZGUgYW5kIG1lc3NhZ2UsIHBsdXMgYW4gb3B0aW9uYWwgZGF0YSBwYXlsb2FkLlxuICAgKlxuICAgKiBJZiB0aHJvd24gaW4gYW4gUlBDIG1ldGhvZCBoYW5kbGVyLCB0aGUgZXJyb3Igd2lsbCBiZSBzZW50IGJhY2sgdG8gdGhlIGNhbGxlci5cbiAgICpcbiAgICogRXJyb3IgY29kZXMgMTAwMS0xOTk5IGFyZSByZXNlcnZlZCBmb3IgYnVpbHQtaW4gZXJyb3JzIChzZWUgUnBjRXJyb3IuRXJyb3JDb2RlIGZvciB0aGVpciBtZWFuaW5ncykuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlOiBudW1iZXIsIG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gdHJ1bmNhdGVCeXRlcyhtZXNzYWdlLCBScGNFcnJvci5NQVhfTUVTU0FHRV9CWVRFUyk7XG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IHRydW5jYXRlQnl0ZXMoZGF0YSwgUnBjRXJyb3IuTUFYX0RBVEFfQllURVMpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGZyb21Qcm90byhwcm90bzogUnBjRXJyb3JfUHJvdG8pIHtcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yKHByb3RvLmNvZGUsIHByb3RvLm1lc3NhZ2UsIHByb3RvLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9Qcm90bygpIHtcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yX1Byb3RvKHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSBhcyBudW1iZXIsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgRXJyb3JDb2RlID0ge1xuICAgIEFQUExJQ0FUSU9OX0VSUk9SOiAxNTAwLFxuICAgIENPTk5FQ1RJT05fVElNRU9VVDogMTUwMSxcbiAgICBSRVNQT05TRV9USU1FT1VUOiAxNTAyLFxuICAgIFJFQ0lQSUVOVF9ESVNDT05ORUNURUQ6IDE1MDMsXG4gICAgUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0U6IDE1MDQsXG4gICAgU0VORF9GQUlMRUQ6IDE1MDUsXG5cbiAgICBVTlNVUFBPUlRFRF9NRVRIT0Q6IDE0MDAsXG4gICAgUkVDSVBJRU5UX05PVF9GT1VORDogMTQwMSxcbiAgICBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFOiAxNDAyLFxuICAgIFVOU1VQUE9SVEVEX1NFUlZFUjogMTQwMyxcbiAgICBVTlNVUFBPUlRFRF9WRVJTSU9OOiAxNDA0LFxuICB9IGFzIGNvbnN0O1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBFcnJvck1lc3NhZ2U6IFJlY29yZDxrZXlvZiB0eXBlb2YgUnBjRXJyb3IuRXJyb3JDb2RlLCBzdHJpbmc+ID0ge1xuICAgIEFQUExJQ0FUSU9OX0VSUk9SOiAnQXBwbGljYXRpb24gZXJyb3IgaW4gbWV0aG9kIGhhbmRsZXInLFxuICAgIENPTk5FQ1RJT05fVElNRU9VVDogJ0Nvbm5lY3Rpb24gdGltZW91dCcsXG4gICAgUkVTUE9OU0VfVElNRU9VVDogJ1Jlc3BvbnNlIHRpbWVvdXQnLFxuICAgIFJFQ0lQSUVOVF9ESVNDT05ORUNURUQ6ICdSZWNpcGllbnQgZGlzY29ubmVjdGVkJyxcbiAgICBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRTogJ1Jlc3BvbnNlIHBheWxvYWQgdG9vIGxhcmdlJyxcbiAgICBTRU5EX0ZBSUxFRDogJ0ZhaWxlZCB0byBzZW5kJyxcblxuICAgIFVOU1VQUE9SVEVEX01FVEhPRDogJ01ldGhvZCBub3Qgc3VwcG9ydGVkIGF0IGRlc3RpbmF0aW9uJyxcbiAgICBSRUNJUElFTlRfTk9UX0ZPVU5EOiAnUmVjaXBpZW50IG5vdCBmb3VuZCcsXG4gICAgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRTogJ1JlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UnLFxuICAgIFVOU1VQUE9SVEVEX1NFUlZFUjogJ1JQQyBub3Qgc3VwcG9ydGVkIGJ5IHNlcnZlcicsXG4gICAgVU5TVVBQT1JURURfVkVSU0lPTjogJ1Vuc3VwcG9ydGVkIFJQQyB2ZXJzaW9uJyxcbiAgfSBhcyBjb25zdDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlcnJvciBvYmplY3QgZnJvbSB0aGUgY29kZSwgd2l0aCBhbiBhdXRvLXBvcHVsYXRlZCBtZXNzYWdlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBidWlsdEluKGtleToga2V5b2YgdHlwZW9mIFJwY0Vycm9yLkVycm9yQ29kZSwgZGF0YT86IHN0cmluZyk6IFJwY0Vycm9yIHtcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yKFJwY0Vycm9yLkVycm9yQ29kZVtrZXldLCBScGNFcnJvci5FcnJvck1lc3NhZ2Vba2V5XSwgZGF0YSk7XG4gIH1cbn1cblxuLypcbiAqIE1heGltdW0gcGF5bG9hZCBzaXplIGZvciBSUEMgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy4gSWYgYSBwYXlsb2FkIGV4Y2VlZHMgdGhpcyBzaXplLFxuICogdGhlIFJQQyBjYWxsIHdpbGwgZmFpbCB3aXRoIGEgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRSgxNDAyKSBvciBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRSgxNTA0KSBlcnJvci5cbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9QQVlMT0FEX0JZVEVTID0gMTUzNjA7IC8vIDE1IEtCXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlTGVuZ3RoKHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyKS5sZW5ndGg7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVuY2F0ZUJ5dGVzKHN0cjogc3RyaW5nLCBtYXhCeXRlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKGJ5dGVMZW5ndGgoc3RyKSA8PSBtYXhCeXRlcykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBsZXQgbG93ID0gMDtcbiAgbGV0IGhpZ2ggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoICsgMSkgLyAyKTtcbiAgICBpZiAoZW5jb2Rlci5lbmNvZGUoc3RyLnNsaWNlKDAsIG1pZCkpLmxlbmd0aCA8PSBtYXhCeXRlcykge1xuICAgICAgbG93ID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyLnNsaWNlKDAsIGxvdyk7XG59XG4iLCJleHBvcnQgY29uc3QgbW9uaXRvckZyZXF1ZW5jeSA9IDIwMDA7XG5cbi8vIGtleSBzdGF0cyBmb3Igc2VuZGVycyBhbmQgcmVjZWl2ZXJzXG5pbnRlcmZhY2UgU2VuZGVyU3RhdHMge1xuICAvKiogbnVtYmVyIG9mIHBhY2tldHMgc2VudCAqL1xuICBwYWNrZXRzU2VudD86IG51bWJlcjtcblxuICAvKiogbnVtYmVyIG9mIGJ5dGVzIHNlbnQgKi9cbiAgYnl0ZXNTZW50PzogbnVtYmVyO1xuXG4gIC8qKiBqaXR0ZXIgYXMgcGVyY2VpdmVkIGJ5IHJlbW90ZSAqL1xuICBqaXR0ZXI/OiBudW1iZXI7XG5cbiAgLyoqIHBhY2tldHMgcmVwb3J0ZWQgbG9zdCBieSByZW1vdGUgKi9cbiAgcGFja2V0c0xvc3Q/OiBudW1iZXI7XG5cbiAgLyoqIFJUVCByZXBvcnRlZCBieSByZW1vdGUgKi9cbiAgcm91bmRUcmlwVGltZT86IG51bWJlcjtcblxuICAvKiogSUQgb2YgdGhlIG91dGJvdW5kIHN0cmVhbSAqL1xuICBzdHJlYW1JZD86IHN0cmluZztcblxuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb1NlbmRlclN0YXRzIGV4dGVuZHMgU2VuZGVyU3RhdHMge1xuICB0eXBlOiAnYXVkaW8nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvU2VuZGVyU3RhdHMgZXh0ZW5kcyBTZW5kZXJTdGF0cyB7XG4gIHR5cGU6ICd2aWRlbyc7XG5cbiAgZmlyQ291bnQ6IG51bWJlcjtcblxuICBwbGlDb3VudDogbnVtYmVyO1xuXG4gIG5hY2tDb3VudDogbnVtYmVyO1xuXG4gIHJpZDogc3RyaW5nO1xuXG4gIGZyYW1lV2lkdGg6IG51bWJlcjtcblxuICBmcmFtZUhlaWdodDogbnVtYmVyO1xuXG4gIGZyYW1lc1BlclNlY29uZDogbnVtYmVyO1xuXG4gIGZyYW1lc1NlbnQ6IG51bWJlcjtcblxuICAvLyBiYW5kd2lkdGgsIGNwdSwgb3RoZXIsIG5vbmVcbiAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb24/OiBzdHJpbmc7XG5cbiAgcXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuXG4gIHF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXM/OiBudW1iZXI7XG5cbiAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50PzogbnVtYmVyO1xuXG4gIHRhcmdldEJpdHJhdGU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFJlY2VpdmVyU3RhdHMge1xuICBqaXR0ZXJCdWZmZXJEZWxheT86IG51bWJlcjtcblxuICAvKiogcGFja2V0cyByZXBvcnRlZCBsb3N0IGJ5IHJlbW90ZSAqL1xuICBwYWNrZXRzTG9zdD86IG51bWJlcjtcblxuICAvKiogbnVtYmVyIG9mIHBhY2tldHMgc2VudCAqL1xuICBwYWNrZXRzUmVjZWl2ZWQ/OiBudW1iZXI7XG5cbiAgYnl0ZXNSZWNlaXZlZD86IG51bWJlcjtcblxuICBzdHJlYW1JZD86IHN0cmluZztcblxuICBqaXR0ZXI/OiBudW1iZXI7XG5cbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9SZWNlaXZlclN0YXRzIGV4dGVuZHMgUmVjZWl2ZXJTdGF0cyB7XG4gIHR5cGU6ICdhdWRpbyc7XG5cbiAgY29uY2VhbGVkU2FtcGxlcz86IG51bWJlcjtcblxuICBjb25jZWFsbWVudEV2ZW50cz86IG51bWJlcjtcblxuICBzaWxlbnRDb25jZWFsZWRTYW1wbGVzPzogbnVtYmVyO1xuXG4gIHNpbGVudENvbmNlYWxtZW50RXZlbnRzPzogbnVtYmVyO1xuXG4gIHRvdGFsQXVkaW9FbmVyZ3k/OiBudW1iZXI7XG5cbiAgdG90YWxTYW1wbGVzRHVyYXRpb24/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9SZWNlaXZlclN0YXRzIGV4dGVuZHMgUmVjZWl2ZXJTdGF0cyB7XG4gIHR5cGU6ICd2aWRlbyc7XG5cbiAgZnJhbWVzRGVjb2RlZDogbnVtYmVyO1xuXG4gIGZyYW1lc0Ryb3BwZWQ6IG51bWJlcjtcblxuICBmcmFtZXNSZWNlaXZlZDogbnVtYmVyO1xuXG4gIGZyYW1lV2lkdGg/OiBudW1iZXI7XG5cbiAgZnJhbWVIZWlnaHQ/OiBudW1iZXI7XG5cbiAgZmlyQ291bnQ/OiBudW1iZXI7XG5cbiAgcGxpQ291bnQ/OiBudW1iZXI7XG5cbiAgbmFja0NvdW50PzogbnVtYmVyO1xuXG4gIGRlY29kZXJJbXBsZW1lbnRhdGlvbj86IHN0cmluZztcblxuICBtaW1lVHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaXRyYXRlPFQgZXh0ZW5kcyBSZWNlaXZlclN0YXRzIHwgU2VuZGVyU3RhdHM+KFxuICBjdXJyZW50U3RhdHM6IFQsXG4gIHByZXZTdGF0cz86IFQsXG4pOiBudW1iZXIge1xuICBpZiAoIXByZXZTdGF0cykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBieXRlc05vdzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBsZXQgYnl0ZXNQcmV2OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGlmICgnYnl0ZXNSZWNlaXZlZCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgYnl0ZXNOb3cgPSAoY3VycmVudFN0YXRzIGFzIFJlY2VpdmVyU3RhdHMpLmJ5dGVzUmVjZWl2ZWQ7XG4gICAgYnl0ZXNQcmV2ID0gKHByZXZTdGF0cyBhcyBSZWNlaXZlclN0YXRzKS5ieXRlc1JlY2VpdmVkO1xuICB9IGVsc2UgaWYgKCdieXRlc1NlbnQnIGluIGN1cnJlbnRTdGF0cykge1xuICAgIGJ5dGVzTm93ID0gKGN1cnJlbnRTdGF0cyBhcyBTZW5kZXJTdGF0cykuYnl0ZXNTZW50O1xuICAgIGJ5dGVzUHJldiA9IChwcmV2U3RhdHMgYXMgU2VuZGVyU3RhdHMpLmJ5dGVzU2VudDtcbiAgfVxuICBpZiAoXG4gICAgYnl0ZXNOb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgIGJ5dGVzUHJldiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgY3VycmVudFN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgcHJldlN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAoKGJ5dGVzTm93IC0gYnl0ZXNQcmV2KSAqIDggKiAxMDAwKSAvIChjdXJyZW50U3RhdHMudGltZXN0YW1wIC0gcHJldlN0YXRzLnRpbWVzdGFtcCk7XG59XG4iLCJpbXBvcnQgeyBNdXRleCB9IGZyb20gJ0BsaXZla2l0L211dGV4JztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAndHMtZGVib3VuY2UnO1xuaW1wb3J0IHsgZ2V0QnJvd3NlciB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXJQYXJzZXInO1xuaW1wb3J0IERldmljZU1hbmFnZXIgZnJvbSAnLi4vRGV2aWNlTWFuYWdlcic7XG5pbXBvcnQgeyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yLCBUcmFja0ludmFsaWRFcnJvciB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNvbXBhcmVWZXJzaW9ucywgaXNNb2JpbGUsIHNsZWVwLCB1bndyYXBDb25zdHJhaW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgVHJhY2ssIGF0dGFjaFRvRWxlbWVudCwgZGV0YWNoVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVmlkZW9Db2RlYyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHJvY2Vzc29yIH0gZnJvbSAnLi9wcm9jZXNzb3IvdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBSZXBsYWNlVHJhY2tPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHREaW1lbnNpb25zVGltZW91dCA9IDEwMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIExvY2FsVHJhY2s8XG4gIFRyYWNrS2luZCBleHRlbmRzIFRyYWNrLktpbmQgPSBUcmFjay5LaW5kLFxuPiBleHRlbmRzIFRyYWNrPFRyYWNrS2luZD4ge1xuICBwcm90ZWN0ZWQgX3NlbmRlcj86IFJUQ1J0cFNlbmRlcjtcblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBzZW5kZXIoKTogUlRDUnRwU2VuZGVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXQgc2VuZGVyKHNlbmRlcjogUlRDUnRwU2VuZGVyIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb2RlYz86IFZpZGVvQ29kZWM7XG5cbiAgZ2V0IGNvbnN0cmFpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25zdHJhaW50cztcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50cztcblxuICBwcm90ZWN0ZWQgcmVhY3F1aXJlVHJhY2s6IGJvb2xlYW47XG5cbiAgcHJvdGVjdGVkIHByb3ZpZGVkQnlVc2VyOiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBtdXRlTG9jazogTXV0ZXg7XG5cbiAgcHJvdGVjdGVkIHBhdXNlVXBzdHJlYW1Mb2NrOiBNdXRleDtcblxuICBwcm90ZWN0ZWQgcHJvY2Vzc29yRWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQ7XG5cbiAgcHJvdGVjdGVkIHByb2Nlc3Nvcj86IFRyYWNrUHJvY2Vzc29yPFRyYWNrS2luZCwgYW55PjtcblxuICBwcm90ZWN0ZWQgcHJvY2Vzc29yTG9jazogTXV0ZXg7XG5cbiAgcHJvdGVjdGVkIGF1ZGlvQ29udGV4dD86IEF1ZGlvQ29udGV4dDtcblxuICBwcm90ZWN0ZWQgbWFudWFsbHlTdG9wcGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByZXN0YXJ0TG9jazogTXV0ZXg7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBraW5kXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAga2luZDogVHJhY2tLaW5kLFxuICAgIGNvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzLFxuICAgIHVzZXJQcm92aWRlZFRyYWNrID0gZmFsc2UsXG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2s7XG4gICAgdGhpcy5tdXRlTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMucGF1c2VVcHN0cmVhbUxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnByb2Nlc3NvckxvY2sgPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnJlc3RhcnRMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG1lZGlhVHJhY2ssIHRydWUpO1xuXG4gICAgLy8gYWRkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciwgY29uc3RyYWludHMgYXJlIHN5bmNlZCB3aXRoIE1lZGlhU3RyZWFtVHJhY2tcbiAgICB0aGlzLl9jb25zdHJhaW50cyA9IG1lZGlhVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICBpZiAoY29uc3RyYWludHMpIHtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suaWQ7XG4gIH1cblxuICBnZXQgZGltZW5zaW9ucygpOiBUcmFjay5EaW1lbnNpb25zIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5raW5kICE9PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBfaXNVcHN0cmVhbVBhdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG5cbiAgZ2V0IGlzVXNlclByb3ZpZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVkQnlVc2VyO1xuICB9XG5cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yPy5wcm9jZXNzZWRUcmFjayA/PyB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG5cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIHJldHVybnMgbWVkaWFTdHJlYW1UcmFjayBzZXR0aW5ncyBvZiB0aGUgY2FwdHVyaW5nIG1lZGlhc3RyZWFtdHJhY2sgc291cmNlIC0gaWdub3JpbmcgcHJvY2Vzc29yc1xuICAgKi9cbiAgZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCBmb3JjZT86IGJvb2xlYW4pIHtcbiAgICBpZiAobmV3VHJhY2sgPT09IHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAvLyBkZXRhY2hcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ25ldy10cmFjaycpO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tVbm11dGVFdmVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbmV3VHJhY2tdKTtcbiAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAvLyB3aGVuIHVuZGVybHlpbmcgdHJhY2sgZW1pdHMgbXV0ZSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRldmljZSBpcyB1bmFibGVcbiAgICAgIC8vIHRvIHByb2R1Y2UgbWVkaWEuIEluIHRoaXMgY2FzZSB3ZSdsbCBuZWVkIHRvIHNpZ25hbCB3aXRoIHJlbW90ZSB0aGF0XG4gICAgICAvLyB0aGUgdHJhY2sgaXMgXCJtdXRlZFwiXG4gICAgICAvLyBub3RlIHRoaXMgaXMgZGlmZmVyZW50IGZyb20gTG9jYWxUcmFjay5tdXRlIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgIC8vIHRvdWNoIE1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZFxuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbXV0ZScsIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQpO1xuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gbmV3VHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NlZFRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnByb2Nlc3NvciAmJiBuZXdUcmFjaykge1xuICAgICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5wcm9jZXNzb3JMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3JFbGVtZW50KSB7XG4gICAgICAgICAgYXR0YWNoVG9FbGVtZW50KG5ld1RyYWNrLCB0aGlzLnByb2Nlc3NvckVsZW1lbnQpO1xuICAgICAgICAgIC8vIGVuc3VyZSB0aGUgcHJvY2Vzc29yRWxlbWVudCBpdHNlbGYgc3RheXMgbXV0ZWRcbiAgICAgICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc29yLnJlc3RhcnQoe1xuICAgICAgICAgIHRyYWNrOiBuZXdUcmFjayxcbiAgICAgICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICAgICAgZWxlbWVudDogdGhpcy5wcm9jZXNzb3JFbGVtZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgcHJvY2Vzc2VkVHJhY2sgPSB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zZW5kZXIgJiYgdGhpcy5zZW5kZXIudHJhbnNwb3J0Py5zdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhwcm9jZXNzZWRUcmFjayA/PyBuZXdUcmFjayk7XG4gICAgfVxuICAgIC8vIGlmIGBuZXdUcmFja2AgaXMgZGlmZmVyZW50IGZyb20gdGhlIGV4aXN0aW5nIHRyYWNrLCBzdG9wIHRoZVxuICAgIC8vIG9sZGVyIHRyYWNrIGp1c3QgYmVmb3JlIHJlcGxhY2luZyBpdFxuICAgIGlmICghdGhpcy5wcm92aWRlZEJ5VXNlciAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrICE9PSBuZXdUcmFjaykge1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfVxuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgPSBuZXdUcmFjaztcbiAgICBpZiAobmV3VHJhY2spIHtcbiAgICAgIC8vIHN5bmMgbXV0ZWQgc3RhdGUgd2l0aCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbmV3bHkgcHJvdmlkZWQgdHJhY2tcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICF0aGlzLmlzTXV0ZWQ7XG4gICAgICAvLyB3aGVuIGEgdmFsaWQgdHJhY2sgaXMgcmVwbGFjZSwgd2UnZCB3YW50IHRvIHN0YXJ0IHByb2R1Y2luZ1xuICAgICAgYXdhaXQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xuICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGF0dGFjaFRvRWxlbWVudChwcm9jZXNzZWRUcmFjayA/PyBuZXdUcmFjaywgZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgd2FpdEZvckRpbWVuc2lvbnModGltZW91dCA9IGRlZmF1bHREaW1lbnNpb25zVGltZW91dCk6IFByb21pc2U8VHJhY2suRGltZW5zaW9ucz4ge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBkaW1lbnNpb25zIGZvciBhdWRpbyB0cmFja3MnKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0QnJvd3NlcigpPy5vcyA9PT0gJ2lPUycpIHtcbiAgICAgIC8vIGJyb3dzZXJzIHJlcG9ydCB3cm9uZyBpbml0aWFsIHJlc29sdXRpb24gb24gaU9TLlxuICAgICAgLy8gd2hlbiBzbGlnaHRseSBkZWxheWluZyB0aGUgY2FsbCB0byAuZ2V0U2V0dGluZ3MoKSwgdGhlIGNvcnJlY3QgcmVzb2x1dGlvbiBpcyBiZWluZyByZXBvcnRlZFxuICAgICAgYXdhaXQgc2xlZXAoMTApO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRlZCA8IHRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IGRpbXMgPSB0aGlzLmRpbWVuc2lvbnM7XG4gICAgICBpZiAoZGltcykge1xuICAgICAgICByZXR1cm4gZGltcztcbiAgICAgIH1cbiAgICAgIGF3YWl0IHNsZWVwKDUwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gZ2V0IHRyYWNrIGRpbWVuc2lvbnMgYWZ0ZXIgdGltZW91dCcpO1xuICB9XG5cbiAgYXN5bmMgc2V0RGV2aWNlSWQoZGV2aWNlSWQ6IENvbnN0cmFpbkRPTVN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmIChcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzLmRldmljZUlkID09PSBkZXZpY2VJZCAmJlxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkID09PSB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPSBkZXZpY2VJZDtcblxuICAgIC8vIHdoZW4gdHJhY2sgaXMgbXV0ZWQsIHVuZGVybHlpbmcgbWVkaWEgc3RyZWFtIHRyYWNrIGlzIHN0b3BwZWQgYW5kXG4gICAgLy8gd2lsbCBiZSByZXN0YXJ0ZWQgbGF0ZXJcbiAgICBpZiAodGhpcy5pc011dGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnJlc3RhcnRUcmFjaygpO1xuXG4gICAgcmV0dXJuIHVud3JhcENvbnN0cmFpbnQoZGV2aWNlSWQpID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gIH1cblxuICBhYnN0cmFjdCByZXN0YXJ0VHJhY2soY29uc3RyYWludHM/OiB1bmtub3duKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQHJldHVybnMgRGV2aWNlSUQgb2YgdGhlIGRldmljZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIGZvciB0aGlzIHRyYWNrXG4gICAqL1xuICBhc3luYyBnZXREZXZpY2VJZChub3JtYWxpemUgPSB0cnVlKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICAvLyBzY3JlZW4gc2hhcmUgZG9lc24ndCBoYXZlIGEgdXNhYmxlIGRldmljZSBpZFxuICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGV2aWNlSWQsIGdyb3VwSWQgfSA9IHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zdCBraW5kID0gdGhpcy5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvID8gJ2F1ZGlvaW5wdXQnIDogJ3ZpZGVvaW5wdXQnO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVxuICAgICAgPyBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkubm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpXG4gICAgICA6IGRldmljZUlkO1xuICB9XG5cbiAgYXN5bmMgbXV0ZSgpIHtcbiAgICB0aGlzLnNldFRyYWNrTXV0ZWQodHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhc3luYyB1bm11dGUoKSB7XG4gICAgdGhpcy5zZXRUcmFja011dGVkKGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFzeW5jIHJlcGxhY2VUcmFjayh0cmFjazogTWVkaWFTdHJlYW1UcmFjaywgb3B0aW9ucz86IFJlcGxhY2VUcmFja09wdGlvbnMpOiBQcm9taXNlPHR5cGVvZiB0aGlzPjtcbiAgYXN5bmMgcmVwbGFjZVRyYWNrKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCB1c2VyUHJvdmlkZWRUcmFjaz86IGJvb2xlYW4pOiBQcm9taXNlPHR5cGVvZiB0aGlzPjtcbiAgYXN5bmMgcmVwbGFjZVRyYWNrKFxuICAgIHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHVzZXJQcm92aWRlZE9yT3B0aW9uczogYm9vbGVhbiB8IFJlcGxhY2VUcmFja09wdGlvbnMgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndW5hYmxlIHRvIHJlcGxhY2UgYW4gdW5wdWJsaXNoZWQgdHJhY2snKTtcbiAgICB9XG5cbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2s6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gICAgbGV0IHN0b3BQcm9jZXNzb3I6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIHVzZXJQcm92aWRlZE9yT3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB1c2VyUHJvdmlkZWRUcmFjayA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHVzZXJQcm92aWRlZE9yT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VyUHJvdmlkZWRUcmFjayA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucy51c2VyUHJvdmlkZWRUcmFjaztcbiAgICAgIHN0b3BQcm9jZXNzb3IgPSB1c2VyUHJvdmlkZWRPck9wdGlvbnMuc3RvcFByb2Nlc3NvcjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2sgPz8gdHJ1ZTtcblxuICAgIHRoaXMubG9nLmRlYnVnKCdyZXBsYWNlIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGF3YWl0IHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayh0cmFjayk7XG4gICAgLy8gdGhpcyBtdXN0IGJlIHN5bmNlZCAqYWZ0ZXIqIHNldHRpbmcgbWVkaWFTdHJlYW1UcmFjayBhYm92ZSwgc2luY2UgaXQgcmVsaWVzXG4gICAgLy8gb24gdGhlIHByZXZpb3VzIHN0YXRlIGluIG9yZGVyIHRvIGNsZWFudXBcblxuICAgIGlmIChzdG9wUHJvY2Vzc29yICYmIHRoaXMucHJvY2Vzc29yKSB7XG4gICAgICBhd2FpdCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmVzdGFydChjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cykge1xuICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5yZXN0YXJ0TG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY29uc3RyYWludHMpIHtcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLl9jb25zdHJhaW50cztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgZGV2aWNlSWQsIGZhY2luZ01vZGUsIC4uLm90aGVyQ29uc3RyYWludHMgfSA9IGNvbnN0cmFpbnRzO1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgdHJhY2sgd2l0aCBjb25zdHJhaW50cycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBjb25zdHJhaW50cyB9KTtcblxuICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMgPSB7XG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgdmlkZW86IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICBzdHJlYW1Db25zdHJhaW50cy52aWRlbyA9IGRldmljZUlkIHx8IGZhY2luZ01vZGUgPyB7IGRldmljZUlkLCBmYWNpbmdNb2RlIH0gOiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtQ29uc3RyYWludHMuYXVkaW8gPSBkZXZpY2VJZCA/IHsgZGV2aWNlSWQgfSA6IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZXNlIHN0ZXBzIGFyZSBkdXBsaWNhdGVkIGZyb20gc2V0TWVkaWFTdHJlYW1UcmFjayBiZWNhdXNlIHdlIG11c3Qgc3RvcFxuICAgICAgLy8gdGhlIHByZXZpb3VzIHRyYWNrcyBiZWZvcmUgbmV3IHRyYWNrcyBjYW4gYmUgYWNxdWlyZWRcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgLy8gb24gU2FmYXJpLCB0aGUgb2xkIGF1ZGlvIHRyYWNrIG11c3QgYmUgc3RvcHBlZCBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY3F1aXJlXG4gICAgICAvLyB0aGUgbmV3IHRyYWNrLCBvdGhlcndpc2UgdGhlIG5ldyB0cmFjayB3aWxsIHN0b3Agd2l0aFxuICAgICAgLy8gJ0EgTWVkaWFTdHJlYW1UcmFjayBlbmRlZCBkdWUgdG8gYSBjYXB0dXJlIGZhaWx1cmVgXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcblxuICAgICAgLy8gY3JlYXRlIG5ldyB0cmFjayBhbmQgYXR0YWNoXG4gICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHN0cmVhbUNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IG5ld1RyYWNrID0gbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClbMF07XG4gICAgICBhd2FpdCBuZXdUcmFjay5hcHBseUNvbnN0cmFpbnRzKG90aGVyQ29uc3RyYWludHMpO1xuICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZS1hY3F1aXJlZCBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgICAgYXdhaXQgdGhpcy5zZXRNZWRpYVN0cmVhbVRyYWNrKG5ld1RyYWNrKTtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMubWFudWFsbHlTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oXG4gICAgICAgICAgJ3RyYWNrIHdhcyBzdG9wcGVkIGR1cmluZyBhIHJlc3RhcnQsIHN0b3BwaW5nIHJlc3RhcnRlZCB0cmFjaycsXG4gICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0VHJhY2tNdXRlZChtdXRlZDogYm9vbGVhbikge1xuICAgIHRoaXMubG9nLmRlYnVnKGBzZXR0aW5nICR7dGhpcy5raW5kfSB0cmFjayAke211dGVkID8gJ211dGVkJyA6ICd1bm11dGVkJ31gLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgaWYgKHRoaXMuaXNNdXRlZCA9PT0gbXV0ZWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkICE9PSBtdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNNdXRlZCA9IG11dGVkO1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB0aGlzLmVtaXQobXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgbmVlZHNSZUFjcXVpc2l0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlYWR5U3RhdGUgIT09ICdsaXZlJyB8fFxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5tdXRlZCB8fFxuICAgICAgIXRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCB8fFxuICAgICAgdGhpcy5yZWFjcXVpcmVUcmFja1xuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgYXdhaXQgc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICBpZiAoIWlzTW9iaWxlKCkpIHJldHVybjtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhgdmlzaWJpbGl0eSBjaGFuZ2VkLCBpcyBpbiBCYWNrZ3JvdW5kOiAke3RoaXMuaXNJbkJhY2tncm91bmR9YCwgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgIGlmICghdGhpcy5pc0luQmFja2dyb3VuZCAmJiB0aGlzLm5lZWRzUmVBY3F1aXNpdGlvbiAmJiAhdGhpcy5pc1VzZXJQcm92aWRlZCAmJiAhdGhpcy5pc011dGVkKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhgdHJhY2sgbmVlZHMgdG8gYmUgcmVhY3F1aXJlZCwgcmVzdGFydGluZyAke3RoaXMuc291cmNlfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnQoKTtcbiAgICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVRyYWNrTXV0ZUV2ZW50ID0gKCkgPT5cbiAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIoKS5jYXRjaCgoKSA9PlxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3RyYWNrIG11dGUgYm91bmNlIGdvdCBjYW5jZWxsZWQgYnkgYW4gdW5tdXRlIGV2ZW50JywgdGhpcy5sb2dDb250ZXh0KSxcbiAgICApO1xuXG4gIHByaXZhdGUgZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB0aGlzLnBhdXNlVXBzdHJlYW0oKTtcbiAgfSwgNTAwMCk7XG5cbiAgcHJpdmF0ZSBoYW5kbGVUcmFja1VubXV0ZUV2ZW50ID0gYXN5bmMgKCkgPT4ge1xuICAgIHRoaXMuZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlci5jYW5jZWwoJ3VubXV0ZScpO1xuICAgIGF3YWl0IHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUVuZGVkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kKSB7XG4gICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgfTtcblxuICBzdG9wKCkge1xuICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gdHJ1ZTtcbiAgICBzdXBlci5zdG9wKCk7XG5cbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgIHRoaXMucHJvY2Vzc29yPy5kZXN0cm95KCk7XG4gICAgdGhpcy5wcm9jZXNzb3IgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogcGF1c2VzIHB1Ymxpc2hpbmcgdG8gdGhlIHNlcnZlciB3aXRob3V0IGRpc2FibGluZyB0aGUgbG9jYWwgTWVkaWFTdHJlYW1UcmFja1xuICAgKiB0aGlzIGlzIHVzZWQgdG8gZGlzcGxheSBhIHVzZXIncyBvd24gdmlkZW8gbG9jYWxseSB3aGlsZSBwYXVzaW5nIHB1Ymxpc2hpbmcgdG9cbiAgICogdGhlIHNlcnZlci5cbiAgICogdGhpcyBBUEkgaXMgdW5zdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIgZHVlIHRvIGEgYnVnXG4gICAqKi9cbiAgYXN5bmMgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrLmxvY2soKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX2lzVXBzdHJlYW1QYXVzZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcGF1c2UgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzKTtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICBpZiAoYnJvd3Nlcj8ubmFtZSA9PT0gJ1NhZmFyaScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzEyLjAnKSA8IDApIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDkxMVxuICAgICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigncGF1c2VVcHN0cmVhbSBpcyBub3Qgc3VwcG9ydGVkIG9uIFNhZmFyaSA8IDEyLicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VuZGVyLnRyYW5zcG9ydD8uc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byByZXN1bWUgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzKTtcblxuICAgICAgaWYgKHRoaXMuc2VuZGVyLnRyYW5zcG9ydD8uc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIC8vIHRoaXMgb3BlcmF0aW9uIGlzIG5vb3AgaWYgbWVkaWFzdHJlYW10cmFjayBpcyBhbHJlYWR5IGJlaW5nIHNlbnRcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIExvY2FsVHJhY2sncyB1bmRlcmx5aW5nIFJUQ1J0cFNlbmRlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBhc3luYyBnZXRSVENTdGF0c1JlcG9ydCgpOiBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0IHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLnNlbmRlcj8uZ2V0U3RhdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHNSZXBvcnQgPSBhd2FpdCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIHJldHVybiBzdGF0c1JlcG9ydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgcHJvY2Vzc29yIG9uIHRoaXMgdHJhY2suXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICpcbiAgICogQHBhcmFtIHByb2Nlc3NvclxuICAgKiBAcGFyYW0gc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHNldFByb2Nlc3Nvcihwcm9jZXNzb3I6IFRyYWNrUHJvY2Vzc29yPFRyYWNrS2luZD4sIHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMucHJvY2Vzc29yTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHVwIHByb2Nlc3NvcicsIHRoaXMubG9nQ29udGV4dCk7XG5cbiAgICAgIGNvbnN0IHByb2Nlc3NvckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMua2luZCkgYXMgSFRNTE1lZGlhRWxlbWVudDtcblxuICAgICAgY29uc3QgcHJvY2Vzc29yT3B0aW9ucyA9IHtcbiAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICB0cmFjazogdGhpcy5fbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgZWxlbWVudDogcHJvY2Vzc29yRWxlbWVudCxcbiAgICAgICAgYXVkaW9Db250ZXh0OiB0aGlzLmF1ZGlvQ29udGV4dCxcbiAgICAgIH07XG4gICAgICBhd2FpdCBwcm9jZXNzb3IuaW5pdChwcm9jZXNzb3JPcHRpb25zKTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdwcm9jZXNzb3IgaW5pdGlhbGl6ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcbiAgICAgIH1cblxuICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIHByb2Nlc3NvckVsZW1lbnQpO1xuICAgICAgcHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XG5cbiAgICAgIHByb2Nlc3NvckVsZW1lbnRcbiAgICAgICAgLnBsYXkoKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PlxuICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdmYWlsZWQgdG8gcGxheSBwcm9jZXNzb3IgZWxlbWVudCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvciB9KSxcbiAgICAgICAgKTtcblxuICAgICAgdGhpcy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSBwcm9jZXNzb3JFbGVtZW50O1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5hdHRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGVsICE9PSB0aGlzLnByb2Nlc3NvckVsZW1lbnQgJiYgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpIHtcbiAgICAgICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgICAgIGF0dGFjaFRvRWxlbWVudCh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaywgZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRlcj8ucmVwbGFjZVRyYWNrKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCB0aGlzLnByb2Nlc3Nvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGdldFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3I7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgdGhlIHRyYWNrIHByb2Nlc3NvclxuICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2xpdmVraXQvdHJhY2stcHJvY2Vzc29ycy1qcyBmb3IgZXhhbXBsZSB1c2FnZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBzdG9wUHJvY2Vzc29yKGtlZXBFbGVtZW50ID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5wcm9jZXNzb3IpIHJldHVybjtcblxuICAgIHRoaXMubG9nLmRlYnVnKCdzdG9wcGluZyBwcm9jZXNzb3InLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrPy5zdG9wKCk7XG4gICAgYXdhaXQgdGhpcy5wcm9jZXNzb3IuZGVzdHJveSgpO1xuICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICAgIGlmICgha2VlcEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudD8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLnByb2Nlc3NvckVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIGFwcGx5IG9yaWdpbmFsIHRyYWNrIGNvbnN0cmFpbnRzIGluIGNhc2UgdGhlIHByb2Nlc3NvciBjaGFuZ2VkIHRoZW1cbiAgICBhd2FpdCB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmFwcGx5Q29uc3RyYWludHModGhpcy5fY29uc3RyYWludHMpO1xuICAgIC8vIGZvcmNlIHJlLXNldHRpbmcgb2YgdGhlIG1lZGlhU3RyZWFtVHJhY2sgb24gdGhlIHNlbmRlclxuICAgIGF3YWl0IHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCB0cnVlKTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbW9uaXRvclNlbmRlcigpOiB2b2lkO1xufVxuIiwiaW1wb3J0IHsgQXVkaW9UcmFja0ZlYXR1cmUgfSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IGNvbXB1dGVCaXRyYXRlLCBtb25pdG9yRnJlcXVlbmN5IH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHR5cGUgeyBBdWRpb1NlbmRlclN0YXRzIH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNSZWFjdE5hdGl2ZSwgaXNXZWIsIHVud3JhcENvbnN0cmFpbnQgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgTG9jYWxUcmFjayBmcm9tICcuL0xvY2FsVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgQXVkaW9DYXB0dXJlT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvUHJvY2Vzc29yT3B0aW9ucywgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3Byb2Nlc3Nvci90eXBlcyc7XG5pbXBvcnQgeyBjb25zdHJhaW50c0Zvck9wdGlvbnMsIGRldGVjdFNpbGVuY2UgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxBdWRpb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFjazxUcmFjay5LaW5kLkF1ZGlvPiB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RvcE9uTXV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcHJldlN0YXRzPzogQXVkaW9TZW5kZXJTdGF0cztcblxuICBwcml2YXRlIGlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgcHJvY2Vzc29yPzogVHJhY2tQcm9jZXNzb3I8VHJhY2suS2luZC5BdWRpbywgQXVkaW9Qcm9jZXNzb3JPcHRpb25zPiB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgZW5oYW5jZWQgbm9pc2UgY2FuY2VsbGF0aW9uIGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIG9uIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldCBlbmhhbmNlZE5vaXNlQ2FuY2VsbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIGNvbnN0cmFpbnRzPzogTWVkaWFUcmFja0NvbnN0cmFpbnRzLFxuICAgIHVzZXJQcm92aWRlZFRyYWNrID0gdHJ1ZSxcbiAgICBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQsXG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuQXVkaW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy5jaGVja0ZvclNpbGVuY2UoKTtcbiAgfVxuXG4gIGFzeW5jIG11dGUoKTogUHJvbWlzZTx0eXBlb2YgdGhpcz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdUcmFjayBhbHJlYWR5IG11dGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGRpc2FibGVkIHNwZWNpYWwgaGFuZGxpbmcgYXMgaXQgd2lsbCBjYXVzZSBCVCBoZWFkc2V0cyB0byBzd2l0Y2ggY29tbXVuaWNhdGlvbiBtb2Rlc1xuICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSAmJiB0aGlzLnN0b3BPbk11dGUgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgbWljcm9waG9uZSBpbmRpY2F0b3IgaXMgdHVybmVkIG9mZlxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHN1cGVyLm11dGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1bm11dGUoKTogUHJvbWlzZTx0eXBlb2YgdGhpcz4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMubXV0ZUxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSB1bm11dGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPVxuICAgICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJlxuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09XG4gICAgICAgICAgdW53cmFwQ29uc3RyYWludCh0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmXG4gICAgICAgICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmXG4gICAgICAgICF0aGlzLmlzVXNlclByb3ZpZGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydFRyYWNrKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdXBlci51bm11dGUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnRUcmFjayhvcHRpb25zPzogQXVkaW9DYXB0dXJlT3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7IGF1ZGlvOiBvcHRpb25zIH0pO1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy5hdWRpbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMuYXVkaW87XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcmVzdGFydChjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cyk6IFByb21pc2U8dHlwZW9mIHRoaXM+IHtcbiAgICBjb25zdCB0cmFjayA9IGF3YWl0IHN1cGVyLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgIHRoaXMuY2hlY2tGb3JTaWxlbmNlKCk7XG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG5cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcigpIHtcbiAgICBpZiAoIWlzV2ViKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubW9uaXRvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5tb25pdG9yU2VuZGVyKCk7XG4gICAgfSwgbW9uaXRvckZyZXF1ZW5jeSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbW9uaXRvclNlbmRlciA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXRoaXMuc2VuZGVyKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHN0YXRzOiBBdWRpb1NlbmRlclN0YXRzIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBzdGF0cyA9IGF3YWl0IHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUgPSAoKSA9PiB7XG4gICAgdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhgS3Jpc3Agbm9pc2UgZmlsdGVyIGVuYWJsZWRgLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMuZW1pdChcbiAgICAgIFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsXG4gICAgICB0aGlzLFxuICAgICAgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLFxuICAgICAgdHJ1ZSxcbiAgICApO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUgPSAoKSA9PiB7XG4gICAgdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5sb2cuZGVidWcoYEtyaXNwIG5vaXNlIGZpbHRlciBkaXNhYmxlZGAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5lbWl0KFxuICAgICAgVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSxcbiAgICAgIHRoaXMsXG4gICAgICBBdWRpb1RyYWNrRmVhdHVyZS5URl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT04sXG4gICAgICBmYWxzZSxcbiAgICApO1xuICB9O1xuXG4gIGFzeW5jIHNldFByb2Nlc3Nvcihwcm9jZXNzb3I6IFRyYWNrUHJvY2Vzc29yPFRyYWNrLktpbmQuQXVkaW8sIEF1ZGlvUHJvY2Vzc29yT3B0aW9ucz4pIHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWlzUmVhY3ROYXRpdmUoKSAmJiAhdGhpcy5hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ0F1ZGlvIGNvbnRleHQgbmVlZHMgdG8gYmUgc2V0IG9uIExvY2FsQXVkaW9UcmFjayBpbiBvcmRlciB0byBlbmFibGUgcHJvY2Vzc29ycycsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9wUHJvY2Vzc29yKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb2Nlc3Nvck9wdGlvbnMgPSB7XG4gICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgdHJhY2s6IHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssXG4gICAgICAgIC8vIFJOIHdvbid0IGhhdmUgb3IgdXNlIEF1ZGlvQ29udGV4dFxuICAgICAgICBhdWRpb0NvbnRleHQ6IHRoaXMuYXVkaW9Db250ZXh0IGFzIEF1ZGlvQ29udGV4dCxcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZy5kZWJ1Zyhgc2V0dGluZyB1cCBhdWRpbyBwcm9jZXNzb3IgJHtwcm9jZXNzb3IubmFtZX1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuXG4gICAgICBhd2FpdCBwcm9jZXNzb3IuaW5pdChwcm9jZXNzb3JPcHRpb25zKTtcbiAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZGVyPy5yZXBsYWNlVHJhY2sodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjay5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICdlbmFibGUtbGsta3Jpc3Atbm9pc2UtZmlsdGVyJyxcbiAgICAgICAgICB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgJ2Rpc2FibGUtbGsta3Jpc3Atbm9pc2UtZmlsdGVyJyxcbiAgICAgICAgICB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJEaXNhYmxlLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMucHJvY2Vzc29yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgfVxuXG4gIGFzeW5jIGdldFNlbmRlclN0YXRzKCk6IFByb21pc2U8QXVkaW9TZW5kZXJTdGF0cyB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghdGhpcy5zZW5kZXI/LmdldFN0YXRzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICBsZXQgYXVkaW9TdGF0czogQXVkaW9TZW5kZXJTdGF0cyB8IHVuZGVmaW5lZDtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICBhdWRpb1N0YXRzID0ge1xuICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgcGFja2V0c1NlbnQ6IHYucGFja2V0c1NlbnQsXG4gICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgIHJvdW5kVHJpcFRpbWU6IHYucm91bmRUcmlwVGltZSxcbiAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF1ZGlvU3RhdHM7XG4gIH1cblxuICBhc3luYyBjaGVja0ZvclNpbGVuY2UoKSB7XG4gICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IGF3YWl0IGRldGVjdFNpbGVuY2UodGhpcyk7XG4gICAgaWYgKHRyYWNrSXNTaWxlbnQpIHtcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3NpbGVuY2UgZGV0ZWN0ZWQgb24gbG9jYWwgYXVkaW8gdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuQXVkaW9TaWxlbmNlRGV0ZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2tJc1NpbGVudDtcbiAgfVxufVxuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgZ2V0QnJvd3NlciB9IGZyb20gJy4uLy4uL3V0aWxzL2Jyb3dzZXJQYXJzZXInO1xuaW1wb3J0IHsgVHJhY2tJbnZhbGlkRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IExvY2FsQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IExvY2FsVmlkZW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7XG4gIEJhY2t1cFZpZGVvQ29kZWMsXG4gIFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gIFZpZGVvQ29kZWMsXG4gIFZpZGVvRW5jb2RpbmcsXG59IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgU2NyZWVuU2hhcmVQcmVzZXRzLCBWaWRlb1ByZXNldCwgVmlkZW9QcmVzZXRzLCBWaWRlb1ByZXNldHM0MyB9IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgY29tcGFyZVZlcnNpb25zLFxuICBnZXRSZWFjdE5hdGl2ZU9zLFxuICBpc0ZpcmVGb3gsXG4gIGlzUmVhY3ROYXRpdmUsXG4gIGlzU1ZDQ29kZWMsXG4gIGlzU2FmYXJpLFxuICB1bndyYXBDb25zdHJhaW50LFxufSBmcm9tICcuLi91dGlscyc7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKFxuICBtZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICBjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cyxcbiAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4pOiBMb2NhbFZpZGVvVHJhY2sgfCBMb2NhbEF1ZGlvVHJhY2sge1xuICBzd2l0Y2ggKG1lZGlhU3RyZWFtVHJhY2sua2luZCkge1xuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIHJldHVybiBuZXcgTG9jYWxBdWRpb1RyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIGNvbnN0cmFpbnRzLCBmYWxzZSwgdW5kZWZpbmVkLCBsb2dnZXJPcHRpb25zKTtcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsVmlkZW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIGxvZ2dlck9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoYHVuc3VwcG9ydGVkIHRyYWNrIHR5cGU6ICR7bWVkaWFTdHJlYW1UcmFjay5raW5kfWApO1xuICB9XG59XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHByZXNldHMxNjkgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0cyk7XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHByZXNldHM0MyA9IE9iamVjdC52YWx1ZXMoVmlkZW9QcmVzZXRzNDMpO1xuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBwcmVzZXRzU2NyZWVuU2hhcmUgPSBPYmplY3QudmFsdWVzKFNjcmVlblNoYXJlUHJlc2V0cyk7XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5ID0gW1ZpZGVvUHJlc2V0cy5oMTgwLCBWaWRlb1ByZXNldHMuaDM2MF07XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDMgPSBbVmlkZW9QcmVzZXRzNDMuaDE4MCwgVmlkZW9QcmVzZXRzNDMuaDM2MF07XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzID0gKGZyb21QcmVzZXQ6IFZpZGVvUHJlc2V0KSA9PiB7XG4gIGNvbnN0IGxheWVycyA9IFt7IHNjYWxlUmVzb2x1dGlvbkRvd25CeTogMiwgZnBzOiBmcm9tUHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSB9XTtcbiAgcmV0dXJuIGxheWVycy5tYXAoXG4gICAgKHQpID0+XG4gICAgICBuZXcgVmlkZW9QcmVzZXQoXG4gICAgICAgIE1hdGguZmxvb3IoZnJvbVByZXNldC53aWR0aCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSxcbiAgICAgICAgTWF0aC5mbG9vcihmcm9tUHJlc2V0LmhlaWdodCAvIHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSxcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgMTUwXzAwMCxcbiAgICAgICAgICBNYXRoLmZsb29yKFxuICAgICAgICAgICAgZnJvbVByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlIC9cbiAgICAgICAgICAgICAgKHQuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ICoqIDIgKlxuICAgICAgICAgICAgICAgICgoZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGUgPz8gMzApIC8gKHQuZnBzID8/IDMwKSkpLFxuICAgICAgICAgICksXG4gICAgICAgICksXG4gICAgICAgIHQuZnBzLFxuICAgICAgICBmcm9tUHJlc2V0LmVuY29kaW5nLnByaW9yaXR5LFxuICAgICAgKSxcbiAgKTtcbn07XG5cbi8vIC8qKlxuLy8gICpcbi8vICAqIEBpbnRlcm5hbFxuLy8gICogQGV4cGVyaW1lbnRhbFxuLy8gICovXG4vLyBjb25zdCBjb21wdXRlRGVmYXVsdE11bHRpQ29kZWNTaW11bGNhc3RFbmNvZGluZ3MgPSAod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcbi8vICAgLy8gdXNlIHZwOCBhcyBhIGRlZmF1bHRcbi8vICAgY29uc3QgdnA4ID0gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhmYWxzZSwgd2lkdGgsIGhlaWdodCk7XG4vLyAgIGNvbnN0IHZwOSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuOSB9O1xuLy8gICBjb25zdCBoMjY0ID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMS4xIH07XG4vLyAgIGNvbnN0IGF2MSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuNyB9O1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHZwOCxcbi8vICAgICB2cDksXG4vLyAgICAgaDI2NCxcbi8vICAgICBhdjEsXG4vLyAgIH07XG4vLyB9O1xuXG5jb25zdCB2aWRlb1JpZHMgPSBbJ3EnLCAnaCcsICdmJ107XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVWaWRlb0VuY29kaW5ncyhcbiAgaXNTY3JlZW5TaGFyZTogYm9vbGVhbixcbiAgd2lkdGg/OiBudW1iZXIsXG4gIGhlaWdodD86IG51bWJlcixcbiAgb3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4pOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSB7XG4gIGxldCB2aWRlb0VuY29kaW5nOiBWaWRlb0VuY29kaW5nIHwgdW5kZWZpbmVkID0gb3B0aW9ucz8udmlkZW9FbmNvZGluZztcblxuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHZpZGVvRW5jb2RpbmcgPSBvcHRpb25zPy5zY3JlZW5TaGFyZUVuY29kaW5nO1xuICB9XG5cbiAgY29uc3QgdXNlU2ltdWxjYXN0ID0gb3B0aW9ucz8uc2ltdWxjYXN0O1xuICBjb25zdCBzY2FsYWJpbGl0eU1vZGUgPSBvcHRpb25zPy5zY2FsYWJpbGl0eU1vZGU7XG4gIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRpb25zPy52aWRlb0NvZGVjO1xuXG4gIGlmICgoIXZpZGVvRW5jb2RpbmcgJiYgIXVzZVNpbXVsY2FzdCAmJiAhc2NhbGFiaWxpdHlNb2RlKSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgIC8vIHdoZW4gd2UgYXJlbid0IHNpbXVsY2FzdGluZyBvciBzdmMsIHdpbGwgbmVlZCB0byByZXR1cm4gYSBzaW5nbGUgZW5jb2Rpbmcgd2l0aG91dFxuICAgIC8vIGNhcHBpbmcgYmFuZHdpZHRoLiB3ZSBhbHdheXMgcmVxdWlyZSBhIGVuY29kaW5nIGZvciBkeW5hY2FzdFxuICAgIHJldHVybiBbe31dO1xuICB9XG5cbiAgaWYgKCF2aWRlb0VuY29kaW5nKSB7XG4gICAgLy8gZmluZCB0aGUgcmlnaHQgZW5jb2RpbmcgYmFzZWQgb24gd2lkdGgvaGVpZ2h0XG4gICAgdmlkZW9FbmNvZGluZyA9IGRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmcoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgdmlkZW9Db2RlYyk7XG4gICAgbG9nLmRlYnVnKCd1c2luZyB2aWRlbyBlbmNvZGluZycsIHZpZGVvRW5jb2RpbmcpO1xuICB9XG5cbiAgY29uc3Qgc291cmNlRnJhbWVyYXRlID0gdmlkZW9FbmNvZGluZy5tYXhGcmFtZXJhdGU7XG5cbiAgY29uc3Qgb3JpZ2luYWwgPSBuZXcgVmlkZW9QcmVzZXQoXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHZpZGVvRW5jb2RpbmcubWF4Qml0cmF0ZSxcbiAgICB2aWRlb0VuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICB2aWRlb0VuY29kaW5nLnByaW9yaXR5LFxuICApO1xuXG4gIGlmIChzY2FsYWJpbGl0eU1vZGUgJiYgaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgIGNvbnN0IHNtID0gbmV3IFNjYWxhYmlsaXR5TW9kZShzY2FsYWJpbGl0eU1vZGUpO1xuXG4gICAgY29uc3QgZW5jb2RpbmdzOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSA9IFtdO1xuXG4gICAgaWYgKHNtLnNwYXRpYWwgPiAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNjYWxhYmlsaXR5TW9kZTogJHtzY2FsYWJpbGl0eU1vZGV9YCk7XG4gICAgfVxuICAgIC8vIEJlZm9yZSBNMTEzIGluIENocm9tZSwgZGVmaW5pbmcgbXVsdGlwbGUgZW5jb2RpbmdzIHdpdGggYW4gU1ZDIGNvZGVjIGluZGljYXRlZFxuICAgIC8vIHRoYXQgU1ZDIG1vZGUgc2hvdWxkIGJlIHVzZWQuIFNhZmFyaSBzdGlsbCB3b3JrcyB0aGlzIHdheS5cbiAgICAvLyBUaGlzIGlzIGEgYml0IGNvbmZ1c2luZyBidXQgaXMgZHVlIHRvIGhvdyBsaWJ3ZWJydGMgaW50ZXJwcmV0ZWQgdGhlIGVuY29kaW5ncyBmaWVsZFxuICAgIC8vIGJlZm9yZSBNMTEzLlxuICAgIC8vIEFubm91bmNlZCBoZXJlOiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2cvZGlzY3Vzcy13ZWJydGMvYy8tUVEzcHhybC1mdz9wbGk9MVxuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKFxuICAgICAgaXNTYWZhcmkoKSB8fFxuICAgICAgLy8gRXZlbiB0aG8gUk4gcnVucyBNMTE0LCBpdCBkb2VzIG5vdCBwcm9kdWNlIFNWQyBsYXllcnMgd2hlbiBhIHNpbmdsZSBlbmNvZGluZ1xuICAgICAgLy8gaXMgcHJvdmlkZWQuIFNvIHdlJ2xsIHVzZSB0aGUgbGVnYWN5IFNWQyBzcGVjaWZpY2F0aW9uIGZvciBub3cuXG4gICAgICAvLyBUT0RPOiB3aGVuIHdlIHVwc3RyZWFtIGxpYndlYnJ0YywgdGhpcyB3aWxsIG5lZWQgYWRkaXRpb25hbCB2ZXJpZmljYXRpb25cbiAgICAgIGlzUmVhY3ROYXRpdmUoKSB8fFxuICAgICAgKGJyb3dzZXI/Lm5hbWUgPT09ICdDaHJvbWUnICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyPy52ZXJzaW9uLCAnMTEzJykgPCAwKVxuICAgICkge1xuICAgICAgY29uc3QgYml0cmF0ZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAyIDogMztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICAgIC8vIGluIGxlZ2FjeSBTVkMsIHNjYWxlUmVzb2x1dGlvbkRvd25CeSBjYW5ub3QgYmUgc2V0XG4gICAgICAgIGVuY29kaW5ncy5wdXNoKHtcbiAgICAgICAgICByaWQ6IHZpZGVvUmlkc1syIC0gaV0sXG4gICAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlIC8gYml0cmF0ZXNSYXRpbyAqKiBpLFxuICAgICAgICAgIG1heEZyYW1lcmF0ZTogb3JpZ2luYWwuZW5jb2RpbmcubWF4RnJhbWVyYXRlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGxlZ2FjeSBTVkMsIHNjYWxhYmlsaXR5TW9kZSBpcyBzZXQgb25seSBvbiB0aGUgZmlyc3QgZW5jb2RpbmdcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUgPSBzY2FsYWJpbGl0eU1vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5ncy5wdXNoKHtcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGU6IG9yaWdpbmFsLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBzY2FsYWJpbGl0eU1vZGU6IHNjYWxhYmlsaXR5TW9kZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmdzWzBdLnByaW9yaXR5ID0gb3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZ3NbMF0ubmV0d29ya1ByaW9yaXR5ID0gb3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuXG4gICAgbG9nLmRlYnVnKGB1c2luZyBzdmMgZW5jb2RpbmdgLCB7IGVuY29kaW5ncyB9KTtcbiAgICByZXR1cm4gZW5jb2RpbmdzO1xuICB9XG5cbiAgaWYgKCF1c2VTaW11bGNhc3QpIHtcbiAgICByZXR1cm4gW3ZpZGVvRW5jb2RpbmddO1xuICB9XG5cbiAgbGV0IHByZXNldHM6IEFycmF5PFZpZGVvUHJlc2V0PiA9IFtdO1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHByZXNldHMgPVxuICAgICAgc29ydFByZXNldHMob3B0aW9ucz8uc2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMpID8/XG4gICAgICBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVzZXRzID1cbiAgICAgIHNvcnRQcmVzZXRzKG9wdGlvbnM/LnZpZGVvU2ltdWxjYXN0TGF5ZXJzKSA/PyBkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzKGlzU2NyZWVuU2hhcmUsIG9yaWdpbmFsKTtcbiAgfVxuICBsZXQgbWlkUHJlc2V0OiBWaWRlb1ByZXNldCB8IHVuZGVmaW5lZDtcbiAgaWYgKHByZXNldHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxvd1ByZXNldCA9IHByZXNldHNbMF07XG4gICAgaWYgKHByZXNldHMubGVuZ3RoID4gMSkge1xuICAgICAgWywgbWlkUHJlc2V0XSA9IHByZXNldHM7XG4gICAgfVxuXG4gICAgLy8gTk9URTpcbiAgICAvLyAgIDEuIE9yZGVyaW5nIG9mIHRoZXNlIGVuY29kaW5ncyBpcyBpbXBvcnRhbnQuIENocm9tZSBzZWVtc1xuICAgIC8vICAgICAgdG8gdXNlIHRoZSBpbmRleCBpbnRvIGVuY29kaW5ncyB0byBkZWNpZGUgd2hpY2ggbGF5ZXJcbiAgICAvLyAgICAgIHRvIGRpc2FibGUgd2hlbiBDUFUgY29uc3RyYWluZWQuXG4gICAgLy8gICAgICBTbyBlbmNvZGluZ3Mgc2hvdWxkIGJlIG9yZGVyZWQgaW4gaW5jcmVhc2luZyBzcGF0aWFsXG4gICAgLy8gICAgICByZXNvbHV0aW9uIG9yZGVyLlxuICAgIC8vICAgMi4gbGl2ZWtpdC1zZXJ2ZXIgdHJhbnNsYXRlcyByaWRzIGludG8gbGF5ZXJzLiBTbywgYWxsIGVuY29kaW5nc1xuICAgIC8vICAgICAgc2hvdWxkIGhhdmUgdGhlIGJhc2UgbGF5ZXIgYHFgIGFuZCB0aGVuIG1vcmUgYWRkZWRcbiAgICAvLyAgICAgIGJhc2VkIG9uIG90aGVyIGNvbmRpdGlvbnMuXG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChzaXplID49IDk2MCAmJiBtaWRQcmVzZXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbbG93UHJlc2V0LCBtaWRQcmVzZXQsIG9yaWdpbmFsXSwgc291cmNlRnJhbWVyYXRlKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPj0gNDgwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW2xvd1ByZXNldCwgb3JpZ2luYWxdLCBzb3VyY2VGcmFtZXJhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5jb2RpbmdzRnJvbVByZXNldHMod2lkdGgsIGhlaWdodCwgW29yaWdpbmFsXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MoXG4gIHRyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gIHZpZGVvQ29kZWM6IEJhY2t1cFZpZGVvQ29kZWMsXG4gIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4pIHtcbiAgLy8gYmFja3VwQ29kZWMgc2hvdWxkIG5vdCBiZSB0cnVlIGFueW1vcmUsIGRlZmF1bHQgY29kZWMgaXMgc2V0IGluIExvY2FsUGFydGljaXBhbnQucHVibGlzaFxuICBpZiAoXG4gICAgIW9wdHMuYmFja3VwQ29kZWMgfHxcbiAgICBvcHRzLmJhY2t1cENvZGVjID09PSB0cnVlIHx8XG4gICAgb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyA9PT0gb3B0cy52aWRlb0NvZGVjXG4gICkge1xuICAgIC8vIGJhY2t1cCBjb2RlYyBwdWJsaXNoaW5nIGlzIGRpc2FibGVkXG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2aWRlb0NvZGVjICE9PSBvcHRzLmJhY2t1cENvZGVjLmNvZGVjKSB7XG4gICAgbG9nLndhcm4oJ3JlcXVlc3RlZCBhIGRpZmZlcmVudCBjb2RlYyB0aGFuIHNwZWNpZmllZCBhcyBiYWNrdXAnLCB7XG4gICAgICBzZXJ2ZXJSZXF1ZXN0ZWQ6IHZpZGVvQ29kZWMsXG4gICAgICBiYWNrdXA6IG9wdHMuYmFja3VwQ29kZWMuY29kZWMsXG4gICAgfSk7XG4gIH1cblxuICBvcHRzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAvLyB1c2UgYmFja3VwIGVuY29kaW5nIHNldHRpbmcgYXMgdmlkZW9FbmNvZGluZyBmb3IgYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmdcbiAgb3B0cy52aWRlb0VuY29kaW5nID0gb3B0cy5iYWNrdXBDb2RlYy5lbmNvZGluZztcblxuICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgY29uc3Qgd2lkdGggPSBzZXR0aW5ncy53aWR0aCA/PyB0cmFjay5kaW1lbnNpb25zPy53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gc2V0dGluZ3MuaGVpZ2h0ID8/IHRyYWNrLmRpbWVuc2lvbnM/LmhlaWdodDtcblxuICAvLyBkaXNhYmxlIHNpbXVsY2FzdCBmb3Igc2NyZWVuc2hhcmUgYmFja3VwIGNvZGVjIHNpbmNlIEwxVHggaXMgdXNlZCBieSBwcmltYXJ5IGNvZGVjXG4gIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiBvcHRzLnNpbXVsY2FzdCkge1xuICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKFxuICAgIHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBvcHRzLFxuICApO1xuICByZXR1cm4gZW5jb2RpbmdzO1xufVxuXG4vKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBcHByb3ByaWF0ZUVuY29kaW5nKFxuICBpc1NjcmVlblNoYXJlOiBib29sZWFuLFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgY29kZWM/OiBWaWRlb0NvZGVjLFxuKTogVmlkZW9FbmNvZGluZyB7XG4gIGNvbnN0IHByZXNldHMgPSBwcmVzZXRzRm9yUmVzb2x1dGlvbihpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgbGV0IHsgZW5jb2RpbmcgfSA9IHByZXNldHNbMF07XG5cbiAgLy8gaGFuZGxlIHBvcnRyYWl0IGJ5IHN3YXBwaW5nIGRpbWVuc2lvbnNcbiAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXNldCA9IHByZXNldHNbaV07XG4gICAgZW5jb2RpbmcgPSBwcmVzZXQuZW5jb2Rpbmc7XG4gICAgaWYgKHByZXNldC53aWR0aCA+PSBzaXplKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBwcmVzZXRzIGFyZSBiYXNlZCBvbiB0aGUgYXNzdW1wdGlvbiBvZiB2cDggYXMgYSBjb2RlY1xuICAvLyBmb3Igb3RoZXIgY29kZWNzIHdlIGFkanVzdCB0aGUgbWF4Qml0cmF0ZSBpZiBubyBzcGVjaWZpYyB2aWRlb0VuY29kaW5nIGhhcyBiZWVuIHByb3ZpZGVkXG4gIC8vIHVzZXJzIHNob3VsZCBvdmVycmlkZSB0aGVzZSB3aXRoIG9uZXMgdGhhdCBhcmUgb3B0aW1pemVkIGZvciB0aGVpciB1c2UgY2FzZVxuICAvLyBOT1RFOiBTVkMgY29kZWMgYml0cmF0ZXMgYXJlIGluY2x1c2l2ZSBvZiBhbGwgc2NhbGFiaWxpdHkgbGF5ZXJzLiB3aGlsZVxuICAvLyBiaXRyYXRlIGZvciBub24tU1ZDIGNvZGVjcyBkb2VzIG5vdCBpbmNsdWRlIG90aGVyIHNpbXVsY2FzdCBsYXllcnMuXG4gIGlmIChjb2RlYykge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ2F2MSc6XG4gICAgICAgIGVuY29kaW5nID0geyAuLi5lbmNvZGluZyB9O1xuICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZSAqIDAuNztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2cDknOlxuICAgICAgICBlbmNvZGluZyA9IHsgLi4uZW5jb2RpbmcgfTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjg1O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbmNvZGluZztcbn1cblxuLyogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcHJlc2V0c0ZvclJlc29sdXRpb24oXG4gIGlzU2NyZWVuU2hhcmU6IGJvb2xlYW4sXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuKTogVmlkZW9QcmVzZXRbXSB7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcmV0dXJuIHByZXNldHNTY3JlZW5TaGFyZTtcbiAgfVxuICBjb25zdCBhc3BlY3QgPSB3aWR0aCA+IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogaGVpZ2h0IC8gd2lkdGg7XG4gIGlmIChNYXRoLmFicyhhc3BlY3QgLSAxNi4wIC8gOSkgPCBNYXRoLmFicyhhc3BlY3QgLSA0LjAgLyAzKSkge1xuICAgIHJldHVybiBwcmVzZXRzMTY5O1xuICB9XG4gIHJldHVybiBwcmVzZXRzNDM7XG59XG5cbi8qIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRTaW11bGNhc3RMYXllcnMoXG4gIGlzU2NyZWVuU2hhcmU6IGJvb2xlYW4sXG4gIG9yaWdpbmFsOiBWaWRlb1ByZXNldCxcbik6IFZpZGVvUHJlc2V0W10ge1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHJldHVybiBjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyhvcmlnaW5hbCk7XG4gIH1cbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcmlnaW5hbDtcbiAgY29uc3QgYXNwZWN0ID0gd2lkdGggPiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IGhlaWdodCAvIHdpZHRoO1xuICBpZiAoTWF0aC5hYnMoYXNwZWN0IC0gMTYuMCAvIDkpIDwgTWF0aC5hYnMoYXNwZWN0IC0gNC4wIC8gMykpIHtcbiAgICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHMxNjk7XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDM7XG59XG5cbi8vIHByZXNldHMgc2hvdWxkIGJlIG9yZGVyZWQgYnkgbG93LCBtZWRpdW0sIGhpZ2hcbmZ1bmN0aW9uIGVuY29kaW5nc0Zyb21QcmVzZXRzKFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgcHJlc2V0czogVmlkZW9QcmVzZXRbXSxcbiAgc291cmNlRnJhbWVyYXRlPzogbnVtYmVyIHwgdW5kZWZpbmVkLFxuKTogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10ge1xuICBjb25zdCBlbmNvZGluZ3M6IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdID0gW107XG4gIHByZXNldHMuZm9yRWFjaCgocHJlc2V0LCBpZHgpID0+IHtcbiAgICBpZiAoaWR4ID49IHZpZGVvUmlkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHJpZCA9IHZpZGVvUmlkc1tpZHhdO1xuXG4gICAgY29uc3QgZW5jb2Rpbmc6IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycyA9IHtcbiAgICAgIHJpZCxcbiAgICAgIHNjYWxlUmVzb2x1dGlvbkRvd25CeTogTWF0aC5tYXgoMSwgc2l6ZSAvIE1hdGgubWluKHByZXNldC53aWR0aCwgcHJlc2V0LmhlaWdodCkpLFxuICAgICAgbWF4Qml0cmF0ZTogcHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGUsXG4gICAgfTtcbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgc291cmNlRnJhbWVyYXRlIGlzIHRoZSBoaWdoZXN0IGZyYW1lcmF0ZSBhcHBsaWVkIGFjcm9zcyBhbGwgbGF5ZXJzIHNvIHRoYXQgdGhlXG4gICAgLy8gb3JpZ2luYWwgZW5jb2RpbmcgZG9lc24ndCBnZXQgYnVtcGVkIHVuaW50ZW50aW9uYWxseSBieSBhbnkgb2YgdGhlIG90aGVyIGxheWVyc1xuICAgIGNvbnN0IG1heEZyYW1lcmF0ZSA9XG4gICAgICBzb3VyY2VGcmFtZXJhdGUgJiYgcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZVxuICAgICAgICA/IE1hdGgubWluKHNvdXJjZUZyYW1lcmF0ZSwgcHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSlcbiAgICAgICAgOiBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgIGlmIChtYXhGcmFtZXJhdGUpIHtcbiAgICAgIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IG1heEZyYW1lcmF0ZTtcbiAgICB9XG4gICAgY29uc3QgY2FuU2V0UHJpb3JpdHkgPSBpc0ZpcmVGb3goKSB8fCBpZHggPT09IDA7XG4gICAgaWYgKHByZXNldC5lbmNvZGluZy5wcmlvcml0eSAmJiBjYW5TZXRQcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmcucHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBwcmVzZXQuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgfSk7XG5cbiAgLy8gUk4gaW9zIHNpbXVsY2FzdCByZXF1aXJlcyBhbGwgc2FtZSBmcmFtZXJhdGVzLlxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpICYmIGdldFJlYWN0TmF0aXZlT3MoKSA9PT0gJ2lvcycpIHtcbiAgICBsZXQgdG9wRnJhbWVyYXRlOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nKSA9PiB7XG4gICAgICBpZiAoIXRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAmJiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPiB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgdG9wRnJhbWVyYXRlID0gZW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IG5vdGlmeU9uY2UgPSB0cnVlO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZykgPT4ge1xuICAgICAgaWYgKGVuY29kaW5nLm1heEZyYW1lcmF0ZSAhPSB0b3BGcmFtZXJhdGUpIHtcbiAgICAgICAgaWYgKG5vdGlmeU9uY2UpIHtcbiAgICAgICAgICBub3RpZnlPbmNlID0gZmFsc2U7XG4gICAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgICBgU2ltdWxjYXN0IG9uIGlPUyBSZWFjdC1OYXRpdmUgcmVxdWlyZXMgYWxsIGVuY29kaW5ncyB0byBzaGFyZSB0aGUgc2FtZSBmcmFtZXJhdGUuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5pbmZvKGBTZXR0aW5nIGZyYW1lcmF0ZSBvZiBlbmNvZGluZyBcXFwiJHtlbmNvZGluZy5yaWQgPz8gJyd9XFxcIiB0byAke3RvcEZyYW1lcmF0ZX1gKTtcbiAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gdG9wRnJhbWVyYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRQcmVzZXRzKHByZXNldHM6IEFycmF5PFZpZGVvUHJlc2V0PiB8IHVuZGVmaW5lZCkge1xuICBpZiAoIXByZXNldHMpIHJldHVybjtcbiAgcmV0dXJuIHByZXNldHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHsgZW5jb2Rpbmc6IGFFbmMgfSA9IGE7XG4gICAgY29uc3QgeyBlbmNvZGluZzogYkVuYyB9ID0gYjtcblxuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPiBiRW5jLm1heEJpdHJhdGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlIDwgYkVuYy5tYXhCaXRyYXRlKSByZXR1cm4gLTE7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA9PT0gYkVuYy5tYXhCaXRyYXRlICYmIGFFbmMubWF4RnJhbWVyYXRlICYmIGJFbmMubWF4RnJhbWVyYXRlKSB7XG4gICAgICByZXR1cm4gYUVuYy5tYXhGcmFtZXJhdGUgPiBiRW5jLm1heEZyYW1lcmF0ZSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU2NhbGFiaWxpdHlNb2RlIHtcbiAgc3BhdGlhbDogbnVtYmVyO1xuXG4gIHRlbXBvcmFsOiBudW1iZXI7XG5cbiAgc3VmZml4OiB1bmRlZmluZWQgfCAnaCcgfCAnX0tFWScgfCAnX0tFWV9TSElGVCc7XG5cbiAgY29uc3RydWN0b3Ioc2NhbGFiaWxpdHlNb2RlOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZXN1bHRzID0gc2NhbGFiaWxpdHlNb2RlLm1hdGNoKC9eTChcXGQpVChcXGQpKGh8X0tFWXxfS0VZX1NISUZUKXswLDF9JC8pO1xuICAgIGlmICghcmVzdWx0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhYmlsaXR5IG1vZGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNwYXRpYWwgPSBwYXJzZUludChyZXN1bHRzWzFdKTtcbiAgICB0aGlzLnRlbXBvcmFsID0gcGFyc2VJbnQocmVzdWx0c1syXSk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMykge1xuICAgICAgc3dpdGNoIChyZXN1bHRzWzNdKSB7XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICBjYXNlICdfS0VZJzpcbiAgICAgICAgY2FzZSAnX0tFWV9TSElGVCc6XG4gICAgICAgICAgdGhpcy5zdWZmaXggPSByZXN1bHRzWzNdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBMJHt0aGlzLnNwYXRpYWx9VCR7dGhpcy50ZW1wb3JhbH0ke3RoaXMuc3VmZml4ID8/ICcnfWA7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHREZWdyYWRhdGlvblByZWZlcmVuY2UodHJhY2s6IExvY2FsVmlkZW9UcmFjayk6IFJUQ0RlZ3JhZGF0aW9uUHJlZmVyZW5jZSB7XG4gIC8vIGEgZmV3IG9mIHJlYXNvbnMgd2UgaGF2ZSBkaWZmZXJlbnQgZGVmYXVsdCBwYXRoczpcbiAgLy8gMS4gd2l0aG91dCB0aGlzLCBDaHJvbWUgc2VlbXMgdG8gYWdncmVzc2l2ZWx5IHJlc2l6ZSB0aGUgU1ZDIHZpZGVvIHN0YXRpbmcgYHF1YWxpdHktbGltaXRhdGlvbjogYmFuZHdpZHRoYCBldmVuIHdoZW4gQlcgaXNuJ3QgYW4gaXNzdWVcbiAgLy8gMi4gc2luY2Ugd2UgYXJlIG92ZXJyaWRpbmcgY29udGVudEhpbnQgdG8gbW90aW9uICh0byB3b3JrYXJvdW5kIEwxVDMgcHVibGlzaGluZyksIGl0IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBkZWdyYWRhdGlvblByZWZlcmVuY2UgdG8gYGJhbGFuY2VkYFxuICBpZiAoXG4gICAgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHxcbiAgICAodHJhY2suY29uc3RyYWludHMuaGVpZ2h0ICYmIHVud3JhcENvbnN0cmFpbnQodHJhY2suY29uc3RyYWludHMuaGVpZ2h0KSA+PSAxMDgwKVxuICApIHtcbiAgICByZXR1cm4gJ21haW50YWluLXJlc29sdXRpb24nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnYmFsYW5jZWQnO1xuICB9XG59XG4iLCJpbXBvcnQgeyBNdXRleCB9IGZyb20gJ0BsaXZla2l0L211dGV4JztcbmltcG9ydCB7XG4gIFZpZGVvUXVhbGl0eSBhcyBQcm90b1ZpZGVvUXVhbGl0eSxcbiAgU3Vic2NyaWJlZENvZGVjLFxuICBTdWJzY3JpYmVkUXVhbGl0eSxcbiAgVmlkZW9MYXllcixcbn0gZnJvbSAnQGxpdmVraXQvcHJvdG9jb2wnO1xuaW1wb3J0IHR5cGUgeyBTaWduYWxDbGllbnQgfSBmcm9tICcuLi8uLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCB0eXBlIHsgU3RydWN0dXJlZExvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBnZXRCcm93c2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvYnJvd3NlclBhcnNlcic7XG5pbXBvcnQgeyBTY2FsYWJpbGl0eU1vZGUgfSBmcm9tICcuLi9wYXJ0aWNpcGFudC9wdWJsaXNoVXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBWaWRlb1NlbmRlclN0YXRzIH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUsIG1vbml0b3JGcmVxdWVuY3kgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjb21wYXJlVmVyc2lvbnMsIGlzRmlyZUZveCwgaXNNb2JpbGUsIGlzV2ViIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IExvY2FsVHJhY2sgZnJvbSAnLi9Mb2NhbFRyYWNrJztcbmltcG9ydCB7IFRyYWNrLCBWaWRlb1F1YWxpdHkgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVmlkZW9DYXB0dXJlT3B0aW9ucywgVmlkZW9Db2RlYyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHJvY2Vzc29yIH0gZnJvbSAnLi9wcm9jZXNzb3IvdHlwZXMnO1xuaW1wb3J0IHsgY29uc3RyYWludHNGb3JPcHRpb25zIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBTaW11bGNhc3RUcmFja0luZm8ge1xuICBjb2RlYzogVmlkZW9Db2RlYztcblxuICBtZWRpYVN0cmVhbVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrO1xuXG4gIHNlbmRlcj86IFJUQ1J0cFNlbmRlcjtcblxuICBlbmNvZGluZ3M/OiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXTtcblxuICBjb25zdHJ1Y3Rvcihjb2RlYzogVmlkZW9Db2RlYywgbWVkaWFTdHJlYW1UcmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICAgIHRoaXMuY29kZWMgPSBjb2RlYztcbiAgICB0aGlzLm1lZGlhU3RyZWFtVHJhY2sgPSBtZWRpYVN0cmVhbVRyYWNrO1xuICB9XG59XG5cbmNvbnN0IHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjID0gNTAwMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxWaWRlb1RyYWNrIGV4dGVuZHMgTG9jYWxUcmFjazxUcmFjay5LaW5kLlZpZGVvPiB7XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzaWduYWxDbGllbnQ/OiBTaWduYWxDbGllbnQ7XG5cbiAgcHJpdmF0ZSBwcmV2U3RhdHM/OiBNYXA8c3RyaW5nLCBWaWRlb1NlbmRlclN0YXRzPjtcblxuICBwcml2YXRlIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdO1xuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzaW11bGNhc3RDb2RlY3M6IE1hcDxWaWRlb0NvZGVjLCBTaW11bGNhc3RUcmFja0luZm8+ID0gbmV3IE1hcDxWaWRlb0NvZGVjLCBTaW11bGNhc3RUcmFja0luZm8+KCk7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVkQ29kZWNzPzogU3Vic2NyaWJlZENvZGVjW107XG5cbiAgLy8gcHJldmVudHMgY29uY3VycmVudCBtYW5pcHVsYXRpb25zIHRvIHRyYWNrIHNlbmRlclxuICAvLyBpZiBtdWx0aXBsZSBnZXQvc2V0UGFyYW1ldGVyIGFyZSBjYWxsZWQgY29uY3VycmVudGx5LCBjZXJ0YWluIHRpbWluZyBvZiBldmVudHNcbiAgLy8gY291bGQgbGVhZCB0byB0aGUgYnJvd3NlciB0aHJvd2luZyBhbiBleGNlcHRpb24gaW4gYHNldFBhcmFtZXRlcmAsIGR1ZSB0b1xuICAvLyBhIG1pc3NpbmcgYGdldFBhcmFtZXRlcmAgY2FsbC5cbiAgcHJpdmF0ZSBzZW5kZXJMb2NrOiBNdXRleDtcblxuICBwcml2YXRlIGRlZ3JhZGF0aW9uUHJlZmVyZW5jZTogUlRDRGVncmFkYXRpb25QcmVmZXJlbmNlID0gJ2JhbGFuY2VkJztcblxuICBnZXQgc2VuZGVyKCk6IFJUQ1J0cFNlbmRlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRlcjtcbiAgfVxuXG4gIHNldCBzZW5kZXIoc2VuZGVyOiBSVENSdHBTZW5kZXIgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9zZW5kZXIgPSBzZW5kZXI7XG4gICAgaWYgKHRoaXMuZGVncmFkYXRpb25QcmVmZXJlbmNlKSB7XG4gICAgICB0aGlzLnNldERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0aGlzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBjb25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50cyxcbiAgICB1c2VyUHJvdmlkZWRUcmFjayA9IHRydWUsXG4gICAgbG9nZ2VyT3B0aW9ucz86IExvZ2dlck9wdGlvbnMsXG4gICkge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuVmlkZW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5zZW5kZXJMb2NrID0gbmV3IE11dGV4KCk7XG4gIH1cblxuICBnZXQgaXNTaW11bGNhc3QoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuc2VuZGVyICYmIHRoaXMuc2VuZGVyLmdldFBhcmFtZXRlcnMoKS5lbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3Ioc2lnbmFsQ2xpZW50OiBTaWduYWxDbGllbnQpIHtcbiAgICB0aGlzLnNpZ25hbENsaWVudCA9IHNpZ25hbENsaWVudDtcbiAgICBpZiAoIWlzV2ViKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc2F2ZSBvcmlnaW5hbCBlbmNvZGluZ3NcbiAgICAvLyBUT0RPIDogbWVyZ2Ugc2ltdWxjYXN0IHRyYWNrcyBzdGF0c1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuc2VuZGVyPy5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgdGhpcy5lbmNvZGluZ3MgPSBwYXJhbXMuZW5jb2RpbmdzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldENvbnN0cmFpbnRzKCk7XG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3MuZm9yRWFjaCgodHJhY2tJbmZvKSA9PiB7XG4gICAgICB0cmFja0luZm8ubWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfSk7XG4gICAgc3VwZXIuc3RvcCgpO1xuICB9XG5cbiAgYXN5bmMgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICBhd2FpdCBzdXBlci5wYXVzZVVwc3RyZWFtKCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBzYyBvZiB0aGlzLnNpbXVsY2FzdENvZGVjcy52YWx1ZXMoKSkge1xuICAgICAgYXdhaXQgc2Muc2VuZGVyPy5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgYXdhaXQgc3VwZXIucmVzdW1lVXBzdHJlYW0oKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBhd2FpdCBzYy5zZW5kZXI/LnJlcGxhY2VUcmFjayhzYy5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBtdXRlKCk6IFByb21pc2U8dHlwZW9mIHRoaXM+IHtcbiAgICBjb25zdCB1bmxvY2sgPSBhd2FpdCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuaXNNdXRlZCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEgJiYgIXRoaXMuaXNVc2VyUHJvdmlkZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIC8vIGFsc28gc3RvcCB0aGUgdHJhY2ssIHNvIHRoYXQgY2FtZXJhIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3VwZXIubXV0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVubXV0ZSgpOiBQcm9taXNlPHR5cGVvZiB0aGlzPiB7XG4gICAgY29uc3QgdW5sb2NrID0gYXdhaXQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdUcmFjayBhbHJlYWR5IHVubXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWFjcXVpcmluZyBjYW1lcmEgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRUcmFjaygpO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3VwZXIudW5tdXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHNldFRyYWNrTXV0ZWQobXV0ZWQ6IGJvb2xlYW4pIHtcbiAgICBzdXBlci5zZXRUcmFja011dGVkKG11dGVkKTtcbiAgICBmb3IgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMoKTogUHJvbWlzZTxWaWRlb1NlbmRlclN0YXRzW10+IHtcbiAgICBpZiAoIXRoaXMuc2VuZGVyPy5nZXRTdGF0cykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zOiBWaWRlb1NlbmRlclN0YXRzW10gPSBbXTtcblxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBpZiAodi50eXBlID09PSAnb3V0Ym91bmQtcnRwJykge1xuICAgICAgICBjb25zdCB2czogVmlkZW9TZW5kZXJTdGF0cyA9IHtcbiAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgIGZyYW1lSGVpZ2h0OiB2LmZyYW1lSGVpZ2h0LFxuICAgICAgICAgIGZyYW1lV2lkdGg6IHYuZnJhbWVXaWR0aCxcbiAgICAgICAgICBmcmFtZXNQZXJTZWNvbmQ6IHYuZnJhbWVzUGVyU2Vjb25kLFxuICAgICAgICAgIGZyYW1lc1NlbnQ6IHYuZnJhbWVzU2VudCxcbiAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcbiAgICAgICAgICBwbGlDb3VudDogdi5wbGlDb3VudCxcbiAgICAgICAgICBuYWNrQ291bnQ6IHYubmFja0NvdW50LFxuICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgIGJ5dGVzU2VudDogdi5ieXRlc1NlbnQsXG4gICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZWFzb246IHYucXVhbGl0eUxpbWl0YXRpb25SZWFzb24sXG4gICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM6IHYucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMsXG4gICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlczogdi5xdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzLFxuICAgICAgICAgIHJpZDogdi5yaWQgPz8gdi5pZCxcbiAgICAgICAgICByZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQ6IHYucmV0cmFuc21pdHRlZFBhY2tldHNTZW50LFxuICAgICAgICAgIHRhcmdldEJpdHJhdGU6IHYudGFyZ2V0Qml0cmF0ZSxcbiAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vwqBsb2NhdGUgdGhlIGFwcHJvcHJpYXRlIHJlbW90ZS1pbmJvdW5kLXJ0cCBpdGVtXG4gICAgICAgIGNvbnN0IHIgPSBzdGF0cy5nZXQodi5yZW1vdGVJZCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgdnMuaml0dGVyID0gci5qaXR0ZXI7XG4gICAgICAgICAgdnMucGFja2V0c0xvc3QgPSByLnBhY2tldHNMb3N0O1xuICAgICAgICAgIHZzLnJvdW5kVHJpcFRpbWUgPSByLnJvdW5kVHJpcFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5wdXNoKHZzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIG1ha2Ugc3VyZSBoaWdoZXN0IHJlcyBsYXllciBpcyBhbHdheXMgZmlyc3RcbiAgICBpdGVtcy5zb3J0KChhLCBiKSA9PiAoYi5mcmFtZVdpZHRoID8/IDApIC0gKGEuZnJhbWVXaWR0aCA/PyAwKSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgc2V0UHVibGlzaGluZ1F1YWxpdHkobWF4UXVhbGl0eTogVmlkZW9RdWFsaXR5KSB7XG4gICAgY29uc3QgcXVhbGl0aWVzOiBTdWJzY3JpYmVkUXVhbGl0eVtdID0gW107XG4gICAgZm9yIChsZXQgcSA9IFZpZGVvUXVhbGl0eS5MT1c7IHEgPD0gVmlkZW9RdWFsaXR5LkhJR0g7IHEgKz0gMSkge1xuICAgICAgcXVhbGl0aWVzLnB1c2goXG4gICAgICAgIG5ldyBTdWJzY3JpYmVkUXVhbGl0eSh7XG4gICAgICAgICAgcXVhbGl0eTogcSxcbiAgICAgICAgICBlbmFibGVkOiBxIDw9IG1heFF1YWxpdHksXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoYHNldHRpbmcgcHVibGlzaGluZyBxdWFsaXR5LiBtYXggcXVhbGl0eSAke21heFF1YWxpdHl9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzKTtcbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnRUcmFjayhvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgdW5kZWZpbmVkO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjb25zdCBzdHJlYW1Db25zdHJhaW50cyA9IGNvbnN0cmFpbnRzRm9yT3B0aW9ucyh7IHZpZGVvOiBvcHRpb25zIH0pO1xuICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzID0gc3RyZWFtQ29uc3RyYWludHMudmlkZW87XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucmVzdGFydChjb25zdHJhaW50cyk7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoc2Muc2VuZGVyICYmIHNjLnNlbmRlci50cmFuc3BvcnQ/LnN0YXRlICE9PSAnY2xvc2VkJykge1xuICAgICAgICBzYy5tZWRpYVN0cmVhbVRyYWNrID0gdGhpcy5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCk7XG4gICAgICAgIGF3YWl0IHNjLnNlbmRlci5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2V0UHJvY2Vzc29yKFxuICAgIHByb2Nlc3NvcjogVHJhY2tQcm9jZXNzb3I8VHJhY2suS2luZC5WaWRlbz4sXG4gICAgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkgPSB0cnVlLFxuICApIHtcbiAgICBhd2FpdCBzdXBlci5zZXRQcm9jZXNzb3IocHJvY2Vzc29yLCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSk7XG5cbiAgICBpZiAodGhpcy5wcm9jZXNzb3I/LnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHNjIG9mIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSB7XG4gICAgICAgIGF3YWl0IHNjLnNlbmRlcj8ucmVwbGFjZVRyYWNrKHRoaXMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBzZXREZWdyYWRhdGlvblByZWZlcmVuY2UocHJlZmVyZW5jZTogUlRDRGVncmFkYXRpb25QcmVmZXJlbmNlKSB7XG4gICAgdGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBwcmVmZXJlbmNlO1xuICAgIGlmICh0aGlzLnNlbmRlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoYHNldHRpbmcgZGVncmFkYXRpb25QcmVmZXJlbmNlIHRvICR7cHJlZmVyZW5jZX1gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBwcmVmZXJlbmNlO1xuICAgICAgICB0aGlzLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybihgZmFpbGVkIHRvIHNldCBkZWdyYWRhdGlvblByZWZlcmVuY2VgLCB7IGVycm9yOiBlLCAuLi50aGlzLmxvZ0NvbnRleHQgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYWRkU2ltdWxjYXN0VHJhY2soXG4gICAgY29kZWM6IFZpZGVvQ29kZWMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICk6IFNpbXVsY2FzdFRyYWNrSW5mbyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMuc2ltdWxjYXN0Q29kZWNzLmhhcyhjb2RlYykpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKGAke2NvZGVjfSBhbHJlYWR5IGFkZGVkLCBza2lwcGluZyBhZGRpbmcgc2ltdWxjYXN0IGNvZGVjYCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvOiBTaW11bGNhc3RUcmFja0luZm8gPSB7XG4gICAgICBjb2RlYyxcbiAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpLFxuICAgICAgc2VuZGVyOiB1bmRlZmluZWQsXG4gICAgICBlbmNvZGluZ3MsXG4gICAgfTtcbiAgICB0aGlzLnNpbXVsY2FzdENvZGVjcy5zZXQoY29kZWMsIHNpbXVsY2FzdENvZGVjSW5mbyk7XG4gICAgcmV0dXJuIHNpbXVsY2FzdENvZGVjSW5mbztcbiAgfVxuXG4gIHNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKGNvZGVjOiBWaWRlb0NvZGVjLCBzZW5kZXI6IFJUQ1J0cFNlbmRlcikge1xuICAgIGNvbnN0IHNpbXVsY2FzdENvZGVjSW5mbyA9IHRoaXMuc2ltdWxjYXN0Q29kZWNzLmdldChjb2RlYyk7XG4gICAgaWYgKCFzaW11bGNhc3RDb2RlY0luZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2ltdWxjYXN0Q29kZWNJbmZvLnNlbmRlciA9IHNlbmRlcjtcblxuICAgIC8vIGJyb3dzZXIgd2lsbCByZWVuYWJsZSBkaXNhYmxlZCBjb2RlYy9sYXllcnMgYWZ0ZXIgbmV3IGNvZGVjIGhhcyBiZWVuIHB1Ymxpc2hlZCxcbiAgICAvLyBzbyByZWZyZXNoIHN1YnNjcmliZWRDb2RlY3MgYWZ0ZXIgcHVibGlzaCBhIG5ldyBjb2RlY1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3Vic2NyaWJlZENvZGVjcykge1xuICAgICAgICB0aGlzLnNldFB1Ymxpc2hpbmdDb2RlY3ModGhpcy5zdWJzY3JpYmVkQ29kZWNzKTtcbiAgICAgIH1cbiAgICB9LCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgY29kZWNzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmcsIHJldHVybnMgbmV3IGNvZGVjcyB0aGF0IGhhdmUgbm90IHlldFxuICAgKiBiZWVuIHB1Ymxpc2hlZFxuICAgKi9cbiAgYXN5bmMgc2V0UHVibGlzaGluZ0NvZGVjcyhjb2RlY3M6IFN1YnNjcmliZWRDb2RlY1tdKTogUHJvbWlzZTxWaWRlb0NvZGVjW10+IHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyBwdWJsaXNoaW5nIGNvZGVjcycsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIGNvZGVjcyxcbiAgICAgIGN1cnJlbnRDb2RlYzogdGhpcy5jb2RlYyxcbiAgICB9KTtcbiAgICAvLyBvbmx5IGVuYWJsZSBzaW11bGNhc3QgY29kZWMgZm9yIHByZWZlcmVuY2UgY29kZWMgc2V0dGVkXG4gICAgaWYgKCF0aGlzLmNvZGVjICYmIGNvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoY29kZWNzWzBdLnF1YWxpdGllcyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdGhpcy5zdWJzY3JpYmVkQ29kZWNzID0gY29kZWNzO1xuXG4gICAgY29uc3QgbmV3Q29kZWNzOiBWaWRlb0NvZGVjW10gPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNvZGVjIG9mIGNvZGVjcykge1xuICAgICAgaWYgKCF0aGlzLmNvZGVjIHx8IHRoaXMuY29kZWMgPT09IGNvZGVjLmNvZGVjKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhjb2RlYy5xdWFsaXRpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0gdGhpcy5zaW11bGNhc3RDb2RlY3MuZ2V0KGNvZGVjLmNvZGVjIGFzIFZpZGVvQ29kZWMpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgdHJ5IHNldFB1Ymxpc2hpbmdDb2RlYyBmb3IgJHtjb2RlYy5jb2RlY31gLCB7XG4gICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIHNpbXVsY2FzdENvZGVjSW5mbyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvIHx8ICFzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBxIG9mIGNvZGVjLnF1YWxpdGllcykge1xuICAgICAgICAgICAgaWYgKHEuZW5hYmxlZCkge1xuICAgICAgICAgICAgICBuZXdDb2RlY3MucHVzaChjb2RlYy5jb2RlYyBhcyBWaWRlb0NvZGVjKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNpbXVsY2FzdENvZGVjSW5mby5lbmNvZGluZ3MpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgdHJ5IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIgJHtjb2RlYy5jb2RlY31gLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGF3YWl0IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIoXG4gICAgICAgICAgICBzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyLFxuICAgICAgICAgICAgc2ltdWxjYXN0Q29kZWNJbmZvLmVuY29kaW5ncyEsXG4gICAgICAgICAgICBjb2RlYy5xdWFsaXRpZXMsXG4gICAgICAgICAgICB0aGlzLnNlbmRlckxvY2ssXG4gICAgICAgICAgICB0aGlzLmxvZyxcbiAgICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdDb2RlY3M7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgbGF5ZXJzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmdcbiAgICovXG4gIGFzeW5jIHNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzOiBTdWJzY3JpYmVkUXVhbGl0eVtdKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NldHRpbmcgcHVibGlzaGluZyBsYXllcnMnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgcXVhbGl0aWVzIH0pO1xuICAgIGlmICghdGhpcy5zZW5kZXIgfHwgIXRoaXMuZW5jb2RpbmdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihcbiAgICAgIHRoaXMuc2VuZGVyLFxuICAgICAgdGhpcy5lbmNvZGluZ3MsXG4gICAgICBxdWFsaXRpZXMsXG4gICAgICB0aGlzLnNlbmRlckxvY2ssXG4gICAgICB0aGlzLmxvZyxcbiAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1vbml0b3JTZW5kZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBzdGF0czogVmlkZW9TZW5kZXJTdGF0c1tdIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBzdGF0cyA9IGF3YWl0IHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzTWFwID0gbmV3IE1hcDxzdHJpbmcsIFZpZGVvU2VuZGVyU3RhdHM+KHN0YXRzLm1hcCgocykgPT4gW3MucmlkLCBzXSkpO1xuXG4gICAgaWYgKHRoaXMucHJldlN0YXRzKSB7XG4gICAgICBsZXQgdG90YWxCaXRyYXRlID0gMDtcbiAgICAgIHN0YXRzTWFwLmZvckVhY2goKHMsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5wcmV2U3RhdHM/LmdldChrZXkpO1xuICAgICAgICB0b3RhbEJpdHJhdGUgKz0gY29tcHV0ZUJpdHJhdGUocywgcHJldik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gdG90YWxCaXRyYXRlO1xuICAgIH1cblxuICAgIHRoaXMucHJldlN0YXRzID0gc3RhdHNNYXA7XG4gIH07XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCkge1xuICAgIGF3YWl0IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCk7XG4gICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XG4gICAgaWYgKHRoaXMuaXNJbkJhY2tncm91bmQgJiYgdGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5DYW1lcmEpIHtcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKFxuICBzZW5kZXI6IFJUQ1J0cFNlbmRlcixcbiAgc2VuZGVyRW5jb2RpbmdzOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSxcbiAgcXVhbGl0aWVzOiBTdWJzY3JpYmVkUXVhbGl0eVtdLFxuICBzZW5kZXJMb2NrOiBNdXRleCxcbiAgbG9nOiBTdHJ1Y3R1cmVkTG9nZ2VyLFxuICBsb2dDb250ZXh0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbikge1xuICBjb25zdCB1bmxvY2sgPSBhd2FpdCBzZW5kZXJMb2NrLmxvY2soKTtcbiAgbG9nLmRlYnVnKCdzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyJywgeyAuLi5sb2dDb250ZXh0LCBzZW5kZXIsIHF1YWxpdGllcywgc2VuZGVyRW5jb2RpbmdzIH0pO1xuICB0cnkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgY29uc3QgeyBlbmNvZGluZ3MgfSA9IHBhcmFtcztcbiAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbmNvZGluZ3MubGVuZ3RoICE9PSBzZW5kZXJFbmNvZGluZ3MubGVuZ3RoKSB7XG4gICAgICBsb2cud2FybignY2Fubm90IHNldCBwdWJsaXNoaW5nIGxheWVycywgZW5jb2RpbmdzIG1pc21hdGNoJywge1xuICAgICAgICAuLi5sb2dDb250ZXh0LFxuICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgIHNlbmRlckVuY29kaW5ncyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBjb25zdCBjbG9zYWJsZVNwYXRpYWwgPVxuICAgICAgYnJvd3Nlcj8ubmFtZSA9PT0gJ0Nocm9tZScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXI/LnZlcnNpb24sICcxMzMnKSA+IDA7XG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGlmIChjbG9zYWJsZVNwYXRpYWwgJiYgZW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSkge1xuICAgICAgLy8gc3ZjIGR5bmFjYXN0IGVuY29kaW5nc1xuICAgICAgY29uc3QgZW5jb2RpbmcgPSBlbmNvZGluZ3NbMF07XG4gICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICBjb25zdCBtb2RlID0gbmV3IFNjYWxhYmlsaXR5TW9kZShlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgbGV0IG1heFF1YWxpdHkgPSBQcm90b1ZpZGVvUXVhbGl0eS5PRkY7XG4gICAgICBxdWFsaXRpZXMuZm9yRWFjaCgocSkgPT4ge1xuICAgICAgICBpZiAocS5lbmFibGVkICYmIChtYXhRdWFsaXR5ID09PSBQcm90b1ZpZGVvUXVhbGl0eS5PRkYgfHwgcS5xdWFsaXR5ID4gbWF4UXVhbGl0eSkpIHtcbiAgICAgICAgICBtYXhRdWFsaXR5ID0gcS5xdWFsaXR5O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1heFF1YWxpdHkgPT09IFByb3RvVmlkZW9RdWFsaXR5Lk9GRikge1xuICAgICAgICBpZiAoZW5jb2RpbmcuYWN0aXZlKSB7XG4gICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWVuY29kaW5nLmFjdGl2ZSB8fCBtb2RlLnNwYXRpYWwgIT09IG1heFF1YWxpdHkgKyAxKSB7XG4gICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTW9kZSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoc2VuZGVyRW5jb2RpbmdzWzBdLnNjYWxhYmlsaXR5TW9kZSk7XG4gICAgICAgIG1vZGUuc3BhdGlhbCA9IG1heFF1YWxpdHkgKyAxO1xuICAgICAgICBtb2RlLnN1ZmZpeCA9IG9yaWdpbmFsTW9kZS5zdWZmaXg7XG4gICAgICAgIGlmIChtb2RlLnNwYXRpYWwgPT09IDEpIHtcbiAgICAgICAgICAvLyBubyBzdWZmaXggZm9yIEwxVHhcbiAgICAgICAgICBtb2RlLnN1ZmZpeCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IG1vZGUudG9TdHJpbmcoKTtcbiAgICAgICAgZW5jb2Rpbmcuc2NhbGVSZXNvbHV0aW9uRG93bkJ5ID0gMiAqKiAoMiAtIG1heFF1YWxpdHkpO1xuICAgICAgICBpZiAoc2VuZGVyRW5jb2RpbmdzWzBdLm1heEJpdHJhdGUpIHtcbiAgICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID1cbiAgICAgICAgICAgIHNlbmRlckVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC9cbiAgICAgICAgICAgIChlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgKiBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNpbXVsY2FzdCBkeW5hY2FzdCBlbmNvZGluZ3NcbiAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgIGxldCByaWQgPSBlbmNvZGluZy5yaWQgPz8gJyc7XG4gICAgICAgIGlmIChyaWQgPT09ICcnKSB7XG4gICAgICAgICAgcmlkID0gJ3EnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSB2aWRlb1F1YWxpdHlGb3JSaWQocmlkKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1YWxpdHkgPSBxdWFsaXRpZXMuZmluZCgocSkgPT4gcS5xdWFsaXR5ID09PSBxdWFsaXR5KTtcbiAgICAgICAgaWYgKCFzdWJzY3JpYmVkUXVhbGl0eSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jb2RpbmcuYWN0aXZlICE9PSBzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkKSB7XG4gICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZDtcbiAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICBgc2V0dGluZyBsYXllciAke3N1YnNjcmliZWRRdWFsaXR5LnF1YWxpdHl9IHRvICR7XG4gICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCdcbiAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgbG9nQ29udGV4dCxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gRmlyZUZveCBkb2VzIG5vdCBzdXBwb3J0IHNldHRpbmcgZW5jb2RpbmcuYWN0aXZlIHRvIGZhbHNlLCBzbyB3ZVxuICAgICAgICAgIC8vIGhhdmUgYSB3b3JrYXJvdW5kIG9mIGxvd2VyaW5nIGl0cyBiaXRyYXRlIGFuZCByZXNvbHV0aW9uIHRvIHRoZSBtaW4uXG4gICAgICAgICAgaWYgKGlzRmlyZUZveCgpKSB7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlZFF1YWxpdHkuZW5hYmxlZCkge1xuICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5zY2FsZVJlc29sdXRpb25Eb3duQnk7XG4gICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5tYXhCaXRyYXRlO1xuICAgICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICAgIGVuY29kaW5nLm1heEZyYW1lUmF0ZSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLm1heEZyYW1lUmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IDQ7XG4gICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSAxMDtcbiAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICBlbmNvZGluZy5tYXhGcmFtZVJhdGUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICBsb2cuZGVidWcoYHNldHRpbmcgZW5jb2RpbmdzYCwgeyAuLi5sb2dDb250ZXh0LCBlbmNvZGluZ3M6IHBhcmFtcy5lbmNvZGluZ3MgfSk7XG4gICAgICBhd2FpdCBzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICB1bmxvY2soKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZDogc3RyaW5nKTogVmlkZW9RdWFsaXR5IHtcbiAgc3dpdGNoIChyaWQpIHtcbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuSElHSDtcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTUVESVVNO1xuICAgIGNhc2UgJ3EnOlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5MT1c7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuSElHSDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gIHN2Yz86IGJvb2xlYW4sXG4pOiBWaWRlb0xheWVyW10ge1xuICAvLyBkZWZhdWx0IHRvIGEgc2luZ2xlIGxheWVyLCBIUVxuICBpZiAoIWVuY29kaW5ncykge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgVmlkZW9MYXllcih7XG4gICAgICAgIHF1YWxpdHk6IFZpZGVvUXVhbGl0eS5ISUdILFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICBzc3JjOiAwLFxuICAgICAgfSksXG4gICAgXTtcbiAgfVxuXG4gIGlmIChzdmMpIHtcbiAgICAvLyBzdmMgbGF5ZXJzXG4gICAgLyogQHRzLWlnbm9yZSAqL1xuICAgIGNvbnN0IGVuY29kaW5nU00gPSBlbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlIGFzIHN0cmluZztcbiAgICBjb25zdCBzbSA9IG5ldyBTY2FsYWJpbGl0eU1vZGUoZW5jb2RpbmdTTSk7XG4gICAgY29uc3QgbGF5ZXJzID0gW107XG4gICAgY29uc3QgcmVzUmF0aW8gPSBzbS5zdWZmaXggPT0gJ2gnID8gMS41IDogMjtcbiAgICBjb25zdCBiaXRyYXRlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDIgOiAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc20uc3BhdGlhbDsgaSArPSAxKSB7XG4gICAgICBsYXllcnMucHVzaChcbiAgICAgICAgbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICAgIHF1YWxpdHk6IE1hdGgubWluKFZpZGVvUXVhbGl0eS5ISUdILCBzbS5zcGF0aWFsIC0gMSkgLSBpLFxuICAgICAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyByZXNSYXRpbyAqKiBpKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyByZXNSYXRpbyAqKiBpKSxcbiAgICAgICAgICBiaXRyYXRlOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZVxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyBiaXRyYXRlc1JhdGlvICoqIGkpXG4gICAgICAgICAgICA6IDAsXG4gICAgICAgICAgc3NyYzogMCxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5ncy5tYXAoKGVuY29kaW5nKSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPz8gMTtcbiAgICBsZXQgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZChlbmNvZGluZy5yaWQgPz8gJycpO1xuICAgIHJldHVybiBuZXcgVmlkZW9MYXllcih7XG4gICAgICBxdWFsaXR5LFxuICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIHNjYWxlKSxcbiAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIHNjYWxlKSxcbiAgICAgIGJpdHJhdGU6IGVuY29kaW5nLm1heEJpdHJhdGUgPz8gMCxcbiAgICAgIHNzcmM6IDAsXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgTXV0ZXggfSBmcm9tICdAbGl2ZWtpdC9tdXRleCc7XG5pbXBvcnQge1xuICB0eXBlIEFkZFRyYWNrUmVxdWVzdCxcbiAgQ2xpZW50Q29uZmlnU2V0dGluZyxcbiAgQ2xpZW50Q29uZmlndXJhdGlvbixcbiAgdHlwZSBDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSxcbiAgRGF0YUNoYW5uZWxJbmZvLFxuICBEYXRhUGFja2V0LFxuICBEYXRhUGFja2V0X0tpbmQsXG4gIERpc2Nvbm5lY3RSZWFzb24sXG4gIHR5cGUgSm9pblJlc3BvbnNlLFxuICB0eXBlIExlYXZlUmVxdWVzdCxcbiAgTGVhdmVSZXF1ZXN0X0FjdGlvbixcbiAgUGFydGljaXBhbnRJbmZvLFxuICBSZWNvbm5lY3RSZWFzb24sXG4gIHR5cGUgUmVjb25uZWN0UmVzcG9uc2UsXG4gIFJlcXVlc3RSZXNwb25zZSxcbiAgUm9vbSBhcyBSb29tTW9kZWwsXG4gIFJwY0FjayxcbiAgUnBjUmVzcG9uc2UsXG4gIFNpZ25hbFRhcmdldCxcbiAgU3BlYWtlckluZm8sXG4gIHR5cGUgU3RyZWFtU3RhdGVVcGRhdGUsXG4gIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICB0eXBlIFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUsXG4gIHR5cGUgU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG4gIFN5bmNTdGF0ZSxcbiAgVHJhY2tJbmZvLFxuICB0eXBlIFRyYWNrUHVibGlzaGVkUmVzcG9uc2UsXG4gIFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSxcbiAgVHJhbnNjcmlwdGlvbixcbiAgVXBkYXRlU3Vic2NyaXB0aW9uLFxuICB0eXBlIFVzZXJQYWNrZXQsXG59IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IE1lZGlhQXR0cmlidXRlcyB9IGZyb20gJ3NkcC10cmFuc2Zvcm0nO1xuaW1wb3J0IHR5cGUgVHlwZWRFdmVudEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgdHlwZSB7IFNpZ25hbE9wdGlvbnMgfSBmcm9tICcuLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCB7XG4gIFNpZ25hbENsaWVudCxcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlLFxuICB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uLFxufSBmcm9tICcuLi9hcGkvU2lnbmFsQ2xpZW50JztcbmltcG9ydCBsb2csIHsgTG9nZ2VyTmFtZXMsIGdldExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSB7IEludGVybmFsUm9vbU9wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zJztcbmltcG9ydCBQQ1RyYW5zcG9ydCwgeyBQQ0V2ZW50cyB9IGZyb20gJy4vUENUcmFuc3BvcnQnO1xuaW1wb3J0IHsgUENUcmFuc3BvcnRNYW5hZ2VyLCBQQ1RyYW5zcG9ydFN0YXRlIH0gZnJvbSAnLi9QQ1RyYW5zcG9ydE1hbmFnZXInO1xuaW1wb3J0IHR5cGUgeyBSZWNvbm5lY3RDb250ZXh0LCBSZWNvbm5lY3RQb2xpY3kgfSBmcm9tICcuL1JlY29ubmVjdFBvbGljeSc7XG5pbXBvcnQgdHlwZSB7IFJlZ2lvblVybFByb3ZpZGVyIH0gZnJvbSAnLi9SZWdpb25VcmxQcm92aWRlcic7XG5pbXBvcnQgeyByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cyc7XG5pbXBvcnQge1xuICBDb25uZWN0aW9uRXJyb3IsXG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbixcbiAgTmVnb3RpYXRpb25FcnJvcixcbiAgVHJhY2tJbnZhbGlkRXJyb3IsXG4gIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUsXG59IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IEVuZ2luZUV2ZW50IH0gZnJvbSAnLi9ldmVudHMnO1xuaW1wb3J0IHsgUnBjRXJyb3IgfSBmcm9tICcuL3JwYyc7XG5pbXBvcnQgQ3JpdGljYWxUaW1lcnMgZnJvbSAnLi90aW1lcnMnO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFjayBmcm9tICcuL3RyYWNrL0xvY2FsVHJhY2snO1xuaW1wb3J0IHR5cGUgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBTaW11bGNhc3RUcmFja0luZm8gfSBmcm9tICcuL3RyYWNrL0xvY2FsVmlkZW9UcmFjayc7XG5pbXBvcnQgdHlwZSBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgdHlwZSB7IFRyYWNrIH0gZnJvbSAnLi90cmFjay9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGlzaE9wdGlvbnMsIFZpZGVvQ29kZWMgfSBmcm9tICcuL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHsgZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8gfSBmcm9tICcuL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgaXNWaWRlb0NvZGVjLFxuICBpc1ZpZGVvVHJhY2ssXG4gIGlzV2ViLFxuICBzbGVlcCxcbiAgc3VwcG9ydHNBZGRUcmFjayxcbiAgc3VwcG9ydHNUcmFuc2NlaXZlcixcbn0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IGxvc3N5RGF0YUNoYW5uZWwgPSAnX2xvc3N5JztcbmNvbnN0IHJlbGlhYmxlRGF0YUNoYW5uZWwgPSAnX3JlbGlhYmxlJztcbmNvbnN0IG1pblJlY29ubmVjdFdhaXQgPSAyICogMTAwMDtcbmNvbnN0IGxlYXZlUmVjb25uZWN0ID0gJ2xlYXZlLXJlY29ubmVjdCc7XG5cbmVudW0gUENTdGF0ZSB7XG4gIE5ldyxcbiAgQ29ubmVjdGVkLFxuICBEaXNjb25uZWN0ZWQsXG4gIFJlY29ubmVjdGluZyxcbiAgQ2xvc2VkLFxufVxuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSVENFbmdpbmUgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxFbmdpbmVFdmVudENhbGxiYWNrcz4pIHtcbiAgY2xpZW50OiBTaWduYWxDbGllbnQ7XG5cbiAgcnRjQ29uZmlnOiBSVENDb25maWd1cmF0aW9uID0ge307XG5cbiAgcGVlckNvbm5lY3Rpb25UaW1lb3V0OiBudW1iZXIgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcblxuICBmdWxsUmVjb25uZWN0T25OZXh0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcGNNYW5hZ2VyPzogUENUcmFuc3BvcnRNYW5hZ2VyO1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGxhdGVzdEpvaW5SZXNwb25zZT86IEpvaW5SZXNwb25zZTtcblxuICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ2xvc2VkO1xuICB9XG5cbiAgZ2V0IHBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZWNvbm5lY3RUaW1lb3V0O1xuICB9XG5cbiAgcHJpdmF0ZSBsb3NzeURDPzogUlRDRGF0YUNoYW5uZWw7XG5cbiAgLy8gQHRzLWlnbm9yZSBub1VudXNlZExvY2Fsc1xuICBwcml2YXRlIGxvc3N5RENTdWI/OiBSVENEYXRhQ2hhbm5lbDtcblxuICBwcml2YXRlIHJlbGlhYmxlREM/OiBSVENEYXRhQ2hhbm5lbDtcblxuICBwcml2YXRlIGRjQnVmZmVyU3RhdHVzOiBNYXA8RGF0YVBhY2tldF9LaW5kLCBib29sZWFuPjtcblxuICAvLyBAdHMtaWdub3JlIG5vVW51c2VkTG9jYWxzXG4gIHByaXZhdGUgcmVsaWFibGVEQ1N1Yj86IFJUQ0RhdGFDaGFubmVsO1xuXG4gIHByaXZhdGUgc3Vic2NyaWJlclByaW1hcnk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHBjU3RhdGU6IFBDU3RhdGUgPSBQQ1N0YXRlLk5ldztcblxuICBwcml2YXRlIF9pc0Nsb3NlZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgcHJpdmF0ZSBwZW5kaW5nVHJhY2tSZXNvbHZlcnM6IHtcbiAgICBba2V5OiBzdHJpbmddOiB7IHJlc29sdmU6IChpbmZvOiBUcmFja0luZm8pID0+IHZvaWQ7IHJlamVjdDogKCkgPT4gdm9pZCB9O1xuICB9ID0ge307XG5cbiAgLy8ga2VlcCBqb2luIGluZm8gYXJvdW5kIGZvciByZWNvbm5lY3QsIHRoaXMgY291bGQgYmUgYSByZWdpb24gdXJsXG4gIHByaXZhdGUgdXJsPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgdG9rZW4/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzaWduYWxPcHRzPzogU2lnbmFsT3B0aW9ucztcblxuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzOiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgcmVjb25uZWN0U3RhcnQ6IG51bWJlciA9IDA7XG5cbiAgcHJpdmF0ZSBjbGllbnRDb25maWd1cmF0aW9uPzogQ2xpZW50Q29uZmlndXJhdGlvbjtcblxuICBwcml2YXRlIGF0dGVtcHRpbmdSZWNvbm5lY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHJlY29ubmVjdFBvbGljeTogUmVjb25uZWN0UG9saWN5O1xuXG4gIHByaXZhdGUgcmVjb25uZWN0VGltZW91dD86IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+O1xuXG4gIHByaXZhdGUgcGFydGljaXBhbnRTaWQ/OiBzdHJpbmc7XG5cbiAgLyoqIGtlZXBzIHRyYWNrIG9mIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBoYXMgYmVlbiB0cmllZCAqL1xuICBwcml2YXRlIGpvaW5BdHRlbXB0czogbnVtYmVyID0gMDtcblxuICAvKiogc3BlY2lmaWVzIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIHJldHJ5ICovXG4gIHByaXZhdGUgbWF4Sm9pbkF0dGVtcHRzOiBudW1iZXIgPSAxO1xuXG4gIHByaXZhdGUgY2xvc2luZ0xvY2s6IE11dGV4O1xuXG4gIHByaXZhdGUgZGF0YVByb2Nlc3NMb2NrOiBNdXRleDtcblxuICBwcml2YXRlIHNob3VsZEZhaWxOZXh0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSByZWdpb25VcmxQcm92aWRlcj86IFJlZ2lvblVybFByb3ZpZGVyO1xuXG4gIHByaXZhdGUgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyT3B0aW9uczogTG9nZ2VyT3B0aW9ucztcblxuICBwcml2YXRlIHB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3B0aW9uczogSW50ZXJuYWxSb29tT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIob3B0aW9ucy5sb2dnZXJOYW1lID8/IExvZ2dlck5hbWVzLkVuZ2luZSk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0ge1xuICAgICAgbG9nZ2VyTmFtZTogb3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgfTtcbiAgICB0aGlzLmNsaWVudCA9IG5ldyBTaWduYWxDbGllbnQodW5kZWZpbmVkLCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50LnNpZ25hbExhdGVuY3kgPSB0aGlzLm9wdGlvbnMuZXhwU2lnbmFsTGF0ZW5jeTtcbiAgICB0aGlzLnJlY29ubmVjdFBvbGljeSA9IHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQb2xpY3k7XG4gICAgdGhpcy5yZWdpc3Rlck9uTGluZUxpc3RlbmVyKCk7XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBNdXRleCgpO1xuICAgIHRoaXMuZGF0YVByb2Nlc3NMb2NrID0gbmV3IE11dGV4KCk7XG4gICAgdGhpcy5kY0J1ZmZlclN0YXR1cyA9IG5ldyBNYXAoW1xuICAgICAgW0RhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZV0sXG4gICAgICBbRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlXSxcbiAgICBdKTtcblxuICAgIHRoaXMuY2xpZW50Lm9uUGFydGljaXBhbnRVcGRhdGUgPSAodXBkYXRlcykgPT5cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5QYXJ0aWNpcGFudFVwZGF0ZSwgdXBkYXRlcyk7XG4gICAgdGhpcy5jbGllbnQub25Db25uZWN0aW9uUXVhbGl0eSA9ICh1cGRhdGUpID0+XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25Sb29tVXBkYXRlID0gKHVwZGF0ZSkgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25FcnJvciA9IChyZXNwKSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHJlc3ApO1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9ICh1cGRhdGUpID0+XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdXBkYXRlKTtcbiAgICB0aGlzLmNsaWVudC5vblNwZWFrZXJzQ2hhbmdlZCA9ICh1cGRhdGUpID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25TdHJlYW1TdGF0ZVVwZGF0ZSA9ICh1cGRhdGUpID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdHJlYW1TdGF0ZUNoYW5nZWQsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25SZXF1ZXN0UmVzcG9uc2UgPSAocmVzcG9uc2UpID0+XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVxdWVzdFJlc3BvbnNlLCByZXNwb25zZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZT8ucm9vbT8ubmFtZSxcbiAgICAgIHJvb21JRDogdGhpcy5sYXRlc3RKb2luUmVzcG9uc2U/LnJvb20/LnNpZCxcbiAgICAgIHBhcnRpY2lwYW50OiB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZT8ucGFydGljaXBhbnQ/LmlkZW50aXR5LFxuICAgICAgcElEOiB0aGlzLmxhdGVzdEpvaW5SZXNwb25zZT8ucGFydGljaXBhbnQ/LnNpZCxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgam9pbihcbiAgICB1cmw6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIG9wdHM6IFNpZ25hbE9wdGlvbnMsXG4gICAgYWJvcnRTaWduYWw/OiBBYm9ydFNpZ25hbCxcbiAgKTogUHJvbWlzZTxKb2luUmVzcG9uc2U+IHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5zaWduYWxPcHRzID0gb3B0cztcbiAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IG9wdHMubWF4UmV0cmllcztcbiAgICB0cnkge1xuICAgICAgdGhpcy5qb2luQXR0ZW1wdHMgKz0gMTtcblxuICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICB0aGlzLl9pc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UgPSBqb2luUmVzcG9uc2U7XG5cbiAgICAgIHRoaXMuc3Vic2NyaWJlclByaW1hcnkgPSBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnk7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29uZmlndXJlKGpvaW5SZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSBvZmZlclxuICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXJQcmltYXJ5IHx8IGpvaW5SZXNwb25zZS5mYXN0UHVibGlzaCkge1xuICAgICAgICB0aGlzLm5lZ290aWF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsaWVudENvbmZpZ3VyYXRpb24gPSBqb2luUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbjtcbiAgICAgIC8vIGVtaXQgc2lnbmFsIGNvbm5lY3RlZCBldmVudCBhZnRlciBhIHNob3J0IGRlbGF5IHRvIGFsbG93IGZvciBqb2luIHJlc3BvbnNlIHRvIGJlIHByb2Nlc3NlZCBvbiByb29tXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgICB9LCAxMCk7XG4gICAgICByZXR1cm4gam9pblJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgIGlmIChlLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgIGBDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlciwgYXR0ZW1wdCAke3RoaXMuam9pbkF0dGVtcHRzfSBvZiAke3RoaXMubWF4Sm9pbkF0dGVtcHRzfWAsXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodGhpcy5qb2luQXR0ZW1wdHMgPCB0aGlzLm1heEpvaW5BdHRlbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB1bmxvY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5DbG9zaW5nKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lcigpO1xuICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgYXdhaXQgdGhpcy5jbGVhbnVwQ2xpZW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy5wY01hbmFnZXI/LmNsb3NlKCk7XG4gICAgdGhpcy5wY01hbmFnZXIgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBkY0NsZWFudXAgPSAoZGM6IFJUQ0RhdGFDaGFubmVsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICBpZiAoIWRjKSByZXR1cm47XG4gICAgICBkYy5jbG9zZSgpO1xuICAgICAgZGMub25idWZmZXJlZGFtb3VudGxvdyA9IG51bGw7XG4gICAgICBkYy5vbmNsb3NlID0gbnVsbDtcbiAgICAgIGRjLm9uY2xvc2luZyA9IG51bGw7XG4gICAgICBkYy5vbmVycm9yID0gbnVsbDtcbiAgICAgIGRjLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICBkYy5vbm9wZW4gPSBudWxsO1xuICAgIH07XG4gICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQyk7XG4gICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQ1N1Yik7XG4gICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQyk7XG4gICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQ1N1Yik7XG5cbiAgICB0aGlzLmxvc3N5REMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb3NzeURDU3ViID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVsaWFibGVEQyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBhc3luYyBjbGVhbnVwQ2xpZW50KCkge1xuICAgIGF3YWl0IHRoaXMuY2xpZW50LmNsb3NlKCk7XG4gICAgdGhpcy5jbGllbnQucmVzZXRDYWxsYmFja3MoKTtcbiAgfVxuXG4gIGFkZFRyYWNrKHJlcTogQWRkVHJhY2tSZXF1ZXN0KTogUHJvbWlzZTxUcmFja0luZm8+IHtcbiAgICBpZiAodGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignYSB0cmFjayB3aXRoIHRoZSBzYW1lIElEIGhhcyBhbHJlYWR5IGJlZW4gcHVibGlzaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxUcmFja0luZm8+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHB1YmxpY2F0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF07XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgJ3B1YmxpY2F0aW9uIG9mIGxvY2FsIHRyYWNrIHRpbWVkIG91dCwgbm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInLFxuICAgICAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH0sIDEwXzAwMCk7XG4gICAgICB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXSA9IHtcbiAgICAgICAgcmVzb2x2ZTogKGluZm86IFRyYWNrSW5mbykgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChwdWJsaWNhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlc29sdmUoaW5mbyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDogKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChwdWJsaWNhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NhbmNlbGxlZCBwdWJsaWNhdGlvbiBieSBjYWxsaW5nIHVucHVibGlzaCcpKTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQWRkVHJhY2socmVxKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHNlbmRlciBmcm9tIFBlZXJDb25uZWN0aW9uLCByZXR1cm5pbmcgdHJ1ZSBpZiBpdCB3YXMgcmVtb3ZlZCBzdWNjZXNzZnVsbHlcbiAgICogYW5kIGEgbmVnb3RpYXRpb24gaXMgbmVjZXNzYXJ5XG4gICAqIEBwYXJhbSBzZW5kZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIHJlbW92ZVRyYWNrKHNlbmRlcjogUlRDUnRwU2VuZGVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHNlbmRlci50cmFjayAmJiB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdKSB7XG4gICAgICBjb25zdCB7IHJlamVjdCB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGNNYW5hZ2VyIS5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZTogdW5rbm93bikge1xuICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHJlbW92ZSB0cmFjaycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdXBkYXRlTXV0ZVN0YXR1cyh0cmFja1NpZDogc3RyaW5nLCBtdXRlZDogYm9vbGVhbikge1xuICAgIHRoaXMuY2xpZW50LnNlbmRNdXRlVHJhY2sodHJhY2tTaWQsIG11dGVkKTtcbiAgfVxuXG4gIGdldCBkYXRhU3Vic2NyaWJlclJlYWR5U3RhdGUoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5yZWxpYWJsZURDU3ViPy5yZWFkeVN0YXRlO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcygpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLnBjTWFuYWdlcj8uZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICB9XG5cbiAgLyogQGludGVybmFsICovXG4gIHNldFJlZ2lvblVybFByb3ZpZGVyKHByb3ZpZGVyOiBSZWdpb25VcmxQcm92aWRlcikge1xuICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY29uZmlndXJlKGpvaW5SZXNwb25zZTogSm9pblJlc3BvbnNlKSB7XG4gICAgLy8gYWxyZWFkeSBjb25maWd1cmVkXG4gICAgaWYgKHRoaXMucGNNYW5hZ2VyICYmIHRoaXMucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50Py5zaWQ7XG5cbiAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKGpvaW5SZXNwb25zZSk7XG5cbiAgICB0aGlzLnBjTWFuYWdlciA9IG5ldyBQQ1RyYW5zcG9ydE1hbmFnZXIoXG4gICAgICBydGNDb25maWcsXG4gICAgICBqb2luUmVzcG9uc2Uuc3Vic2NyaWJlclByaW1hcnksXG4gICAgICB0aGlzLmxvZ2dlck9wdGlvbnMsXG4gICAgKTtcblxuICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5UcmFuc3BvcnRzQ3JlYXRlZCwgdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLCB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyKTtcblxuICAgIHRoaXMucGNNYW5hZ2VyLm9uSWNlQ2FuZGlkYXRlID0gKGNhbmRpZGF0ZSwgdGFyZ2V0KSA9PiB7XG4gICAgICB0aGlzLmNsaWVudC5zZW5kSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5wY01hbmFnZXIub25QdWJsaXNoZXJPZmZlciA9IChvZmZlcikgPT4ge1xuICAgICAgdGhpcy5jbGllbnQuc2VuZE9mZmVyKG9mZmVyKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wY01hbmFnZXIub25EYXRhQ2hhbm5lbCA9IHRoaXMuaGFuZGxlRGF0YUNoYW5uZWw7XG4gICAgdGhpcy5wY01hbmFnZXIub25TdGF0ZUNoYW5nZSA9IGFzeW5jIChjb25uZWN0aW9uU3RhdGUsIHB1Ymxpc2hlclN0YXRlLCBzdWJzY3JpYmVyU3RhdGUpID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKGBwcmltYXJ5IFBDIHN0YXRlIGNoYW5nZWQgJHtjb25uZWN0aW9uU3RhdGV9YCwgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgICAgaWYgKFsnY2xvc2VkJywgJ2Rpc2Nvbm5lY3RlZCcsICdmYWlsZWQnXS5pbmNsdWRlcyhwdWJsaXNoZXJTdGF0ZSkpIHtcbiAgICAgICAgLy8gcmVzZXQgcHVibGlzaGVyIGNvbm5lY3Rpb24gcHJvbWlzZVxuICAgICAgICB0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5OZXc7XG4gICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgICAgICBpZiAoc2hvdWxkRW1pdCkge1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0ZWQsIGpvaW5SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlID09PSBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCkge1xuICAgICAgICAvLyBvbiBTYWZhcmksIFBlZXJDb25uZWN0aW9uIHdpbGwgc3dpdGNoIHRvICdkaXNjb25uZWN0ZWQnIGR1cmluZyByZW5lZ290aWF0aW9uXG4gICAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XG5cbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoXG4gICAgICAgICAgICAncGVlcmNvbm5lY3Rpb24gZmFpbGVkJyxcbiAgICAgICAgICAgIHN1YnNjcmliZXJTdGF0ZSA9PT0gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgPyBSZWNvbm5lY3RSZWFzb24uUlJfU1VCU0NSSUJFUl9GQUlMRURcbiAgICAgICAgICAgICAgOiBSZWNvbm5lY3RSZWFzb24uUlJfUFVCTElTSEVSX0ZBSUxFRCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRldGVjdCBjYXNlcyB3aGVyZSBib3RoIHNpZ25hbCBjbGllbnQgYW5kIHBlZXIgY29ubmVjdGlvbiBhcmUgc2V2ZXJlZCBhbmQgYXNzdW1lIHRoYXQgdXNlciBoYXMgbG9zdCBuZXR3b3JrIGNvbm5lY3Rpb25cbiAgICAgIGNvbnN0IGlzU2lnbmFsU2V2ZXJlZCA9XG4gICAgICAgIHRoaXMuY2xpZW50LmlzRGlzY29ubmVjdGVkIHx8XG4gICAgICAgIHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgICAgIGNvbnN0IGlzUENTZXZlcmVkID0gW1xuICAgICAgICBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCxcbiAgICAgICAgUENUcmFuc3BvcnRTdGF0ZS5DTE9TSU5HLFxuICAgICAgICBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NFRCxcbiAgICAgIF0uaW5jbHVkZXMoY29ubmVjdGlvblN0YXRlKTtcbiAgICAgIGlmIChpc1NpZ25hbFNldmVyZWQgJiYgaXNQQ1NldmVyZWQgJiYgIXRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5PZmZsaW5lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucGNNYW5hZ2VyLm9uVHJhY2sgPSAoZXY6IFJUQ1RyYWNrRXZlbnQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIGV2LnRyYWNrLCBldi5zdHJlYW1zWzBdLCBldi5yZWNlaXZlcik7XG4gICAgfTtcblxuICAgIGlmICghc3VwcG9ydE9wdGlvbmFsRGF0YWNoYW5uZWwoam9pblJlc3BvbnNlLnNlcnZlckluZm8/LnByb3RvY29sKSkge1xuICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCkge1xuICAgIC8vIGNvbmZpZ3VyZSBzaWduYWxpbmcgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25BbnN3ZXIgPSBhc3luYyAoc2QpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBhbnN3ZXInLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgUlRDU2RwVHlwZTogc2QudHlwZSB9KTtcbiAgICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLnNldFB1Ymxpc2hlckFuc3dlcihzZCk7XG4gICAgfTtcblxuICAgIC8vIGFkZCBjYW5kaWRhdGUgb24gdHJpY2tsZVxuICAgIHRoaXMuY2xpZW50Lm9uVHJpY2tsZSA9IChjYW5kaWRhdGUsIHRhcmdldCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygnZ290IElDRSBjYW5kaWRhdGUgZnJvbSBwZWVyJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGNhbmRpZGF0ZSwgdGFyZ2V0IH0pO1xuICAgICAgdGhpcy5wY01hbmFnZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgLy8gd2hlbiBzZXJ2ZXIgY3JlYXRlcyBhbiBvZmZlciBmb3IgdGhlIGNsaWVudFxuICAgIHRoaXMuY2xpZW50Lm9uT2ZmZXIgPSBhc3luYyAoc2QpID0+IHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1B1Ymxpc2hlZCA9IChyZXM6IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UpID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1B1Ymxpc2hlZFJlc3BvbnNlJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGNpZDogcmVzLmNpZCxcbiAgICAgICAgdHJhY2s6IHJlcy50cmFjaz8uc2lkLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKGBtaXNzaW5nIHRyYWNrIHJlc29sdmVyIGZvciAke3Jlcy5jaWR9YCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBjaWQ6IHJlcy5jaWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IHJlc29sdmUgfSA9IHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3Jlcy5jaWRdO1xuICAgICAgcmVzb2x2ZShyZXMudHJhY2shKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQgPSAocmVzcG9uc2U6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSkgPT4ge1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgcmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkID0gKHRyYWNrU2lkOiBzdHJpbmcpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgdHJhY2tTaWQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vblRva2VuUmVmcmVzaCA9ICh0b2tlbjogc3RyaW5nKSA9PiB7XG4gICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfTtcblxuICAgIHRoaXMuY2xpZW50Lm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCB0cmFja1NpZCwgbXV0ZWQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gKHVwZGF0ZTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdXBkYXRlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGllbnQub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnc2lnbmFsJywgUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsaWVudC5vbkxlYXZlID0gKGxlYXZlOiBMZWF2ZVJlcXVlc3QpID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdjbGllbnQgbGVhdmUgcmVxdWVzdCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCByZWFzb246IGxlYXZlPy5yZWFzb24gfSk7XG4gICAgICBpZiAobGVhdmUucmVnaW9ucyAmJiB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyByZWdpb25zJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci5zZXRTZXJ2ZXJSZXBvcnRlZFJlZ2lvbnMobGVhdmUucmVnaW9ucyk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGxlYXZlLmFjdGlvbikge1xuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uRElTQ09OTkVDVDpcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBsZWF2ZT8ucmVhc29uKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRUNPTk5FQ1Q6XG4gICAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QobGVhdmVSZWNvbm5lY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uUkVTVU1FOlxuICAgICAgICAgIC8vIHJlY29ubmVjdCBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIG5leHQgYXR0ZW1wdFxuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChsZWF2ZVJlY29ubmVjdCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZVJUQ0NvbmZpZ3VyYXRpb24oc2VydmVyUmVzcG9uc2U6IEpvaW5SZXNwb25zZSB8IFJlY29ubmVjdFJlc3BvbnNlKTogUlRDQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3QgcnRjQ29uZmlnID0geyAuLi50aGlzLnJ0Y0NvbmZpZyB9O1xuXG4gICAgaWYgKHRoaXMuc2lnbmFsT3B0cz8uZTJlZUVuYWJsZWQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdFMkVFIC0gc2V0dGluZyB1cCB0cmFuc3BvcnRzIHdpdGggaW5zZXJ0YWJsZSBzdHJlYW1zJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIC8vICB0aGlzIG1ha2VzIHN1cmUgdGhhdCBubyBkYXRhIGlzIHNlbnQgYmVmb3JlIHRoZSB0cmFuc2Zvcm1zIGFyZSByZWFkeVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcnRjQ29uZmlnLmVuY29kZWRJbnNlcnRhYmxlU3RyZWFtcyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIElDRSBzZXJ2ZXJzIGJlZm9yZSBjcmVhdGluZyBQZWVyQ29ubmVjdGlvblxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzICYmICFydGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgY29uc3QgcnRjSWNlU2VydmVyczogUlRDSWNlU2VydmVyW10gPSBbXTtcbiAgICAgIHNlcnZlclJlc3BvbnNlLmljZVNlcnZlcnMuZm9yRWFjaCgoaWNlU2VydmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlcjogUlRDSWNlU2VydmVyID0ge1xuICAgICAgICAgIHVybHM6IGljZVNlcnZlci51cmxzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaWNlU2VydmVyLnVzZXJuYW1lKSBydGNJY2VTZXJ2ZXIudXNlcm5hbWUgPSBpY2VTZXJ2ZXIudXNlcm5hbWU7XG4gICAgICAgIGlmIChpY2VTZXJ2ZXIuY3JlZGVudGlhbCkge1xuICAgICAgICAgIHJ0Y0ljZVNlcnZlci5jcmVkZW50aWFsID0gaWNlU2VydmVyLmNyZWRlbnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgcnRjSWNlU2VydmVycy5wdXNoKHJ0Y0ljZVNlcnZlcik7XG4gICAgICB9KTtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzID0gcnRjSWNlU2VydmVycztcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uICYmXG4gICAgICBzZXJ2ZXJSZXNwb25zZS5jbGllbnRDb25maWd1cmF0aW9uLmZvcmNlUmVsYXkgPT09IENsaWVudENvbmZpZ1NldHRpbmcuRU5BQkxFRFxuICAgICkge1xuICAgICAgcnRjQ29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSA9ICdyZWxheSc7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJ0Y0NvbmZpZy5zZHBTZW1hbnRpY3MgPSAndW5pZmllZC1wbGFuJztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcnRjQ29uZmlnLmNvbnRpbnVhbEdhdGhlcmluZ1BvbGljeSA9ICdnYXRoZXJfY29udGludWFsbHknO1xuXG4gICAgcmV0dXJuIHJ0Y0NvbmZpZztcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGF0YUNoYW5uZWxzKCkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBvbGQgZGF0YSBjaGFubmVsIGNhbGxiYWNrcyBpZiByZWNyZWF0ZVxuICAgIGlmICh0aGlzLmxvc3N5REMpIHtcbiAgICAgIHRoaXMubG9zc3lEQy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWxpYWJsZURDKSB7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgZGF0YSBjaGFubmVsc1xuICAgIHRoaXMubG9zc3lEQyA9IHRoaXMucGNNYW5hZ2VyLmNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsKGxvc3N5RGF0YUNoYW5uZWwsIHtcbiAgICAgIC8vIHdpbGwgZHJvcCBvbGRlciBwYWNrZXRzIHRoYXQgYXJyaXZlXG4gICAgICBvcmRlcmVkOiB0cnVlLFxuICAgICAgbWF4UmV0cmFuc21pdHM6IDAsXG4gICAgfSk7XG4gICAgdGhpcy5yZWxpYWJsZURDID0gdGhpcy5wY01hbmFnZXIuY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwocmVsaWFibGVEYXRhQ2hhbm5lbCwge1xuICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIGFsc28gaGFuZGxlIG1lc3NhZ2VzIG92ZXIgdGhlIHB1YiBjaGFubmVsLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcblxuICAgIC8vIGhhbmRsZSBkYXRhY2hhbm5lbCBlcnJvcnNcbiAgICB0aGlzLmxvc3N5REMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gdGhpcy5oYW5kbGVEYXRhRXJyb3I7XG5cbiAgICAvLyBzZXQgdXAgZGMgYnVmZmVyIHRocmVzaG9sZCwgc2V0IHRvIDY0a0IgKG90aGVyd2lzZSAwIGJ5IGRlZmF1bHQpXG4gICAgdGhpcy5sb3NzeURDLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gNjU1MzU7XG4gICAgdGhpcy5yZWxpYWJsZURDLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gNjU1MzU7XG5cbiAgICAvLyBoYW5kbGUgYnVmZmVyIGFtb3VudCBsb3cgZXZlbnRzXG4gICAgdGhpcy5sb3NzeURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xuICAgIHRoaXMucmVsaWFibGVEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRGF0YUNoYW5uZWwgPSBhc3luYyAoeyBjaGFubmVsIH06IFJUQ0RhdGFDaGFubmVsRXZlbnQpID0+IHtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWwubGFiZWwgPT09IHJlbGlhYmxlRGF0YUNoYW5uZWwpIHtcbiAgICAgIHRoaXMucmVsaWFibGVEQ1N1YiA9IGNoYW5uZWw7XG4gICAgfSBlbHNlIGlmIChjaGFubmVsLmxhYmVsID09PSBsb3NzeURhdGFDaGFubmVsKSB7XG4gICAgICB0aGlzLmxvc3N5RENTdWIgPSBjaGFubmVsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nLmRlYnVnKGBvbiBkYXRhIGNoYW5uZWwgJHtjaGFubmVsLmlkfSwgJHtjaGFubmVsLmxhYmVsfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgY2hhbm5lbC5vbm1lc3NhZ2UgPSB0aGlzLmhhbmRsZURhdGFNZXNzYWdlO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGF0YU1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgLy8gbWFrZSBzdXJlIHRvIHJlc3BlY3QgaW5jb21pbmcgZGF0YSBtZXNzYWdlIG9yZGVyIGJ5IHByb2Nlc3NpbmcgbWVzc2FnZSBldmVudHMgb25lIGFmdGVyIHRoZSBvdGhlclxuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuZGF0YVByb2Nlc3NMb2NrLmxvY2soKTtcbiAgICB0cnkge1xuICAgICAgLy8gZGVjb2RlXG4gICAgICBsZXQgYnVmZmVyOiBBcnJheUJ1ZmZlciB8IHVuZGVmaW5lZDtcbiAgICAgIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBidWZmZXIgPSBtZXNzYWdlLmRhdGE7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgYnVmZmVyID0gYXdhaXQgbWVzc2FnZS5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcigndW5zdXBwb3J0ZWQgZGF0YSB0eXBlJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGRhdGE6IG1lc3NhZ2UuZGF0YSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZHAgPSBEYXRhUGFja2V0LmZyb21CaW5hcnkobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XG5cbiAgICAgIGlmIChkcC52YWx1ZT8uY2FzZSA9PT0gJ3NwZWFrZXInKSB7XG4gICAgICAgIC8vIGRpc3BhdGNoIHNwZWFrZXIgdXBkYXRlc1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIGRwLnZhbHVlLnZhbHVlLnNwZWFrZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkcC52YWx1ZT8uY2FzZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgLy8gY29tcGF0aWJpbGl0eVxuICAgICAgICAgIGFwcGx5VXNlckRhdGFDb21wYXQoZHAsIGRwLnZhbHVlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCBkcCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVubG9jaygpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZURhdGFFcnJvciA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICBjb25zdCBjaGFubmVsID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBSVENEYXRhQ2hhbm5lbDtcbiAgICBjb25zdCBjaGFubmVsS2luZCA9IGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyAnbG9zc3knIDogJ3JlbGlhYmxlJztcblxuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEVycm9yRXZlbnQgJiYgZXZlbnQuZXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGV2ZW50LmVycm9yO1xuICAgICAgdGhpcy5sb2cuZXJyb3IoYERhdGFDaGFubmVsIGVycm9yIG9uICR7Y2hhbm5lbEtpbmR9OiAke2V2ZW50Lm1lc3NhZ2V9YCwge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKGBVbmtub3duIERhdGFDaGFubmVsIGVycm9yIG9uICR7Y2hhbm5lbEtpbmR9YCwgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93ID0gKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIFJUQ0RhdGFDaGFubmVsO1xuICAgIGNvbnN0IGNoYW5uZWxLaW5kID1cbiAgICAgIGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyBEYXRhUGFja2V0X0tpbmQuTE9TU1kgOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEU7XG5cbiAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyhjaGFubmVsS2luZCk7XG4gIH07XG5cbiAgYXN5bmMgY3JlYXRlU2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmIChzdXBwb3J0c1RyYW5zY2VpdmVyKCkpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgY29uc3Qgc2VuZGVyID0gYXdhaXQgdGhpcy5jcmVhdGVSVENSdHBTZW5kZXIodHJhY2subWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUmVxdWlyZWQgd2ViUlRDIEFQSXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlU2ltdWxjYXN0U2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFZpZGVvVHJhY2ssXG4gICAgc2ltdWxjYXN0VHJhY2s6IFNpbXVsY2FzdFRyYWNrSW5mbyxcbiAgICBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICAgIGVuY29kaW5ncz86IFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVyc1tdLFxuICApIHtcbiAgICAvLyBzdG9yZSBSVENSdHBTZW5kZXJcbiAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhZGQtdHJhY2sgZmFsbGJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdDYW5ub3Qgc3RyZWFtIG9uIHRoaXMgZGV2aWNlJyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyZWFtczogTWVkaWFTdHJlYW1bXSA9IFtdO1xuXG4gICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XG4gICAgICBzdHJlYW1zLnB1c2godHJhY2subWVkaWFTdHJlYW0pO1xuICAgIH1cblxuICAgIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICB0cmFjay5jb2RlYyA9IG9wdHMudmlkZW9Db2RlYztcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2NlaXZlckluaXQ6IFJUQ1J0cFRyYW5zY2VpdmVySW5pdCA9IHsgZGlyZWN0aW9uOiAnc2VuZG9ubHknLCBzdHJlYW1zIH07XG4gICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgfVxuICAgIC8vIGFkZFRyYW5zY2VpdmVyIGZvciByZWFjdC1uYXRpdmUgaXMgYXN5bmMuIHdlYiBpcyBzeW5jaHJvbm91cywgYnV0IGF3YWl0IHdvbid0IGVmZmVjdCBpdC5cbiAgICBjb25zdCB0cmFuc2NlaXZlciA9IGF3YWl0IHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKFxuICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjayxcbiAgICAgIHRyYW5zY2VpdmVySW5pdCxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIoXG4gICAgdHJhY2s6IExvY2FsVmlkZW9UcmFjayxcbiAgICBzaW11bGNhc3RUcmFjazogU2ltdWxjYXN0VHJhY2tJbmZvLFxuICAgIG9wdHM6IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgZW5jb2RpbmdzPzogUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzW10sXG4gICkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zY2VpdmVySW5pdDogUlRDUnRwVHJhbnNjZWl2ZXJJbml0ID0geyBkaXJlY3Rpb246ICdzZW5kb25seScgfTtcbiAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICB0cmFuc2NlaXZlckluaXQuc2VuZEVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICB9XG4gICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gYXdhaXQgdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIoXG4gICAgICBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgdHJhbnNjZWl2ZXJJbml0LFxuICAgICk7XG4gICAgaWYgKCFvcHRzLnZpZGVvQ29kZWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhY2suc2V0U2ltdWxjYXN0VHJhY2tTZW5kZXIob3B0cy52aWRlb0NvZGVjLCB0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXI7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFjayh0cmFjayk7XG4gIH1cblxuICAvLyB3ZWJzb2NrZXQgcmVjb25uZWN0IGJlaGF2aW9yLiBpZiB3ZWJzb2NrZXQgaXMgaW50ZXJydXB0ZWQsIGFuZCB0aGUgUGVlckNvbm5lY3Rpb25cbiAgLy8gY29udGludWVzIHRvIHdvcmssIHdlIGNhbiByZWNvbm5lY3QgdG8gd2Vic29ja2V0IHRvIGNvbnRpbnVlIHRoZSBzZXNzaW9uXG4gIC8vIGFmdGVyIGEgbnVtYmVyIG9mIHJldHJpZXMsIHdlJ2xsIGNsb3NlIGFuZCBnaXZlIHVwIHBlcm1hbmVudGx5XG4gIHByaXZhdGUgaGFuZGxlRGlzY29ubmVjdCA9IChjb25uZWN0aW9uOiBzdHJpbmcsIGRpc2Nvbm5lY3RSZWFzb24/OiBSZWNvbm5lY3RSZWFzb24pID0+IHtcbiAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvZy53YXJuKGAke2Nvbm5lY3Rpb259IGRpc2Nvbm5lY3RlZGAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPT09IDApIHtcbiAgICAgIC8vIG9ubHkgcmVzZXQgc3RhcnQgdGltZSBvbiB0aGUgZmlyc3QgdHJ5XG4gICAgICB0aGlzLnJlY29ubmVjdFN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXNjb25uZWN0ID0gKGR1cmF0aW9uOiBudW1iZXIpID0+IHtcbiAgICAgIHRoaXMubG9nLndhcm4oXG4gICAgICAgIGBjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gYXR0ZW1wdHMsICR7ZHVyYXRpb259bXMuIGdpdmluZyB1cGAsXG4gICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gdGhpcy5yZWNvbm5lY3RTdGFydDtcbiAgICBsZXQgZGVsYXkgPSB0aGlzLmdldE5leHRSZXRyeURlbGF5KHtcbiAgICAgIGVsYXBzZWRNczogZHVyYXRpb24sXG4gICAgICByZXRyeUNvdW50OiB0aGlzLnJlY29ubmVjdEF0dGVtcHRzLFxuICAgIH0pO1xuXG4gICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICBkaXNjb25uZWN0KGR1cmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb24gPT09IGxlYXZlUmVjb25uZWN0KSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5sb2cuZGVidWcoYHJlY29ubmVjdGluZyBpbiAke2RlbGF5fW1zYCwgdGhpcy5sb2dDb250ZXh0KTtcblxuICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMudG9rZW4gJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgLy8gdG9rZW4gbWF5IGhhdmUgYmVlbiByZWZyZXNoZWQsIHdlIGRvIG5vdCB3YW50IHRvIHJlY3JlYXRlIHRoZSByZWdpb25VcmxQcm92aWRlclxuICAgICAgLy8gc2luY2UgdGhlIGN1cnJlbnQgZW5naW5lIG1heSBoYXZlIGluaGVyaXRlZCBhIHJlZ2lvbmFsIHVybFxuICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlci51cGRhdGVUb2tlbih0aGlzLnRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dChcbiAgICAgICgpID0+XG4gICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdChkaXNjb25uZWN0UmVhc29uKS5maW5hbGx5KCgpID0+ICh0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB1bmRlZmluZWQpKSxcbiAgICAgIGRlbGF5LFxuICAgICk7XG4gIH07XG5cbiAgcHJpdmF0ZSBhc3luYyBhdHRlbXB0UmVjb25uZWN0KHJlYXNvbj86IFJlY29ubmVjdFJlYXNvbikge1xuICAgIGlmICh0aGlzLl9pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBndWFyZCBmb3IgYXR0ZW1wdGluZyByZWNvbm5lY3Rpb24gbXVsdGlwbGUgdGltZXMgd2hpbGUgb25lIGF0dGVtcHQgaXMgc3RpbGwgbm90IGZpbmlzaGVkXG4gICAgaWYgKHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCkge1xuICAgICAgbG9nLndhcm4oJ2FscmVhZHkgYXR0ZW1wdGluZyByZWNvbm5lY3QsIHJldHVybmluZyBlYXJseScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbj8ucmVzdW1lQ29ubmVjdGlvbiA9PT0gQ2xpZW50Q29uZmlnU2V0dGluZy5ESVNBQkxFRCB8fFxuICAgICAgLy8gc2lnbmFsaW5nIHN0YXRlIGNvdWxkIGNoYW5nZSB0byBjbG9zZWQgZHVlIHRvIGhhcmR3YXJlIHNsZWVwXG4gICAgICAvLyB0aG9zZSBjb25uZWN0aW9ucyBjYW5ub3QgYmUgcmVzdW1lZFxuICAgICAgKHRoaXMucGNNYW5hZ2VyPy5jdXJyZW50U3RhdGUgPz8gUENUcmFuc3BvcnRTdGF0ZS5ORVcpID09PSBQQ1RyYW5zcG9ydFN0YXRlLk5FV1xuICAgICkge1xuICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0Q29ubmVjdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN1bWVDb25uZWN0aW9uKHJlYXNvbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyUGVuZGluZ1JlY29ubmVjdCgpO1xuICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyArPSAxO1xuICAgICAgbGV0IHJlY292ZXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygncmVjZWl2ZWQgdW5yZWNvdmVyYWJsZSBlcnJvcicsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvcjogZSB9KTtcbiAgICAgICAgLy8gdW5yZWNvdmVyYWJsZVxuICAgICAgICByZWNvdmVyYWJsZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghKGUgaW5zdGFuY2VvZiBTaWduYWxSZWNvbm5lY3RFcnJvcikpIHtcbiAgICAgICAgLy8gY2Fubm90IHJlc3VtZVxuICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdyZWNvbm5lY3QnLCBSZWNvbm5lY3RSZWFzb24uUlJfVU5LTk9XTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICAgIGBjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0c30gYXR0ZW1wdHMsICR7XG4gICAgICAgICAgICBEYXRlLm5vdygpIC0gdGhpcy5yZWNvbm5lY3RTdGFydFxuICAgICAgICAgIH1tcy4gZ2l2aW5nIHVwYCxcbiAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TmV4dFJldHJ5RGVsYXkoY29udGV4dDogUmVjb25uZWN0Q29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RQb2xpY3kubmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2VuY291bnRlcmVkIGVycm9yIGluIHJlY29ubmVjdCBwb2xpY3knLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgfVxuXG4gICAgLy8gZXJyb3IgaW4gdXNlciBjb2RlIHdpdGggcHJvdmlkZWQgcmVjb25uZWN0IHBvbGljeSwgc3RvcCByZWNvbm5lY3RpbmdcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVzdGFydENvbm5lY3Rpb24ocmVnaW9uVXJsPzogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpcy51cmwgfHwgIXRoaXMudG9rZW4pIHtcbiAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB1cmwgb3IgdG9rZW4gbm90IHNhdmVkJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9nLmluZm8oYHJlY29ubmVjdGluZywgYXR0ZW1wdDogJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuUmVzdGFydGluZyk7XG5cbiAgICAgIGlmICghdGhpcy5jbGllbnQuaXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuc2VuZExlYXZlKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKTtcbiAgICAgIGF3YWl0IHRoaXMuY2xlYW51cENsaWVudCgpO1xuXG4gICAgICBsZXQgam9pblJlc3BvbnNlOiBKb2luUmVzcG9uc2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmFsT3B0cykge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oXG4gICAgICAgICAgICAnYXR0ZW1wdGVkIGNvbm5lY3Rpb24gcmVzdGFydCwgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBwcmVzZW50JyxcbiAgICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICApO1xuICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2UgYSByZWdpb25VcmwgaXMgcGFzc2VkLCB0aGUgcmVnaW9uIFVSTCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgIGpvaW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuam9pbihyZWdpb25VcmwgPz8gdGhpcy51cmwsIHRoaXMudG9rZW4sIHRoaXMuc2lnbmFsT3B0cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsaWVudC5zZXRSZWNvbm5lY3RlZCgpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlc3RhcnRlZCwgam9pblJlc3BvbnNlKTtcblxuICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yUENSZWNvbm5lY3RlZCgpO1xuXG4gICAgICAvLyByZS1jaGVjayBzaWduYWwgY29ubmVjdGlvbiBzdGF0ZSBiZWZvcmUgc2V0dGluZyBlbmdpbmUgYXMgcmVzdW1lZFxuICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICB0aHJvdyBuZXcgU2lnbmFsUmVjb25uZWN0RXJyb3IoJ1NpZ25hbCBjb25uZWN0aW9uIGdvdCBzZXZlcmVkIGR1cmluZyByZWNvbm5lY3QnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlcj8ucmVzZXRBdHRlbXB0cygpO1xuICAgICAgLy8gcmVjb25uZWN0IHN1Y2Nlc3NcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0ZWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBuZXh0UmVnaW9uVXJsID0gYXdhaXQgdGhpcy5yZWdpb25VcmxQcm92aWRlcj8uZ2V0TmV4dEJlc3RSZWdpb25VcmwoKTtcbiAgICAgIGlmIChuZXh0UmVnaW9uVXJsKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVzdGFydENvbm5lY3Rpb24obmV4dFJlZ2lvblVybCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIG1vcmUgcmVnaW9ucyB0byB0cnkgKG9yIHdlJ3JlIG5vdCBvbiBjbG91ZClcbiAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlcj8ucmVzZXRBdHRlbXB0cygpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlc3VtZUNvbm5lY3Rpb24ocmVhc29uPzogUmVjb25uZWN0UmVhc29uKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnVybCB8fCAhdGhpcy50b2tlbikge1xuICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnY291bGQgbm90IHJlY29ubmVjdCwgdXJsIG9yIHRva2VuIG5vdCBzYXZlZCcpO1xuICAgIH1cbiAgICAvLyB0cmlnZ2VyIHB1Ymxpc2hlciByZWNvbm5lY3RcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGFuZCBzdWJzY3JpYmVyIGNvbm5lY3Rpb25zIHVuc2V0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2cuaW5mbyhgcmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24sIGF0dGVtcHQgJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtaW5nKTtcbiAgICBsZXQgcmVzOiBSZWNvbm5lY3RSZXNwb25zZSB8IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zZXR1cFNpZ25hbENsaWVudENhbGxiYWNrcygpO1xuICAgICAgcmVzID0gYXdhaXQgdGhpcy5jbGllbnQucmVjb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB0aGlzLnBhcnRpY2lwYW50U2lkLCByZWFzb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKGVycm9yLm1lc3NhZ2UsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBlcnJvciB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENvbm5lY3Rpb25FcnJvclJlYXNvbi5Ob3RBbGxvd2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTGVhdmVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCk7XG5cbiAgICBpZiAocmVzKSB7XG4gICAgICBjb25zdCBydGNDb25maWcgPSB0aGlzLm1ha2VSVENDb25maWd1cmF0aW9uKHJlcyk7XG4gICAgICB0aGlzLnBjTWFuYWdlci51cGRhdGVDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ0RpZCBub3QgcmVjZWl2ZSByZWNvbm5lY3QgcmVzcG9uc2UnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpbXVsYXRlZCBmYWlsdXJlJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5wY01hbmFnZXIudHJpZ2dlckljZVJlc3RhcnQoKTtcblxuICAgIGF3YWl0IHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcblxuICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCdTaWduYWwgY29ubmVjdGlvbiBnb3Qgc2V2ZXJlZCBkdXJpbmcgcmVjb25uZWN0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcblxuICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXG4gICAgLy8gKGZvciBzYWZhcmkgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDY4OClcbiAgICBpZiAodGhpcy5yZWxpYWJsZURDPy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgdGhpcy5yZWxpYWJsZURDLmlkID09PSBudWxsKSB7XG4gICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgIH1cblxuICAgIC8vIHJlc3VtZSBzdWNjZXNzXG4gICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtZWQpO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGltZW91dD86IG51bWJlciwgYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJyk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB3YWl0Rm9yUENSZWNvbm5lY3RlZCgpIHtcbiAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLlJlY29ubmVjdGluZztcblxuICAgIHRoaXMubG9nLmRlYnVnKCd3YWl0aW5nIGZvciBwZWVyIGNvbm5lY3Rpb24gdG8gcmVjb25uZWN0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2xlZXAobWluUmVjb25uZWN0V2FpdCk7IC8vIEZJWE1FIHNldFRpbWVvdXQgYWdhaW4gbm90IGlkZWFsIGZvciBhIGNvbm5lY3Rpb24gY3JpdGljYWwgcGF0aFxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbih1bmRlZmluZWQsIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuQ29ubmVjdGVkO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIGEgYGZhaWxlZGAgc3RhdGUgaGVyZSBmb3IgdGhlIFBDP1xuICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICBgY291bGQgbm90IGVzdGFibGlzaCBQQyBjb25uZWN0aW9uLCAke2UubWVzc2FnZX1gLFxuICAgICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgd2FpdEZvclJlc3RhcnRlZCA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25SZXN0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgb25EaXNjb25uZWN0ZWQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25EaXNjb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LlJlc3RhcnRlZCwgb25SZXN0YXJ0ZWQpO1xuICAgICAgICByZWplY3QoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuUmVzdGFydGVkLCBvblJlc3RhcnRlZCk7XG4gICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCBvbkRpc2Nvbm5lY3RlZCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBwdWJsaXNoUnBjUmVzcG9uc2UoXG4gICAgZGVzdGluYXRpb25JZGVudGl0eTogc3RyaW5nLFxuICAgIHJlcXVlc3RJZDogc3RyaW5nLFxuICAgIHBheWxvYWQ6IHN0cmluZyB8IG51bGwsXG4gICAgZXJyb3I6IFJwY0Vycm9yIHwgbnVsbCxcbiAgKSB7XG4gICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbZGVzdGluYXRpb25JZGVudGl0eV0sXG4gICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBjYXNlOiAncnBjUmVzcG9uc2UnLFxuICAgICAgICB2YWx1ZTogbmV3IFJwY1Jlc3BvbnNlKHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgdmFsdWU6IGVycm9yXG4gICAgICAgICAgICA/IHsgY2FzZTogJ2Vycm9yJywgdmFsdWU6IGVycm9yLnRvUHJvdG8oKSB9XG4gICAgICAgICAgICA6IHsgY2FzZTogJ3BheWxvYWQnLCB2YWx1ZTogcGF5bG9hZCA/PyAnJyB9LFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgcHVibGlzaFJwY0FjayhkZXN0aW5hdGlvbklkZW50aXR5OiBzdHJpbmcsIHJlcXVlc3RJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBbZGVzdGluYXRpb25JZGVudGl0eV0sXG4gICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBjYXNlOiAncnBjQWNrJyxcbiAgICAgICAgdmFsdWU6IG5ldyBScGNBY2soe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgc2VuZERhdGFQYWNrZXQocGFja2V0OiBEYXRhUGFja2V0LCBraW5kOiBEYXRhUGFja2V0X0tpbmQpIHtcbiAgICBjb25zdCBtc2cgPSBwYWNrZXQudG9CaW5hcnkoKTtcblxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBkbyBoYXZlIGEgZGF0YSBjb25uZWN0aW9uXG4gICAgYXdhaXQgdGhpcy5lbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZCk7XG5cbiAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpO1xuICAgIGlmIChkYykge1xuICAgICAgZGMuc2VuZChtc2cpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzKGtpbmQpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMgPSAoa2luZDogRGF0YVBhY2tldF9LaW5kKSA9PiB7XG4gICAgY29uc3Qgc3RhdHVzID0gdGhpcy5pc0J1ZmZlclN0YXR1c0xvdyhraW5kKTtcbiAgICBpZiAodHlwZW9mIHN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcgJiYgc3RhdHVzICE9PSB0aGlzLmRjQnVmZmVyU3RhdHVzLmdldChraW5kKSkge1xuICAgICAgdGhpcy5kY0J1ZmZlclN0YXR1cy5zZXQoa2luZCwgc3RhdHVzKTtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIHN0YXR1cywga2luZCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaXNCdWZmZXJTdGF0dXNMb3cgPSAoa2luZDogRGF0YVBhY2tldF9LaW5kKTogYm9vbGVhbiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgY29uc3QgZGMgPSB0aGlzLmRhdGFDaGFubmVsRm9yS2luZChraW5kKTtcbiAgICBpZiAoZGMpIHtcbiAgICAgIHJldHVybiBkYy5idWZmZXJlZEFtb3VudCA8PSBkYy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZDtcbiAgICB9XG4gIH07XG5cbiAgd2FpdEZvckJ1ZmZlclN0YXR1c0xvdyhraW5kOiBEYXRhUGFja2V0X0tpbmQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNCdWZmZXJTdGF0dXNMb3coa2luZCkpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25DbG9zaW5nID0gKCkgPT4gcmVqZWN0KCdFbmdpbmUgY2xvc2VkJyk7XG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkNsb3NpbmcpO1xuICAgICAgICB3aGlsZSAoIXRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XG4gICAgICAgICAgYXdhaXQgc2xlZXAoMTApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uQ2xvc2luZyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIGVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoXG4gICAga2luZDogRGF0YVBhY2tldF9LaW5kLFxuICAgIHN1YnNjcmliZXI6IGJvb2xlYW4gPSB0aGlzLnN1YnNjcmliZXJQcmltYXJ5LFxuICApIHtcbiAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gc3Vic2NyaWJlciA/IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIgOiB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXI7XG4gICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHN1YnNjcmliZXIgPyAnU3Vic2NyaWJlcicgOiAnUHVibGlzaGVyJztcbiAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgICAgYCR7dHJhbnNwb3J0TmFtZX0gY29ubmVjdGlvbiBub3Qgc2V0YCxcbiAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBuZWVkTmVnb3RpYXRpb24gPSBmYWxzZTtcbiAgICBpZiAoIXN1YnNjcmliZXIgJiYgIXRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpKSB7XG4gICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgbmVlZE5lZ290aWF0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhbmVlZE5lZ290aWF0aW9uICYmXG4gICAgICAhc3Vic2NyaWJlciAmJlxuICAgICAgIXRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5pc0lDRUNvbm5lY3RlZCAmJlxuICAgICAgdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLmdldElDRUNvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY2hlY2tpbmcnXG4gICAgKSB7XG4gICAgICBuZWVkTmVnb3RpYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmVlZE5lZ290aWF0aW9uKSB7XG4gICAgICAvLyBzdGFydCBuZWdvdGlhdGlvblxuICAgICAgdGhpcy5uZWdvdGlhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRDaGFubmVsID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCwgc3Vic2NyaWJlcik7XG4gICAgaWYgKHRhcmdldENoYW5uZWw/LnJlYWR5U3RhdGUgPT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdhaXQgdW50aWwgSUNFIGNvbm5lY3RlZFxuICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgIHdoaWxlIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA8IGVuZFRpbWUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHJhbnNwb3J0LmlzSUNFQ29ubmVjdGVkICYmXG4gICAgICAgIHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpPy5yZWFkeVN0YXRlID09PSAnb3BlbidcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBzbGVlcCg1MCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcbiAgICAgIGBjb3VsZCBub3QgZXN0YWJsaXNoICR7dHJhbnNwb3J0TmFtZX0gY29ubmVjdGlvbiwgc3RhdGU6ICR7dHJhbnNwb3J0LmdldElDRUNvbm5lY3Rpb25TdGF0ZSgpfWAsXG4gICAgICBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcixcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBlbnN1cmVQdWJsaXNoZXJDb25uZWN0ZWQoa2luZDogRGF0YVBhY2tldF9LaW5kKSB7XG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlKSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5lbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkKGtpbmQsIGZhbHNlKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICB2ZXJpZnlUcmFuc3BvcnQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBwcmltYXJ5IGNvbm5lY3Rpb25cbiAgICBpZiAodGhpcy5wY01hbmFnZXIuY3VycmVudFN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBzaWduYWwgaXMgY29ubmVjdGVkXG4gICAgaWYgKCF0aGlzLmNsaWVudC53cyB8fCB0aGlzLmNsaWVudC53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhc3luYyBuZWdvdGlhdGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gb2JzZXJ2ZSBzaWduYWwgc3RhdGVcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICByZWplY3QobmV3IE5lZ290aWF0aW9uRXJyb3IoJ1BDIG1hbmFnZXIgaXMgY2xvc2VkJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGNNYW5hZ2VyLnJlcXVpcmVQdWJsaXNoZXIoKTtcbiAgICAgIC8vIGRvbid0IG5lZ290aWF0ZSB3aXRob3V0IGFueSB0cmFuc2NlaXZlcnMgb3IgZGF0YSBjaGFubmVsLCBpdCB3aWxsIGdlbmVyYXRlIHNkcCB3aXRob3V0IGljZSBmcmFnIHRoZW4gbmVnb3RpYXRlIGZhaWxlZFxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkubGVuZ3RoID09IDAgJiZcbiAgICAgICAgIXRoaXMubG9zc3lEQyAmJlxuICAgICAgICAhdGhpcy5yZWxpYWJsZURDXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXG4gICAgICBjb25zdCBoYW5kbGVDbG9zZWQgPSAoKSA9PiB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZW5naW5lIGRpc2Nvbm5lY3RlZCB3aGlsZSBuZWdvdGlhdGlvbiB3YXMgb25nb2luZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgcmVqZWN0KCdjYW5ub3QgbmVnb3RpYXRlIG9uIGNsb3NlZCBlbmdpbmUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub24oRW5naW5lRXZlbnQuQ2xvc2luZywgaGFuZGxlQ2xvc2VkKTtcblxuICAgICAgdGhpcy5wY01hbmFnZXIucHVibGlzaGVyLm9uY2UoXG4gICAgICAgIFBDRXZlbnRzLlJUUFZpZGVvUGF5bG9hZFR5cGVzLFxuICAgICAgICAocnRwVHlwZXM6IE1lZGlhQXR0cmlidXRlc1sncnRwJ10pID0+IHtcbiAgICAgICAgICBjb25zdCBydHBNYXAgPSBuZXcgTWFwPG51bWJlciwgVmlkZW9Db2RlYz4oKTtcbiAgICAgICAgICBydHBUeXBlcy5mb3JFYWNoKChydHApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gcnRwLmNvZGVjLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoaXNWaWRlb0NvZGVjKGNvZGVjKSkge1xuICAgICAgICAgICAgICBydHBNYXAuc2V0KHJ0cC5wYXlsb2FkLCBjb2RlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJUUFZpZGVvTWFwVXBkYXRlLCBydHBNYXApO1xuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wY01hbmFnZXIubmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE5lZ290aWF0aW9uRXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgnbmVnb3RpYXRpb24nLCBSZWNvbm5lY3RSZWFzb24uUlJfVU5LTk9XTik7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIGhhbmRsZUNsb3NlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkYXRhQ2hhbm5lbEZvcktpbmQoa2luZDogRGF0YVBhY2tldF9LaW5kLCBzdWI/OiBib29sZWFuKTogUlRDRGF0YUNoYW5uZWwgfCB1bmRlZmluZWQge1xuICAgIGlmICghc3ViKSB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvc3N5REM7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGlhYmxlREM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQ1N1YjtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQ1N1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNlbmRTeW5jU3RhdGUocmVtb3RlVHJhY2tzOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uW10sIGxvY2FsVHJhY2tzOiBMb2NhbFRyYWNrUHVibGljYXRpb25bXSkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N5bmMgc3RhdGUgY2Fubm90IGJlIHNlbnQgd2l0aG91dCBwZWVyIGNvbm5lY3Rpb24gc2V0dXAnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0Fuc3dlciA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIuZ2V0TG9jYWxEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IHByZXZpb3VzT2ZmZXIgPSB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyLmdldFJlbW90ZURlc2NyaXB0aW9uKCk7XG5cbiAgICAvKiAxLiBhdXRvc3Vic2NyaWJlIG9uLCBzbyBzdWJzY3JpYmVkIHRyYWNrcyA9IGFsbCB0cmFja3MgLSB1bnN1YiB0cmFja3MsXG4gICAgICAgICAgaW4gdGhpcyBjYXNlLCB3ZSBzZW5kIHVuc3ViIHRyYWNrcywgc28gc2VydmVyIGFkZCBhbGwgdHJhY2tzIHRvIHRoaXNcbiAgICAgICAgICBzdWJzY3JpYmUgcGMgYW5kIHVuc3ViIHNwZWNpYWwgdHJhY2tzIGZyb20gaXQuXG4gICAgICAgMi4gYXV0b3N1YnNjcmliZSBvZmYsIHdlIHNlbmQgc3Vic2NyaWJlZCB0cmFja3MuXG4gICAgKi9cbiAgICBjb25zdCBhdXRvU3Vic2NyaWJlID0gdGhpcy5zaWduYWxPcHRzPy5hdXRvU3Vic2NyaWJlID8/IHRydWU7XG4gICAgY29uc3QgdHJhY2tTaWRzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBjb25zdCB0cmFja1NpZHNEaXNhYmxlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICByZW1vdGVUcmFja3MuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgIGlmICh0cmFjay5pc0Rlc2lyZWQgIT09IGF1dG9TdWJzY3JpYmUpIHtcbiAgICAgICAgdHJhY2tTaWRzLnB1c2godHJhY2sudHJhY2tTaWQpO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFjay5pc0VuYWJsZWQpIHtcbiAgICAgICAgdHJhY2tTaWRzRGlzYWJsZWQucHVzaCh0cmFjay50cmFja1NpZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNsaWVudC5zZW5kU3luY1N0YXRlKFxuICAgICAgbmV3IFN5bmNTdGF0ZSh7XG4gICAgICAgIGFuc3dlcjogcHJldmlvdXNBbnN3ZXJcbiAgICAgICAgICA/IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgICBzZHA6IHByZXZpb3VzQW5zd2VyLnNkcCxcbiAgICAgICAgICAgICAgdHlwZTogcHJldmlvdXNBbnN3ZXIudHlwZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIG9mZmVyOiBwcmV2aW91c09mZmVyXG4gICAgICAgICAgPyB0b1Byb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgICAgc2RwOiBwcmV2aW91c09mZmVyLnNkcCxcbiAgICAgICAgICAgICAgdHlwZTogcHJldmlvdXNPZmZlci50eXBlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3Vic2NyaXB0aW9uOiBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgICB0cmFja1NpZHMsXG4gICAgICAgICAgc3Vic2NyaWJlOiAhYXV0b1N1YnNjcmliZSxcbiAgICAgICAgICBwYXJ0aWNpcGFudFRyYWNrczogW10sXG4gICAgICAgIH0pLFxuICAgICAgICBwdWJsaXNoVHJhY2tzOiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyhsb2NhbFRyYWNrcyksXG4gICAgICAgIGRhdGFDaGFubmVsczogdGhpcy5kYXRhQ2hhbm5lbHNJbmZvKCksXG4gICAgICAgIHRyYWNrU2lkc0Rpc2FibGVkLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBmYWlsTmV4dCgpIHtcbiAgICAvLyBkZWJ1Z2dpbmcgbWV0aG9kIHRvIGZhaWwgdGhlIG5leHQgcmVjb25uZWN0L3Jlc3VtZSBhdHRlbXB0XG4gICAgdGhpcy5zaG91bGRGYWlsTmV4dCA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGRhdGFDaGFubmVsc0luZm8oKTogRGF0YUNoYW5uZWxJbmZvW10ge1xuICAgIGNvbnN0IGluZm9zOiBEYXRhQ2hhbm5lbEluZm9bXSA9IFtdO1xuICAgIGNvbnN0IGdldEluZm8gPSAoZGM6IFJUQ0RhdGFDaGFubmVsIHwgdW5kZWZpbmVkLCB0YXJnZXQ6IFNpZ25hbFRhcmdldCkgPT4ge1xuICAgICAgaWYgKGRjPy5pZCAhPT0gdW5kZWZpbmVkICYmIGRjLmlkICE9PSBudWxsKSB7XG4gICAgICAgIGluZm9zLnB1c2goXG4gICAgICAgICAgbmV3IERhdGFDaGFubmVsSW5mbyh7XG4gICAgICAgICAgICBsYWJlbDogZGMubGFiZWwsXG4gICAgICAgICAgICBpZDogZGMuaWQsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5MT1NTWSksIFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpO1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuTE9TU1ksIHRydWUpLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsIHRydWUpLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XG4gICAgcmV0dXJuIGluZm9zO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclJlY29ubmVjdFRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQnJvd3Nlck9uTGluZSA9ICgpID0+IHtcbiAgICAvLyBpbiBjYXNlIHRoZSBlbmdpbmUgaXMgY3VycmVudGx5IHJlY29ubmVjdGluZywgYXR0ZW1wdCBhIHJlY29ubmVjdCBpbW1lZGlhdGVseSBhZnRlciB0aGUgYnJvd3NlciBzdGF0ZSBoYXMgY2hhbmdlZCB0byAnb25MaW5lJ1xuICAgIGlmICh0aGlzLmNsaWVudC5jdXJyZW50U3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpIHtcbiAgICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICB0aGlzLmF0dGVtcHRSZWNvbm5lY3QoUmVjb25uZWN0UmVhc29uLlJSX1NJR05BTF9ESVNDT05ORUNURUQpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLmhhbmRsZUJyb3dzZXJPbkxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU2lnbmFsUmVjb25uZWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgdHlwZSBFbmdpbmVFdmVudENhbGxiYWNrcyA9IHtcbiAgY29ubmVjdGVkOiAoam9pblJlc3A6IEpvaW5SZXNwb25zZSkgPT4gdm9pZDtcbiAgZGlzY29ubmVjdGVkOiAocmVhc29uPzogRGlzY29ubmVjdFJlYXNvbikgPT4gdm9pZDtcbiAgcmVzdW1pbmc6ICgpID0+IHZvaWQ7XG4gIHJlc3VtZWQ6ICgpID0+IHZvaWQ7XG4gIHJlc3RhcnRpbmc6ICgpID0+IHZvaWQ7XG4gIHJlc3RhcnRlZDogKCkgPT4gdm9pZDtcbiAgc2lnbmFsUmVzdW1lZDogKCkgPT4gdm9pZDtcbiAgc2lnbmFsUmVzdGFydGVkOiAoam9pblJlc3A6IEpvaW5SZXNwb25zZSkgPT4gdm9pZDtcbiAgY2xvc2luZzogKCkgPT4gdm9pZDtcbiAgbWVkaWFUcmFja0FkZGVkOiAoXG4gICAgdHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgc3RyZWFtczogTWVkaWFTdHJlYW0sXG4gICAgcmVjZWl2ZXI6IFJUQ1J0cFJlY2VpdmVyLFxuICApID0+IHZvaWQ7XG4gIGFjdGl2ZVNwZWFrZXJzVXBkYXRlOiAoc3BlYWtlcnM6IEFycmF5PFNwZWFrZXJJbmZvPikgPT4gdm9pZDtcbiAgZGF0YVBhY2tldFJlY2VpdmVkOiAocGFja2V0OiBEYXRhUGFja2V0KSA9PiB2b2lkO1xuICB0cmFuc2NyaXB0aW9uUmVjZWl2ZWQ6ICh0cmFuc2NyaXB0aW9uOiBUcmFuc2NyaXB0aW9uKSA9PiB2b2lkO1xuICB0cmFuc3BvcnRzQ3JlYXRlZDogKHB1Ymxpc2hlcjogUENUcmFuc3BvcnQsIHN1YnNjcmliZXI6IFBDVHJhbnNwb3J0KSA9PiB2b2lkO1xuICAvKiogQGludGVybmFsICovXG4gIHRyYWNrU2VuZGVyQWRkZWQ6ICh0cmFjazogVHJhY2ssIHNlbmRlcjogUlRDUnRwU2VuZGVyKSA9PiB2b2lkO1xuICBydHBWaWRlb01hcFVwZGF0ZTogKHJ0cE1hcDogTWFwPG51bWJlciwgVmlkZW9Db2RlYz4pID0+IHZvaWQ7XG4gIGRjQnVmZmVyU3RhdHVzQ2hhbmdlZDogKGlzTG93OiBib29sZWFuLCBraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50VXBkYXRlOiAoaW5mb3M6IFBhcnRpY2lwYW50SW5mb1tdKSA9PiB2b2lkO1xuICByb29tVXBkYXRlOiAocm9vbTogUm9vbU1vZGVsKSA9PiB2b2lkO1xuICBjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZTogKHVwZGF0ZTogQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUpID0+IHZvaWQ7XG4gIHNwZWFrZXJzQ2hhbmdlZDogKHNwZWFrZXJVcGRhdGVzOiBTcGVha2VySW5mb1tdKSA9PiB2b2lkO1xuICBzdHJlYW1TdGF0ZUNoYW5nZWQ6ICh1cGRhdGU6IFN0cmVhbVN0YXRlVXBkYXRlKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25FcnJvcjogKHJlc3A6IFN1YnNjcmlwdGlvblJlc3BvbnNlKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlOiAodXBkYXRlOiBTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSA9PiB2b2lkO1xuICBzdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZTogKHVwZGF0ZTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpID0+IHZvaWQ7XG4gIGxvY2FsVHJhY2tVbnB1Ymxpc2hlZDogKHVucHVibGlzaGVkUmVzcG9uc2U6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSkgPT4gdm9pZDtcbiAgbG9jYWxUcmFja1N1YnNjcmliZWQ6ICh0cmFja1NpZDogc3RyaW5nKSA9PiB2b2lkO1xuICByZW1vdGVNdXRlOiAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIG9mZmxpbmU6ICgpID0+IHZvaWQ7XG4gIHNpZ25hbFJlcXVlc3RSZXNwb25zZTogKHJlc3BvbnNlOiBSZXF1ZXN0UmVzcG9uc2UpID0+IHZvaWQ7XG4gIHNpZ25hbENvbm5lY3RlZDogKCkgPT4gdm9pZDtcbn07XG5cbmZ1bmN0aW9uIHN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsKHByb3RvY29sOiBudW1iZXIgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgcmV0dXJuIHByb3RvY29sICE9PSB1bmRlZmluZWQgJiYgcHJvdG9jb2wgPiAxMztcbn1cblxuZnVuY3Rpb24gYXBwbHlVc2VyRGF0YUNvbXBhdChuZXdPYmo6IERhdGFQYWNrZXQsIG9sZE9iajogVXNlclBhY2tldCkge1xuICBjb25zdCBwYXJ0aWNpcGFudElkZW50aXR5ID0gbmV3T2JqLnBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICA/IG5ld09iai5wYXJ0aWNpcGFudElkZW50aXR5XG4gICAgOiBvbGRPYmoucGFydGljaXBhbnRJZGVudGl0eTtcbiAgbmV3T2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBwYXJ0aWNpcGFudElkZW50aXR5O1xuICBvbGRPYmoucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XG5cbiAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID1cbiAgICBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzLmxlbmd0aCAhPT0gMFxuICAgICAgPyBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzXG4gICAgICA6IG9sZE9iai5kZXN0aW5hdGlvbklkZW50aXRpZXM7XG4gIG5ld09iai5kZXN0aW5hdGlvbklkZW50aXRpZXMgPSBkZXN0aW5hdGlvbklkZW50aXRpZXM7XG4gIG9sZE9iai5kZXN0aW5hdGlvbklkZW50aXRpZXMgPSBkZXN0aW5hdGlvbklkZW50aXRpZXM7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFJlZ2lvbkluZm8sIFJlZ2lvblNldHRpbmdzIH0gZnJvbSAnQGxpdmVraXQvcHJvdG9jb2wnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24gfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBpc0Nsb3VkIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBSZWdpb25VcmxQcm92aWRlciB7XG4gIHByaXZhdGUgc2VydmVyVXJsOiBVUkw7XG5cbiAgcHJpdmF0ZSB0b2tlbjogc3RyaW5nO1xuXG4gIHByaXZhdGUgcmVnaW9uU2V0dGluZ3M6IFJlZ2lvblNldHRpbmdzIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgbGFzdFVwZGF0ZUF0OiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgc2V0dGluZ3NDYWNoZVRpbWUgPSAzXzAwMDtcblxuICBwcml2YXRlIGF0dGVtcHRlZFJlZ2lvbnM6IFJlZ2lvbkluZm9bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCB0b2tlbjogc3RyaW5nKSB7XG4gICAgdGhpcy5zZXJ2ZXJVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG5cbiAgdXBkYXRlVG9rZW4odG9rZW46IHN0cmluZykge1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgfVxuXG4gIGlzQ2xvdWQoKSB7XG4gICAgcmV0dXJuIGlzQ2xvdWQodGhpcy5zZXJ2ZXJVcmwpO1xuICB9XG5cbiAgZ2V0U2VydmVyVXJsKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZlclVybDtcbiAgfVxuXG4gIGFzeW5jIGdldE5leHRCZXN0UmVnaW9uVXJsKGFib3J0U2lnbmFsPzogQWJvcnRTaWduYWwpIHtcbiAgICBpZiAoIXRoaXMuaXNDbG91ZCgpKSB7XG4gICAgICB0aHJvdyBFcnJvcigncmVnaW9uIGF2YWlsYWJpbGl0eSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgTGl2ZUtpdCBDbG91ZCBkb21haW5zJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWdpb25TZXR0aW5ncyB8fCBEYXRlLm5vdygpIC0gdGhpcy5sYXN0VXBkYXRlQXQgPiB0aGlzLnNldHRpbmdzQ2FjaGVUaW1lKSB7XG4gICAgICB0aGlzLnJlZ2lvblNldHRpbmdzID0gYXdhaXQgdGhpcy5mZXRjaFJlZ2lvblNldHRpbmdzKGFib3J0U2lnbmFsKTtcbiAgICB9XG4gICAgY29uc3QgcmVnaW9uc0xlZnQgPSB0aGlzLnJlZ2lvblNldHRpbmdzLnJlZ2lvbnMuZmlsdGVyKFxuICAgICAgKHJlZ2lvbikgPT4gIXRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5maW5kKChhdHRlbXB0ZWQpID0+IGF0dGVtcHRlZC51cmwgPT09IHJlZ2lvbi51cmwpLFxuICAgICk7XG4gICAgaWYgKHJlZ2lvbnNMZWZ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5leHRSZWdpb24gPSByZWdpb25zTGVmdFswXTtcbiAgICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5wdXNoKG5leHRSZWdpb24pO1xuICAgICAgbG9nLmRlYnVnKGBuZXh0IHJlZ2lvbjogJHtuZXh0UmVnaW9uLnJlZ2lvbn1gKTtcbiAgICAgIHJldHVybiBuZXh0UmVnaW9uLnVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRBdHRlbXB0cygpIHtcbiAgICB0aGlzLmF0dGVtcHRlZFJlZ2lvbnMgPSBbXTtcbiAgfVxuXG4gIC8qIEBpbnRlcm5hbCAqL1xuICBhc3luYyBmZXRjaFJlZ2lvblNldHRpbmdzKHNpZ25hbD86IEFib3J0U2lnbmFsKSB7XG4gICAgY29uc3QgcmVnaW9uU2V0dGluZ3NSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2dldENsb3VkQ29uZmlnVXJsKHRoaXMuc2VydmVyVXJsKX0vcmVnaW9uc2AsIHtcbiAgICAgIGhlYWRlcnM6IHsgYXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMudG9rZW59YCB9LFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuICAgIGlmIChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCByZWdpb25TZXR0aW5ncyA9IChhd2FpdCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLmpzb24oKSkgYXMgUmVnaW9uU2V0dGluZ3M7XG4gICAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IERhdGUubm93KCk7XG4gICAgICByZXR1cm4gcmVnaW9uU2V0dGluZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgZmV0Y2ggcmVnaW9uIHNldHRpbmdzOiAke3JlZ2lvblNldHRpbmdzUmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1cyA9PT0gNDAxXG4gICAgICAgICAgPyBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZFxuICAgICAgICAgIDogQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IsXG4gICAgICAgIHJlZ2lvblNldHRpbmdzUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzZXRTZXJ2ZXJSZXBvcnRlZFJlZ2lvbnMocmVnaW9uczogUmVnaW9uU2V0dGluZ3MpIHtcbiAgICB0aGlzLnJlZ2lvblNldHRpbmdzID0gcmVnaW9ucztcbiAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IERhdGUubm93KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2xvdWRDb25maWdVcmwoc2VydmVyVXJsOiBVUkwpIHtcbiAgcmV0dXJuIGAke3NlcnZlclVybC5wcm90b2NvbC5yZXBsYWNlKCd3cycsICdodHRwJyl9Ly8ke3NlcnZlclVybC5ob3N0fS9zZXR0aW5nc2A7XG59XG4iLCJpbXBvcnQgdHlwZSB7IERhdGFTdHJlYW1fQ2h1bmsgfSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgdHlwZSB7IEJhc2VTdHJlYW1JbmZvLCBCeXRlU3RyZWFtSW5mbywgVGV4dFN0cmVhbUluZm8gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGJpZ0ludFRvTnVtYmVyIH0gZnJvbSAnLi91dGlscyc7XG5cbmFic3RyYWN0IGNsYXNzIEJhc2VTdHJlYW1SZWFkZXI8VCBleHRlbmRzIEJhc2VTdHJlYW1JbmZvPiB7XG4gIHByb3RlY3RlZCByZWFkZXI6IFJlYWRhYmxlU3RyZWFtPERhdGFTdHJlYW1fQ2h1bms+O1xuXG4gIHByb3RlY3RlZCB0b3RhbEJ5dGVTaXplPzogbnVtYmVyO1xuXG4gIHByb3RlY3RlZCBfaW5mbzogVDtcblxuICBwcm90ZWN0ZWQgYnl0ZXNSZWNlaXZlZDogbnVtYmVyO1xuXG4gIGdldCBpbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZvO1xuICB9XG5cbiAgY29uc3RydWN0b3IoaW5mbzogVCwgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxEYXRhU3RyZWFtX0NodW5rPiwgdG90YWxCeXRlU2l6ZT86IG51bWJlcikge1xuICAgIHRoaXMucmVhZGVyID0gc3RyZWFtO1xuICAgIHRoaXMudG90YWxCeXRlU2l6ZSA9IHRvdGFsQnl0ZVNpemU7XG4gICAgdGhpcy5faW5mbyA9IGluZm87XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBoYW5kbGVDaHVua1JlY2VpdmVkKGNodW5rOiBEYXRhU3RyZWFtX0NodW5rKTogdm9pZDtcblxuICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHZvaWQ7XG5cbiAgYWJzdHJhY3QgcmVhZEFsbCgpOiBQcm9taXNlPHN0cmluZyB8IEFycmF5PFVpbnQ4QXJyYXk+Pjtcbn1cblxuZXhwb3J0IGNsYXNzIEJ5dGVTdHJlYW1SZWFkZXIgZXh0ZW5kcyBCYXNlU3RyZWFtUmVhZGVyPEJ5dGVTdHJlYW1JbmZvPiB7XG4gIHByb3RlY3RlZCBoYW5kbGVDaHVua1JlY2VpdmVkKGNodW5rOiBEYXRhU3RyZWFtX0NodW5rKSB7XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGNodW5rLmNvbnRlbnQuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLnRvdGFsQnl0ZVNpemVcbiAgICAgID8gdGhpcy5ieXRlc1JlY2VpdmVkIC8gdGhpcy50b3RhbEJ5dGVTaXplXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/LihjdXJyZW50UHJvZ3Jlc3MpO1xuICB9XG5cbiAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXIuZ2V0UmVhZGVyKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogYXN5bmMgKCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8VWludDhBcnJheT4+ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIGFzIGFueSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNodW5rUmVjZWl2ZWQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZS5jb250ZW50IH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yc1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgYXN5bmMgcmV0dXJuKCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8VWludDhBcnJheT4+IHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRBbGwoKTogUHJvbWlzZTxBcnJheTxVaW50OEFycmF5Pj4ge1xuICAgIGxldCBjaHVua3M6IFNldDxVaW50OEFycmF5PiA9IG5ldyBTZXQoKTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMpIHtcbiAgICAgIGNodW5rcy5hZGQoY2h1bmspO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjaHVua3MpO1xuICB9XG59XG5cbi8qKlxuICogQSBjbGFzcyB0byByZWFkIGNodW5rcyBmcm9tIGEgUmVhZGFibGVTdHJlYW0gYW5kIHByb3ZpZGUgdGhlbSBpbiBhIHN0cnVjdHVyZWQgZm9ybWF0LlxuICovXG5leHBvcnQgY2xhc3MgVGV4dFN0cmVhbVJlYWRlciBleHRlbmRzIEJhc2VTdHJlYW1SZWFkZXI8VGV4dFN0cmVhbUluZm8+IHtcbiAgcHJpdmF0ZSByZWNlaXZlZENodW5rczogTWFwPG51bWJlciwgRGF0YVN0cmVhbV9DaHVuaz47XG5cbiAgLyoqXG4gICAqIEEgVGV4dFN0cmVhbVJlYWRlciBpbnN0YW5jZSBjYW4gYmUgdXNlZCBhcyBhbiBBc3luY0l0ZXJhdG9yIHRoYXQgcmV0dXJucyB0aGUgZW50aXJlIHN0cmluZ1xuICAgKiB0aGF0IGhhcyBiZWVuIHJlY2VpdmVkIHVwIHRvIHRoZSBjdXJyZW50IHBvaW50IGluIHRpbWUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBpbmZvOiBUZXh0U3RyZWFtSW5mbyxcbiAgICBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPERhdGFTdHJlYW1fQ2h1bms+LFxuICAgIHRvdGFsQ2h1bmtDb3VudD86IG51bWJlcixcbiAgKSB7XG4gICAgc3VwZXIoaW5mbywgc3RyZWFtLCB0b3RhbENodW5rQ291bnQpO1xuICAgIHRoaXMucmVjZWl2ZWRDaHVua3MgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgaGFuZGxlQ2h1bmtSZWNlaXZlZChjaHVuazogRGF0YVN0cmVhbV9DaHVuaykge1xuICAgIGNvbnN0IGluZGV4ID0gYmlnSW50VG9OdW1iZXIoY2h1bmsuY2h1bmtJbmRleCk7XG4gICAgY29uc3QgcHJldmlvdXNDaHVua0F0SW5kZXggPSB0aGlzLnJlY2VpdmVkQ2h1bmtzLmdldChpbmRleCk7XG4gICAgaWYgKHByZXZpb3VzQ2h1bmtBdEluZGV4ICYmIHByZXZpb3VzQ2h1bmtBdEluZGV4LnZlcnNpb24gPiBjaHVuay52ZXJzaW9uKSB7XG4gICAgICAvLyB3ZSBoYXZlIGEgbmV3ZXIgdmVyc2lvbiBhbHJlYWR5LCBkcm9wcGluZyB0aGUgb2xkIG9uZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlY2VpdmVkQ2h1bmtzLnNldChpbmRleCwgY2h1bmspO1xuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBjaHVuay5jb250ZW50LmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgY3VycmVudFByb2dyZXNzID0gdGhpcy50b3RhbEJ5dGVTaXplXG4gICAgICA/IHRoaXMuYnl0ZXNSZWNlaXZlZCAvIHRoaXMudG90YWxCeXRlU2l6ZVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oY3VycmVudFByb2dyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcHJvZ3Jlc3MgLSBwcm9ncmVzcyBvZiB0aGUgc3RyZWFtIGJldHdlZW4gMCBhbmQgMS4gVW5kZWZpbmVkIGZvciBzdHJlYW1zIG9mIHVua25vd24gc2l6ZVxuICAgKi9cbiAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBBc3luYyBpdGVyYXRvciBpbXBsZW1lbnRhdGlvbiB0byBhbGxvdyB1c2FnZSBvZiBgZm9yIGF3YWl0Li4ub2ZgIHN5bnRheC5cbiAgICogWWllbGRzIHN0cnVjdHVyZWQgY2h1bmtzIGZyb20gdGhlIHN0cmVhbS5cbiAgICpcbiAgICovXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgY29uc3QgcmVhZGVyID0gdGhpcy5yZWFkZXIuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGFzeW5jICgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PHN0cmluZz4+ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2h1bmtSZWNlaXZlZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogZGVjb2Rlci5kZWNvZGUodmFsdWUuY29udGVudCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvcnNcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGFzeW5jIHJldHVybigpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PHN0cmluZz4+IHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRBbGwoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBsZXQgZmluYWxTdHJpbmc6IHN0cmluZyA9ICcnO1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdGhpcykge1xuICAgICAgZmluYWxTdHJpbmcgKz0gY2h1bms7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFN0cmluZztcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCeXRlU3RyZWFtSGFuZGxlciA9IChcbiAgcmVhZGVyOiBCeXRlU3RyZWFtUmVhZGVyLFxuICBwYXJ0aWNpcGFudEluZm86IHsgaWRlbnRpdHk6IHN0cmluZyB9LFxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBUZXh0U3RyZWFtSGFuZGxlciA9IChcbiAgcmVhZGVyOiBUZXh0U3RyZWFtUmVhZGVyLFxuICBwYXJ0aWNpcGFudEluZm86IHsgaWRlbnRpdHk6IHN0cmluZyB9LFxuKSA9PiB2b2lkO1xuIiwiaW1wb3J0IHR5cGUgeyBCYXNlU3RyZWFtSW5mbywgQnl0ZVN0cmVhbUluZm8sIFRleHRTdHJlYW1JbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNsYXNzIEJhc2VTdHJlYW1Xcml0ZXI8VCwgSW5mb1R5cGUgZXh0ZW5kcyBCYXNlU3RyZWFtSW5mbz4ge1xuICBwcm90ZWN0ZWQgd3JpdGFibGVTdHJlYW06IFdyaXRhYmxlU3RyZWFtPFQ+O1xuXG4gIHByb3RlY3RlZCBkZWZhdWx0V3JpdGVyOiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXI8VD47XG5cbiAgcHJvdGVjdGVkIG9uQ2xvc2U/OiAoKSA9PiB2b2lkO1xuXG4gIHJlYWRvbmx5IGluZm86IEluZm9UeXBlO1xuXG4gIGNvbnN0cnVjdG9yKHdyaXRhYmxlU3RyZWFtOiBXcml0YWJsZVN0cmVhbTxUPiwgaW5mbzogSW5mb1R5cGUsIG9uQ2xvc2U/OiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy53cml0YWJsZVN0cmVhbSA9IHdyaXRhYmxlU3RyZWFtO1xuICAgIHRoaXMuZGVmYXVsdFdyaXRlciA9IHdyaXRhYmxlU3RyZWFtLmdldFdyaXRlcigpO1xuICAgIHRoaXMub25DbG9zZSA9IG9uQ2xvc2U7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgfVxuXG4gIHdyaXRlKGNodW5rOiBUKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdFdyaXRlci53cml0ZShjaHVuayk7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBhd2FpdCB0aGlzLmRlZmF1bHRXcml0ZXIuY2xvc2UoKTtcbiAgICB0aGlzLmRlZmF1bHRXcml0ZXIucmVsZWFzZUxvY2soKTtcbiAgICB0aGlzLm9uQ2xvc2U/LigpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUZXh0U3RyZWFtV3JpdGVyIGV4dGVuZHMgQmFzZVN0cmVhbVdyaXRlcjxzdHJpbmcsIFRleHRTdHJlYW1JbmZvPiB7fVxuXG5leHBvcnQgY2xhc3MgQnl0ZVN0cmVhbVdyaXRlciBleHRlbmRzIEJhc2VTdHJlYW1Xcml0ZXI8VWludDhBcnJheSwgQnl0ZVN0cmVhbUluZm8+IHt9XG4iLCJpbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7IG1vbml0b3JGcmVxdWVuY3kgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHsgc3VwcG9ydHNTeW5jaHJvbml6YXRpb25Tb3VyY2VzIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlbW90ZVRyYWNrPFxuICBUcmFja0tpbmQgZXh0ZW5kcyBUcmFjay5LaW5kID0gVHJhY2suS2luZCxcbj4gZXh0ZW5kcyBUcmFjazxUcmFja0tpbmQ+IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZWNlaXZlcjogUlRDUnRwUmVjZWl2ZXIgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVkaWFUcmFjazogTWVkaWFTdHJlYW1UcmFjayxcbiAgICBzaWQ6IHN0cmluZyxcbiAgICBraW5kOiBUcmFja0tpbmQsXG4gICAgcmVjZWl2ZXI6IFJUQ1J0cFJlY2VpdmVyLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihtZWRpYVRyYWNrLCBraW5kLCBsb2dnZXJPcHRpb25zKTtcblxuICAgIHRoaXMuc2lkID0gc2lkO1xuICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgfVxuXG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TXV0ZWQobXV0ZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5pc011dGVkICE9PSBtdXRlZCkge1xuICAgICAgdGhpcy5pc011dGVkID0gbXV0ZWQ7XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgICB0aGlzLmVtaXQobXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldE1lZGlhU3RyZWFtKHN0cmVhbTogTWVkaWFTdHJlYW0pIHtcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhY2sgaXMgZmluaXNoZWRcbiAgICB0aGlzLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xuICAgIGNvbnN0IG9uUmVtb3ZlVHJhY2sgPSAoZXZlbnQ6IE1lZGlhU3RyZWFtVHJhY2tFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRyYWNrID09PSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICAgICAgICBpZiAodGhpcy5yZWNlaXZlciAmJiAncGxheW91dERlbGF5SGludCcgaW4gdGhpcy5yZWNlaXZlcikge1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIucGxheW91dERlbGF5SGludCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIG9uUmVtb3ZlVHJhY2spO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5zdGFydE1vbml0b3IoKTtcbiAgICAvLyB1c2UgYGVuYWJsZWRgIG9mIHRyYWNrIHRvIGVuYWJsZSByZS11c2Ugb2YgdHJhbnNjZWl2ZXJcbiAgICBzdXBlci5lbmFibGUoKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xuICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxuICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIFJlbW90ZVRyYWNrJ3MgdW5kZXJseWluZyBSVENSdHBSZWNlaXZlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBhc3luYyBnZXRSVENTdGF0c1JlcG9ydCgpOiBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0IHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLnJlY2VpdmVyPy5nZXRTdGF0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGF0c1JlcG9ydCA9IGF3YWl0IHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRvIHNldCBhIHBsYXlvdXQgZGVsYXkgKGluIHNlY29uZHMpIGZvciB0aGlzIHRyYWNrLlxuICAgKiBBIGhpZ2hlciB2YWx1ZSBhbGxvd3MgZm9yIG1vcmUgYnVmZmVyaW5nIG9mIHRoZSB0cmFjayBpbiB0aGUgYnJvd3NlclxuICAgKiBhbmQgd2lsbCByZXN1bHQgaW4gYSBkZWxheSBvZiBtZWRpYSBiZWluZyBwbGF5ZWQgYmFjayBvZiBgZGVsYXlJblNlY29uZHNgXG4gICAqL1xuICBzZXRQbGF5b3V0RGVsYXkoZGVsYXlJblNlY29uZHM6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlY2VpdmVyKSB7XG4gICAgICBpZiAoJ3BsYXlvdXREZWxheUhpbnQnIGluIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlci5wbGF5b3V0RGVsYXlIaW50ID0gZGVsYXlJblNlY29uZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdQbGF5b3V0IGRlbGF5IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ0Nhbm5vdCBzZXQgcGxheW91dCBkZWxheSwgdHJhY2sgYWxyZWFkeSBlbmRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXlvdXQgZGVsYXkgKGluIHNlY29uZHMpIG9mIHRoaXMgdHJhY2suXG4gICAqL1xuICBnZXRQbGF5b3V0RGVsYXkoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5yZWNlaXZlcikge1xuICAgICAgaWYgKCdwbGF5b3V0RGVsYXlIaW50JyBpbiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVyLnBsYXlvdXREZWxheUhpbnQgYXMgbnVtYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignUGxheW91dCBkZWxheSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdDYW5ub3QgZ2V0IHBsYXlvdXQgZGVsYXksIHRyYWNrIGFscmVhZHkgZW5kZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RhcnRNb25pdG9yKCkge1xuICAgIGlmICghdGhpcy5tb25pdG9ySW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMubW9uaXRvckludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5tb25pdG9yUmVjZWl2ZXIoKSwgbW9uaXRvckZyZXF1ZW5jeSk7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c1N5bmNocm9uaXphdGlvblNvdXJjZXMoKSkge1xuICAgICAgdGhpcy5yZWdpc3RlclRpbWVTeW5jVXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IG1vbml0b3JSZWNlaXZlcigpOiB2b2lkO1xuXG4gIHJlZ2lzdGVyVGltZVN5bmNVcGRhdGUoKSB7XG4gICAgY29uc3QgbG9vcCA9ICgpID0+IHtcbiAgICAgIHRoaXMudGltZVN5bmNIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gbG9vcCgpKTtcbiAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLnJlY2VpdmVyPy5nZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzKClbMF07XG4gICAgICBpZiAoc291cmNlcykge1xuICAgICAgICBjb25zdCB7IHRpbWVzdGFtcCwgcnRwVGltZXN0YW1wIH0gPSBzb3VyY2VzO1xuICAgICAgICBpZiAocnRwVGltZXN0YW1wICYmIHRoaXMucnRwVGltZXN0YW1wICE9PSBydHBUaW1lc3RhbXApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5UaW1lU3luY1VwZGF0ZSwgeyB0aW1lc3RhbXAsIHJ0cFRpbWVzdGFtcCB9KTtcbiAgICAgICAgICB0aGlzLnJ0cFRpbWVzdGFtcCA9IHJ0cFRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbG9vcCgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgQXVkaW9SZWNlaXZlclN0YXRzIH0gZnJvbSAnLi4vc3RhdHMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpdHJhdGUgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc1JlYWN0TmF0aXZlLCBzdXBwb3J0c1NldFNpbmtJZCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBSZW1vdGVUcmFjayBmcm9tICcuL1JlbW90ZVRyYWNrJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvT3V0cHV0T3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZUF1ZGlvVHJhY2sgZXh0ZW5kcyBSZW1vdGVUcmFjazxUcmFjay5LaW5kLkF1ZGlvPiB7XG4gIHByaXZhdGUgcHJldlN0YXRzPzogQXVkaW9SZWNlaXZlclN0YXRzO1xuXG4gIHByaXZhdGUgZWxlbWVudFZvbHVtZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgYXVkaW9Db250ZXh0PzogQXVkaW9Db250ZXh0O1xuXG4gIHByaXZhdGUgZ2Fpbk5vZGU/OiBHYWluTm9kZTtcblxuICBwcml2YXRlIHNvdXJjZU5vZGU/OiBNZWRpYVN0cmVhbUF1ZGlvU291cmNlTm9kZTtcblxuICBwcml2YXRlIHdlYkF1ZGlvUGx1Z2luTm9kZXM6IEF1ZGlvTm9kZVtdO1xuXG4gIHByaXZhdGUgc2lua0lkPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lZGlhVHJhY2s6IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgc2lkOiBzdHJpbmcsXG4gICAgcmVjZWl2ZXI6IFJUQ1J0cFJlY2VpdmVyLFxuICAgIGF1ZGlvQ29udGV4dD86IEF1ZGlvQ29udGV4dCxcbiAgICBhdWRpb091dHB1dD86IEF1ZGlvT3V0cHV0T3B0aW9ucyxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gW107XG4gICAgaWYgKGF1ZGlvT3V0cHV0KSB7XG4gICAgICB0aGlzLnNpbmtJZCA9IGF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgZm9yIGFsbCBhdHRhY2hlZCBhdWRpbyBlbGVtZW50c1xuICAgKi9cbiAgc2V0Vm9sdW1lKHZvbHVtZTogbnVtYmVyKSB7XG4gICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmF0dGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICB0aGlzLmdhaW5Ob2RlPy5nYWluLnNldFRhcmdldEF0VGltZSh2b2x1bWUsIDAsIDAuMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suX3NldFZvbHVtZSh2b2x1bWUpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRWb2x1bWUgPSB2b2x1bWU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgdm9sdW1lIG9mIGF0dGFjaGVkIGF1ZGlvIGVsZW1lbnRzIChsb3VkZXN0KVxuICAgKi9cbiAgZ2V0Vm9sdW1lKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFZvbHVtZTtcbiAgICB9XG4gICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgLy8gUk4gdm9sdW1lIHZhbHVlIGRlZmF1bHRzIHRvIDEuMCBpZiBoYXNuJ3QgYmVlbiBjaGFuZ2VkLlxuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG4gICAgbGV0IGhpZ2hlc3RWb2x1bWUgPSAwO1xuICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC52b2x1bWUgPiBoaWdoZXN0Vm9sdW1lKSB7XG4gICAgICAgIGhpZ2hlc3RWb2x1bWUgPSBlbGVtZW50LnZvbHVtZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGVzdFZvbHVtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjYWxscyBzZXRTaW5rSWQgb24gYWxsIGF0dGFjaGVkIGVsZW1lbnRzLCBpZiBzdXBwb3J0ZWRcbiAgICogQHBhcmFtIGRldmljZUlkIGF1ZGlvIG91dHB1dCBkZXZpY2VcbiAgICovXG4gIGFzeW5jIHNldFNpbmtJZChkZXZpY2VJZDogc3RyaW5nKSB7XG4gICAgdGhpcy5zaW5rSWQgPSBkZXZpY2VJZDtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5tYXAoKGVsbSkgPT4ge1xuICAgICAgICBpZiAoIXN1cHBvcnRzU2V0U2lua0lkKGVsbSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICByZXR1cm4gZWxtLnNldFNpbmtJZChkZXZpY2VJZCkgYXMgUHJvbWlzZTx2b2lkPjtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBhdHRhY2goKTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50O1xuICBhdHRhY2goZWxlbWVudD86IEhUTUxNZWRpYUVsZW1lbnQpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICBjb25zdCBuZWVkc05ld1dlYkF1ZGlvQ29ubmVjdGlvbiA9IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDA7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaW5rSWQgJiYgc3VwcG9ydHNTZXRTaW5rSWQoZWxlbWVudCkpIHtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVsZW1lbnQuc2V0U2lua0lkKHRoaXMuc2lua0lkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIG5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXNpbmcgYXVkaW8gY29udGV4dCBtYXBwaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCBlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQudm9sdW1lID0gMDtcbiAgICAgIGVsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2b2x1bWUgc2V0dGluZyBpcyBiZWluZyBhcHBsaWVkIHRvIHRoZSBuZXdseSBhdHRhY2hlZCBlbGVtZW50XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGZyb20gYWxsIGF0dGFjaGVkIGVsZW1lbnRzXG4gICAqL1xuICBkZXRhY2goKTogSFRNTE1lZGlhRWxlbWVudFtdO1xuXG4gIC8qKlxuICAgKiBEZXRhY2ggZnJvbSBhIHNpbmdsZSBlbGVtZW50XG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqL1xuICBkZXRhY2goZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gIGRldGFjaChlbGVtZW50PzogSFRNTE1lZGlhRWxlbWVudCk6IEhUTUxNZWRpYUVsZW1lbnQgfCBIVE1MTWVkaWFFbGVtZW50W10ge1xuICAgIGxldCBkZXRhY2hlZDogSFRNTE1lZGlhRWxlbWVudCB8IEhUTUxNZWRpYUVsZW1lbnRbXTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBhbnkgYXR0YWNoZWQgZWxlbWVudHMgYWZ0ZXIgZGV0YWNoaW5nLCBjb25uZWN0IHdlYmF1ZGlvIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQncyBsZWZ0XG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICBpZiAoYXVkaW9Db250ZXh0ICYmIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyhhdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBub2RlcyAtIEFuIGFycmF5IG9mIFdlYkF1ZGlvIG5vZGVzLiBUaGVzZSBub2RlcyBzaG91bGQgbm90IGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHdoZW4gcGFzc2VkLCBhcyB0aGUgc2RrIHdpbGwgdGFrZSBjYXJlIG9mIGNvbm5lY3RpbmcgdGhlbSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzOiBBdWRpb05vZGVbXSkge1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2RlcyA9IG5vZGVzO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCAmJiB0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXR0YWNoZWRFbGVtZW50c1swXSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25uZWN0V2ViQXVkaW8oY29udGV4dDogQXVkaW9Db250ZXh0LCBlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KSB7XG4gICAgdGhpcy5kaXNjb25uZWN0V2ViQXVkaW8oKTtcbiAgICAvLyBAdHMtaWdub3JlIGF0dGFjaGVkIGVsZW1lbnRzIGFsd2F5cyBoYXZlIGEgc3JjT2JqZWN0IHNldFxuICAgIHRoaXMuc291cmNlTm9kZSA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoZWxlbWVudC5zcmNPYmplY3QpO1xuICAgIGxldCBsYXN0Tm9kZTogQXVkaW9Ob2RlID0gdGhpcy5zb3VyY2VOb2RlO1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBsYXN0Tm9kZS5jb25uZWN0KG5vZGUpO1xuICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgIH0pO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICBsYXN0Tm9kZS5jb25uZWN0KHRoaXMuZ2Fpbk5vZGUpO1xuICAgIHRoaXMuZ2Fpbk5vZGUuY29ubmVjdChjb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIHRoaXMuZ2Fpbk5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodGhpcy5lbGVtZW50Vm9sdW1lLCAwLCAwLjEpO1xuICAgIH1cblxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgY29udGV4dFxuICAgICAgICAucmVzdW1lKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmIChjb250ZXh0LnN0YXRlICE9PSAncnVubmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICAgICAgVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJBdWRpbyBDb250ZXh0IGNvdWxkbid0IGJlIHN0YXJ0ZWQgYXV0b21hdGljYWxseVwiKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkaXNjb25uZWN0V2ViQXVkaW8oKSB7XG4gICAgdGhpcy5nYWluTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuc291cmNlTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1vbml0b3JSZWNlaXZlciA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcblxuICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgfTtcblxuICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKCk6IFByb21pc2U8QXVkaW9SZWNlaXZlclN0YXRzIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLnJlY2VpdmVyIHx8ICF0aGlzLnJlY2VpdmVyLmdldFN0YXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgbGV0IHJlY2VpdmVyU3RhdHM6IEF1ZGlvUmVjZWl2ZXJTdGF0cyB8IHVuZGVmaW5lZDtcbiAgICBzdGF0cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBpZiAodi50eXBlID09PSAnaW5ib3VuZC1ydHAnKSB7XG4gICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXIsXG4gICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgIGNvbmNlYWxlZFNhbXBsZXM6IHYuY29uY2VhbGVkU2FtcGxlcyxcbiAgICAgICAgICBjb25jZWFsbWVudEV2ZW50czogdi5jb25jZWFsbWVudEV2ZW50cyxcbiAgICAgICAgICBzaWxlbnRDb25jZWFsZWRTYW1wbGVzOiB2LnNpbGVudENvbmNlYWxlZFNhbXBsZXMsXG4gICAgICAgICAgc2lsZW50Q29uY2VhbG1lbnRFdmVudHM6IHYuc2lsZW50Q29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgdG90YWxBdWRpb0VuZXJneTogdi50b3RhbEF1ZGlvRW5lcmd5LFxuICAgICAgICAgIHRvdGFsU2FtcGxlc0R1cmF0aW9uOiB2LnRvdGFsU2FtcGxlc0R1cmF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZWNlaXZlclN0YXRzO1xuICB9XG59XG4iLCJpbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3RzLWRlYm91bmNlJztcbmltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBWaWRlb1JlY2VpdmVyU3RhdHMgfSBmcm9tICcuLi9zdGF0cyc7XG5pbXBvcnQgeyBjb21wdXRlQml0cmF0ZSB9IGZyb20gJy4uL3N0YXRzJztcbmltcG9ydCBDcml0aWNhbFRpbWVycyBmcm9tICcuLi90aW1lcnMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlTWVkaWFFbGVtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RGV2aWNlUGl4ZWxSYXRpbywgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIGdldFJlc2l6ZU9ic2VydmVyLCBpc1dlYiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBSZW1vdGVUcmFjayBmcm9tICcuL1JlbW90ZVRyYWNrJztcbmltcG9ydCB7IFRyYWNrLCBhdHRhY2hUb0VsZW1lbnQsIGRldGFjaFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5pbXBvcnQgdHlwZSB7IEFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgUkVBQ1RJT05fREVMQVkgPSAxMDA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZVZpZGVvVHJhY2sgZXh0ZW5kcyBSZW1vdGVUcmFjazxUcmFjay5LaW5kLlZpZGVvPiB7XG4gIHByaXZhdGUgcHJldlN0YXRzPzogVmlkZW9SZWNlaXZlclN0YXRzO1xuXG4gIHByaXZhdGUgZWxlbWVudEluZm9zOiBFbGVtZW50SW5mb1tdID0gW107XG5cbiAgcHJpdmF0ZSBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzPzogQWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcblxuICBwcml2YXRlIGxhc3RWaXNpYmxlPzogYm9vbGVhbjtcblxuICBwcml2YXRlIGxhc3REaW1lbnNpb25zPzogVHJhY2suRGltZW5zaW9ucztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHNpZDogc3RyaW5nLFxuICAgIHJlY2VpdmVyOiBSVENSdHBSZWNlaXZlcixcbiAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzPzogQWRhcHRpdmVTdHJlYW1TZXR0aW5ncyxcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLlZpZGVvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcbiAgfVxuXG4gIGdldCBpc0FkYXB0aXZlU3RyZWFtKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgIT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlOiBXaGVuIHVzaW5nIGFkYXB0aXZlU3RyZWFtLCB5b3UgbmVlZCB0byB1c2UgcmVtb3RlVmlkZW9UcmFjay5hdHRhY2goKSB0byBhZGQgdGhlIHRyYWNrIHRvIGEgSFRNTFZpZGVvRWxlbWVudCwgb3RoZXJ3aXNlIHlvdXIgdmlkZW8gdHJhY2tzIG1pZ2h0IG5ldmVyIHN0YXJ0XG4gICAqL1xuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TXV0ZWQobXV0ZWQ6IGJvb2xlYW4pIHtcbiAgICBzdXBlci5zZXRNdXRlZChtdXRlZCk7XG5cbiAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgLy8gZGV0YWNoIG9yIGF0dGFjaFxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIGRldGFjaFRyYWNrKHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KHRoaXMuX21lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXR0YWNoKCk6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gIGF0dGFjaChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudDtcbiAgYXR0YWNoKGVsZW1lbnQ/OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudCB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gc3VwZXIuYXR0YWNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dGFjaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBJdCdzIHBvc3NpYmxlIGF0dGFjaCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgb24gYW4gZWxlbWVudC4gV2hlbiB0aGF0J3NcbiAgICAvLyB0aGUgY2FzZSwgd2UnZCB3YW50IHRvIGF2b2lkIGFkZGluZyBkdXBsaWNhdGUgZWxlbWVudEluZm9zXG4gICAgaWYgKFxuICAgICAgdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICYmXG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKChpbmZvKSA9PiBpbmZvLmVsZW1lbnQgPT09IGVsZW1lbnQpID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRJbmZvID0gbmV3IEhUTUxFbGVtZW50SW5mbyhlbGVtZW50KTtcbiAgICAgIHRoaXMub2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcyB3aGVuIGFkYXB0aXZlIHN0cmVhbWluZy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgb2JzZXJ2ZUVsZW1lbnRJbmZvKGVsZW1lbnRJbmZvOiBFbGVtZW50SW5mbykge1xuICAgIGlmIChcbiAgICAgIHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJlxuICAgICAgdGhpcy5lbGVtZW50SW5mb3MuZmluZCgoaW5mbykgPT4gaW5mbyA9PT0gZWxlbWVudEluZm8pID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgICAgIH07XG4gICAgICBlbGVtZW50SW5mby5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5lbGVtZW50SW5mb3MucHVzaChlbGVtZW50SW5mbyk7XG4gICAgICBlbGVtZW50SW5mby5vYnNlcnZlKCk7XG4gICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCByZXNpemUgdXBkYXRlIGN5Y2xlXG4gICAgICAvLyBpZiB0aGUgdGFiIGlzIGJhY2tncm91bmRlZCwgdGhlIGluaXRpYWwgcmVzaXplIGV2ZW50IGRvZXMgbm90IGZpcmUgdW50aWxcbiAgICAgIC8vIHRoZSB0YWIgY29tZXMgaW50byBmb2N1cyBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3Zpc2liaWxpdHkgcmVzaXplIG9ic2VydmVyIG5vdCB0cmlnZ2VyZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIG9ic2VydmluZyBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGVsZW1lbnRJbmZvOiBFbGVtZW50SW5mbykge1xuICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdzdG9wT2JzZXJ2aW5nRWxlbWVudEluZm8gaWdub3JlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoKGluZm8pID0+IGluZm8gPT09IGVsZW1lbnRJbmZvKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2Ygc3RvcEVsZW1lbnRJbmZvcykge1xuICAgICAgaW5mby5zdG9wT2JzZXJ2aW5nKCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKChpbmZvKSA9PiBpbmZvICE9PSBlbGVtZW50SW5mbyk7XG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgdGhpcy5kZWJvdW5jZWRIYW5kbGVSZXNpemUoKTtcbiAgfVxuXG4gIGRldGFjaCgpOiBIVE1MTWVkaWFFbGVtZW50W107XG4gIGRldGFjaChlbGVtZW50OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudDtcbiAgZGV0YWNoKGVsZW1lbnQ/OiBIVE1MTWVkaWFFbGVtZW50KTogSFRNTE1lZGlhRWxlbWVudCB8IEhUTUxNZWRpYUVsZW1lbnRbXSB7XG4gICAgbGV0IGRldGFjaGVkRWxlbWVudHM6IEhUTUxNZWRpYUVsZW1lbnRbXSA9IFtdO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgZGV0YWNoZWRFbGVtZW50cyA9IHN1cGVyLmRldGFjaCgpO1xuXG4gICAgZm9yIChjb25zdCBlIG9mIGRldGFjaGVkRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnQoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRldGFjaGVkRWxlbWVudHM7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGdldERlY29kZXJJbXBsZW1lbnRhdGlvbigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnByZXZTdGF0cz8uZGVjb2RlckltcGxlbWVudGF0aW9uO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1vbml0b3JSZWNlaXZlciA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRCaXRyYXRlID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLmdldFJlY2VpdmVyU3RhdHMoKTtcblxuICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cyAmJiB0aGlzLnJlY2VpdmVyKSB7XG4gICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgfTtcblxuICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKCk6IFByb21pc2U8VmlkZW9SZWNlaXZlclN0YXRzIHwgdW5kZWZpbmVkPiB7XG4gICAgaWYgKCF0aGlzLnJlY2VpdmVyIHx8ICF0aGlzLnJlY2VpdmVyLmdldFN0YXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgbGV0IHJlY2VpdmVyU3RhdHM6IFZpZGVvUmVjZWl2ZXJTdGF0cyB8IHVuZGVmaW5lZDtcbiAgICBsZXQgY29kZWNJRCA9ICcnO1xuICAgIGxldCBjb2RlY3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgIHN0YXRzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGlmICh2LnR5cGUgPT09ICdpbmJvdW5kLXJ0cCcpIHtcbiAgICAgICAgY29kZWNJRCA9IHYuY29kZWNJZDtcbiAgICAgICAgcmVjZWl2ZXJTdGF0cyA9IHtcbiAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgIGZyYW1lc0RlY29kZWQ6IHYuZnJhbWVzRGVjb2RlZCxcbiAgICAgICAgICBmcmFtZXNEcm9wcGVkOiB2LmZyYW1lc0Ryb3BwZWQsXG4gICAgICAgICAgZnJhbWVzUmVjZWl2ZWQ6IHYuZnJhbWVzUmVjZWl2ZWQsXG4gICAgICAgICAgcGFja2V0c1JlY2VpdmVkOiB2LnBhY2tldHNSZWNlaXZlZCxcbiAgICAgICAgICBwYWNrZXRzTG9zdDogdi5wYWNrZXRzTG9zdCxcbiAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgZnJhbWVIZWlnaHQ6IHYuZnJhbWVIZWlnaHQsXG4gICAgICAgICAgcGxpQ291bnQ6IHYucGxpQ291bnQsXG4gICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICBqaXR0ZXI6IHYuaml0dGVyLFxuICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgYnl0ZXNSZWNlaXZlZDogdi5ieXRlc1JlY2VpdmVkLFxuICAgICAgICAgIGRlY29kZXJJbXBsZW1lbnRhdGlvbjogdi5kZWNvZGVySW1wbGVtZW50YXRpb24sXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gJ2NvZGVjJykge1xuICAgICAgICBjb2RlY3Muc2V0KHYuaWQsIHYpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZWNlaXZlclN0YXRzICYmIGNvZGVjSUQgIT09ICcnICYmIGNvZGVjcy5nZXQoY29kZWNJRCkpIHtcbiAgICAgIHJlY2VpdmVyU3RhdHMubWltZVR5cGUgPSBjb2RlY3MuZ2V0KGNvZGVjSUQpLm1pbWVUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgfVxuXG4gIHByaXZhdGUgc3RvcE9ic2VydmluZ0VsZW1lbnQoZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCkge1xuICAgIGNvbnN0IHN0b3BFbGVtZW50SW5mb3MgPSB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoKGluZm8pID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBhd2FpdCBzdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgIGlmICghdGhpcy5pc0FkYXB0aXZlU3RyZWFtKSByZXR1cm47XG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gIH1cblxuICBwcml2YXRlIHJlYWRvbmx5IGRlYm91bmNlZEhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKCgpID0+IHtcbiAgICB0aGlzLnVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgfSwgUkVBQ1RJT05fREVMQVkpO1xuXG4gIHByaXZhdGUgdXBkYXRlVmlzaWJpbGl0eSgpIHtcbiAgICBjb25zdCBsYXN0VmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMuZWxlbWVudEluZm9zLnJlZHVjZShcbiAgICAgIChwcmV2LCBpbmZvKSA9PiBNYXRoLm1heChwcmV2LCBpbmZvLnZpc2liaWxpdHlDaGFuZ2VkQXQgfHwgMCksXG4gICAgICAwLFxuICAgICk7XG5cbiAgICBjb25zdCBiYWNrZ3JvdW5kUGF1c2UgPVxuICAgICAgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz8ucGF1c2VWaWRlb0luQmFja2dyb3VuZCA/PyB0cnVlKSAvLyBkZWZhdWx0IHRvIHRydWVcbiAgICAgICAgPyB0aGlzLmlzSW5CYWNrZ3JvdW5kXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgaXNQaVBNb2RlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZSgoaW5mbykgPT4gaW5mby5waWN0dXJlSW5QaWN0dXJlKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPVxuICAgICAgKHRoaXMuZWxlbWVudEluZm9zLnNvbWUoKGluZm8pID0+IGluZm8udmlzaWJsZSkgJiYgIWJhY2tncm91bmRQYXVzZSkgfHwgaXNQaVBNb2RlO1xuXG4gICAgaWYgKHRoaXMubGFzdFZpc2libGUgPT09IGlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNWaXNpYmxlICYmIERhdGUubm93KCkgLSBsYXN0VmlzaWJpbGl0eUNoYW5nZSA8IFJFQUNUSU9OX0RFTEFZKSB7XG4gICAgICAvLyBkZWxheSBoaWRkZW4gZXZlbnRzXG4gICAgICBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0VmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaXNpYmlsaXR5Q2hhbmdlZCwgaXNWaXNpYmxlLCB0aGlzKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGltZW5zaW9ucygpIHtcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IHRoaXMuZ2V0UGl4ZWxEZW5zaXR5KCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHRoaXMuZWxlbWVudEluZm9zKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudFdpZHRoID0gaW5mby53aWR0aCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRIZWlnaHQgPSBpbmZvLmhlaWdodCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50V2lkdGggKyBjdXJyZW50RWxlbWVudEhlaWdodCA+IG1heFdpZHRoICsgbWF4SGVpZ2h0KSB7XG4gICAgICAgIG1heFdpZHRoID0gY3VycmVudEVsZW1lbnRXaWR0aDtcbiAgICAgICAgbWF4SGVpZ2h0ID0gY3VycmVudEVsZW1lbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGFzdERpbWVuc2lvbnM/LndpZHRoID09PSBtYXhXaWR0aCAmJiB0aGlzLmxhc3REaW1lbnNpb25zPy5oZWlnaHQgPT09IG1heEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubGFzdERpbWVuc2lvbnMgPSB7XG4gICAgICB3aWR0aDogbWF4V2lkdGgsXG4gICAgICBoZWlnaHQ6IG1heEhlaWdodCxcbiAgICB9O1xuXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5sYXN0RGltZW5zaW9ucywgdGhpcyk7XG4gIH1cblxuICBwcml2YXRlIGdldFBpeGVsRGVuc2l0eSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz8ucGl4ZWxEZW5zaXR5O1xuICAgIGlmIChwaXhlbERlbnNpdHkgPT09ICdzY3JlZW4nKSB7XG4gICAgICByZXR1cm4gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIH0gZWxzZSBpZiAoIXBpeGVsRGVuc2l0eSkge1xuICAgICAgLy8gd2hlbiB1bnNldCwgd2UnbGwgcGljayBhIHNhbmUgZGVmYXVsdCBoZXJlLlxuICAgICAgLy8gZm9yIGhpZ2hlciBwaXhlbCBkZW5zaXR5IGRldmljZXMgKG1vYmlsZSBwaG9uZXMsIGV0YyksIHdlJ2xsIHVzZSAyXG4gICAgICAvLyBvdGhlcndpc2UgaXQgZGVmYXVsdHMgdG8gMVxuICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICAgIGlmIChkZXZpY2VQaXhlbFJhdGlvID4gMikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxEZW5zaXR5O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudEluZm8ge1xuICBlbGVtZW50OiBvYmplY3Q7XG4gIHdpZHRoKCk6IG51bWJlcjtcbiAgaGVpZ2h0KCk6IG51bWJlcjtcbiAgdmlzaWJsZTogYm9vbGVhbjtcbiAgcGljdHVyZUluUGljdHVyZTogYm9vbGVhbjtcbiAgdmlzaWJpbGl0eUNoYW5nZWRBdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gIGhhbmRsZVJlc2l6ZT86ICgpID0+IHZvaWQ7XG4gIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkPzogKCkgPT4gdm9pZDtcbiAgb2JzZXJ2ZSgpOiB2b2lkO1xuICBzdG9wT2JzZXJ2aW5nKCk6IHZvaWQ7XG59XG5cbmNsYXNzIEhUTUxFbGVtZW50SW5mbyBpbXBsZW1lbnRzIEVsZW1lbnRJbmZvIHtcbiAgZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudDtcblxuICBnZXQgdmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUCB8fCB0aGlzLmlzSW50ZXJzZWN0aW5nO1xuICB9XG5cbiAgZ2V0IHBpY3R1cmVJblBpY3R1cmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaVA7XG4gIH1cblxuICB2aXNpYmlsaXR5Q2hhbmdlZEF0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgaGFuZGxlUmVzaXplPzogKCkgPT4gdm9pZDtcblxuICBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZD86ICgpID0+IHZvaWQ7XG5cbiAgcHJpdmF0ZSBpc1BpUDogYm9vbGVhbjtcblxuICBwcml2YXRlIGlzSW50ZXJzZWN0aW5nOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQsIHZpc2libGU/OiBib29sZWFuKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gdmlzaWJsZSA/PyBpc0VsZW1lbnRJblZpZXdwb3J0KGVsZW1lbnQpO1xuICAgIHRoaXMuaXNQaVAgPSBpc1dlYigpICYmIGlzRWxlbWVudEluUGlQKGVsZW1lbnQpO1xuICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IDA7XG4gIH1cblxuICB3aWR0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIH1cblxuICBoZWlnaHQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIG9ic2VydmUoKSB7XG4gICAgLy8gbWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgY3VycmVudCB2aXNpYmxlIHN0YXRlIG9uY2Ugd2Ugc3RhcnQgdG8gb2JzZXJ2ZVxuICAgIHRoaXMuaXNJbnRlcnNlY3RpbmcgPSBpc0VsZW1lbnRJblZpZXdwb3J0KHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XG5cbiAgICAodGhpcy5lbGVtZW50IGFzIE9ic2VydmFibGVNZWRpYUVsZW1lbnQpLmhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlUmVzaXplPy4oKTtcbiAgICB9O1xuICAgICh0aGlzLmVsZW1lbnQgYXMgT2JzZXJ2YWJsZU1lZGlhRWxlbWVudCkuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQ7XG5cbiAgICBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICBnZXRSZXNpemVPYnNlcnZlcigpLm9ic2VydmUodGhpcy5lbGVtZW50KTtcbiAgICAodGhpcy5lbGVtZW50IGFzIEhUTUxWaWRlb0VsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XG4gICAgKHRoaXMuZWxlbWVudCBhcyBIVE1MVmlkZW9FbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICAgIHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmU/LmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVyJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlPy53aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxuXG4gIHByaXZhdGUgb25WaXNpYmlsaXR5Q2hhbmdlZCA9IChlbnRyeTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkgPT4ge1xuICAgIGNvbnN0IHsgdGFyZ2V0LCBpc0ludGVyc2VjdGluZyB9ID0gZW50cnk7XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRBdCA9IERhdGUubm93KCk7XG4gICAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkPy4oKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkVudGVyUGlQID0gKCkgPT4ge1xuICAgIHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmU/LndpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQ/LigpO1xuICB9O1xuXG4gIHByaXZhdGUgb25MZWF2ZVBpUCA9ICgpID0+IHtcbiAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkPy4oKTtcbiAgfTtcblxuICBzdG9wT2JzZXJ2aW5nKCkge1xuICAgIGdldEludGVyc2VjdGlvbk9ic2VydmVyKCk/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGdldFJlc2l6ZU9ic2VydmVyKCk/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgICh0aGlzLmVsZW1lbnQgYXMgSFRNTFZpZGVvRWxlbWVudCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLFxuICAgICAgdGhpcy5vbkVudGVyUGlQLFxuICAgICk7XG4gICAgKHRoaXMuZWxlbWVudCBhcyBIVE1MVmlkZW9FbGVtZW50KS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgJ2xlYXZlcGljdHVyZWlucGljdHVyZScsXG4gICAgICB0aGlzLm9uTGVhdmVQaVAsXG4gICAgKTtcbiAgICB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlPy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcicsIHRoaXMub25FbnRlclBpUCk7XG4gICAgd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZT8ud2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50SW5QaVAoZWw6IEhUTUxFbGVtZW50KSB7XG4gIC8vIFNpbXBsZSB2aWRlbyBQaVBcbiAgaWYgKGRvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50ID09PSBlbCkgcmV0dXJuIHRydWU7XG4gIC8vIERvY3VtZW50IFBpUFxuICBpZiAod2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZT8ud2luZG93KVxuICAgIHJldHVybiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsLCB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlPy53aW5kb3cpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGRvZXMgbm90IGFjY291bnQgZm9yIG9jY2x1c2lvbiBieSBvdGhlciBlbGVtZW50cyBvciBvcGFjaXR5IHByb3BlcnR5XG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsOiBIVE1MRWxlbWVudCwgd2luPzogV2luZG93KSB7XG4gIGNvbnN0IHZpZXdwb3J0V2luZG93ID0gd2luIHx8IHdpbmRvdztcbiAgbGV0IHRvcCA9IGVsLm9mZnNldFRvcDtcbiAgbGV0IGxlZnQgPSBlbC5vZmZzZXRMZWZ0O1xuICBjb25zdCB3aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSBlbDtcbiAgY29uc3QgeyBkaXNwbGF5IH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcblxuICB3aGlsZSAoZWwub2Zmc2V0UGFyZW50KSB7XG4gICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgdG9wICs9IGVsLm9mZnNldFRvcDtcbiAgICBsZWZ0ICs9IGVsLm9mZnNldExlZnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHRvcCA8IHZpZXdwb3J0V2luZG93LnBhZ2VZT2Zmc2V0ICsgdmlld3BvcnRXaW5kb3cuaW5uZXJIZWlnaHQgJiZcbiAgICBsZWZ0IDwgdmlld3BvcnRXaW5kb3cucGFnZVhPZmZzZXQgKyB2aWV3cG9ydFdpbmRvdy5pbm5lcldpZHRoICYmXG4gICAgdG9wICsgaGVpZ2h0ID4gdmlld3BvcnRXaW5kb3cucGFnZVlPZmZzZXQgJiZcbiAgICBsZWZ0ICsgd2lkdGggPiB2aWV3cG9ydFdpbmRvdy5wYWdlWE9mZnNldCAmJlxuICAgICFoaWRkZW4gJiZcbiAgICBkaXNwbGF5ICE9PSAnbm9uZSdcbiAgKTtcbn1cbiIsImltcG9ydCB7IEVuY3J5cHRpb25fVHlwZSB9IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB0eXBlIHtcbiAgU3Vic2NyaXB0aW9uRXJyb3IsXG4gIFRyYWNrSW5mbyxcbiAgVXBkYXRlU3Vic2NyaXB0aW9uLFxuICBVcGRhdGVUcmFja1NldHRpbmdzLFxufSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFdmVudEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IExvZ2dlck9wdGlvbnMsIFRyYW5zY3JpcHRpb25TZWdtZW50IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNBdWRpb1RyYWNrLCBpc1ZpZGVvVHJhY2sgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4vTG9jYWxBdWRpb1RyYWNrJztcbmltcG9ydCBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IFJlbW90ZUF1ZGlvVHJhY2sgZnJvbSAnLi9SZW1vdGVBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4vUmVtb3RlVHJhY2snO1xuaW1wb3J0IFJlbW90ZVZpZGVvVHJhY2sgZnJvbSAnLi9SZW1vdGVWaWRlb1RyYWNrJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi9UcmFjayc7XG5pbXBvcnQgeyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFja1B1YmxpY2F0aW9uIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFdmVudEVtaXR0ZXI8UHVibGljYXRpb25FdmVudENhbGxiYWNrcz4pIHtcbiAga2luZDogVHJhY2suS2luZDtcblxuICB0cmFja05hbWU6IHN0cmluZztcblxuICB0cmFja1NpZDogVHJhY2suU0lEO1xuXG4gIHRyYWNrPzogVHJhY2s7XG5cbiAgc291cmNlOiBUcmFjay5Tb3VyY2U7XG5cbiAgLyoqIE1pbWVUeXBlIG9mIHRoZSBwdWJsaXNoZWQgdHJhY2sgKi9cbiAgbWltZVR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqIGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luYWwgcHVibGlzaGVkIHN0cmVhbSwgdmlkZW8tb25seSAqL1xuICBkaW1lbnNpb25zPzogVHJhY2suRGltZW5zaW9ucztcblxuICAvKiogdHJ1ZSBpZiB0cmFjayB3YXMgc2ltdWxjYXN0ZWQgdG8gc2VydmVyLCB2aWRlby1vbmx5ICovXG4gIHNpbXVsY2FzdGVkPzogYm9vbGVhbjtcblxuICAvKiogQGludGVybmFsICovXG4gIHRyYWNrSW5mbz86IFRyYWNrSW5mbztcblxuICBwcm90ZWN0ZWQgbWV0YWRhdGFNdXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBlbmNyeXB0aW9uOiBFbmNyeXB0aW9uX1R5cGUgPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcblxuICBwcm90ZWN0ZWQgbG9nID0gbG9nO1xuXG4gIHByaXZhdGUgbG9nZ2VyQ29udGV4dENiPzogTG9nZ2VyT3B0aW9uc1snbG9nZ2VyQ29udGV4dENiJ107XG5cbiAgY29uc3RydWN0b3Ioa2luZDogVHJhY2suS2luZCwgaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIobG9nZ2VyT3B0aW9ucz8ubG9nZ2VyTmFtZSA/PyBMb2dnZXJOYW1lcy5QdWJsaWNhdGlvbik7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSB0aGlzLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy50cmFja1NpZCA9IGlkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRUcmFjayh0cmFjaz86IFRyYWNrKSB7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cblxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgLy8gZm9yd2FyZCBldmVudHNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMuaGFuZGxlTXV0ZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLmhhbmRsZVVubXV0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5sb2dnZXJDb250ZXh0Q2I/LigpLFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGlzTXV0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGFNdXRlZDtcbiAgfVxuXG4gIGdldCBpc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgaXNTdWJzY3JpYmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRyYWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXQgaXNFbmNyeXB0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cblxuICBhYnN0cmFjdCBnZXQgaXNMb2NhbCgpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBhbiBbQXVkaW9UcmFja10gaWYgdGhpcyBwdWJsaWNhdGlvbiBob2xkcyBhbiBhdWRpbyB0cmFja1xuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKTogTG9jYWxBdWRpb1RyYWNrIHwgUmVtb3RlQXVkaW9UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKGlzQXVkaW9UcmFjayh0aGlzLnRyYWNrKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGFuIFtWaWRlb1RyYWNrXSBpZiB0aGlzIHB1YmxpY2F0aW9uIGhvbGRzIGEgdmlkZW8gdHJhY2tcbiAgICovXG4gIGdldCB2aWRlb1RyYWNrKCk6IExvY2FsVmlkZW9UcmFjayB8IFJlbW90ZVZpZGVvVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIGlmIChpc1ZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU11dGVkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50Lk11dGVkKTtcbiAgfTtcblxuICBoYW5kbGVVbm11dGVkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVubXV0ZWQpO1xuICB9O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvOiBUcmFja0luZm8pIHtcbiAgICB0aGlzLnRyYWNrU2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBpbmZvLm5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5zb3VyY2VGcm9tUHJvdG8oaW5mby5zb3VyY2UpO1xuICAgIHRoaXMubWltZVR5cGUgPSBpbmZvLm1pbWVUeXBlO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgaW5mby53aWR0aCA+IDApIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IGluZm8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5mby5oZWlnaHQsXG4gICAgICB9O1xuICAgICAgdGhpcy5zaW11bGNhc3RlZCA9IGluZm8uc2ltdWxjYXN0O1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb24gPSBpbmZvLmVuY3J5cHRpb247XG4gICAgdGhpcy50cmFja0luZm8gPSBpbmZvO1xuICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGUgcHVibGljYXRpb24gaW5mbycsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBpbmZvIH0pO1xuICB9XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhY2tQdWJsaWNhdGlvbiB7XG4gIGV4cG9ydCBlbnVtIFN1YnNjcmlwdGlvblN0YXR1cyB7XG4gICAgRGVzaXJlZCA9ICdkZXNpcmVkJyxcbiAgICBTdWJzY3JpYmVkID0gJ3N1YnNjcmliZWQnLFxuICAgIFVuc3Vic2NyaWJlZCA9ICd1bnN1YnNjcmliZWQnLFxuICB9XG5cbiAgZXhwb3J0IGVudW0gUGVybWlzc2lvblN0YXR1cyB7XG4gICAgQWxsb3dlZCA9ICdhbGxvd2VkJyxcbiAgICBOb3RBbGxvd2VkID0gJ25vdF9hbGxvd2VkJyxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQdWJsaWNhdGlvbkV2ZW50Q2FsbGJhY2tzID0ge1xuICBtdXRlZDogKCkgPT4gdm9pZDtcbiAgdW5tdXRlZDogKCkgPT4gdm9pZDtcbiAgZW5kZWQ6ICh0cmFjaz86IFRyYWNrKSA9PiB2b2lkO1xuICB1cGRhdGVTZXR0aW5nczogKHNldHRpbmdzOiBVcGRhdGVUcmFja1NldHRpbmdzKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZDogKFxuICAgIHN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLFxuICAgIHByZXZTdGF0dXM6IFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyxcbiAgKSA9PiB2b2lkO1xuICB1cGRhdGVTdWJzY3JpcHRpb246IChzdWI6IFVwZGF0ZVN1YnNjcmlwdGlvbikgPT4gdm9pZDtcbiAgc3Vic2NyaWJlZDogKHRyYWNrOiBSZW1vdGVUcmFjaykgPT4gdm9pZDtcbiAgdW5zdWJzY3JpYmVkOiAodHJhY2s6IFJlbW90ZVRyYWNrKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiAoXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyxcbiAgICBwcmV2U3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyxcbiAgKSA9PiB2b2lkO1xuICBzdWJzY3JpcHRpb25GYWlsZWQ6IChlcnJvcjogU3Vic2NyaXB0aW9uRXJyb3IpID0+IHZvaWQ7XG4gIHRyYW5zY3JpcHRpb25SZWNlaXZlZDogKHRyYW5zY3JpcHRpb246IFRyYW5zY3JpcHRpb25TZWdtZW50W10pID0+IHZvaWQ7XG4gIHRpbWVTeW5jVXBkYXRlOiAodGltZXN0YW1wOiBudW1iZXIpID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IHsgQXVkaW9UcmFja0ZlYXR1cmUsIFRyYWNrSW5mbyB9IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB7IFRyYWNrRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNBdWRpb1RyYWNrIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IExvY2FsQXVkaW9UcmFjayBmcm9tICcuL0xvY2FsQXVkaW9UcmFjayc7XG5pbXBvcnQgdHlwZSBMb2NhbFRyYWNrIGZyb20gJy4vTG9jYWxUcmFjayc7XG5pbXBvcnQgdHlwZSBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4vVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgdHlwZSB7IFRyYWNrUHVibGlzaE9wdGlvbnMgfSBmcm9tICcuL29wdGlvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2NhbFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgdHJhY2s/OiBMb2NhbFRyYWNrID0gdW5kZWZpbmVkO1xuXG4gIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zO1xuXG4gIGdldCBpc1Vwc3RyZWFtUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrPy5pc1Vwc3RyZWFtUGF1c2VkO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2luZDogVHJhY2suS2luZCwgdGk6IFRyYWNrSW5mbywgdHJhY2s/OiBMb2NhbFRyYWNrLCBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG5cbiAgICB0aGlzLnVwZGF0ZUluZm8odGkpO1xuICAgIHRoaXMuc2V0VHJhY2sodHJhY2spO1xuICB9XG5cbiAgc2V0VHJhY2sodHJhY2s/OiBUcmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cblxuICAgIHN1cGVyLnNldFRyYWNrKHRyYWNrKTtcblxuICAgIGlmICh0cmFjaykge1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNNdXRlZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2suaXNNdXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzTXV0ZWQ7XG4gIH1cblxuICBnZXQgYXVkaW9UcmFjaygpOiBMb2NhbEF1ZGlvVHJhY2sgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBzdXBlci5hdWRpb1RyYWNrIGFzIExvY2FsQXVkaW9UcmFjayB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldCB2aWRlb1RyYWNrKCk6IExvY2FsVmlkZW9UcmFjayB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHN1cGVyLnZpZGVvVHJhY2sgYXMgTG9jYWxWaWRlb1RyYWNrIHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTXV0ZSB0aGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cbiAgICovXG4gIGFzeW5jIG11dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2s/Lm11dGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm11dGUgdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb25cbiAgICovXG4gIGFzeW5jIHVubXV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjaz8udW5tdXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2VzIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gZnJvbSBiZWluZyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICogYW5kIHNpZ25hbHMgXCJtdXRlZFwiIGV2ZW50IHRvIG90aGVyIHBhcnRpY2lwYW50c1xuICAgKiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gcGF1c2UgdGhlIHN0cmVhbSB3aXRob3V0IHBhdXNpbmcgdGhlIGxvY2FsIG1lZGlhIHN0cmVhbSB0cmFja1xuICAgKi9cbiAgYXN5bmMgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICBhd2FpdCB0aGlzLnRyYWNrPy5wYXVzZVVwc3RyZWFtKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lcyBzZW5kaW5nIHRoZSBtZWRpYSBzdHJlYW0gdHJhY2sgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHVibGljYXRpb24gdG8gdGhlIHNlcnZlciBhZnRlciBhIGNhbGwgdG8gW1twYXVzZVVwc3RyZWFtKCldXVxuICAgKiBhbmQgc2lnbmFscyBcInVubXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHMgKHVubGVzcyB0aGUgdHJhY2sgaXMgZXhwbGljaXRseSBtdXRlZClcbiAgICovXG4gIGFzeW5jIHJlc3VtZVVwc3RyZWFtKCkge1xuICAgIGF3YWl0IHRoaXMudHJhY2s/LnJlc3VtZVVwc3RyZWFtKCk7XG4gIH1cblxuICBnZXRUcmFja0ZlYXR1cmVzKCkge1xuICAgIGlmIChpc0F1ZGlvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy50cmFjayEuZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpO1xuICAgICAgY29uc3QgZmVhdHVyZXM6IFNldDxBdWRpb1RyYWNrRmVhdHVyZT4gPSBuZXcgU2V0KCk7XG4gICAgICBpZiAoc2V0dGluZ3MuYXV0b0dhaW5Db250cm9sKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9BVVRPX0dBSU5fQ09OVFJPTCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuZWNob0NhbmNlbGxhdGlvbikge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfRUNIT19DQU5DRUxMQVRJT04pO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLm5vaXNlU3VwcHJlc3Npb24pIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PSVNFX1NVUFBSRVNTSU9OKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy5jaGFubmVsQ291bnQgJiYgc2V0dGluZ3MuY2hhbm5lbENvdW50ID4gMSkge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfU1RFUkVPKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5vcHRpb25zPy5kdHgpIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX05PX0RUWCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50cmFjay5lbmhhbmNlZE5vaXNlQ2FuY2VsbGF0aW9uKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9FTkhBTkNFRF9OT0lTRV9DQU5DRUxMQVRJT04pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZmVhdHVyZXMudmFsdWVzKCkpO1xuICAgIH0gZWxzZSByZXR1cm4gW107XG4gIH1cblxuICBoYW5kbGVUcmFja0VuZGVkID0gKCkgPT4ge1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkKTtcbiAgfTtcbn1cbiIsImltcG9ydCBEZXZpY2VNYW5hZ2VyIGZyb20gJy4uL0RldmljZU1hbmFnZXInO1xuaW1wb3J0IHsgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cyB9IGZyb20gJy4uL2RlZmF1bHRzJztcbmltcG9ydCB7IERldmljZVVuc3VwcG9ydGVkRXJyb3IsIFRyYWNrSW52YWxpZEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sgfSBmcm9tICcuLi9wYXJ0aWNpcGFudC9wdWJsaXNoVXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBMb2dnZXJPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgaXNBdWRpb1RyYWNrLCBpc1NhZmFyaTE3LCBpc1ZpZGVvVHJhY2ssIHVud3JhcENvbnN0cmFpbnQgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4vTG9jYWxBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIExvY2FsVHJhY2sgZnJvbSAnLi9Mb2NhbFRyYWNrJztcbmltcG9ydCBMb2NhbFZpZGVvVHJhY2sgZnJvbSAnLi9Mb2NhbFZpZGVvVHJhY2snO1xuaW1wb3J0IHsgVHJhY2sgfSBmcm9tICcuL1RyYWNrJztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9DYXB0dXJlT3B0aW9ucyxcbiAgQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zLFxuICBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zLFxuICBWaWRlb0NhcHR1cmVPcHRpb25zLFxufSBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgU2NyZWVuU2hhcmVQcmVzZXRzIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7XG4gIGNvbnN0cmFpbnRzRm9yT3B0aW9ucyxcbiAgZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyxcbiAgbWVyZ2VEZWZhdWx0T3B0aW9ucyxcbiAgc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyxcbn0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvY2FsIHZpZGVvIGFuZCBhdWRpbyB0cmFjayBhdCB0aGUgc2FtZSB0aW1lLiBXaGVuIGFjcXVpcmluZyBib3RoXG4gKiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHRvZ2V0aGVyLCBpdCdsbCBkaXNwbGF5IGEgc2luZ2xlIHBlcm1pc3Npb24gcHJvbXB0IHRvXG4gKiB0aGUgdXNlciBpbnN0ZWFkIG9mIHR3byBzZXBhcmF0ZSBvbmVzLlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsVHJhY2tzKFxuICBvcHRpb25zPzogQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zLFxuICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbik6IFByb21pc2U8QXJyYXk8TG9jYWxUcmFjaz4+IHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9ucyB0byB0cnVlXG4gIGNvbnN0IGludGVybmFsT3B0aW9ucyA9IHsgLi4uKG9wdGlvbnMgPz8ge30pIH07XG4gIGxldCBhdHRlbXB0RXhhY3RNYXRjaCA9IGZhbHNlO1xuICBsZXQgcmV0cnlBdWRpb09wdGlvbnM6IEF1ZGlvQ2FwdHVyZU9wdGlvbnMgfCB1bmRlZmluZWQgfCBib29sZWFuID0gb3B0aW9ucz8uYXVkaW87XG4gIGxldCByZXRyeVZpZGVvT3B0aW9uczogVmlkZW9DYXB0dXJlT3B0aW9ucyB8IHVuZGVmaW5lZCB8IGJvb2xlYW4gPSBvcHRpb25zPy52aWRlbztcbiAgLy8gaWYgdGhlIHVzZXIgcGFzc2VzIGEgZGV2aWNlIGlkIGFzIGEgc3RyaW5nLCB3ZSBkZWZhdWx0IHRvIGV4YWN0IG1hdGNoXG4gIGlmIChcbiAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gJiZcbiAgICB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQgPT09ICdzdHJpbmcnXG4gICkge1xuICAgIGNvbnN0IGRldmljZUlkOiBzdHJpbmcgPSBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQ7XG4gICAgaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkID0geyBleGFjdDogZGV2aWNlSWQgfTtcbiAgICBhdHRlbXB0RXhhY3RNYXRjaCA9IHRydWU7XG4gICAgcmV0cnlBdWRpb09wdGlvbnMgPSB7XG4gICAgICAuLi5pbnRlcm5hbE9wdGlvbnMuYXVkaW8sXG4gICAgICBkZXZpY2VJZDogeyBpZGVhbDogZGV2aWNlSWQgfSxcbiAgICB9O1xuICB9XG4gIGlmIChcbiAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8gJiZcbiAgICB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQgPT09ICdzdHJpbmcnXG4gICkge1xuICAgIGNvbnN0IGRldmljZUlkOiBzdHJpbmcgPSBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQ7XG4gICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkID0geyBleGFjdDogZGV2aWNlSWQgfTtcbiAgICBhdHRlbXB0RXhhY3RNYXRjaCA9IHRydWU7XG4gICAgcmV0cnlWaWRlb09wdGlvbnMgPSB7XG4gICAgICAuLi5pbnRlcm5hbE9wdGlvbnMudmlkZW8sXG4gICAgICBkZXZpY2VJZDogeyBpZGVhbDogZGV2aWNlSWQgfSxcbiAgICB9O1xuICB9XG4gIC8vIFRPRE8gaWYgaW50ZXJuYWwgb3B0aW9ucyBkb24ndCBoYXZlIGRldmljZSBJZCBzcGVjaWZpZWQsIHNldCBpdCB0byAnZGVmYXVsdCdcbiAgaWYgKFxuICAgIGludGVybmFsT3B0aW9ucy5hdWRpbyA9PT0gdHJ1ZSB8fFxuICAgICh0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0JyAmJiAhaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkKVxuICApIHtcbiAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPSB7IGRldmljZUlkOiAnZGVmYXVsdCcgfTtcbiAgfVxuICBpZiAoXG4gICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSB0cnVlIHx8XG4gICAgKHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnICYmICFpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQpXG4gICkge1xuICAgIGludGVybmFsT3B0aW9ucy52aWRlbyA9IHsgZGV2aWNlSWQ6ICdkZWZhdWx0JyB9O1xuICB9XG4gIGNvbnN0IHsgYXVkaW9Qcm9jZXNzb3IsIHZpZGVvUHJvY2Vzc29yIH0gPSBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKGludGVybmFsT3B0aW9ucyk7XG4gIGNvbnN0IG9wdHMgPSBtZXJnZURlZmF1bHRPcHRpb25zKGludGVybmFsT3B0aW9ucywgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cyk7XG4gIGNvbnN0IGNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKG9wdHMpO1xuXG4gIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHByb21pc2Ugb24gRGV2aWNlTWFuYWdlciBhbmQgYXdhaXQgaXQgaW4gZ2V0TG9jYWxEZXZpY2VzKClcbiAgLy8gd29ya3MgYXJvdW5kIGlPUyBTYWZhcmkgQnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzkzNjNcbiAgY29uc3QgbWVkaWFQcm9taXNlID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuXG4gIGlmIChpbnRlcm5hbE9wdGlvbnMuYXVkaW8pIHtcbiAgICBEZXZpY2VNYW5hZ2VyLnVzZXJNZWRpYVByb21pc2VNYXAuc2V0KCdhdWRpb2lucHV0JywgbWVkaWFQcm9taXNlKTtcbiAgICBtZWRpYVByb21pc2UuY2F0Y2goKCkgPT4gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmRlbGV0ZSgnYXVkaW9pbnB1dCcpKTtcbiAgfVxuICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvKSB7XG4gICAgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLnNldCgndmlkZW9pbnB1dCcsIG1lZGlhUHJvbWlzZSk7XG4gICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ3ZpZGVvaW5wdXQnKSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBtZWRpYVByb21pc2U7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLm1hcChhc3luYyAobWVkaWFTdHJlYW1UcmFjaykgPT4ge1xuICAgICAgICBjb25zdCBpc0F1ZGlvID0gbWVkaWFTdHJlYW1UcmFjay5raW5kID09PSAnYXVkaW8nO1xuICAgICAgICBsZXQgdHJhY2tPcHRpb25zID0gaXNBdWRpbyA/IG9wdHMhLmF1ZGlvIDogb3B0cyEudmlkZW87XG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tPcHRpb25zID09PSAnYm9vbGVhbicgfHwgIXRyYWNrT3B0aW9ucykge1xuICAgICAgICAgIHRyYWNrT3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFja0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHMgfCB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNvbk9yQm9vbCA9IGlzQXVkaW8gPyBjb25zdHJhaW50cy5hdWRpbyA6IGNvbnN0cmFpbnRzLnZpZGVvO1xuICAgICAgICBpZiAodHlwZW9mIGNvbk9yQm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29uc3RyYWludHMgd2l0aCB0aGUgZGV2aWNlIGlkIHRoZSB1c2VyIGdhdmUgcGVybWlzc2lvbnMgdG8gaW4gdGhlIHBlcm1pc3Npb24gcHJvbXB0XG4gICAgICAgIC8vIG90aGVyd2lzZSBlYWNoIHRyYWNrIHJlc3RhcnQgKGUuZy4gbXV0ZSAtIHVubXV0ZSkgd2lsbCB0cnkgdG8gaW5pdGlhbGl6ZSB0aGUgZGV2aWNlIGFnYWluIC0+IGNhdXNpbmcgYWRkaXRpb25hbCBwZXJtaXNzaW9uIHByb21wdHNcbiAgICAgICAgY29uc3QgbmV3RGV2aWNlSWQgPSBtZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0cmFja0NvbnN0cmFpbnRzPy5kZXZpY2VJZCAmJlxuICAgICAgICAgIHVud3JhcENvbnN0cmFpbnQodHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCkgIT09IG5ld0RldmljZUlkXG4gICAgICAgICkge1xuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMuZGV2aWNlSWQgPSBuZXdEZXZpY2VJZDtcbiAgICAgICAgfSBlbHNlIGlmICghdHJhY2tDb25zdHJhaW50cykge1xuICAgICAgICAgIHRyYWNrQ29uc3RyYWludHMgPSB7IGRldmljZUlkOiBuZXdEZXZpY2VJZCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJhY2sgPSBtZWRpYVRyYWNrVG9Mb2NhbFRyYWNrKG1lZGlhU3RyZWFtVHJhY2ssIHRyYWNrQ29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtID0gc3RyZWFtO1xuXG4gICAgICAgIGlmIChpc0F1ZGlvVHJhY2sodHJhY2spICYmIGF1ZGlvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgYXdhaXQgdHJhY2suc2V0UHJvY2Vzc29yKGF1ZGlvUHJvY2Vzc29yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spICYmIHZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgYXdhaXQgdHJhY2suc2V0UHJvY2Vzc29yKHZpZGVvUHJvY2Vzc29yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgIH0pLFxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIWF0dGVtcHRFeGFjdE1hdGNoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTG9jYWxUcmFja3MoXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGF1ZGlvOiByZXRyeUF1ZGlvT3B0aW9ucyxcbiAgICAgICAgdmlkZW86IHJldHJ5VmlkZW9PcHRpb25zLFxuICAgICAgfSxcbiAgICAgIGxvZ2dlck9wdGlvbnMsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBbW0xvY2FsVmlkZW9UcmFja11dIHdpdGggZ2V0VXNlck1lZGlhKClcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVMb2NhbFZpZGVvVHJhY2soXG4gIG9wdGlvbnM/OiBWaWRlb0NhcHR1cmVPcHRpb25zLFxuKTogUHJvbWlzZTxMb2NhbFZpZGVvVHJhY2s+IHtcbiAgY29uc3QgdHJhY2tzID0gYXdhaXQgY3JlYXRlTG9jYWxUcmFja3Moe1xuICAgIGF1ZGlvOiBmYWxzZSxcbiAgICB2aWRlbzogb3B0aW9ucyA/PyB0cnVlLFxuICB9KTtcbiAgcmV0dXJuIDxMb2NhbFZpZGVvVHJhY2s+dHJhY2tzWzBdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlTG9jYWxBdWRpb1RyYWNrKFxuICBvcHRpb25zPzogQXVkaW9DYXB0dXJlT3B0aW9ucyxcbik6IFByb21pc2U8TG9jYWxBdWRpb1RyYWNrPiB7XG4gIGNvbnN0IHRyYWNrcyA9IGF3YWl0IGNyZWF0ZUxvY2FsVHJhY2tzKHtcbiAgICBhdWRpbzogb3B0aW9ucyA/PyB0cnVlLFxuICAgIHZpZGVvOiBmYWxzZSxcbiAgfSk7XG4gIHJldHVybiA8TG9jYWxBdWRpb1RyYWNrPnRyYWNrc1swXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyhcbiAgb3B0aW9ucz86IFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4pOiBQcm9taXNlPEFycmF5PExvY2FsVHJhY2s+PiB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcbiAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICB9XG5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcignZ2V0RGlzcGxheU1lZGlhIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3Qgc3RyZWFtOiBNZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKTtcblxuICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ25vIHZpZGVvIHRyYWNrIGZvdW5kJyk7XG4gIH1cbiAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gIHNjcmVlblZpZGVvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZTtcbiAgY29uc3QgbG9jYWxUcmFja3M6IEFycmF5PExvY2FsVHJhY2s+ID0gW3NjcmVlblZpZGVvXTtcbiAgaWYgKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzY3JlZW5BdWRpbyA9IG5ldyBMb2NhbEF1ZGlvVHJhY2soc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICB9XG4gIHJldHVybiBsb2NhbFRyYWNrcztcbn1cbiIsImltcG9ydCB7XG4gIERhdGFQYWNrZXRfS2luZCxcbiAgUGFydGljaXBhbnRJbmZvLFxuICBQYXJ0aWNpcGFudEluZm9fS2luZCBhcyBQYXJ0aWNpcGFudEtpbmQsXG4gIFBhcnRpY2lwYW50UGVybWlzc2lvbixcbiAgQ29ubmVjdGlvblF1YWxpdHkgYXMgUHJvdG9RdWFsaXR5LFxuICB0eXBlIFNpcERUTUYsXG4gIFN1YnNjcmlwdGlvbkVycm9yLFxufSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IGxvZywgeyBMb2dnZXJOYW1lcywgdHlwZSBTdHJ1Y3R1cmVkTG9nZ2VyLCBnZXRMb2dnZXIgfSBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgUGFydGljaXBhbnRFdmVudCwgVHJhY2tFdmVudCB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBMb2NhbFRyYWNrUHVibGljYXRpb24gZnJvbSAnLi4vdHJhY2svTG9jYWxUcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4uL3RyYWNrL1JlbW90ZVRyYWNrJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4uL3RyYWNrL1RyYWNrJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4uL3RyYWNrL1RyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IHsgZGlmZkF0dHJpYnV0ZXMgfSBmcm9tICcuLi90cmFjay91dGlscyc7XG5pbXBvcnQgdHlwZSB7IENoYXRNZXNzYWdlLCBMb2dnZXJPcHRpb25zLCBUcmFuc2NyaXB0aW9uU2VnbWVudCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzQXVkaW9UcmFjayB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGVudW0gQ29ubmVjdGlvblF1YWxpdHkge1xuICBFeGNlbGxlbnQgPSAnZXhjZWxsZW50JyxcbiAgR29vZCA9ICdnb29kJyxcbiAgUG9vciA9ICdwb29yJyxcbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IGEgcGFydGljaXBhbnQgaGFzIHRlbXBvcmFyaWx5IChvciBwZXJtYW5lbnRseSkgbG9zdCBjb25uZWN0aW9uIHRvIExpdmVLaXQuXG4gICAqIEZvciBwZXJtYW5lbnQgZGlzY29ubmVjdGlvbiBhIGBQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIGFmdGVyIGEgdGltZW91dFxuICAgKi9cbiAgTG9zdCA9ICdsb3N0JyxcbiAgVW5rbm93biA9ICd1bmtub3duJyxcbn1cblxuZnVuY3Rpb24gcXVhbGl0eUZyb21Qcm90byhxOiBQcm90b1F1YWxpdHkpOiBDb25uZWN0aW9uUXVhbGl0eSB7XG4gIHN3aXRjaCAocSkge1xuICAgIGNhc2UgUHJvdG9RdWFsaXR5LkVYQ0VMTEVOVDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5FeGNlbGxlbnQ7XG4gICAgY2FzZSBQcm90b1F1YWxpdHkuR09PRDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Hb29kO1xuICAgIGNhc2UgUHJvdG9RdWFsaXR5LlBPT1I6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuUG9vcjtcbiAgICBjYXNlIFByb3RvUXVhbGl0eS5MT1NUOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5Lkxvc3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICB9XG59XG5cbmV4cG9ydCB7IFBhcnRpY2lwYW50S2luZCB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXJ0aWNpcGFudCBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRW1pdHRlcjxQYXJ0aWNpcGFudEV2ZW50Q2FsbGJhY2tzPikge1xuICBwcm90ZWN0ZWQgcGFydGljaXBhbnRJbmZvPzogUGFydGljaXBhbnRJbmZvO1xuXG4gIGF1ZGlvVHJhY2tQdWJsaWNhdGlvbnM6IE1hcDxzdHJpbmcsIFRyYWNrUHVibGljYXRpb24+O1xuXG4gIHZpZGVvVHJhY2tQdWJsaWNhdGlvbnM6IE1hcDxzdHJpbmcsIFRyYWNrUHVibGljYXRpb24+O1xuXG4gIC8qKiBtYXAgb2YgdHJhY2sgc2lkID0+IGFsbCBwdWJsaXNoZWQgdHJhY2tzICovXG4gIHRyYWNrUHVibGljYXRpb25zOiBNYXA8c3RyaW5nLCBUcmFja1B1YmxpY2F0aW9uPjtcblxuICAvKiogYXVkaW8gbGV2ZWwgYmV0d2VlbiAwLTEuMCwgMSBiZWluZyBsb3VkZXN0LCAwIGJlaW5nIHNvZnRlc3QgKi9cbiAgYXVkaW9MZXZlbDogbnVtYmVyID0gMDtcblxuICAvKiogaWYgcGFydGljaXBhbnQgaXMgY3VycmVudGx5IHNwZWFraW5nICovXG4gIGlzU3BlYWtpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogc2VydmVyIGFzc2lnbmVkIHVuaXF1ZSBpZCAqL1xuICBzaWQ6IHN0cmluZztcblxuICAvKiogY2xpZW50IGFzc2lnbmVkIGlkZW50aXR5LCBlbmNvZGVkIGluIEpXVCB0b2tlbiAqL1xuICBpZGVudGl0eTogc3RyaW5nO1xuXG4gIC8qKiBjbGllbnQgYXNzaWduZWQgZGlzcGxheSBuYW1lLCBlbmNvZGVkIGluIEpXVCB0b2tlbiAqL1xuICBuYW1lPzogc3RyaW5nO1xuXG4gIC8qKiBjbGllbnQgbWV0YWRhdGEsIG9wYXF1ZSB0byBsaXZla2l0ICovXG4gIG1ldGFkYXRhPzogc3RyaW5nO1xuXG4gIHByaXZhdGUgX2F0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgbGFzdFNwb2tlQXQ/OiBEYXRlIHwgdW5kZWZpbmVkO1xuXG4gIHBlcm1pc3Npb25zPzogUGFydGljaXBhbnRQZXJtaXNzaW9uO1xuXG4gIHByb3RlY3RlZCBfa2luZDogUGFydGljaXBhbnRLaW5kO1xuXG4gIHByaXZhdGUgX2Nvbm5lY3Rpb25RdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eSA9IENvbm5lY3Rpb25RdWFsaXR5LlVua25vd247XG5cbiAgcHJvdGVjdGVkIGF1ZGlvQ29udGV4dD86IEF1ZGlvQ29udGV4dDtcblxuICBwcm90ZWN0ZWQgbG9nOiBTdHJ1Y3R1cmVkTG9nZ2VyID0gbG9nO1xuXG4gIHByb3RlY3RlZCBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucztcblxuICBwcm90ZWN0ZWQgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMubG9nZ2VyT3B0aW9ucz8ubG9nZ2VyQ29udGV4dENiPy4oKSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLnNpemUgPiAwICYmXG4gICAgICBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmV2ZXJ5KCh0cikgPT4gdHIuaXNFbmNyeXB0ZWQpXG4gICAgKTtcbiAgfVxuXG4gIGdldCBpc0FnZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBlcm1pc3Npb25zPy5hZ2VudCB8fCB0aGlzLmtpbmQgPT09IFBhcnRpY2lwYW50S2luZC5BR0VOVDtcbiAgfVxuXG4gIGdldCBraW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9raW5kO1xuICB9XG5cbiAgLyoqIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMsIHNpbWlsYXIgdG8gbWV0YWRhdGEsIGJ1dCBhcyBhIGtleS92YWx1ZSBtYXAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKTogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4udGhpcy5fYXR0cmlidXRlcyB9KTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc2lkOiBzdHJpbmcsXG4gICAgaWRlbnRpdHk6IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIG1ldGFkYXRhPzogc3RyaW5nLFxuICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICAgIGtpbmQ6IFBhcnRpY2lwYW50S2luZCA9IFBhcnRpY2lwYW50S2luZC5TVEFOREFSRCxcbiAgKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnM/LmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuUGFydGljaXBhbnQpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XG5cbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMuc2lkID0gc2lkO1xuICAgIHRoaXMuaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fa2luZCA9IGtpbmQ7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgPz8ge307XG4gIH1cblxuICBnZXRUcmFja1B1YmxpY2F0aW9ucygpOiBUcmFja1B1YmxpY2F0aW9uW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCB0cmFjayB0aGF0IG1hdGNoZXMgdGhlIHNvdXJjZSBmaWx0ZXIsIGZvciBleGFtcGxlLCBnZXR0aW5nXG4gICAqIHRoZSB1c2VyJ3MgY2FtZXJhIHRyYWNrIHdpdGggZ2V0VHJhY2tCeVNvdXJjZShUcmFjay5Tb3VyY2UuQ2FtZXJhKS5cbiAgICovXG4gIGdldFRyYWNrUHVibGljYXRpb24oc291cmNlOiBUcmFjay5Tb3VyY2UpOiBUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja1B1YmxpY2F0aW9ucykge1xuICAgICAgaWYgKHB1Yi5zb3VyY2UgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHRoZSB0cmFjaydzIG5hbWUuXG4gICAqL1xuICBnZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWU6IHN0cmluZyk6IFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGZvciAoY29uc3QgWywgcHViXSBvZiB0aGlzLnRyYWNrUHVibGljYXRpb25zKSB7XG4gICAgICBpZiAocHViLnRyYWNrTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBjb25uZWN0aW9uUXVhbGl0eSgpOiBDb25uZWN0aW9uUXVhbGl0eSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25RdWFsaXR5O1xuICB9XG5cbiAgZ2V0IGlzQ2FtZXJhRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICByZXR1cm4gISh0cmFjaz8uaXNNdXRlZCA/PyB0cnVlKTtcbiAgfVxuXG4gIGdldCBpc01pY3JvcGhvbmVFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICByZXR1cm4gISh0cmFjaz8uaXNNdXRlZCA/PyB0cnVlKTtcbiAgfVxuXG4gIGdldCBpc1NjcmVlblNoYXJlRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpO1xuICAgIHJldHVybiAhIXRyYWNrO1xuICB9XG5cbiAgZ2V0IGlzTG9jYWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIHdoZW4gcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tICovXG4gIGdldCBqb2luZWRBdCgpOiBEYXRlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudEluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIucGFyc2VJbnQodGhpcy5wYXJ0aWNpcGFudEluZm8uam9pbmVkQXQudG9TdHJpbmcoKSkgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbzogUGFydGljaXBhbnRJbmZvKTogYm9vbGVhbiB7XG4gICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgdXBkYXRlIGNvdWxkIGJlIGFwcGxpZWQgb3V0IG9mIG9yZGVyIGR1ZSB0byBhd2FpdFxuICAgIC8vIGR1cmluZyByZWNvbm5lY3Qgc2VxdWVuY2VzLiB3aGVuIHRoYXQgaGFwcGVucywgaXQncyBwb3NzaWJsZSBmb3Igc2VydmVyXG4gICAgLy8gdG8gaGF2ZSBzZW50IG1vcmUgcmVjZW50IHZlcnNpb24gb2YgcGFydGljaXBhbnQgaW5mbyB3aGlsZSBKUyBpcyB3YWl0aW5nXG4gICAgLy8gdG8gcHJvY2VzcyB0aGUgZXhpc3RpbmcgcGF5bG9hZC5cbiAgICAvLyB3aGVuIHRoZSBwYXJ0aWNpcGFudCBzaWQgcmVtYWlucyB0aGUgc2FtZSwgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIGxhdGVyIHZlcnNpb25cbiAgICAvLyBvZiB0aGUgcGF5bG9hZCwgdGhleSBjYW4gYmUgc2FmZWx5IHNraXBwZWRcbiAgICBpZiAoXG4gICAgICB0aGlzLnBhcnRpY2lwYW50SW5mbyAmJlxuICAgICAgdGhpcy5wYXJ0aWNpcGFudEluZm8uc2lkID09PSBpbmZvLnNpZCAmJlxuICAgICAgdGhpcy5wYXJ0aWNpcGFudEluZm8udmVyc2lvbiA+IGluZm8udmVyc2lvblxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlkZW50aXR5ID0gaW5mby5pZGVudGl0eTtcbiAgICB0aGlzLnNpZCA9IGluZm8uc2lkO1xuICAgIHRoaXMuX3NldE5hbWUoaW5mby5uYW1lKTtcbiAgICB0aGlzLl9zZXRNZXRhZGF0YShpbmZvLm1ldGFkYXRhKTtcbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVzKGluZm8uYXR0cmlidXRlcyk7XG4gICAgaWYgKGluZm8ucGVybWlzc2lvbikge1xuICAgICAgdGhpcy5zZXRQZXJtaXNzaW9ucyhpbmZvLnBlcm1pc3Npb24pO1xuICAgIH1cbiAgICAvLyBzZXQgdGhpcyBsYXN0IHNvIHNldE1ldGFkYXRhIGNhbiBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMucGFydGljaXBhbnRJbmZvID0gaW5mbztcbiAgICB0aGlzLmxvZy50cmFjZSgndXBkYXRlIHBhcnRpY2lwYW50IGluZm8nLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgaW5mbyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIG1ldGFkYXRhIGZyb20gc2VydmVyXG4gICAqKi9cbiAgcHJpdmF0ZSBfc2V0TWV0YWRhdGEobWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm1ldGFkYXRhICE9PSBtZDtcbiAgICBjb25zdCBwcmV2TWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZDtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgcHJldk1ldGFkYXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zZXROYW1lKG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLm5hbWUgIT09IG5hbWU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBtZXRhZGF0YSBmcm9tIHNlcnZlclxuICAgKiovXG4gIHByaXZhdGUgX3NldEF0dHJpYnV0ZXMoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGNvbnN0IGRpZmYgPSBkaWZmQXR0cmlidXRlcyh0aGlzLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBkaWZmKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zOiBQYXJ0aWNpcGFudFBlcm1pc3Npb24pOiBib29sZWFuIHtcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbnMgPSB0aGlzLnBlcm1pc3Npb25zO1xuICAgIGNvbnN0IGNoYW5nZWQgPVxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaCAhPT0gdGhpcy5wZXJtaXNzaW9ucz8uY2FuUHVibGlzaCB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlICE9PSB0aGlzLnBlcm1pc3Npb25zPy5jYW5TdWJzY3JpYmUgfHxcbiAgICAgIHBlcm1pc3Npb25zLmNhblB1Ymxpc2hEYXRhICE9PSB0aGlzLnBlcm1pc3Npb25zPy5jYW5QdWJsaXNoRGF0YSB8fFxuICAgICAgcGVybWlzc2lvbnMuaGlkZGVuICE9PSB0aGlzLnBlcm1pc3Npb25zPy5oaWRkZW4gfHxcbiAgICAgIHBlcm1pc3Npb25zLnJlY29yZGVyICE9PSB0aGlzLnBlcm1pc3Npb25zPy5yZWNvcmRlciB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoICE9PSB0aGlzLnBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLmxlbmd0aCB8fFxuICAgICAgcGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMuc29tZShcbiAgICAgICAgKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgIT09IHRoaXMucGVybWlzc2lvbnM/LmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSxcbiAgICAgICkgfHxcbiAgICAgIHBlcm1pc3Npb25zLmNhblN1YnNjcmliZU1ldHJpY3MgIT09IHRoaXMucGVybWlzc2lvbnM/LmNhblN1YnNjcmliZU1ldHJpY3M7XG4gICAgdGhpcy5wZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0SXNTcGVha2luZyhzcGVha2luZzogYm9vbGVhbikge1xuICAgIGlmIChzcGVha2luZyA9PT0gdGhpcy5pc1NwZWFraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNTcGVha2luZyA9IHNwZWFraW5nO1xuICAgIGlmIChzcGVha2luZykge1xuICAgICAgdGhpcy5sYXN0U3Bva2VBdCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LklzU3BlYWtpbmdDaGFuZ2VkLCBzcGVha2luZyk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldENvbm5lY3Rpb25RdWFsaXR5KHE6IFByb3RvUXVhbGl0eSkge1xuICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBxdWFsaXR5RnJvbVByb3RvKHEpO1xuICAgIGlmIChwcmV2UXVhbGl0eSAhPT0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldEF1ZGlvQ29udGV4dChjdHg6IEF1ZGlvQ29udGV4dCB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gY3R4O1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKFxuICAgICAgKHRyYWNrKSA9PiBpc0F1ZGlvVHJhY2sodHJhY2sudHJhY2spICYmIHRyYWNrLnRyYWNrLnNldEF1ZGlvQ29udGV4dChjdHgpLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbjogVHJhY2tQdWJsaWNhdGlvbikge1xuICAgIC8vIGZvcndhcmQgcHVibGljYXRpb24gZHJpdmVuIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuTXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcblxuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG5cbiAgICBjb25zdCBwdWIgPSBwdWJsaWNhdGlvbjtcbiAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICBwdWIudHJhY2suc2lkID0gcHVibGljYXRpb24udHJhY2tTaWQ7XG4gICAgfVxuXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQYXJ0aWNpcGFudEV2ZW50Q2FsbGJhY2tzID0ge1xuICB0cmFja1B1Ymxpc2hlZDogKHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmliZWQ6ICh0cmFjazogUmVtb3RlVHJhY2ssIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvbkZhaWxlZDogKHRyYWNrU2lkOiBzdHJpbmcsIHJlYXNvbj86IFN1YnNjcmlwdGlvbkVycm9yKSA9PiB2b2lkO1xuICB0cmFja1VucHVibGlzaGVkOiAocHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHRyYWNrVW5zdWJzY3JpYmVkOiAodHJhY2s6IFJlbW90ZVRyYWNrLCBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgdHJhY2tNdXRlZDogKHB1YmxpY2F0aW9uOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICB0cmFja1VubXV0ZWQ6IChwdWJsaWNhdGlvbjogVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgbG9jYWxUcmFja1B1Ymxpc2hlZDogKHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIGxvY2FsVHJhY2tVbnB1Ymxpc2hlZDogKHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24pID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkOiAocHJldk1ldGFkYXRhOiBzdHJpbmcgfCB1bmRlZmluZWQsIHBhcnRpY2lwYW50PzogYW55KSA9PiB2b2lkO1xuICBwYXJ0aWNpcGFudE5hbWVDaGFuZ2VkOiAobmFtZTogc3RyaW5nKSA9PiB2b2lkO1xuICBkYXRhUmVjZWl2ZWQ6IChwYXlsb2FkOiBVaW50OEFycmF5LCBraW5kOiBEYXRhUGFja2V0X0tpbmQpID0+IHZvaWQ7XG4gIHNpcERUTUZSZWNlaXZlZDogKGR0bWY6IFNpcERUTUYpID0+IHZvaWQ7XG4gIHRyYW5zY3JpcHRpb25SZWNlaXZlZDogKFxuICAgIHRyYW5zY3JpcHRpb246IFRyYW5zY3JpcHRpb25TZWdtZW50W10sXG4gICAgcHVibGljYXRpb24/OiBUcmFja1B1YmxpY2F0aW9uLFxuICApID0+IHZvaWQ7XG4gIGlzU3BlYWtpbmdDaGFuZ2VkOiAoc3BlYWtpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIGNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZDogKGNvbm5lY3Rpb25RdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eSkgPT4gdm9pZDtcbiAgdHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQ6IChcbiAgICBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbixcbiAgICBzdHJlYW1TdGF0ZTogVHJhY2suU3RyZWFtU3RhdGUsXG4gICkgPT4gdm9pZDtcbiAgdHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLFxuICAgIHN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLFxuICApID0+IHZvaWQ7XG4gIG1lZGlhRGV2aWNlc0Vycm9yOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xuICBhdWRpb1N0cmVhbUFjcXVpcmVkOiAoKSA9PiB2b2lkO1xuICBwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZDogKHByZXZQZXJtaXNzaW9ucz86IFBhcnRpY2lwYW50UGVybWlzc2lvbikgPT4gdm9pZDtcbiAgdHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyxcbiAgKSA9PiB2b2lkO1xuICBhdHRyaWJ1dGVzQ2hhbmdlZDogKGNoYW5nZWRBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSA9PiB2b2lkO1xuICBsb2NhbFRyYWNrU3Vic2NyaWJlZDogKHRyYWNrUHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbikgPT4gdm9pZDtcbiAgY2hhdE1lc3NhZ2U6IChtc2c6IENoYXRNZXNzYWdlKSA9PiB2b2lkO1xufTtcbiIsImltcG9ydCB7IFRyYWNrUGVybWlzc2lvbiB9IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbiB7XG4gIC8qKlxuICAgKiBUaGUgcGFydGljaXBhbnQgaWRlbnRpdHkgdGhpcyBwZXJtaXNzaW9uIGFwcGxpZXMgdG8uXG4gICAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgdGhpcyBvciBgcGFydGljaXBhbnRTaWRgXG4gICAqL1xuICBwYXJ0aWNpcGFudElkZW50aXR5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcGFydGljaXBhbnQgc2VydmVyIGlkIHRoaXMgcGVybWlzc2lvbiBhcHBsaWVzIHRvLlxuICAgKiBZb3UgY2FuIGVpdGhlciBwcm92aWRlIHRoaXMgb3IgYHBhcnRpY2lwYW50SWRlbnRpdHlgXG4gICAqL1xuICBwYXJ0aWNpcGFudFNpZD86IHN0cmluZztcblxuICAvKipcbiAgICogR3JhbnQgcGVybWlzc2lvbiB0byBhbGwgYWxsIHRyYWNrcy4gVGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFsbG93ZWRUcmFja1NpZHMuXG4gICAqIGZhbHNlIGlmIHVuc2V0LlxuICAgKi9cbiAgYWxsb3dBbGw/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiB0cmFjayBpZHMgdGhhdCB0aGUgdGFyZ2V0IHBhcnRpY2lwYW50IGNhbiBzdWJzY3JpYmUgdG8uXG4gICAqIFdoZW4gdW5zZXQsIGl0J2xsIGFsbG93IGFsbCB0cmFja3MgdG8gYmUgc3Vic2NyaWJlZCBieSB0aGUgcGFydGljaXBhbnQuXG4gICAqIFdoZW4gZW1wdHksIHRoaXMgcGFydGljaXBhbnQgaXMgZGlzYWxsb3dlZCBmcm9tIHN1YnNjcmliaW5nIHRvIGFueSB0cmFja3MuXG4gICAqL1xuICBhbGxvd2VkVHJhY2tTaWRzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFja1Blcm1pc3Npb25Ub1Byb3RvKHBlcm1zOiBQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbik6IFRyYWNrUGVybWlzc2lvbiB7XG4gIGlmICghcGVybXMucGFydGljaXBhbnRTaWQgJiYgIXBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB0cmFjayBwZXJtaXNzaW9uLCBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIG9mIHBhcnRpY2lwYW50SWRlbnRpdHkgYW5kIHBhcnRpY2lwYW50U2lkJyxcbiAgICApO1xuICB9XG4gIHJldHVybiBuZXcgVHJhY2tQZXJtaXNzaW9uKHtcbiAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwZXJtcy5wYXJ0aWNpcGFudElkZW50aXR5ID8/ICcnLFxuICAgIHBhcnRpY2lwYW50U2lkOiBwZXJtcy5wYXJ0aWNpcGFudFNpZCA/PyAnJyxcbiAgICBhbGxUcmFja3M6IHBlcm1zLmFsbG93QWxsID8/IGZhbHNlLFxuICAgIHRyYWNrU2lkczogcGVybXMuYWxsb3dlZFRyYWNrU2lkcyB8fCBbXSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBNdXRleCB9IGZyb20gJ0BsaXZla2l0L211dGV4JztcbmltcG9ydCB7XG4gIEFkZFRyYWNrUmVxdWVzdCxcbiAgQmFja3VwQ29kZWNQb2xpY3ksXG4gIENoYXRNZXNzYWdlIGFzIENoYXRNZXNzYWdlTW9kZWwsXG4gIENvZGVjLFxuICBEYXRhUGFja2V0LFxuICBEYXRhUGFja2V0X0tpbmQsXG4gIERhdGFTdHJlYW1fQnl0ZUhlYWRlcixcbiAgRGF0YVN0cmVhbV9DaHVuayxcbiAgRGF0YVN0cmVhbV9IZWFkZXIsXG4gIERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSxcbiAgRGF0YVN0cmVhbV9UZXh0SGVhZGVyLFxuICBEYXRhU3RyZWFtX1RyYWlsZXIsXG4gIEVuY3J5cHRpb25fVHlwZSxcbiAgUGFydGljaXBhbnRJbmZvLFxuICBQYXJ0aWNpcGFudFBlcm1pc3Npb24sXG4gIFJlcXVlc3RSZXNwb25zZSxcbiAgUmVxdWVzdFJlc3BvbnNlX1JlYXNvbixcbiAgUnBjQWNrLFxuICBScGNSZXF1ZXN0LFxuICBScGNSZXNwb25zZSxcbiAgU2ltdWxjYXN0Q29kZWMsXG4gIFNpcERUTUYsXG4gIFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICBUcmFja0luZm8sXG4gIFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSxcbiAgVXNlclBhY2tldCxcbiAgcHJvdG9JbnQ2NCxcbn0gZnJvbSAnQGxpdmVraXQvcHJvdG9jb2wnO1xuaW1wb3J0IHsgU2lnbmFsQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgdHlwZSB7IEludGVybmFsUm9vbU9wdGlvbnMgfSBmcm9tICcuLi8uLi9vcHRpb25zJztcbmltcG9ydCB7IFBDVHJhbnNwb3J0U3RhdGUgfSBmcm9tICcuLi9QQ1RyYW5zcG9ydE1hbmFnZXInO1xuaW1wb3J0IHR5cGUgUlRDRW5naW5lIGZyb20gJy4uL1JUQ0VuZ2luZSc7XG5pbXBvcnQgeyBCeXRlU3RyZWFtV3JpdGVyLCBUZXh0U3RyZWFtV3JpdGVyIH0gZnJvbSAnLi4vU3RyZWFtV3JpdGVyJztcbmltcG9ydCB7IGRlZmF1bHRWaWRlb0NvZGVjIH0gZnJvbSAnLi4vZGVmYXVsdHMnO1xuaW1wb3J0IHtcbiAgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcixcbiAgTGl2ZWtpdEVycm9yLFxuICBQdWJsaXNoVHJhY2tFcnJvcixcbiAgU2lnbmFsUmVxdWVzdEVycm9yLFxuICBUcmFja0ludmFsaWRFcnJvcixcbiAgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSxcbn0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IEVuZ2luZUV2ZW50LCBQYXJ0aWNpcGFudEV2ZW50LCBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB7XG4gIE1BWF9QQVlMT0FEX0JZVEVTLFxuICB0eXBlIFBlcmZvcm1ScGNQYXJhbXMsXG4gIFJwY0Vycm9yLFxuICB0eXBlIFJwY0ludm9jYXRpb25EYXRhLFxuICBieXRlTGVuZ3RoLFxufSBmcm9tICcuLi9ycGMnO1xuaW1wb3J0IExvY2FsQXVkaW9UcmFjayBmcm9tICcuLi90cmFjay9Mb2NhbEF1ZGlvVHJhY2snO1xuaW1wb3J0IExvY2FsVHJhY2sgZnJvbSAnLi4vdHJhY2svTG9jYWxUcmFjayc7XG5pbXBvcnQgTG9jYWxUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4uL3RyYWNrL0xvY2FsVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgTG9jYWxWaWRlb1RyYWNrLCB7IHZpZGVvTGF5ZXJzRnJvbUVuY29kaW5ncyB9IGZyb20gJy4uL3RyYWNrL0xvY2FsVmlkZW9UcmFjayc7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4uL3RyYWNrL1RyYWNrJztcbmltcG9ydCB7IGNyZWF0ZUxvY2FsVHJhY2tzIH0gZnJvbSAnLi4vdHJhY2svY3JlYXRlJztcbmltcG9ydCB0eXBlIHtcbiAgQXVkaW9DYXB0dXJlT3B0aW9ucyxcbiAgQmFja3VwVmlkZW9Db2RlYyxcbiAgQ3JlYXRlTG9jYWxUcmFja3NPcHRpb25zLFxuICBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zLFxuICBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICBWaWRlb0NhcHR1cmVPcHRpb25zLFxufSBmcm9tICcuLi90cmFjay9vcHRpb25zJztcbmltcG9ydCB7IFNjcmVlblNoYXJlUHJlc2V0cywgVmlkZW9QcmVzZXRzLCBpc0JhY2t1cENvZGVjIH0gZnJvbSAnLi4vdHJhY2svb3B0aW9ucyc7XG5pbXBvcnQge1xuICBnZXRMb2dDb250ZXh0RnJvbVRyYWNrLFxuICBnZXRUcmFja1NvdXJjZUZyb21Qcm90byxcbiAgbWVyZ2VEZWZhdWx0T3B0aW9ucyxcbiAgbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcsXG4gIHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMsXG59IGZyb20gJy4uL3RyYWNrL3V0aWxzJztcbmltcG9ydCB7XG4gIHR5cGUgQnl0ZVN0cmVhbUluZm8sXG4gIHR5cGUgQ2hhdE1lc3NhZ2UsXG4gIHR5cGUgRGF0YVB1Ymxpc2hPcHRpb25zLFxuICB0eXBlIFNlbmRUZXh0T3B0aW9ucyxcbiAgdHlwZSBTdHJlYW1UZXh0T3B0aW9ucyxcbiAgdHlwZSBUZXh0U3RyZWFtSW5mbyxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgRnV0dXJlLFxuICBjb21wYXJlVmVyc2lvbnMsXG4gIGlzQXVkaW9UcmFjayxcbiAgaXNFMkVFU2ltdWxjYXN0U3VwcG9ydGVkLFxuICBpc0ZpcmVGb3gsXG4gIGlzTG9jYWxBdWRpb1RyYWNrLFxuICBpc0xvY2FsVHJhY2ssXG4gIGlzTG9jYWxWaWRlb1RyYWNrLFxuICBpc1NWQ0NvZGVjLFxuICBpc1NhZmFyaTE3LFxuICBpc1ZpZGVvVHJhY2ssXG4gIGlzV2ViLFxuICBudW1iZXJUb0JpZ0ludCxcbiAgc2xlZXAsXG4gIHNwbGl0VXRmOCxcbiAgc3VwcG9ydHNBVjEsXG4gIHN1cHBvcnRzVlA5LFxufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgUGFydGljaXBhbnQgZnJvbSAnLi9QYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSB7IFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uIH0gZnJvbSAnLi9QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbic7XG5pbXBvcnQgeyB0cmFja1Blcm1pc3Npb25Ub1Byb3RvIH0gZnJvbSAnLi9QYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbic7XG5pbXBvcnQge1xuICBjb21wdXRlVHJhY2tCYWNrdXBFbmNvZGluZ3MsXG4gIGNvbXB1dGVWaWRlb0VuY29kaW5ncyxcbiAgZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSxcbn0gZnJvbSAnLi9wdWJsaXNoVXRpbHMnO1xuXG5jb25zdCBTVFJFQU1fQ0hVTktfU0laRSA9IDE1XzAwMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgYXVkaW9UcmFja1B1YmxpY2F0aW9uczogTWFwPHN0cmluZywgTG9jYWxUcmFja1B1YmxpY2F0aW9uPjtcblxuICB2aWRlb1RyYWNrUHVibGljYXRpb25zOiBNYXA8c3RyaW5nLCBMb2NhbFRyYWNrUHVibGljYXRpb24+O1xuXG4gIC8qKiBtYXAgb2YgdHJhY2sgc2lkID0+IGFsbCBwdWJsaXNoZWQgdHJhY2tzICovXG4gIHRyYWNrUHVibGljYXRpb25zOiBNYXA8c3RyaW5nLCBMb2NhbFRyYWNrUHVibGljYXRpb24+O1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZW5naW5lOiBSVENFbmdpbmU7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhY3RpdmVEZXZpY2VNYXA6IE1hcDxNZWRpYURldmljZUtpbmQsIHN0cmluZz47XG5cbiAgcHJpdmF0ZSBwZW5kaW5nUHVibGlzaGluZyA9IG5ldyBTZXQ8VHJhY2suU291cmNlPigpO1xuXG4gIHByaXZhdGUgcGVuZGluZ1B1Ymxpc2hQcm9taXNlcyA9IG5ldyBNYXA8TG9jYWxUcmFjaywgUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24+PigpO1xuXG4gIHByaXZhdGUgcmVwdWJsaXNoUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGNhbWVyYUVycm9yOiBFcnJvciB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIG1pY3JvcGhvbmVFcnJvcjogRXJyb3IgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM6IEFycmF5PFBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uPiA9IFtdO1xuXG4gIHByaXZhdGUgYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlOiBib29sZWFuID0gdHJ1ZTtcblxuICAvLyBrZWVwIGEgcG9pbnRlciB0byByb29tIG9wdGlvbnNcbiAgcHJpdmF0ZSByb29tT3B0aW9uczogSW50ZXJuYWxSb29tT3B0aW9ucztcblxuICBwcml2YXRlIGVuY3J5cHRpb25UeXBlOiBFbmNyeXB0aW9uX1R5cGUgPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcblxuICBwcml2YXRlIHJlY29ubmVjdEZ1dHVyZT86IEZ1dHVyZTx2b2lkPjtcblxuICBwcml2YXRlIHJwY0hhbmRsZXJzOiBNYXA8c3RyaW5nLCAoZGF0YTogUnBjSW52b2NhdGlvbkRhdGEpID0+IFByb21pc2U8c3RyaW5nPj47XG5cbiAgcHJpdmF0ZSBwZW5kaW5nU2lnbmFsUmVxdWVzdHM6IE1hcDxcbiAgICBudW1iZXIsXG4gICAge1xuICAgICAgcmVzb2x2ZTogKGFyZzogYW55KSA9PiB2b2lkO1xuICAgICAgcmVqZWN0OiAocmVhc29uOiBMaXZla2l0RXJyb3IpID0+IHZvaWQ7XG4gICAgICB2YWx1ZXM6IFBhcnRpYWw8UmVjb3JkPGtleW9mIExvY2FsUGFydGljaXBhbnQsIGFueT4+O1xuICAgIH1cbiAgPjtcblxuICBwcml2YXRlIGVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3M6IENvZGVjW10gPSBbXTtcblxuICBwcml2YXRlIHBlbmRpbmdBY2tzID0gbmV3IE1hcDxzdHJpbmcsIHsgcmVzb2x2ZTogKCkgPT4gdm9pZDsgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nIH0+KCk7XG5cbiAgcHJpdmF0ZSBwZW5kaW5nUmVzcG9uc2VzID0gbmV3IE1hcDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgcmVzb2x2ZTogKHBheWxvYWQ6IHN0cmluZyB8IG51bGwsIGVycm9yOiBScGNFcnJvciB8IG51bGwpID0+IHZvaWQ7XG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmc7XG4gICAgfVxuICA+KCk7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBzaWQ6IHN0cmluZyxcbiAgICBpZGVudGl0eTogc3RyaW5nLFxuICAgIGVuZ2luZTogUlRDRW5naW5lLFxuICAgIG9wdGlvbnM6IEludGVybmFsUm9vbU9wdGlvbnMsXG4gICAgcm9vbVJwY0hhbmRsZXJzOiBNYXA8c3RyaW5nLCAoZGF0YTogUnBjSW52b2NhdGlvbkRhdGEpID0+IFByb21pc2U8c3RyaW5nPj4sXG4gICkge1xuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5lbmdpbmUubG9nQ29udGV4dCxcbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgdGhpcy5yb29tT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zZXR1cEVuZ2luZShlbmdpbmUpO1xuICAgIHRoaXMuYWN0aXZlRGV2aWNlTWFwID0gbmV3IE1hcChbXG4gICAgICBbJ2F1ZGlvaW5wdXQnLCAnZGVmYXVsdCddLFxuICAgICAgWyd2aWRlb2lucHV0JywgJ2RlZmF1bHQnXSxcbiAgICAgIFsnYXVkaW9vdXRwdXQnLCAnZGVmYXVsdCddLFxuICAgIF0pO1xuICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucnBjSGFuZGxlcnMgPSByb29tUnBjSGFuZGxlcnM7XG4gIH1cblxuICBnZXQgbGFzdENhbWVyYUVycm9yKCk6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFFcnJvcjtcbiAgfVxuXG4gIGdldCBsYXN0TWljcm9waG9uZUVycm9yKCk6IEVycm9yIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5taWNyb3Bob25lRXJyb3I7XG4gIH1cblxuICBnZXQgaXNFMkVFRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cblxuICBnZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZTogVHJhY2suU291cmNlKTogTG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjayBhcyBMb2NhbFRyYWNrUHVibGljYXRpb247XG4gICAgfVxuICB9XG5cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lOiBzdHJpbmcpOiBMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjayBhcyBMb2NhbFRyYWNrUHVibGljYXRpb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0dXBFbmdpbmUoZW5naW5lOiBSVENFbmdpbmUpIHtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCAodHJhY2tTaWQ6IHN0cmluZywgbXV0ZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViIHx8ICFwdWIudHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgIHB1Yi5tdXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWIudW5tdXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmVuZ2luZVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LkNvbm5lY3RlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIHRoaXMuaGFuZGxlUmVjb25uZWN0ZWQpXG4gICAgICAub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdW1lZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZylcbiAgICAgIC5vbihFbmdpbmVFdmVudC5SZXN1bWluZywgdGhpcy5oYW5kbGVSZWNvbm5lY3RpbmcpXG4gICAgICAub24oRW5naW5lRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLmhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIHRoaXMuaGFuZGxlRGlzY29ubmVjdGVkKVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlcXVlc3RSZXNwb25zZSwgdGhpcy5oYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UpXG4gICAgICAub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlPHZvaWQ+KCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlUmVjb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnJlc29sdmU/LigpO1xuICAgIHRoaXMucmVjb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucygpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUucHJvbWlzZS5jYXRjaCgoZSkgPT4gdGhpcy5sb2cud2FybihlLm1lc3NhZ2UsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmU/LnJlamVjdD8uKCdHb3QgZGlzY29ubmVjdGVkIGR1cmluZyByZWNvbm5lY3Rpb24gYXR0ZW1wdCcpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU2lnbmFsUmVxdWVzdFJlc3BvbnNlID0gKHJlc3BvbnNlOiBSZXF1ZXN0UmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCB7IHJlcXVlc3RJZCwgcmVhc29uLCBtZXNzYWdlIH0gPSByZXNwb25zZTtcbiAgICBjb25zdCB0YXJnZXRSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgaWYgKHRhcmdldFJlcXVlc3QpIHtcbiAgICAgIGlmIChyZWFzb24gIT09IFJlcXVlc3RSZXNwb25zZV9SZWFzb24uT0spIHtcbiAgICAgICAgdGFyZ2V0UmVxdWVzdC5yZWplY3QobmV3IFNpZ25hbFJlcXVlc3RFcnJvcihtZXNzYWdlLCByZWFzb24pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZURhdGFQYWNrZXQgPSAocGFja2V0OiBEYXRhUGFja2V0KSA9PiB7XG4gICAgc3dpdGNoIChwYWNrZXQudmFsdWUuY2FzZSkge1xuICAgICAgY2FzZSAncnBjUmVzcG9uc2UnOlxuICAgICAgICBsZXQgcnBjUmVzcG9uc2UgPSBwYWNrZXQudmFsdWUudmFsdWUgYXMgUnBjUmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXlsb2FkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yOiBScGNFcnJvciB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChycGNSZXNwb25zZS52YWx1ZS5jYXNlID09PSAncGF5bG9hZCcpIHtcbiAgICAgICAgICBwYXlsb2FkID0gcnBjUmVzcG9uc2UudmFsdWUudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAocnBjUmVzcG9uc2UudmFsdWUuY2FzZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGVycm9yID0gUnBjRXJyb3IuZnJvbVByb3RvKHJwY1Jlc3BvbnNlLnZhbHVlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjUmVzcG9uc2UocnBjUmVzcG9uc2UucmVxdWVzdElkLCBwYXlsb2FkLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncnBjQWNrJzpcbiAgICAgICAgbGV0IHJwY0FjayA9IHBhY2tldC52YWx1ZS52YWx1ZSBhcyBScGNBY2s7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdScGNBY2socnBjQWNrLnJlcXVlc3RJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhbmQgdXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIHNldE1ldGFkYXRhKG1ldGFkYXRhOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnJlcXVlc3RNZXRhZGF0YVVwZGF0ZSh7IG1ldGFkYXRhIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW5kIHVwZGF0ZXMgdGhlIG5hbWUgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIGFzeW5jIHNldE5hbWUobmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoeyBuYW1lIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBvciB1cGRhdGUgcGFydGljaXBhbnQgYXR0cmlidXRlcy4gSXQgd2lsbCBtYWtlIHVwZGF0ZXMgb25seSB0byBrZXlzIHRoYXRcbiAgICogYXJlIHByZXNlbnQgaW4gYGF0dHJpYnV0ZXNgLCBhbmQgd2lsbCBub3Qgb3ZlcnJpZGUgb3RoZXJzLlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogQHBhcmFtIGF0dHJpYnV0ZXMgYXR0cmlidXRlcyB0byB1cGRhdGVcbiAgICovXG4gIGFzeW5jIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGF3YWl0IHRoaXMucmVxdWVzdE1ldGFkYXRhVXBkYXRlKHsgYXR0cmlidXRlcyB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdE1ldGFkYXRhVXBkYXRlKHtcbiAgICBtZXRhZGF0YSxcbiAgICBuYW1lLFxuICAgIGF0dHJpYnV0ZXMsXG4gIH06IHtcbiAgICBtZXRhZGF0YT86IHN0cmluZztcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBpc1JlamVjdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlTG9jYWxNZXRhZGF0YShcbiAgICAgICAgICBtZXRhZGF0YSA/PyB0aGlzLm1ldGFkYXRhID8/ICcnLFxuICAgICAgICAgIG5hbWUgPz8gdGhpcy5uYW1lID8/ICcnLFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5zZXQocmVxdWVzdElkLCB7XG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3Q6IChlcnJvcjogTGl2ZWtpdEVycm9yKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgaXNSZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2YWx1ZXM6IHsgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSA8IDVfMDAwICYmICFpc1JlamVjdGVkKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKCFuYW1lIHx8IHRoaXMubmFtZSA9PT0gbmFtZSkgJiZcbiAgICAgICAgICAgICghbWV0YWRhdGEgfHwgdGhpcy5tZXRhZGF0YSA9PT0gbWV0YWRhdGEpICYmXG4gICAgICAgICAgICAoIWF0dHJpYnV0ZXMgfHxcbiAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZXZlcnkoXG4gICAgICAgICAgICAgICAgKFtrZXksIHZhbHVlXSkgPT5cbiAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1trZXldID09PSB2YWx1ZSB8fCAodmFsdWUgPT09ICcnICYmICF0aGlzLmF0dHJpYnV0ZXNba2V5XSksXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTaWduYWxSZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgc2xlZXAoNTApO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBuZXcgU2lnbmFsUmVxdWVzdEVycm9yKCdSZXF1ZXN0IHRvIHVwZGF0ZSBsb2NhbCBtZXRhZGF0YSB0aW1lZCBvdXQnLCAnVGltZW91dEVycm9yJyksXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGEgcGFydGljaXBhbnQncyBjYW1lcmEgdHJhY2suXG4gICAqXG4gICAqIElmIGEgdHJhY2sgaGFzIGFscmVhZHkgcHVibGlzaGVkLCBpdCdsbCBtdXRlIG9yIHVubXV0ZSB0aGUgdHJhY2suXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcbiAgICovXG4gIHNldENhbWVyYUVuYWJsZWQoXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogVmlkZW9DYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5DYW1lcmEsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhIHBhcnRpY2lwYW50J3MgbWljcm9waG9uZSB0cmFjay5cbiAgICpcbiAgICogSWYgYSB0cmFjayBoYXMgYWxyZWFkeSBwdWJsaXNoZWQsIGl0J2xsIG11dGUgb3IgdW5tdXRlIHRoZSB0cmFjay5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0TWljcm9waG9uZUVuYWJsZWQoXG4gICAgZW5hYmxlZDogYm9vbGVhbixcbiAgICBvcHRpb25zPzogQXVkaW9DYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICk6IFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgb3Igc3RvcCBzaGFyaW5nIGEgcGFydGljaXBhbnQncyBzY3JlZW5cbiAgICogUmVzb2x2ZXMgd2l0aCBhIGBMb2NhbFRyYWNrUHVibGljYXRpb25gIGluc3RhbmNlIGlmIHN1Y2Nlc3NmdWwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZVxuICAgKi9cbiAgc2V0U2NyZWVuU2hhcmVFbmFibGVkKFxuICAgIGVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgb3B0aW9ucz86IFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4gICAgcHVibGlzaE9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICApOiBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnM6IFBhcnRpY2lwYW50UGVybWlzc2lvbik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHN1cGVyLnNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKTtcbiAgICBpZiAoY2hhbmdlZCAmJiBwcmV2UGVybWlzc2lvbnMpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBlbmFibGVkID8gRW5jcnlwdGlvbl9UeXBlLkdDTSA6IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgIGF3YWl0IHRoaXMucmVwdWJsaXNoQWxsVHJhY2tzKHVuZGVmaW5lZCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIHB1Ymxpc2hpbmcgZm9yIGEgdHJhY2sgYnkgc291cmNlLiBUaGlzIHNlcnZlcyBhcyBhIHNpbXBsZVxuICAgKiB3YXkgdG8gbWFuYWdlIHRoZSBjb21tb24gdHJhY2tzIChjYW1lcmEsIG1pYywgb3Igc2NyZWVuIHNoYXJlKS5cbiAgICogUmVzb2x2ZXMgd2l0aCBMb2NhbFRyYWNrUHVibGljYXRpb24gaWYgc3VjY2Vzc2Z1bCBhbmQgdm9pZCBvdGhlcndpc2VcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgc2V0VHJhY2tFbmFibGVkKFxuICAgIHNvdXJjZTogRXh0cmFjdDxUcmFjay5Tb3VyY2UsIFRyYWNrLlNvdXJjZS5DYW1lcmE+LFxuICAgIGVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgb3B0aW9ucz86IFZpZGVvQ2FwdHVyZU9wdGlvbnMsXG4gICAgcHVibGlzaE9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICApOiBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZD47XG4gIHByaXZhdGUgYXN5bmMgc2V0VHJhY2tFbmFibGVkKFxuICAgIHNvdXJjZTogRXh0cmFjdDxUcmFjay5Tb3VyY2UsIFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lPixcbiAgICBlbmFibGVkOiBib29sZWFuLFxuICAgIG9wdGlvbnM/OiBBdWRpb0NhcHR1cmVPcHRpb25zLFxuICAgIHB1Ymxpc2hPcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ+O1xuICBwcml2YXRlIGFzeW5jIHNldFRyYWNrRW5hYmxlZChcbiAgICBzb3VyY2U6IEV4dHJhY3Q8VHJhY2suU291cmNlLCBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU+LFxuICAgIGVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgb3B0aW9ucz86IFNjcmVlblNoYXJlQ2FwdHVyZU9wdGlvbnMsXG4gICAgcHVibGlzaE9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zLFxuICApOiBQcm9taXNlPExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZD47XG4gIHByaXZhdGUgYXN5bmMgc2V0VHJhY2tFbmFibGVkKFxuICAgIHNvdXJjZTogVHJhY2suU291cmNlLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgb3B0aW9ucz86IFZpZGVvQ2FwdHVyZU9wdGlvbnMgfCBBdWRpb0NhcHR1cmVPcHRpb25zIHwgU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyxcbiAgICBwdWJsaXNoT3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICkge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZXRUcmFja0VuYWJsZWQnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgc291cmNlLCBlbmFibGVkIH0pO1xuICAgIGlmICh0aGlzLnJlcHVibGlzaFByb21pc2UpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVwdWJsaXNoUHJvbWlzZTtcbiAgICB9XG4gICAgbGV0IHRyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKHNvdXJjZSk7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICBhd2FpdCB0cmFjay51bm11dGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsb2NhbFRyYWNrczogQXJyYXk8TG9jYWxUcmFjaz4gfCB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgY29uc3QgcGVuZGluZ1RyYWNrID0gYXdhaXQgdGhpcy53YWl0Rm9yUGVuZGluZ1B1YmxpY2F0aW9uT2ZTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICBpZiAoIXBlbmRpbmdUcmFjaykge1xuICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnd2FpdGluZyBmb3IgcGVuZGluZyBwdWJsaWNhdGlvbiBwcm9taXNlIHRpbWVkIG91dCcsIHtcbiAgICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgcGVuZGluZ1RyYWNrPy51bm11dGUoKTtcbiAgICAgICAgICByZXR1cm4gcGVuZGluZ1RyYWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuYWRkKHNvdXJjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLkNhbWVyYTpcbiAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSBhd2FpdCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgdmlkZW86IChvcHRpb25zIGFzIFZpZGVvQ2FwdHVyZU9wdGlvbnMgfCB1bmRlZmluZWQpID8/IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgICAgICAgbG9jYWxUcmFja3MgPSBhd2FpdCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgICAgICAgYXVkaW86IChvcHRpb25zIGFzIEF1ZGlvQ2FwdHVyZU9wdGlvbnMgfCB1bmRlZmluZWQpID8/IHRydWUsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IGF3YWl0IHRoaXMuY3JlYXRlU2NyZWVuVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAuLi4ob3B0aW9ucyBhcyBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zIHwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgbG9jYWxUcmFja3M/LmZvckVhY2goKHRyKSA9PiB7XG4gICAgICAgICAgICB0ci5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZXM6IEFycmF5PFByb21pc2U8TG9jYWxUcmFja1B1YmxpY2F0aW9uPj4gPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGxvY2FsVHJhY2sgb2YgbG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3B1Ymxpc2hpbmcgdHJhY2snLCB7XG4gICAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayhsb2NhbFRyYWNrKSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwdWJsaXNoUHJvbWlzZXMucHVzaCh0aGlzLnB1Ymxpc2hUcmFjayhsb2NhbFRyYWNrLCBwdWJsaXNoT3B0aW9ucykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwdWJsaXNoZWRUcmFja3MgPSBhd2FpdCBQcm9taXNlLmFsbChwdWJsaXNoUHJvbWlzZXMpO1xuXG4gICAgICAgICAgLy8gZm9yIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbnMgaW5jbHVkaW5nIGF1ZGlvLCB0aGlzIHdpbGwgb25seSByZXR1cm4gdGhlIHNjcmVlbiBzaGFyZSBwdWJsaWNhdGlvbiwgbm90IHRoZSBzY3JlZW4gc2hhcmUgYXVkaW8gb25lXG4gICAgICAgICAgLy8gcmV2aXNpdCBpZiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheSBvZiB0cmFja3MgaW5zdGVhZCBmb3IgdjJcbiAgICAgICAgICBbdHJhY2tdID0gcHVibGlzaGVkVHJhY2tzO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9jYWxUcmFja3M/LmZvckVhY2goKHRyKSA9PiB7XG4gICAgICAgICAgICB0ci5zdG9wKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdHJhY2s/LnRyYWNrICYmIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUncyBubyB0cmFjayBhdmFpbGFibGUgeWV0IGZpcnN0IHdhaXQgZm9yIHBlbmRpbmcgcHVibGlzaGluZyBwcm9taXNlcyBvZiB0aGF0IHNvdXJjZSB0byBzZWUgaWYgaXQgYmVjb21lcyBhdmFpbGFibGVcbiAgICAgICAgdHJhY2sgPSBhd2FpdCB0aGlzLndhaXRGb3JQZW5kaW5nUHVibGljYXRpb25PZlNvdXJjZShzb3VyY2UpO1xuICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5sb2cuaW5mbygnd2FpdGluZyBmb3IgcGVuZGluZyBwdWJsaWNhdGlvbiBwcm9taXNlIHRpbWVkIG91dCcsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLnRyYWNrKSB7XG4gICAgICAgIC8vIHNjcmVlbnNoYXJlIGNhbm5vdCBiZSBtdXRlZCwgdW5wdWJsaXNoIGluc3RlYWRcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgdHJhY2sgPSBhd2FpdCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLnRyYWNrKTtcbiAgICAgICAgICBjb25zdCBzY3JlZW5BdWRpb1RyYWNrID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uKFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvKTtcbiAgICAgICAgICBpZiAoc2NyZWVuQXVkaW9UcmFjayAmJiBzY3JlZW5BdWRpb1RyYWNrLnRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnVucHVibGlzaFRyYWNrKHNjcmVlbkF1ZGlvVHJhY2sudHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCB0cmFjay5tdXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYWNrO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYm90aCBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAqIGRpc3BsYXlpbmcgYSBzaW5nbGUgUGVybWlzc2lvbiBEaWFsb2cgYm94IHRvIHRoZSBlbmQgdXNlci5cbiAgICovXG4gIGFzeW5jIGVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoVHJhY2suU291cmNlLkNhbWVyYSkgfHxcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKVxuICAgICkge1xuICAgICAgLy8gbm8tb3AgaXQncyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFja3M6IExvY2FsVHJhY2tbXSA9IGF3YWl0IHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYWNrcy5tYXAoKHRyYWNrKSA9PiB0aGlzLnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBsb2NhbCBjYW1lcmEgYW5kL29yIG1pY3JvcGhvbmUgdHJhY2tzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBjcmVhdGVUcmFja3Mob3B0aW9ucz86IENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyk6IFByb21pc2U8TG9jYWxUcmFja1tdPiB7XG4gICAgb3B0aW9ucyA/Pz0ge307XG5cbiAgICBjb25zdCBtZXJnZWRPcHRpb25zV2l0aFByb2Nlc3NvcnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHRoaXMucm9vbU9wdGlvbnM/LmF1ZGlvQ2FwdHVyZURlZmF1bHRzLFxuICAgICAgdGhpcy5yb29tT3B0aW9ucz8udmlkZW9DYXB0dXJlRGVmYXVsdHMsXG4gICAgKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmFja3MgPSBhd2FpdCBjcmVhdGVMb2NhbFRyYWNrcyhtZXJnZWRPcHRpb25zV2l0aFByb2Nlc3NvcnMsIHtcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbG9jYWxUcmFja3MgPSB0cmFja3MubWFwKCh0cmFjaykgPT4ge1xuICAgICAgICBpZiAoaXNBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgIHRoaXMubWljcm9waG9uZUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICB0aGlzLmNhbWVyYUVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXVkaW8pIHtcbiAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgICAgICAgIHRoaXMuY2FtZXJhRXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gICAqIEEgTG9jYWxWaWRlb1RyYWNrIGlzIGFsd2F5cyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAgICogSWYgeyBhdWRpbzogdHJ1ZSB9LCBhbmQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYXVkaW8gY2FwdHVyZSwgYSBMb2NhbEF1ZGlvVHJhY2sgaXMgYWxzbyBjcmVhdGVkLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlU2NyZWVuVHJhY2tzKG9wdGlvbnM/OiBTY3JlZW5TaGFyZUNhcHR1cmVPcHRpb25zKTogUHJvbWlzZTxBcnJheTxMb2NhbFRyYWNrPj4ge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gY29uc3RyYWluIHRoZSBkaW1lbnNpb25zLCBvdGhlcndpc2UgaXQgY291bGQgbGVhZCB0byBsb3cgYml0cmF0ZVxuICAgICAgLy8gZHVlIHRvIGVuY29kaW5nIGEgaHVnZSB2aWRlby4gRW5jb2Rpbmcgc3VjaCBsYXJnZSBzdXJmYWNlcyBpcyByZWFsbHkgZXhwZW5zaXZlXG4gICAgICAvLyB1bmZvcnR1bmF0ZWx5IFNhZmFyaSAxNyBoYXMgYSBidXQgYW5kIGNhbm5vdCBiZSBjb25zdHJhaW5lZCBieSBkZWZhdWx0XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW06IE1lZGlhU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpO1xuXG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSwge1xuICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgfSk7XG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGlmIChvcHRpb25zLmNvbnRlbnRIaW50KSB7XG4gICAgICBzY3JlZW5WaWRlby5tZWRpYVN0cmVhbVRyYWNrLmNvbnRlbnRIaW50ID0gb3B0aW9ucy5jb250ZW50SGludDtcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbFRyYWNrczogQXJyYXk8TG9jYWxUcmFjaz4gPSBbc2NyZWVuVmlkZW9dO1xuICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkKTtcbiAgICAgIGNvbnN0IHNjcmVlbkF1ZGlvID0gbmV3IExvY2FsQXVkaW9UcmFjayhcbiAgICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxuICAgICAgICB7IGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSwgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQgfSxcbiAgICAgICk7XG4gICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgIGxvY2FsVHJhY2tzLnB1c2goc2NyZWVuQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBhIG5ldyB0cmFjayB0byB0aGUgcm9vbVxuICAgKiBAcGFyYW0gdHJhY2tcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hUcmFjayh0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssIG9wdGlvbnM/OiBUcmFja1B1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaE9yUmVwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayhcbiAgICB0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgb3B0aW9ucz86IFRyYWNrUHVibGlzaE9wdGlvbnMsXG4gICAgaXNSZXB1Ymxpc2ggPSBmYWxzZSxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24+IHtcbiAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICB0cmFjay5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucmVjb25uZWN0RnV0dXJlPy5wcm9taXNlO1xuICAgIGlmICh0aGlzLnJlcHVibGlzaFByb21pc2UgJiYgIWlzUmVwdWJsaXNoKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlcHVibGlzaFByb21pc2U7XG4gICAgfVxuICAgIGlmIChpc0xvY2FsVHJhY2sodHJhY2spICYmIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5oYXModHJhY2spKSB7XG4gICAgICBhd2FpdCB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZ2V0KHRyYWNrKTtcbiAgICB9XG4gICAgbGV0IGRlZmF1bHRDb25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIGRlZmF1bHRDb25zdHJhaW50cyA9IHRyYWNrLmdldENvbnN0cmFpbnRzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIHdhbnQgdG8gYWNjZXNzIGNvbnN0cmFpbnRzIGRpcmVjdGx5IGFzIGB0cmFjay5tZWRpYVN0cmVhbVRyYWNrYFxuICAgICAgLy8gbWlnaHQgYmUgcG9pbnRpbmcgdG8gYSBub24tZGV2aWNlIHRyYWNrIChlLmcuIHByb2Nlc3NlZCB0cmFjaykgYWxyZWFkeVxuICAgICAgZGVmYXVsdENvbnN0cmFpbnRzID0gdHJhY2suY29uc3RyYWludHM7XG4gICAgICBsZXQgZGV2aWNlS2luZDogTWVkaWFEZXZpY2VLaW5kIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgc3dpdGNoICh0cmFjay5zb3VyY2UpIHtcbiAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgICBkZXZpY2VLaW5kID0gJ2F1ZGlvaW5wdXQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5DYW1lcmE6XG4gICAgICAgICAgZGV2aWNlS2luZCA9ICd2aWRlb2lucHV0JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChkZXZpY2VLaW5kICYmIHRoaXMuYWN0aXZlRGV2aWNlTWFwLmhhcyhkZXZpY2VLaW5kKSkge1xuICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB7XG4gICAgICAgICAgLi4uZGVmYXVsdENvbnN0cmFpbnRzLFxuICAgICAgICAgIGRldmljZUlkOiB0aGlzLmFjdGl2ZURldmljZU1hcC5nZXQoZGV2aWNlS2luZCksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgcmF3IG1lZGlhIHRyYWNrIGludG8gYXVkaW8gb3IgdmlkZW8gdHJhY2tcbiAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICBzd2l0Y2ggKHRyYWNrLmtpbmQpIHtcbiAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgIHRyYWNrID0gbmV3IExvY2FsQXVkaW9UcmFjayh0cmFjaywgZGVmYXVsdENvbnN0cmFpbnRzLCB0cnVlLCB0aGlzLmF1ZGlvQ29udGV4dCwge1xuICAgICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICB0cmFjayA9IG5ldyBMb2NhbFZpZGVvVHJhY2sodHJhY2ssIGRlZmF1bHRDb25zdHJhaW50cywgdHJ1ZSwge1xuICAgICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKGB1bnN1cHBvcnRlZCBNZWRpYVN0cmVhbVRyYWNrIGtpbmQgJHt0cmFjay5raW5kfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjay51cGRhdGVMb2dnZXJPcHRpb25zKHtcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGlzIGl0IGFscmVhZHkgcHVibGlzaGVkPyBpZiBzbyBza2lwXG4gICAgbGV0IGV4aXN0aW5nUHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2goKHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaWNhdGlvbi50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHVibGljYXRpb247XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigndHJhY2sgaGFzIGFscmVhZHkgYmVlbiBwdWJsaXNoZWQsIHNraXBwaW5nJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdQdWJsaWNhdGlvbiksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGlzU3RlcmVvSW5wdXQgPVxuICAgICAgKCdjaGFubmVsQ291bnQnIGluIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKSAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjaGFubmVsQ291bnRgIG9uIGdldFNldHRpbmdzKCkgaXMgY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBTYWZhcmksIGJ1dCBpcyBnZW5lcmFsbHkgdGhlIGJlc3Qgd2F5IHRvIGRldGVybWluZSBhIHN0ZXJlbyB0cmFjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja1NldHRpbmdzL2NoYW5uZWxDb3VudFxuICAgICAgICB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuY2hhbm5lbENvdW50ID09PSAyKSB8fFxuICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpLmNoYW5uZWxDb3VudCA9PT0gMjtcbiAgICBjb25zdCBpc1N0ZXJlbyA9IG9wdGlvbnM/LmZvcmNlU3RlcmVvID8/IGlzU3RlcmVvSW5wdXQ7XG5cbiAgICAvLyBkaXNhYmxlIGR0eCBmb3Igc3RlcmVvIHRyYWNrIGlmIG5vdCBlbmFibGVkIGV4cGxpY2l0bHlcbiAgICBpZiAoaXNTdGVyZW8pIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFxuICAgICAgICAgIGBPcHVzIERUWCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLmAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXG4gICAgICAgICAgYE9wdXMgUkVEIHdpbGwgYmUgZGlzYWJsZWQgZm9yIHN0ZXJlbyB0cmFja3MgYnkgZGVmYXVsdC4gRW5hYmxlIHRoZW0gZXhwbGljaXRseSB0byBtYWtlIGl0IHdvcmsuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZHR4ID8/PSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVkID8/PSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgb3B0czogVHJhY2tQdWJsaXNoT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMucm9vbU9wdGlvbnMucHVibGlzaERlZmF1bHRzLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgaWYgKCFpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQoKSAmJiB0aGlzLnJvb21PcHRpb25zLmUyZWUpIHtcbiAgICAgIHRoaXMubG9nLmluZm8oXG4gICAgICAgIGBFbmQtdG8tZW5kIGVuY3J5cHRpb24gaXMgc2V0IHVwLCBzaW11bGNhc3QgcHVibGlzaGluZyB3aWxsIGJlIGRpc2FibGVkIG9uIFNhZmFyaSB2ZXJzaW9ucyBhbmQgaU9TIGJyb3dzZXJzIHJ1bm5pbmcgaU9TIDwgdjE3LjJgLFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc291cmNlKSB7XG4gICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgICB9XG4gICAgY29uc3QgcHVibGlzaFByb21pc2UgPSBuZXcgUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmVuZ2luZS5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlZmVycmluZyB0cmFjayBwdWJsaWNhdGlvbiB1bnRpbCBzaWduYWwgaXMgY29ubmVjdGVkJywge1xuICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgdHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IG9uU2lnbmFsQ29ubmVjdGVkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSBhd2FpdCB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShwdWJsaWNhdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgb25TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgUHVibGlzaFRyYWNrRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3B1Ymxpc2hpbmcgcmVqZWN0ZWQgYXMgZW5naW5lIG5vdCBjb25uZWN0ZWQgd2l0aGluIHRpbWVvdXQnLFxuICAgICAgICAgICAgICAgIDQwOCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgMTVfMDAwKTtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5vbmNlKEVuZ2luZUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgb25TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LkNsb3NpbmcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5TaWduYWxDb25uZWN0ZWQsIG9uU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ3B1Ymxpc2hpbmcgcmVqZWN0ZWQgYXMgZW5naW5lIGNsb3NlZCcsIDQ5OSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IGF3YWl0IHRoaXMucHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pO1xuICAgICAgICAgICAgcmVzb2x2ZShwdWJsaWNhdGlvbik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLnNldCh0cmFjaywgcHVibGlzaFByb21pc2UpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IGF3YWl0IHB1Ymxpc2hQcm9taXNlO1xuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5kZWxldGUodHJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFzUGVybWlzc2lvbnNUb1B1Ymxpc2godHJhY2s6IExvY2FsVHJhY2spOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMucGVybWlzc2lvbnMpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ25vIHBlcm1pc3Npb25zIHByZXNlbnQgZm9yIHB1Ymxpc2hpbmcgdHJhY2snLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBjYW5QdWJsaXNoLCBjYW5QdWJsaXNoU291cmNlcyB9ID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICBpZiAoXG4gICAgICBjYW5QdWJsaXNoICYmXG4gICAgICAoY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgIGNhblB1Ymxpc2hTb3VyY2VzLm1hcCgoc291cmNlKSA9PiBnZXRUcmFja1NvdXJjZUZyb21Qcm90byhzb3VyY2UpKS5pbmNsdWRlcyh0cmFjay5zb3VyY2UpKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMubG9nLndhcm4oJ2luc3VmZmljaWVudCBwZXJtaXNzaW9ucyB0byBwdWJsaXNoJywge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgfSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwdWJsaXNoKHRyYWNrOiBMb2NhbFRyYWNrLCBvcHRzOiBUcmFja1B1Ymxpc2hPcHRpb25zLCBpc1N0ZXJlbzogYm9vbGVhbikge1xuICAgIGlmICghdGhpcy5oYXNQZXJtaXNzaW9uc1RvUHVibGlzaCh0cmFjaykpIHtcbiAgICAgIHRocm93IG5ldyBQdWJsaXNoVHJhY2tFcnJvcignZmFpbGVkIHRvIHB1Ymxpc2ggdHJhY2ssIGluc3VmZmljaWVudCBwZXJtaXNzaW9ucycsIDQwMyk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVHJhY2tPZlNvdXJjZSA9IEFycmF5LmZyb20odGhpcy50cmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmluZChcbiAgICAgIChwdWJsaXNoZWRUcmFjaykgPT4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBwdWJsaXNoZWRUcmFjay5zb3VyY2UgPT09IHRyYWNrLnNvdXJjZSxcbiAgICApO1xuICAgIGlmIChleGlzdGluZ1RyYWNrT2ZTb3VyY2UgJiYgdHJhY2suc291cmNlICE9PSBUcmFjay5Tb3VyY2UuVW5rbm93bikge1xuICAgICAgdGhpcy5sb2cuaW5mbyhgcHVibGlzaGluZyBhIHNlY29uZCB0cmFjayB3aXRoIHRoZSBzYW1lIHNvdXJjZTogJHt0cmFjay5zb3VyY2V9YCwge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnN0b3BNaWNUcmFja09uTXV0ZSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICB0cmFjay5zdG9wT25NdXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgaXNGaXJlRm94KCkpIHtcbiAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggc2ltdWxjYXN0ZWQgc2NyZWVuIHNoYXJlXG4gICAgICAvLyB3ZSBmcmVxdWVudGx5IGdldCBubyBkYXRhIG9uIGxheWVyIDAgd2hlbiBlbmFibGVkXG4gICAgICBvcHRzLnNpbXVsY2FzdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHJlcXVpcmUgZnVsbCBBVjEvVlA5IFNWQyBzdXBwb3J0IHByaW9yIHRvIHVzaW5nIGl0XG4gICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ2F2MScgJiYgIXN1cHBvcnRzQVYxKCkpIHtcbiAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gJ3ZwOScgJiYgIXN1cHBvcnRzVlA5KCkpIHtcbiAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9wdHMudmlkZW9Db2RlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRzLnZpZGVvQ29kZWMgPSBkZWZhdWx0VmlkZW9Db2RlYztcbiAgICB9XG4gICAgaWYgKHRoaXMuZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBhIHN1cHBvcnRlZCBjb2RlYyBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3Muc29tZShcbiAgICAgICAgICAoYykgPT4gb3B0cy52aWRlb0NvZGVjID09PSBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhjLm1pbWUpLFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzWzBdLm1pbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZpZGVvQ29kZWMgPSBvcHRzLnZpZGVvQ29kZWM7XG5cbiAgICAvLyBoYW5kbGUgdHJhY2sgYWN0aW9uc1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICB0cmFjay5vbihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMub25UcmFja0ZlYXR1cmVVcGRhdGUpO1xuXG4gICAgLy8gY3JlYXRlIHRyYWNrIHB1YmxpY2F0aW9uIGZyb20gdHJhY2tcbiAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcbiAgICAgIC8vIGdldCBsb2NhbCB0cmFjayBpZCBmb3IgdXNlIGR1cmluZyBwdWJsaXNoaW5nXG4gICAgICBjaWQ6IHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suaWQsXG4gICAgICBuYW1lOiBvcHRzLm5hbWUsXG4gICAgICB0eXBlOiBUcmFjay5raW5kVG9Qcm90byh0cmFjay5raW5kKSxcbiAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICBkaXNhYmxlRHR4OiAhKG9wdHMuZHR4ID8/IHRydWUpLFxuICAgICAgZW5jcnlwdGlvbjogdGhpcy5lbmNyeXB0aW9uVHlwZSxcbiAgICAgIHN0ZXJlbzogaXNTdGVyZW8sXG4gICAgICBkaXNhYmxlUmVkOiB0aGlzLmlzRTJFRUVuYWJsZWQgfHwgIShvcHRzLnJlZCA/PyB0cnVlKSxcbiAgICAgIHN0cmVhbTogb3B0cz8uc3RyZWFtLFxuICAgICAgYmFja3VwQ29kZWNQb2xpY3k6IG9wdHM/LmJhY2t1cENvZGVjUG9saWN5IGFzIEJhY2t1cENvZGVjUG9saWN5LFxuICAgIH0pO1xuXG4gICAgLy8gY29tcHV0ZSBlbmNvZGluZ3MgYW5kIGxheWVycyBmb3IgdmlkZW9cbiAgICBsZXQgZW5jb2RpbmdzOiBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnNbXSB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgbGV0IGRpbXM6IFRyYWNrLkRpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGltcyA9IGF3YWl0IHRyYWNrLndhaXRGb3JEaW1lbnNpb25zKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIHVzZSBkZWZhdWx0cywgaXQncyBxdWl0ZSBwYWluZnVsIGZvciBjb25nZXN0aW9uIGNvbnRyb2wgd2l0aG91dCBzaW11bGNhc3RcbiAgICAgICAgLy8gc28gdXNpbmcgZGVmYXVsdCBkaW1zIGFjY29yZGluZyB0byBwdWJsaXNoIHNldHRpbmdzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRSZXMgPVxuICAgICAgICAgIHRoaXMucm9vbU9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHM/LnJlc29sdXRpb24gPz8gVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvbjtcbiAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICB3aWR0aDogZGVmYXVsdFJlcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGRlZmF1bHRSZXMuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBsb2cgZmFpbHVyZVxuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGRldGVybWluZSB0cmFjayBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0cycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgZGltcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBiZSBkZWZpbmVkIGZvciB2aWRlb1xuICAgICAgcmVxLndpZHRoID0gZGltcy53aWR0aDtcbiAgICAgIHJlcS5oZWlnaHQgPSBkaW1zLmhlaWdodDtcbiAgICAgIC8vIGZvciBzdmMgY29kZWNzLCBkaXNhYmxlIHNpbXVsY2FzdCBhbmQgdXNlIHZwOCBmb3IgYmFja3VwIGNvZGVjXG4gICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIGlmIChpc1NWQ0NvZGVjKHZpZGVvQ29kZWMpKSB7XG4gICAgICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgICAvLyB2cDkgc3ZjIHdpdGggc2NyZWVuc2hhcmUgY2Fubm90IGVuY29kZSBtdWx0aXBsZSBzcGF0aWFsIGxheWVyc1xuICAgICAgICAgICAgLy8gZG9pbmcgc28gcmVkdWNlcyBwdWJsaXNoIHJlc29sdXRpb24gdG8gbWluaW1hbCByZXNvbHV0aW9uXG4gICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgIC8vIENocm9tZSBkb2VzIG5vdCBhbGxvdyBtb3JlIHRoYW4gNSBmcHMgd2l0aCBMMVQzLCBhbmQgaXQgaGFzIGVuY29kaW5nIGJ1Z3Mgd2l0aCBMM1QzXG4gICAgICAgICAgICAvLyBJdCBoYXMgYSBkaWZmZXJlbnQgcGF0aCBmb3Igc2NyZWVuc2hhcmUgaGFuZGxpbmcgYW5kIGl0IHNlZW1zIHRvIGJlIHVudGVzdGVkL2J1Z2d5XG4gICAgICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQsIHdlIGFyZSBzZXR0aW5nIGNvbnRlbnRIaW50IHRvIGZvcmNlIGl0IHRvIGdvIHRocm91Z2ggdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHBhdGggYXMgcmVndWxhciBjYW1lcmEgdmlkZW8uIFdoaWxlIHRoaXMgaXMgbm90IG9wdGltYWwsIGl0IGRlbGl2ZXJzIHRoZSBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gdGhhdCB3ZSBuZWVkXG4gICAgICAgICAgICBpZiAoJ2NvbnRlbnRIaW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICAgIHRyYWNrLm1lZGlhU3RyZWFtVHJhY2suY29udGVudEhpbnQgPSAnbW90aW9uJztcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnZm9yY2luZyBjb250ZW50SGludCB0byBtb3Rpb24gZm9yIHNjcmVlbnNoYXJlIHdpdGggU1ZDIGNvZGVjcycsIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzZXQgc2NhbGFiaWxpdHlNb2RlIHRvICdMM1QzX0tFWScgYnkgZGVmYXVsdFxuICAgICAgICAgIG9wdHMuc2NhbGFiaWxpdHlNb2RlID0gb3B0cy5zY2FsYWJpbGl0eU1vZGUgPz8gJ0wzVDNfS0VZJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcS5zaW11bGNhc3RDb2RlY3MgPSBbXG4gICAgICAgICAgbmV3IFNpbXVsY2FzdENvZGVjKHtcbiAgICAgICAgICAgIGNvZGVjOiB2aWRlb0NvZGVjLFxuICAgICAgICAgICAgY2lkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIHNldCB1cCBiYWNrdXBcbiAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUpIHtcbiAgICAgICAgICBvcHRzLmJhY2t1cENvZGVjID0geyBjb2RlYzogZGVmYXVsdFZpZGVvQ29kZWMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgb3B0cy5iYWNrdXBDb2RlYyAmJlxuICAgICAgICAgIHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMgJiZcbiAgICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIG9uY2UgZTJlZSBpcyBzdXBwb3J0ZWQgZm9yIGJhY2t1cCBjb2RlY3NcbiAgICAgICAgICByZXEuZW5jcnlwdGlvbiA9PT0gRW5jcnlwdGlvbl9UeXBlLk5PTkVcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbXVsdGktY29kZWMgc2ltdWxjYXN0IHJlcXVpcmVzIGR5bmFjYXN0XG4gICAgICAgICAgaWYgKCF0aGlzLnJvb21PcHRpb25zLmR5bmFjYXN0KSB7XG4gICAgICAgICAgICB0aGlzLnJvb21PcHRpb25zLmR5bmFjYXN0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxLnNpbXVsY2FzdENvZGVjcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFNpbXVsY2FzdENvZGVjKHtcbiAgICAgICAgICAgICAgY29kZWM6IG9wdHMuYmFja3VwQ29kZWMuY29kZWMsXG4gICAgICAgICAgICAgIGNpZDogJycsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyhcbiAgICAgICAgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsXG4gICAgICAgIHJlcS53aWR0aCxcbiAgICAgICAgcmVxLmhlaWdodCxcbiAgICAgICAgb3B0cyxcbiAgICAgICk7XG4gICAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKFxuICAgICAgICByZXEud2lkdGgsXG4gICAgICAgIHJlcS5oZWlnaHQsXG4gICAgICAgIGVuY29kaW5ncyxcbiAgICAgICAgaXNTVkNDb2RlYyhvcHRzLnZpZGVvQ29kZWMpLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgIGVuY29kaW5ncyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG1heEJpdHJhdGU6IG9wdHMuYXVkaW9QcmVzZXQ/Lm1heEJpdHJhdGUsXG4gICAgICAgICAgcHJpb3JpdHk6IG9wdHMuYXVkaW9QcmVzZXQ/LnByaW9yaXR5ID8/ICdoaWdoJyxcbiAgICAgICAgICBuZXR3b3JrUHJpb3JpdHk6IG9wdHMuYXVkaW9QcmVzZXQ/LnByaW9yaXR5ID8/ICdoaWdoJyxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmVuZ2luZSB8fCB0aGlzLmVuZ2luZS5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG5lZ290aWF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwY01hbmFnZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICB9XG5cbiAgICAgIHRyYWNrLnNlbmRlciA9IGF3YWl0IHRoaXMuZW5naW5lLmNyZWF0ZVNlbmRlcih0cmFjaywgb3B0cywgZW5jb2RpbmdzKTtcblxuICAgICAgaWYgKGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICBvcHRzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSA/Pz0gZ2V0RGVmYXVsdERlZ3JhZGF0aW9uUHJlZmVyZW5jZSh0cmFjayk7XG4gICAgICAgIHRyYWNrLnNldERlZ3JhZGF0aW9uUHJlZmVyZW5jZShvcHRzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgaWYgKGlzRmlyZUZveCgpICYmIHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICAvKiBSZWZlciB0byBSRkMgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM3NTg3I3NlY3Rpb24tNi4xLFxuICAgICAgICAgICAgIGxpdmVraXQtc2VydmVyIHVzZXMgbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwIGluIHRoZSBhbnN3ZXIgc2RwIHRvIHBlcm1pdCBjbGllbnQgdG9cbiAgICAgICAgICAgICBwdWJsaXNoIGhpZ2ggcXVhbGl0eSBhdWRpbyB0cmFjay4gQnV0IGZpcmVmb3ggYWx3YXlzIHVzZXMgdGhpcyB2YWx1ZSBhcyB0aGUgYWN0dWFsXG4gICAgICAgICAgICAgYml0cmF0ZXMsIGNhdXNpbmcgdGhlIGF1ZGlvIGJpdHJhdGVzIHRvIHJpc2UgdG8gNTEwS2JwcyBpbiBhbnkgc3RlcmVvIGNhc2UgdW5leHBlY3RlZGx5LlxuICAgICAgICAgICAgIFNvIHRoZSBjbGllbnQgbmVlZCB0byBtb2RpZnkgbWF4YXZlcnJhZ2ViaXRyYXRlcyBpbiBhbnN3ZXIgc2RwIHRvIHVzZXIgcHJvdmlkZWQgdmFsdWUgdG9cbiAgICAgICAgICAgICBmaXggdGhlIGlzc3VlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxldCB0cmFja1RyYW5zY2VpdmVyOiBSVENSdHBUcmFuc2NlaXZlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zY2VpdmVyIG9mIHRoaXMuZW5naW5lLnBjTWFuYWdlci5wdWJsaXNoZXIuZ2V0VHJhbnNjZWl2ZXJzKCkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrLnNlbmRlcikge1xuICAgICAgICAgICAgICB0cmFja1RyYW5zY2VpdmVyID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJhY2tUcmFuc2NlaXZlcikge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyOiB0cmFja1RyYW5zY2VpdmVyLFxuICAgICAgICAgICAgICBjb2RlYzogJ29wdXMnLFxuICAgICAgICAgICAgICBtYXhicjogZW5jb2RpbmdzWzBdPy5tYXhCaXRyYXRlID8gZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwIDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0cmFjay5jb2RlYyAmJiBpc1NWQ0NvZGVjKHRyYWNrLmNvZGVjKSAmJiBlbmNvZGluZ3NbMF0/Lm1heEJpdHJhdGUpIHtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLnNldFRyYWNrQ29kZWNCaXRyYXRlKHtcbiAgICAgICAgICAgIGNpZDogcmVxLmNpZCxcbiAgICAgICAgICAgIGNvZGVjOiB0cmFjay5jb2RlYyxcbiAgICAgICAgICAgIG1heGJyOiBlbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIDEwMDAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgfTtcblxuICAgIGxldCB0aTogVHJhY2tJbmZvO1xuICAgIGlmICh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmV0cyA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpLCBuZWdvdGlhdGUoKV0pO1xuICAgICAgdGkgPSByZXRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aSA9IGF3YWl0IHRoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSk7XG4gICAgICAvLyBzZXJ2ZXIgbWlnaHQgbm90IHN1cHBvcnQgdGhlIGNvZGVjIHRoZSBjbGllbnQgaGFzIHJlcXVlc3RlZCwgaW4gdGhhdCBjYXNlLCBmYWxsYmFja1xuICAgICAgLy8gdG8gYSBzdXBwb3J0ZWQgY29kZWNcbiAgICAgIGxldCBwcmltYXJ5Q29kZWNNaW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICB0aS5jb2RlY3MuZm9yRWFjaCgoY29kZWMpID0+IHtcbiAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByaW1hcnlDb2RlY01pbWUgPSBjb2RlYy5taW1lVHlwZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocHJpbWFyeUNvZGVjTWltZSAmJiB0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDb2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHByaW1hcnlDb2RlY01pbWUpO1xuICAgICAgICBpZiAodXBkYXRlZENvZGVjICE9PSB2aWRlb0NvZGVjKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2ZhbGxpbmcgYmFjayB0byBzZXJ2ZXIgc2VsZWN0ZWQgY29kZWMnLCB7XG4gICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgICAgICAgIGNvZGVjOiB1cGRhdGVkQ29kZWMsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gdXBkYXRlZENvZGVjO1xuXG4gICAgICAgICAgLy8gcmVjb21wdXRlIGVuY29kaW5ncyBzaW5jZSBiaXRyYXRlcy9ldGMgY291bGQgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKFxuICAgICAgICAgICAgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsXG4gICAgICAgICAgICByZXEud2lkdGgsXG4gICAgICAgICAgICByZXEuaGVpZ2h0LFxuICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBuZWdvdGlhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBwdWJsaWNhdGlvbiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24odHJhY2sua2luZCwgdGksIHRyYWNrLCB7XG4gICAgICBsb2dnZXJOYW1lOiB0aGlzLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICB9KTtcbiAgICAvLyBzYXZlIG9wdGlvbnMgZm9yIHdoZW4gaXQgbmVlZHMgdG8gYmUgcmVwdWJsaXNoZWQgYWdhaW5cbiAgICBwdWJsaWNhdGlvbi5vcHRpb25zID0gb3B0cztcbiAgICB0cmFjay5zaWQgPSB0aS5zaWQ7XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgcHVibGlzaGluZyAke3RyYWNrLmtpbmR9IHdpdGggZW5jb2RpbmdzYCwge1xuICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgZW5jb2RpbmdzLFxuICAgICAgdHJhY2tJbmZvOiB0aSxcbiAgICB9KTtcblxuICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgIHRyYWNrLnN0YXJ0TW9uaXRvcih0aGlzLmVuZ2luZS5jbGllbnQpO1xuICAgIH0gZWxzZSBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICB0cmFjay5zdGFydE1vbml0b3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgIC8vIHNlbmQgZXZlbnQgZm9yIHB1YmxpY2F0aW9uXG4gICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuXG4gIG92ZXJyaWRlIGdldCBpc0xvY2FsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbFxuICAgKiBwdWJsaXNoIGFkZGl0aW9uYWwgY29kZWMgdG8gZXhpc3RpbmcgdHJhY2tcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayhcbiAgICB0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgdmlkZW9Db2RlYzogQmFja3VwVmlkZW9Db2RlYyxcbiAgICBvcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucyxcbiAgKSB7XG4gICAgLy8gVE9ETyByZW1vdmUgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIHRyYWNrc1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlzIGl0IG5vdCBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjogTG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkO1xuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCgocHVibGljYXRpb24pID0+IHtcbiAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICBleGlzdGluZ1B1YmxpY2F0aW9uID0gPExvY2FsVHJhY2tQdWJsaWNhdGlvbj5wdWJsaWNhdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWV4aXN0aW5nUHVibGljYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IHB1Ymxpc2hlZCcpO1xuICAgIH1cblxuICAgIGlmICghaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3RyYWNrIGlzIG5vdCBhIHZpZGVvIHRyYWNrJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0czogVHJhY2tQdWJsaXNoT3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMucm9vbU9wdGlvbnM/LnB1Ymxpc2hEZWZhdWx0cyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cyk7XG4gICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgIHRoaXMubG9nLmluZm8oXG4gICAgICAgIGBiYWNrdXAgY29kZWMgaGFzIGJlZW4gZGlzYWJsZWQsIGlnbm9yaW5nIHJlcXVlc3QgdG8gYWRkIGFkZGl0aW9uYWwgY29kZWMgZm9yIHRyYWNrYCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpbXVsY2FzdFRyYWNrID0gdHJhY2suYWRkU2ltdWxjYXN0VHJhY2sodmlkZW9Db2RlYywgZW5jb2RpbmdzKTtcbiAgICBpZiAoIXNpbXVsY2FzdFRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlcSA9IG5ldyBBZGRUcmFja1JlcXVlc3Qoe1xuICAgICAgY2lkOiBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgIHNvdXJjZTogVHJhY2suc291cmNlVG9Qcm90byh0cmFjay5zb3VyY2UpLFxuICAgICAgc2lkOiB0cmFjay5zaWQsXG4gICAgICBzaW11bGNhc3RDb2RlY3M6IFtcbiAgICAgICAge1xuICAgICAgICAgIGNvZGVjOiBvcHRzLnZpZGVvQ29kZWMsXG4gICAgICAgICAgY2lkOiBzaW11bGNhc3RUcmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KTtcbiAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHJlcS53aWR0aCwgcmVxLmhlaWdodCwgZW5jb2RpbmdzKTtcblxuICAgIGlmICghdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjYW5ub3QgcHVibGlzaCB0cmFjayB3aGVuIG5vdCBjb25uZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZWdvdGlhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2NlaXZlckluaXQ6IFJUQ1J0cFRyYW5zY2VpdmVySW5pdCA9IHsgZGlyZWN0aW9uOiAnc2VuZG9ubHknIH07XG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgIHRyYW5zY2VpdmVySW5pdC5zZW5kRW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY3JlYXRlU2ltdWxjYXN0U2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcblxuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJldHMgPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKSwgbmVnb3RpYXRlKCldKTtcbiAgICBjb25zdCB0aSA9IHJldHNbMF07XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgcHVibGlzaGVkICR7dmlkZW9Db2RlY30gZm9yIHRyYWNrICR7dHJhY2suc2lkfWAsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIGVuY29kaW5ncyxcbiAgICAgIHRyYWNrSW5mbzogdGksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyB1bnB1Ymxpc2hUcmFjayhcbiAgICB0cmFjazogTG9jYWxUcmFjayB8IE1lZGlhU3RyZWFtVHJhY2ssXG4gICAgc3RvcE9uVW5wdWJsaXNoPzogYm9vbGVhbixcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAoaXNMb2NhbFRyYWNrKHRyYWNrKSkge1xuICAgICAgY29uc3QgcHVibGlzaFByb21pc2UgPSB0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZ2V0KHRyYWNrKTtcbiAgICAgIGlmIChwdWJsaXNoUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdhd2FpdGluZyBwdWJsaXNoIHByb21pc2UgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdW5wdWJsaXNoJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHB1Ymxpc2hQcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBsb29rIHRocm91Z2ggYWxsIHB1Ymxpc2hlZCB0cmFja3MgdG8gZmluZCB0aGUgcmlnaHQgb25lc1xuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRQdWJsaWNhdGlvbkZvclRyYWNrKHRyYWNrKTtcblxuICAgIGNvbnN0IHB1YkxvZ0NvbnRleHQgPSBwdWJsaWNhdGlvbiA/IGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5sb2cuZGVidWcoJ3VucHVibGlzaGluZyB0cmFjaycsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIC4uLnB1YkxvZ0NvbnRleHQsXG4gICAgfSk7XG5cbiAgICBpZiAoIXB1YmxpY2F0aW9uIHx8ICFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgdGhpcy5sb2cud2FybigndHJhY2sgd2FzIG5vdCB1bnB1Ymxpc2hlZCBiZWNhdXNlIG5vIHB1YmxpY2F0aW9uIHdhcyBmb3VuZCcsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAuLi5wdWJMb2dDb250ZXh0LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyYWNrID0gcHVibGljYXRpb24udHJhY2s7XG4gICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5Vbm11dGVkLCB0aGlzLm9uVHJhY2tVbm11dGVkKTtcbiAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVUcmFja0VuZGVkKTtcbiAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVwc3RyZWFtUmVzdW1lZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1SZXN1bWVkKTtcbiAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcy5vblRyYWNrRmVhdHVyZVVwZGF0ZSk7XG5cbiAgICBpZiAoc3RvcE9uVW5wdWJsaXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0b3BPblVucHVibGlzaCA9IHRoaXMucm9vbU9wdGlvbnM/LnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2ggPz8gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHN0b3BPblVucHVibGlzaCkge1xuICAgICAgdHJhY2suc3RvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFjay5zdG9wTW9uaXRvcigpO1xuICAgIH1cblxuICAgIGxldCBuZWdvdGlhdGlvbk5lZWRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyYWNrU2VuZGVyID0gdHJhY2suc2VuZGVyO1xuICAgIHRyYWNrLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICBpZiAoXG4gICAgICB0aGlzLmVuZ2luZS5wY01hbmFnZXIgJiZcbiAgICAgIHRoaXMuZW5naW5lLnBjTWFuYWdlci5jdXJyZW50U3RhdGUgPCBQQ1RyYW5zcG9ydFN0YXRlLkZBSUxFRCAmJlxuICAgICAgdHJhY2tTZW5kZXJcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHJhbnNjZWl2ZXIgb2YgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKSkge1xuICAgICAgICAgIC8vIGlmIHNlbmRlciBpcyBub3QgY3VycmVudGx5IHNlbmRpbmcgKGFmdGVyIHJlcGxhY2VUcmFjayhudWxsKSlcbiAgICAgICAgICAvLyByZW1vdmVUcmFjayB3b3VsZCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgICAgICAvLyB0byBlbnN1cmUgd2UgZW5kIHVwIHN1Y2Nlc3NmdWxseSByZW1vdmluZyB0aGUgdHJhY2ssIG1hbnVhbGx5IHNldFxuICAgICAgICAgIC8vIHRoZSB0cmFuc2NlaXZlciB0byBpbmFjdGl2ZVxuICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrU2VuZGVyKSB7XG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tTZW5kZXIpKSB7XG4gICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIHRyYWNrSW5mb10gb2YgdHJhY2suc2ltdWxjYXN0Q29kZWNzKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tJbmZvLnNlbmRlcikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUucmVtb3ZlVHJhY2sodHJhY2tJbmZvLnNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhY2tJbmZvLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2suc2ltdWxjYXN0Q29kZWNzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignZmFpbGVkIHRvIHVucHVibGlzaCB0cmFjaycsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgLi4ucHViTG9nQ29udGV4dCxcbiAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGZyb20gb3VyIG1hcHNcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICBjYXNlIFRyYWNrLktpbmQuQXVkaW86XG4gICAgICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShwdWJsaWNhdGlvbi50cmFja1NpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgcHVibGljYXRpb24uc2V0VHJhY2sodW5kZWZpbmVkKTtcblxuICAgIGlmIChuZWdvdGlhdGlvbk5lZWRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuXG4gIGFzeW5jIHVucHVibGlzaFRyYWNrcyhcbiAgICB0cmFja3M6IExvY2FsVHJhY2tbXSB8IE1lZGlhU3RyZWFtVHJhY2tbXSxcbiAgKTogUHJvbWlzZTxMb2NhbFRyYWNrUHVibGljYXRpb25bXT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0cmFjaykgPT4gdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIoKHRyYWNrKSA9PiAhIXRyYWNrKTtcbiAgfVxuXG4gIGFzeW5jIHJlcHVibGlzaEFsbFRyYWNrcyhvcHRpb25zPzogVHJhY2tQdWJsaXNoT3B0aW9ucywgcmVzdGFydFRyYWNrczogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5yZXB1Ymxpc2hQcm9taXNlKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlcHVibGlzaFByb21pc2U7XG4gICAgfVxuICAgIHRoaXMucmVwdWJsaXNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxvY2FsUHViczogTG9jYWxUcmFja1B1YmxpY2F0aW9uW10gPSBbXTtcbiAgICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwdWIpID0+IHtcbiAgICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICBwdWIub3B0aW9ucyA9IHsgLi4ucHViLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUHVicy5wdXNoKHB1Yik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBsb2NhbFB1YnMubWFwKGFzeW5jIChwdWIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gcHViLnRyYWNrITtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2ssIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcmVzdGFydFRyYWNrcyAmJlxuICAgICAgICAgICAgICAhdHJhY2suaXNNdXRlZCAmJlxuICAgICAgICAgICAgICB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJlxuICAgICAgICAgICAgICB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvICYmXG4gICAgICAgICAgICAgIChpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykgfHwgaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSAmJlxuICAgICAgICAgICAgICAhdHJhY2suaXNVc2VyUHJvdmlkZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBnZW5lcmFsbHkgd2UgbmVlZCB0byByZXN0YXJ0IHRoZSB0cmFjayBiZWZvcmUgcHVibGlzaGluZywgb2Z0ZW4gYSBmdWxsIHJlY29ubmVjdFxuICAgICAgICAgICAgICAvLyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBjb21wdXRlciBoYWQgZ29uZSB0byBzbGVlcC5cbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgZXhpc3RpbmcgdHJhY2snLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgICAgIHRyYWNrOiBwdWIudHJhY2tTaWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaE9yUmVwdWJsaXNoVHJhY2sodHJhY2ssIHB1Yi5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5yZXB1Ymxpc2hQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5yZXB1Ymxpc2hQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgZGF0YSBwYXlsb2FkIHRvIHRoZSByb29tLiBEYXRhIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGVhY2hcbiAgICogcGFydGljaXBhbnQgaW4gdGhlIHJvb20gaWYgdGhlIGRlc3RpbmF0aW9uIGZpZWxkIGluIHB1Ymxpc2hPcHRpb25zIGlzIGVtcHR5XG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIFVpbnQ4QXJyYXkgb2YgdGhlIHBheWxvYWQuIFRvIHNlbmQgc3RyaW5nIGRhdGEsIHVzZSBUZXh0RW5jb2Rlci5lbmNvZGVcbiAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uYWxseSBzcGVjaWZ5IGEgYHJlbGlhYmxlYCwgYHRvcGljYCBhbmQgYGRlc3RpbmF0aW9uYFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaERhdGEoZGF0YTogVWludDhBcnJheSwgb3B0aW9uczogRGF0YVB1Ymxpc2hPcHRpb25zID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBraW5kID0gb3B0aW9ucy5yZWxpYWJsZSA/IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSA6IERhdGFQYWNrZXRfS2luZC5MT1NTWTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBvcHRpb25zLmRlc3RpbmF0aW9uSWRlbnRpdGllcztcbiAgICBjb25zdCB0b3BpYyA9IG9wdGlvbnMudG9waWM7XG5cbiAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICBraW5kOiBraW5kLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgY2FzZTogJ3VzZXInLFxuICAgICAgICB2YWx1ZTogbmV3IFVzZXJQYWNrZXQoe1xuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHRoaXMuaWRlbnRpdHksXG4gICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgICAgdG9waWMsXG4gICAgICAgIH0pLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGF3YWl0IHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBTSVAgRFRNRiBtZXNzYWdlIHRvIHRoZSByb29tLlxuICAgKlxuICAgKiBAcGFyYW0gY29kZSBEVE1GIGNvZGVcbiAgICogQHBhcmFtIGRpZ2l0IERUTUYgZGlnaXRcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hEdG1mKGNvZGU6IG51bWJlciwgZGlnaXQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGNhc2U6ICdzaXBEdG1mJyxcbiAgICAgICAgdmFsdWU6IG5ldyBTaXBEVE1GKHtcbiAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgIGRpZ2l0OiBkaWdpdCxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICB9XG5cbiAgYXN5bmMgc2VuZENoYXRNZXNzYWdlKHRleHQ6IHN0cmluZywgb3B0aW9ucz86IFNlbmRUZXh0T3B0aW9ucyk6IFByb21pc2U8Q2hhdE1lc3NhZ2U+IHtcbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgIG1lc3NhZ2U6IHRleHQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBhdHRhY2hlZEZpbGVzOiBvcHRpb25zPy5hdHRhY2htZW50cyxcbiAgICB9IGFzIGNvbnN0IHNhdGlzZmllcyBDaGF0TWVzc2FnZTtcbiAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBjYXNlOiAnY2hhdE1lc3NhZ2UnLFxuICAgICAgICB2YWx1ZTogbmV3IENoYXRNZXNzYWdlTW9kZWwoe1xuICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICB0aW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UobXNnLnRpbWVzdGFtcCksXG4gICAgICAgIH0pLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG5cbiAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgbXNnKTtcbiAgICByZXR1cm4gbXNnO1xuICB9XG5cbiAgYXN5bmMgZWRpdENoYXRNZXNzYWdlKGVkaXRUZXh0OiBzdHJpbmcsIG9yaWdpbmFsTWVzc2FnZTogQ2hhdE1lc3NhZ2UpIHtcbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICAuLi5vcmlnaW5hbE1lc3NhZ2UsXG4gICAgICBtZXNzYWdlOiBlZGl0VGV4dCxcbiAgICAgIGVkaXRUaW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfSBhcyBjb25zdCBzYXRpc2ZpZXMgQ2hhdE1lc3NhZ2U7XG4gICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgY2FzZTogJ2NoYXRNZXNzYWdlJyxcbiAgICAgICAgdmFsdWU6IG5ldyBDaGF0TWVzc2FnZU1vZGVsKHtcbiAgICAgICAgICAuLi5tc2csXG4gICAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKG1zZy50aW1lc3RhbXApLFxuICAgICAgICAgIGVkaXRUaW1lc3RhbXA6IHByb3RvSW50NjQucGFyc2UobXNnLmVkaXRUaW1lc3RhbXApLFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNoYXRNZXNzYWdlLCBtc2cpO1xuICAgIHJldHVybiBtc2c7XG4gIH1cblxuICBhc3luYyBzZW5kVGV4dCh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM/OiBTZW5kVGV4dE9wdGlvbnMpOiBQcm9taXNlPFRleHRTdHJlYW1JbmZvPiB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIGNvbnN0IHRleHRJbkJ5dGVzID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgIGNvbnN0IHRvdGFsVGV4dExlbmd0aCA9IHRleHRJbkJ5dGVzLmJ5dGVMZW5ndGg7XG5cbiAgICBjb25zdCBmaWxlSWRzID0gb3B0aW9ucz8uYXR0YWNobWVudHM/Lm1hcCgoKSA9PiBjcnlwdG8ucmFuZG9tVVVJRCgpKTtcblxuICAgIGNvbnN0IHByb2dyZXNzZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihmaWxlSWRzID8gZmlsZUlkcy5sZW5ndGggKyAxIDogMSkuZmlsbCgwKTtcblxuICAgIGNvbnN0IGhhbmRsZVByb2dyZXNzID0gKHByb2dyZXNzOiBudW1iZXIsIGlkeDogbnVtYmVyKSA9PiB7XG4gICAgICBwcm9ncmVzc2VzW2lkeF0gPSBwcm9ncmVzcztcbiAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBwcm9ncmVzc2VzLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XG4gICAgICBvcHRpb25zPy5vblByb2dyZXNzPy4odG90YWxQcm9ncmVzcyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHdyaXRlciA9IGF3YWl0IHRoaXMuc3RyZWFtVGV4dCh7XG4gICAgICBzdHJlYW1JZCxcbiAgICAgIHRvdGFsU2l6ZTogdG90YWxUZXh0TGVuZ3RoLFxuICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBvcHRpb25zPy5kZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICB0b3BpYzogb3B0aW9ucz8udG9waWMsXG4gICAgICBhdHRhY2hlZFN0cmVhbUlkczogZmlsZUlkcyxcbiAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnM/LmF0dHJpYnV0ZXMsXG4gICAgfSk7XG5cbiAgICBhd2FpdCB3cml0ZXIud3JpdGUodGV4dCk7XG4gICAgLy8gc2V0IHRleHQgcGFydCBvZiBwcm9ncmVzcyB0byAxXG4gICAgaGFuZGxlUHJvZ3Jlc3MoMSwgMCk7XG5cbiAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcblxuICAgIGlmIChvcHRpb25zPy5hdHRhY2htZW50cyAmJiBmaWxlSWRzKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgb3B0aW9ucy5hdHRhY2htZW50cy5tYXAoYXN5bmMgKGZpbGUsIGlkeCkgPT5cbiAgICAgICAgICB0aGlzLl9zZW5kRmlsZShmaWxlSWRzW2lkeF0sIGZpbGUsIHtcbiAgICAgICAgICAgIHRvcGljOiBvcHRpb25zLnRvcGljLFxuICAgICAgICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICBoYW5kbGVQcm9ncmVzcyhwcm9ncmVzcywgaWR4ICsgMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlci5pbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsIENBVVRJT04sIG1pZ2h0IGdldCByZW1vdmVkIGluIGEgbWlub3IgcmVsZWFzZVxuICAgKi9cbiAgYXN5bmMgc3RyZWFtVGV4dChvcHRpb25zPzogU3RyZWFtVGV4dE9wdGlvbnMpOiBQcm9taXNlPFRleHRTdHJlYW1Xcml0ZXI+IHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IG9wdGlvbnM/LnN0cmVhbUlkID8/IGNyeXB0by5yYW5kb21VVUlEKCk7XG5cbiAgICBjb25zdCBpbmZvOiBUZXh0U3RyZWFtSW5mbyA9IHtcbiAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB0b3BpYzogb3B0aW9ucz8udG9waWMgPz8gJycsXG4gICAgICBzaXplOiBvcHRpb25zPy50b3RhbFNpemUsXG4gICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zPy5hdHRyaWJ1dGVzLFxuICAgIH07XG4gICAgY29uc3QgaGVhZGVyID0gbmV3IERhdGFTdHJlYW1fSGVhZGVyKHtcbiAgICAgIHN0cmVhbUlkLFxuICAgICAgbWltZVR5cGU6IGluZm8ubWltZVR5cGUsXG4gICAgICB0b3BpYzogaW5mby50b3BpYyxcbiAgICAgIHRpbWVzdGFtcDogbnVtYmVyVG9CaWdJbnQoaW5mby50aW1lc3RhbXApLFxuICAgICAgdG90YWxMZW5ndGg6IG51bWJlclRvQmlnSW50KG9wdGlvbnM/LnRvdGFsU2l6ZSksXG4gICAgICBhdHRyaWJ1dGVzOiBpbmZvLmF0dHJpYnV0ZXMsXG4gICAgICBjb250ZW50SGVhZGVyOiB7XG4gICAgICAgIGNhc2U6ICd0ZXh0SGVhZGVyJyxcbiAgICAgICAgdmFsdWU6IG5ldyBEYXRhU3RyZWFtX1RleHRIZWFkZXIoe1xuICAgICAgICAgIHZlcnNpb246IG9wdGlvbnM/LnZlcnNpb24sXG4gICAgICAgICAgYXR0YWNoZWRTdHJlYW1JZHM6IG9wdGlvbnM/LmF0dGFjaGVkU3RyZWFtSWRzLFxuICAgICAgICAgIHJlcGx5VG9TdHJlYW1JZDogb3B0aW9ucz8ucmVwbHlUb1N0cmVhbUlkLFxuICAgICAgICAgIG9wZXJhdGlvblR5cGU6XG4gICAgICAgICAgICBvcHRpb25zPy50eXBlID09PSAndXBkYXRlJ1xuICAgICAgICAgICAgICA/IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZS5VUERBVEVcbiAgICAgICAgICAgICAgOiBEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUuQ1JFQVRFLFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgZGVzdGluYXRpb25JZGVudGl0aWVzID0gb3B0aW9ucz8uZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGNhc2U6ICdzdHJlYW1IZWFkZXInLFxuICAgICAgICB2YWx1ZTogaGVhZGVyLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG5cbiAgICBsZXQgY2h1bmtJZCA9IDA7XG4gICAgY29uc3QgbG9jYWxQID0gdGhpcztcblxuICAgIGNvbnN0IHdyaXRhYmxlU3RyZWFtID0gbmV3IFdyaXRhYmxlU3RyZWFtPHN0cmluZz4oe1xuICAgICAgLy8gSW1wbGVtZW50IHRoZSBzaW5rXG4gICAgICBhc3luYyB3cml0ZSh0ZXh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgdGV4dEJ5dGVDaHVuayBvZiBzcGxpdFV0ZjgodGV4dCwgU1RSRUFNX0NIVU5LX1NJWkUpKSB7XG4gICAgICAgICAgYXdhaXQgbG9jYWxQLmVuZ2luZS53YWl0Rm9yQnVmZmVyU3RhdHVzTG93KERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgRGF0YVN0cmVhbV9DaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiB0ZXh0Qnl0ZUNodW5rLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBjaHVua0luZGV4OiBudW1iZXJUb0JpZ0ludChjaHVua0lkKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBjaHVua1BhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1DaHVuaycsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXdhaXQgbG9jYWxQLmVuZ2luZS5zZW5kRGF0YVBhY2tldChjaHVua1BhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcblxuICAgICAgICAgIGNodW5rSWQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBjb25zdCB0cmFpbGVyID0gbmV3IERhdGFTdHJlYW1fVHJhaWxlcih7XG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFpbGVyUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2FzZTogJ3N0cmVhbVRyYWlsZXInLFxuICAgICAgICAgICAgdmFsdWU6IHRyYWlsZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGxvY2FsUC5lbmdpbmUuc2VuZERhdGFQYWNrZXQodHJhaWxlclBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgIH0sXG4gICAgICBhYm9ydChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NpbmsgZXJyb3I6JywgZXJyKTtcbiAgICAgICAgLy8gVE9ETyBoYW5kbGUgYWJvcnRzIHRvIHNpZ25hbCBzb21ldGhpbmcgdG8gcmVjZWl2ZXIgc2lkZVxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGxldCBvbkVuZ2luZUNsb3NlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgfTtcblxuICAgIGxvY2FsUC5lbmdpbmUub25jZShFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkVuZ2luZUNsb3NlKTtcblxuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBUZXh0U3RyZWFtV3JpdGVyKHdyaXRhYmxlU3RyZWFtLCBpbmZvLCAoKSA9PlxuICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uRW5naW5lQ2xvc2UpLFxuICAgICk7XG5cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9XG5cbiAgYXN5bmMgc2VuZEZpbGUoXG4gICAgZmlsZTogRmlsZSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgbWltZVR5cGU/OiBzdHJpbmc7XG4gICAgICB0b3BpYz86IHN0cmluZztcbiAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcz86IEFycmF5PHN0cmluZz47XG4gICAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgfSxcbiAgKTogUHJvbWlzZTx7IGlkOiBzdHJpbmcgfT4ge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICBhd2FpdCB0aGlzLl9zZW5kRmlsZShzdHJlYW1JZCwgZmlsZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHsgaWQ6IHN0cmVhbUlkIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9zZW5kRmlsZShcbiAgICBzdHJlYW1JZDogc3RyaW5nLFxuICAgIGZpbGU6IEZpbGUsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIG1pbWVUeXBlPzogc3RyaW5nO1xuICAgICAgdG9waWM/OiBzdHJpbmc7XG4gICAgICBlbmNyeXB0aW9uVHlwZT86IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzPzogQXJyYXk8c3RyaW5nPjtcbiAgICAgIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IG51bWJlcikgPT4gdm9pZDtcbiAgICB9LFxuICApIHtcbiAgICBjb25zdCB3cml0ZXIgPSBhd2FpdCB0aGlzLnN0cmVhbUJ5dGVzKHtcbiAgICAgIHN0cmVhbUlkLFxuICAgICAgdG90YWxTaXplOiBmaWxlLnNpemUsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICBtaW1lVHlwZTogb3B0aW9ucz8ubWltZVR5cGUgPz8gZmlsZS50eXBlLFxuICAgICAgdG9waWM6IG9wdGlvbnM/LnRvcGljLFxuICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBvcHRpb25zPy5kZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgfSk7XG4gICAgY29uc3QgcmVhZGVyID0gZmlsZS5zdHJlYW0oKS5nZXRSZWFkZXIoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgcmV0dXJuIHdyaXRlci5pbmZvO1xuICB9XG5cbiAgYXN5bmMgc3RyZWFtQnl0ZXMob3B0aW9ucz86IHtcbiAgICBuYW1lPzogc3RyaW5nO1xuICAgIHRvcGljPzogc3RyaW5nO1xuICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcz86IEFycmF5PHN0cmluZz47XG4gICAgc3RyZWFtSWQ/OiBzdHJpbmc7XG4gICAgbWltZVR5cGU/OiBzdHJpbmc7XG4gICAgdG90YWxTaXplPzogbnVtYmVyO1xuICB9KSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBvcHRpb25zPy5zdHJlYW1JZCA/PyBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG9wdGlvbnM/LmRlc3RpbmF0aW9uSWRlbnRpdGllcztcblxuICAgIGNvbnN0IGluZm86IEJ5dGVTdHJlYW1JbmZvID0ge1xuICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgbWltZVR5cGU6IG9wdGlvbnM/Lm1pbWVUeXBlID8/ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgdG9waWM6IG9wdGlvbnM/LnRvcGljID8/ICcnLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgYXR0cmlidXRlczogb3B0aW9ucz8uYXR0cmlidXRlcyxcbiAgICAgIHNpemU6IG9wdGlvbnM/LnRvdGFsU2l6ZSxcbiAgICAgIG5hbWU6IG9wdGlvbnM/Lm5hbWUgPz8gJ3Vua25vd24nLFxuICAgIH07XG5cbiAgICBjb25zdCBoZWFkZXIgPSBuZXcgRGF0YVN0cmVhbV9IZWFkZXIoe1xuICAgICAgdG90YWxMZW5ndGg6IG51bWJlclRvQmlnSW50KGluZm8uc2l6ZSA/PyAwKSxcbiAgICAgIG1pbWVUeXBlOiBpbmZvLm1pbWVUeXBlLFxuICAgICAgc3RyZWFtSWQsXG4gICAgICB0b3BpYzogaW5mby50b3BpYyxcbiAgICAgIHRpbWVzdGFtcDogbnVtYmVyVG9CaWdJbnQoRGF0ZS5ub3coKSksXG4gICAgICBjb250ZW50SGVhZGVyOiB7XG4gICAgICAgIGNhc2U6ICdieXRlSGVhZGVyJyxcbiAgICAgICAgdmFsdWU6IG5ldyBEYXRhU3RyZWFtX0J5dGVIZWFkZXIoe1xuICAgICAgICAgIG5hbWU6IGluZm8ubmFtZSxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgY2FzZTogJ3N0cmVhbUhlYWRlcicsXG4gICAgICAgIHZhbHVlOiBoZWFkZXIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuXG4gICAgbGV0IGNodW5rSWQgPSAwO1xuICAgIGNvbnN0IHdyaXRlTXV0ZXggPSBuZXcgTXV0ZXgoKTtcbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLmVuZ2luZTtcbiAgICBjb25zdCBsb2cgPSB0aGlzLmxvZztcblxuICAgIGNvbnN0IHdyaXRhYmxlU3RyZWFtID0gbmV3IFdyaXRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KHtcbiAgICAgIGFzeW5jIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHdyaXRlTXV0ZXgubG9jaygpO1xuXG4gICAgICAgIGxldCBieXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aGlsZSAoYnl0ZU9mZnNldCA8IGNodW5rLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YkNodW5rID0gY2h1bmsuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIFNUUkVBTV9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGF3YWl0IGVuZ2luZS53YWl0Rm9yQnVmZmVyU3RhdHVzTG93KERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgICBjb25zdCBjaHVua1BhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1DaHVuaycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRhU3RyZWFtX0NodW5rKHtcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN1YkNodW5rLFxuICAgICAgICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICAgICAgICBjaHVua0luZGV4OiBudW1iZXJUb0JpZ0ludChjaHVua0lkKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgZW5naW5lLnNlbmREYXRhUGFja2V0KGNodW5rUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgICAgICAgY2h1bmtJZCArPSAxO1xuICAgICAgICAgICAgYnl0ZU9mZnNldCArPSBzdWJDaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBjb25zdCB0cmFpbGVyID0gbmV3IERhdGFTdHJlYW1fVHJhaWxlcih7XG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFpbGVyUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2FzZTogJ3N0cmVhbVRyYWlsZXInLFxuICAgICAgICAgICAgdmFsdWU6IHRyYWlsZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGVuZ2luZS5zZW5kRGF0YVBhY2tldCh0cmFpbGVyUGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgfSxcbiAgICAgIGFib3J0KGVycikge1xuICAgICAgICBsb2cuZXJyb3IoJ1NpbmsgZXJyb3I6JywgZXJyKTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBieXRlV3JpdGVyID0gbmV3IEJ5dGVTdHJlYW1Xcml0ZXIod3JpdGFibGVTdHJlYW0sIGluZm8pO1xuXG4gICAgcmV0dXJuIGJ5dGVXcml0ZXI7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGUgYW4gUlBDIGNhbGwgdG8gYSByZW1vdGUgcGFydGljaXBhbnRcbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIGluaXRpYXRpbmcgdGhlIFJQQyBjYWxsLCBzZWUge0BsaW5rIFBlcmZvcm1ScGNQYXJhbXN9XG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIHBheWxvYWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxuICAgKiBAdGhyb3dzIEVycm9yIG9uIGZhaWx1cmUuIERldGFpbHMgaW4gYG1lc3NhZ2VgLlxuICAgKi9cbiAgYXN5bmMgcGVyZm9ybVJwYyh7XG4gICAgZGVzdGluYXRpb25JZGVudGl0eSxcbiAgICBtZXRob2QsXG4gICAgcGF5bG9hZCxcbiAgICByZXNwb25zZVRpbWVvdXQgPSAxMDAwMCxcbiAgfTogUGVyZm9ybVJwY1BhcmFtcyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgbWF4Um91bmRUcmlwTGF0ZW5jeSA9IDIwMDA7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKGJ5dGVMZW5ndGgocGF5bG9hZCkgPiBNQVhfUEFZTE9BRF9CWVRFUykge1xuICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuZW5naW5lLmxhdGVzdEpvaW5SZXNwb25zZT8uc2VydmVySW5mbz8udmVyc2lvbiAmJlxuICAgICAgICBjb21wYXJlVmVyc2lvbnModGhpcy5lbmdpbmUubGF0ZXN0Sm9pblJlc3BvbnNlPy5zZXJ2ZXJJbmZvPy52ZXJzaW9uLCAnMS44LjAnKSA8IDBcbiAgICAgICkge1xuICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfU0VSVkVSJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgIGF3YWl0IHRoaXMucHVibGlzaFJwY1JlcXVlc3QoXG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdHksXG4gICAgICAgIGlkLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBheWxvYWQsXG4gICAgICAgIHJlc3BvbnNlVGltZW91dCAtIG1heFJvdW5kVHJpcExhdGVuY3ksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBhY2tUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xuICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignQ09OTkVDVElPTl9USU1FT1VUJykpO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3BvbnNlVGltZW91dElkKTtcbiAgICAgIH0sIG1heFJvdW5kVHJpcExhdGVuY3kpO1xuXG4gICAgICB0aGlzLnBlbmRpbmdBY2tzLnNldChpZCwge1xuICAgICAgICByZXNvbHZlOiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGFja1RpbWVvdXRJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IGRlc3RpbmF0aW9uSWRlbnRpdHksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLmRlbGV0ZShpZCk7XG4gICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdSRVNQT05TRV9USU1FT1VUJykpO1xuICAgICAgfSwgcmVzcG9uc2VUaW1lb3V0KTtcblxuICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzLnNldChpZCwge1xuICAgICAgICByZXNvbHZlOiAocmVzcG9uc2VQYXlsb2FkOiBzdHJpbmcgfCBudWxsLCByZXNwb25zZUVycm9yOiBScGNFcnJvciB8IG51bGwpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQocmVzcG9uc2VUaW1lb3V0SWQpO1xuICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdBY2tzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUlBDIHJlc3BvbnNlIHJlY2VpdmVkIGJlZm9yZSBhY2snLCBpZCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZW91dElkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlRXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlUGF5bG9hZCA/PyAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBkZXN0aW5hdGlvbklkZW50aXR5LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByb29tLnJlZ2lzdGVyUnBjTWV0aG9kYCBpbnN0ZWFkXG4gICAqL1xuICByZWdpc3RlclJwY01ldGhvZChtZXRob2Q6IHN0cmluZywgaGFuZGxlcjogKGRhdGE6IFJwY0ludm9jYXRpb25EYXRhKSA9PiBQcm9taXNlPHN0cmluZz4pIHtcbiAgICBpZiAodGhpcy5ycGNIYW5kbGVycy5oYXMobWV0aG9kKSkge1xuICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgYHlvdSdyZSBvdmVycmlkaW5nIHRoZSBSUEMgaGFuZGxlciBmb3IgbWV0aG9kICR7bWV0aG9kfSwgaW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3JgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnJwY0hhbmRsZXJzLnNldChtZXRob2QsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgcm9vbS51bnJlZ2lzdGVyUnBjTWV0aG9kYCBpbnN0ZWFkXG4gICAqL1xuICB1bnJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZDogc3RyaW5nKSB7XG4gICAgdGhpcy5ycGNIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9sIHdobyBjYW4gc3Vic2NyaWJlIHRvIExvY2FsUGFydGljaXBhbnQncyBwdWJsaXNoZWQgdHJhY2tzLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhbGwgcGFydGljaXBhbnRzIGNhbiBzdWJzY3JpYmUuIFRoaXMgYWxsb3dzIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICogd2hvIGlzIGFibGUgdG8gc3Vic2NyaWJlIGF0IGEgcGFydGljaXBhbnQgYW5kIHRyYWNrIGxldmVsLlxuICAgKlxuICAgKiBOb3RlOiBpZiBhY2Nlc3MgaXMgZ2l2ZW4gYXQgYSB0cmFjay1sZXZlbCAoaS5lLiBib3RoIFthbGxQYXJ0aWNpcGFudHNBbGxvd2VkXSBhbmRcbiAgICogW1BhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uLmFsbFRyYWNrc0FsbG93ZWRdIGFyZSBmYWxzZSksIGFueSBuZXdlciBwdWJsaXNoZWQgdHJhY2tzXG4gICAqIHdpbGwgbm90IGdyYW50IHBlcm1pc3Npb25zIHRvIGFueSBwYXJ0aWNpcGFudHMgYW5kIHdpbGwgcmVxdWlyZSBhIHN1YnNlcXVlbnRcbiAgICogcGVybWlzc2lvbnMgdXBkYXRlIHRvIGFsbG93IHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQgQWxsb3dzIGFsbCBwYXJ0aWNpcGFudHMgdG8gc3Vic2NyaWJlIGFsbCB0cmFja3MuXG4gICAqICBUYWtlcyBwcmVjZWRlbmNlIG92ZXIgW1twYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnNdXSBpZiBzZXQgdG8gdHJ1ZS5cbiAgICogIEJ5IGRlZmF1bHQgdGhpcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyBGdWxsIGxpc3Qgb2YgaW5kaXZpZHVhbCBwZXJtaXNzaW9ucyBwZXJcbiAgICogIHBhcnRpY2lwYW50L3RyYWNrLiBBbnkgb21pdHRlZCBwYXJ0aWNpcGFudHMgd2lsbCBub3QgcmVjZWl2ZSBhbnkgcGVybWlzc2lvbnMuXG4gICAqL1xuICBzZXRUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKFxuICAgIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ6IGJvb2xlYW4sXG4gICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiBQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbltdID0gW10sXG4gICkge1xuICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zO1xuICAgIHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlID0gYWxsUGFydGljaXBhbnRzQWxsb3dlZDtcbiAgICBpZiAoIXRoaXMuZW5naW5lLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy51cGRhdGVUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25zKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVJbmNvbWluZ1JwY0FjayhyZXF1ZXN0SWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnBlbmRpbmdBY2tzLmdldChyZXF1ZXN0SWQpO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyLnJlc29sdmUoKTtcbiAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjayByZWNlaXZlZCBmb3IgdW5leHBlY3RlZCBSUEMgcmVxdWVzdCcsIHJlcXVlc3RJZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVJbmNvbWluZ1JwY1Jlc3BvbnNlKFxuICAgIHJlcXVlc3RJZDogc3RyaW5nLFxuICAgIHBheWxvYWQ6IHN0cmluZyB8IG51bGwsXG4gICAgZXJyb3I6IFJwY0Vycm9yIHwgbnVsbCxcbiAgKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5nZXQocmVxdWVzdElkKTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlci5yZXNvbHZlKHBheWxvYWQsIGVycm9yKTtcbiAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUocmVxdWVzdElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignUmVzcG9uc2UgcmVjZWl2ZWQgZm9yIHVuZXhwZWN0ZWQgUlBDIHJlcXVlc3QnLCByZXF1ZXN0SWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHJpdmF0ZSBhc3luYyBwdWJsaXNoUnBjUmVxdWVzdChcbiAgICBkZXN0aW5hdGlvbklkZW50aXR5OiBzdHJpbmcsXG4gICAgcmVxdWVzdElkOiBzdHJpbmcsXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgcGF5bG9hZDogc3RyaW5nLFxuICAgIHJlc3BvbnNlVGltZW91dDogbnVtYmVyLFxuICApIHtcbiAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcbiAgICAgIGtpbmQ6IERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGNhc2U6ICdycGNSZXF1ZXN0JyxcbiAgICAgICAgdmFsdWU6IG5ldyBScGNSZXF1ZXN0KHtcbiAgICAgICAgICBpZDogcmVxdWVzdElkLFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgIHJlc3BvbnNlVGltZW91dE1zOiByZXNwb25zZVRpbWVvdXQsXG4gICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBoYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcpIHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgeyBwYXJ0aWNpcGFudElkZW50aXR5OiBwZW5kaW5nSWRlbnRpdHkgfV0gb2YgdGhpcy5wZW5kaW5nQWNrcykge1xuICAgICAgaWYgKHBlbmRpbmdJZGVudGl0eSA9PT0gcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLmRlbGV0ZShpZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbaWQsIHsgcGFydGljaXBhbnRJZGVudGl0eTogcGVuZGluZ0lkZW50aXR5LCByZXNvbHZlIH1dIG9mIHRoaXMucGVuZGluZ1Jlc3BvbnNlcykge1xuICAgICAgaWYgKHBlbmRpbmdJZGVudGl0eSA9PT0gcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICByZXNvbHZlKG51bGwsIFJwY0Vycm9yLmJ1aWx0SW4oJ1JFQ0lQSUVOVF9ESVNDT05ORUNURUQnKSk7XG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0RW5hYmxlZFB1Ymxpc2hDb2RlY3MoY29kZWNzOiBDb2RlY1tdKSB7XG4gICAgdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzID0gY29kZWNzLmZpbHRlcihcbiAgICAgIChjKSA9PiBjLm1pbWUuc3BsaXQoJy8nKVswXS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8nLFxuICAgICk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbzogUGFydGljaXBhbnRJbmZvKTogYm9vbGVhbiB7XG4gICAgaWYgKGluZm8uc2lkICE9PSB0aGlzLnNpZCkge1xuICAgICAgLy8gZHJvcCB1cGRhdGVzIHRoYXQgc3BlY2lmeSBhIHdyb25nIHNpZC5cbiAgICAgIC8vIHRoZSBzaWQgZm9yIGxvY2FsIHBhcnRpY2lwYW50IGlzIG9ubHkgZXhwbGljaXRseSBzZXQgb24gam9pbiBhbmQgZnVsbCByZWNvbm5lY3RcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIG11dGUgc3RhdHVzLlxuICAgIC8vIGlmIHNlcnZlcidzIHRyYWNrIG11dGUgc3RhdHVzIGRvZXNuJ3QgbWF0Y2ggYWN0dWFsLCB3ZSdsbCBoYXZlIHRvIHVwZGF0ZVxuICAgIC8vIHRoZSBzZXJ2ZXIncyBjb3B5XG4gICAgaW5mby50cmFja3MuZm9yRWFjaCgodGkpID0+IHtcbiAgICAgIGNvbnN0IHB1YiA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRpLnNpZCk7XG5cbiAgICAgIGlmIChwdWIpIHtcbiAgICAgICAgY29uc3QgbXV0ZWRPblNlcnZlciA9IHB1Yi5pc011dGVkIHx8IChwdWIudHJhY2s/LmlzVXBzdHJlYW1QYXVzZWQgPz8gZmFsc2UpO1xuICAgICAgICBpZiAobXV0ZWRPblNlcnZlciAhPT0gdGkubXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgc2VydmVyIG11dGUgc3RhdGUgYWZ0ZXIgcmVjb25jaWxlJywge1xuICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpLFxuICAgICAgICAgICAgbXV0ZWRPblNlcnZlcixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZE11dGVUcmFjayh0aS5zaWQsIG11dGVkT25TZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMgPSAoKSA9PiB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0aW5nIHRyYWNrIHN1YnNjcmlwdGlvbiBwZXJtaXNzaW9ucycsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIGFsbFBhcnRpY2lwYW50c0FsbG93ZWQ6IHRoaXMuYWxsUGFydGljaXBhbnRzQWxsb3dlZFRvU3Vic2NyaWJlLFxuICAgICAgcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zOiB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyxcbiAgICB9KTtcbiAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zKFxuICAgICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUsXG4gICAgICB0aGlzLnBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucy5tYXAoKHApID0+IHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocCkpLFxuICAgICk7XG4gIH07XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwcml2YXRlIG9uVHJhY2tVbm11dGVkID0gKHRyYWNrOiBMb2NhbFRyYWNrKSA9PiB7XG4gICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRyYWNrLmlzVXBzdHJlYW1QYXVzZWQpO1xuICB9O1xuXG4gIC8vIHdoZW4gdGhlIGxvY2FsIHRyYWNrIGNoYW5nZXMgaW4gbXV0ZSBzdGF0dXMsIHdlJ2xsIG5vdGlmeSBzZXJ2ZXIgYXMgc3VjaFxuICAvKiogQGludGVybmFsICovXG4gIHByaXZhdGUgb25UcmFja011dGVkID0gKHRyYWNrOiBMb2NhbFRyYWNrLCBtdXRlZD86IGJvb2xlYW4pID0+IHtcbiAgICBpZiAobXV0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbXV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdHJhY2suc2lkKSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IHVwZGF0ZSBtdXRlIHN0YXR1cyBmb3IgdW5wdWJsaXNoZWQgdHJhY2snLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjayksXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVuZ2luZS51cGRhdGVNdXRlU3RhdHVzKHRyYWNrLnNpZCwgbXV0ZWQpO1xuICB9O1xuXG4gIHByaXZhdGUgb25UcmFja1Vwc3RyZWFtUGF1c2VkID0gKHRyYWNrOiBMb2NhbFRyYWNrKSA9PiB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3Vwc3RyZWFtIHBhdXNlZCcsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgIH0pO1xuICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cnVlKTtcbiAgfTtcblxuICBwcml2YXRlIG9uVHJhY2tVcHN0cmVhbVJlc3VtZWQgPSAodHJhY2s6IExvY2FsVHJhY2spID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygndXBzdHJlYW0gcmVzdW1lZCcsIHtcbiAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgIH0pO1xuICAgIHRoaXMub25UcmFja011dGVkKHRyYWNrLCB0cmFjay5pc011dGVkKTtcbiAgfTtcblxuICBwcml2YXRlIG9uVHJhY2tGZWF0dXJlVXBkYXRlID0gKHRyYWNrOiBMb2NhbEF1ZGlvVHJhY2spID0+IHtcbiAgICBjb25zdCBwdWIgPSB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHRyYWNrLnNpZCEpO1xuICAgIGlmICghcHViKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKFxuICAgICAgICBgQ291bGQgbm90IHVwZGF0ZSBsb2NhbCBhdWRpbyB0cmFjayBzZXR0aW5ncywgbWlzc2luZyBwdWJsaWNhdGlvbiBmb3IgdHJhY2sgJHt0cmFjay5zaWR9YCxcbiAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrU2lkLCBwdWIuZ2V0VHJhY2tGZWF0dXJlcygpKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlID0gYXN5bmMgKHVwZGF0ZTogU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUpID0+IHtcbiAgICBpZiAoIXRoaXMucm9vbU9wdGlvbnM/LmR5bmFjYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHB1YiA9IHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5nZXQodXBkYXRlLnRyYWNrU2lkKTtcbiAgICBpZiAoIXB1Yikge1xuICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgc3Vic2NyaWJlZCBxdWFsaXR5IHVwZGF0ZSBmb3IgdW5rbm93biB0cmFjaycsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICB0cmFja1NpZDogdXBkYXRlLnRyYWNrU2lkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh1cGRhdGUuc3Vic2NyaWJlZENvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoIXB1Yi52aWRlb1RyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IGF3YWl0IHB1Yi52aWRlb1RyYWNrLnNldFB1Ymxpc2hpbmdDb2RlY3ModXBkYXRlLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjb2RlYyBvZiBuZXdDb2RlY3MpIHtcbiAgICAgICAgaWYgKGlzQmFja3VwQ29kZWMoY29kZWMpKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoYHB1Ymxpc2ggJHtjb2RlY30gZm9yICR7cHViLnZpZGVvVHJhY2suc2lkfWAsIHtcbiAgICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2socHViKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBZGRpdGlvbmFsQ29kZWNGb3JUcmFjayhwdWIudmlkZW9UcmFjaywgY29kZWMsIHB1Yi5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgcHViLnZpZGVvVHJhY2s/LnNldFB1Ymxpc2hpbmdMYXllcnModXBkYXRlLnN1YnNjcmliZWRRdWFsaXRpZXMpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9ICh1bnB1Ymxpc2hlZDogVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldCh1bnB1Ymxpc2hlZC50cmFja1NpZCk7XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgdW5wdWJsaXNoZWQgZXZlbnQgZm9yIHVua25vd24gdHJhY2snLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgdHJhY2tTaWQ6IHVucHVibGlzaGVkLnRyYWNrU2lkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2sudHJhY2shKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZVRyYWNrRW5kZWQgPSBhc3luYyAodHJhY2s6IExvY2FsVHJhY2spID0+IHtcbiAgICBpZiAoXG4gICAgICB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSB8fFxuICAgICAgdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpb1xuICAgICkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3VucHVibGlzaGluZyBsb2NhbCB0cmFjayBkdWUgdG8gVHJhY2tFbmRlZCcsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgfSBlbHNlIGlmICh0cmFjay5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgYXdhaXQgdHJhY2subXV0ZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25zID0gYXdhaXQgbmF2aWdhdG9yPy5wZXJtaXNzaW9ucy5xdWVyeSh7XG4gICAgICAgICAgICAgIC8vIHRoZSBwZXJtaXNzaW9uIHF1ZXJ5IGZvciBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgbmFtZTogdHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhID8gJ2NhbWVyYScgOiAnbWljcm9waG9uZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGVybWlzc2lvbnMgJiYgY3VycmVudFBlcm1pc3Npb25zLnN0YXRlID09PSAnZGVuaWVkJykge1xuICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKGB1c2VyIGhhcyByZXZva2VkIGFjY2VzcyB0byAke3RyYWNrLnNvdXJjZX1gLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBkZXRlY3QgZ3JhbnRlZCBjaGFuZ2UgYWZ0ZXIgcGVybWlzc2lvbnMgd2VyZSBkZW5pZWQgdG8gdHJ5IGFuZCByZXN1bWUgdGhlblxuICAgICAgICAgICAgICBjdXJyZW50UGVybWlzc2lvbnMub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9ucy5zdGF0ZSAhPT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghdHJhY2suaXNNdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldFVzZXJNZWRpYSBQZXJtaXNzaW9uIGRlbmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgLy8gcGVybWlzc2lvbnMgcXVlcnkgZmFpbHMgZm9yIGZpcmVmb3gsIHdlIGNvbnRpbnVlIGFuZCB0cnkgdG8gcmVzdGFydCB0aGUgdHJhY2tcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFjay5pc011dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3RyYWNrIGVuZGVkLCBhdHRlbXB0aW5nIHRvIHVzZSBhIGRpZmZlcmVudCBkZXZpY2UnLCB7XG4gICAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCBkZXZpY2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBhd2FpdCB0cmFjay5yZXN0YXJ0VHJhY2soeyBkZXZpY2VJZDogJ2RlZmF1bHQnIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0cmFjay5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybihgY291bGQgbm90IHJlc3RhcnQgdHJhY2ssIG11dGluZyBpbnN0ZWFkYCwge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYWNrLm11dGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBnZXRQdWJsaWNhdGlvbkZvclRyYWNrKFxuICAgIHRyYWNrOiBMb2NhbFRyYWNrIHwgTWVkaWFTdHJlYW1UcmFjayxcbiAgKTogTG9jYWxUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgcHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgY29uc3QgbG9jYWxUcmFjayA9IHB1Yi50cmFjaztcbiAgICAgIGlmICghbG9jYWxUcmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgbG9va3Mgb3Zlcmx5IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGlzIG9iamVjdCB0cmVlXG4gICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgIGlmIChpc0xvY2FsQXVkaW9UcmFjayhsb2NhbFRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayhsb2NhbFRyYWNrKSkge1xuICAgICAgICAgIGlmIChsb2NhbFRyYWNrLm1lZGlhU3RyZWFtVHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHViO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xuICAgICAgICBwdWJsaWNhdGlvbiA9IDxMb2NhbFRyYWNrUHVibGljYXRpb24+cHViO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZTogVHJhY2suU291cmNlKSB7XG4gICAgY29uc3Qgd2FpdEZvclBlbmRpbmdUaW1lb3V0ID0gMTBfMDAwO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IHN0YXJ0VGltZSArIHdhaXRGb3JQZW5kaW5nVGltZW91dCkge1xuICAgICAgY29uc3QgcHVibGlzaFByb21pc2VFbnRyeSA9IEFycmF5LmZyb20odGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzLmVudHJpZXMoKSkuZmluZChcbiAgICAgICAgKFtwZW5kaW5nVHJhY2tdKSA9PiBwZW5kaW5nVHJhY2suc291cmNlID09PSBzb3VyY2UsXG4gICAgICApO1xuICAgICAgaWYgKHB1Ymxpc2hQcm9taXNlRW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHB1Ymxpc2hQcm9taXNlRW50cnlbMV07XG4gICAgICB9XG4gICAgICBhd2FpdCBzbGVlcCgyMCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBQYXJ0aWNpcGFudFRyYWNrcyxcbiAgU3Vic2NyaXB0aW9uRXJyb3IsXG4gIFRyYWNrSW5mbyxcbiAgVXBkYXRlU3Vic2NyaXB0aW9uLFxuICBVcGRhdGVUcmFja1NldHRpbmdzLFxufSBmcm9tICdAbGl2ZWtpdC9wcm90b2NvbCc7XG5pbXBvcnQgeyBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzUmVtb3RlVmlkZW9UcmFjayB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIFJlbW90ZVRyYWNrIGZyb20gJy4vUmVtb3RlVHJhY2snO1xuaW1wb3J0IHsgVHJhY2ssIFZpZGVvUXVhbGl0eSB9IGZyb20gJy4vVHJhY2snO1xuaW1wb3J0IHsgVHJhY2tQdWJsaWNhdGlvbiB9IGZyb20gJy4vVHJhY2tQdWJsaWNhdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZVRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgdHJhY2s/OiBSZW1vdGVUcmFjayA9IHVuZGVmaW5lZDtcblxuICAvKiogQGludGVybmFsICovXG4gIHByb3RlY3RlZCBhbGxvd2VkID0gdHJ1ZTtcblxuICAvLyBrZWVwcyB0cmFjayBvZiBjbGllbnQncyBkZXNpcmUgdG8gc3Vic2NyaWJlIHRvIGEgdHJhY2ssIGFsc28gdHJ1ZSBpZiBhdXRvU3Vic2NyaWJlIGlzIGFjdGl2ZVxuICBwcm90ZWN0ZWQgc3Vic2NyaWJlZD86IGJvb2xlYW47XG5cbiAgcHJvdGVjdGVkIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIGN1cnJlbnRWaWRlb1F1YWxpdHk/OiBWaWRlb1F1YWxpdHkgPSBWaWRlb1F1YWxpdHkuSElHSDtcblxuICBwcm90ZWN0ZWQgdmlkZW9EaW1lbnNpb25zPzogVHJhY2suRGltZW5zaW9ucztcblxuICBwcm90ZWN0ZWQgZnBzPzogbnVtYmVyO1xuXG4gIHByb3RlY3RlZCBzdWJzY3JpcHRpb25FcnJvcj86IFN1YnNjcmlwdGlvbkVycm9yO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGtpbmQ6IFRyYWNrLktpbmQsXG4gICAgdGk6IFRyYWNrSW5mbyxcbiAgICBhdXRvU3Vic2NyaWJlOiBib29sZWFuIHwgdW5kZWZpbmVkLFxuICAgIGxvZ2dlck9wdGlvbnM/OiBMb2dnZXJPcHRpb25zLFxuICApIHtcbiAgICBzdXBlcihraW5kLCB0aS5zaWQsIHRpLm5hbWUsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGF1dG9TdWJzY3JpYmU7XG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgdG8gdGhpcyByZW1vdGUgdHJhY2tcbiAgICogQHBhcmFtIHN1YnNjcmliZWQgdHJ1ZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgZmFsc2UgdG8gdW5zdWJzY3JpYmVcbiAgICovXG4gIHNldFN1YnNjcmliZWQoc3Vic2NyaWJlZDogYm9vbGVhbikge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBzdWJzY3JpYmVkO1xuICAgIC8vIHJlc2V0IGFsbG93ZWQgc3RhdHVzIHdoZW4gZGVzaXJlZCBzdWJzY3JpcHRpb24gc3RhdGUgY2hhbmdlc1xuICAgIC8vIHNlcnZlciB3aWxsIG5vdGlmeSBjbGllbnQgdmlhIHNpZ25hbCBtZXNzYWdlIGlmIGl0J3Mgbm90IGFsbG93ZWRcbiAgICBpZiAoc3Vic2NyaWJlZCkge1xuICAgICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWIgPSBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgc3Vic2NyaWJlOiB0aGlzLnN1YnNjcmliZWQsXG4gICAgICBwYXJ0aWNpcGFudFRyYWNrczogW1xuICAgICAgICBuZXcgUGFydGljaXBhbnRUcmFja3Moe1xuICAgICAgICAgIC8vIHNlbmRpbmcgYW4gZW1wdHkgcGFydGljaXBhbnQgaWQgc2luY2UgVHJhY2tQdWJsaWNhdGlvbiBkb2Vzbid0IGtlZXAgaXRcbiAgICAgICAgICAvLyB0aGlzIGlzIGZpbGxlZCBpbiBieSB0aGUgcGFydGljaXBhbnQgdGhhdCByZWNlaXZlcyB0aGlzIG1lc3NhZ2VcbiAgICAgICAgICBwYXJ0aWNpcGFudFNpZDogJycsXG4gICAgICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF0sXG4gICAgICAgIH0pLFxuICAgICAgXSxcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIHN1Yik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICB9XG5cbiAgZ2V0IHN1YnNjcmlwdGlvblN0YXR1cygpOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5VbnN1YnNjcmliZWQ7XG4gICAgfVxuICAgIGlmICghc3VwZXIuaXNTdWJzY3JpYmVkKSB7XG4gICAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuRGVzaXJlZDtcbiAgICB9XG4gICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlN1YnNjcmliZWQ7XG4gIH1cblxuICBnZXQgcGVybWlzc2lvblN0YXR1cygpOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMge1xuICAgIHJldHVybiB0aGlzLmFsbG93ZWRcbiAgICAgID8gVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLkFsbG93ZWRcbiAgICAgIDogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLk5vdEFsbG93ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRyYWNrIGlzIHN1YnNjcmliZWQsIGFuZCByZWFkeSBmb3IgcGxheWJhY2tcbiAgICovXG4gIGdldCBpc1N1YnNjcmliZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzU3Vic2NyaWJlZDtcbiAgfVxuXG4gIC8vIHJldHVybnMgY2xpZW50J3MgZGVzaXJlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBhbHNvIHRydWUgaWYgYXV0b1N1YnNjcmliZSBpcyBlbmFibGVkXG4gIGdldCBpc0Rlc2lyZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlZCAhPT0gZmFsc2U7XG4gIH1cblxuICBnZXQgaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZDtcbiAgfVxuXG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXNhYmxlIHNlcnZlciBmcm9tIHNlbmRpbmcgZG93biBkYXRhIGZvciB0aGlzIHRyYWNrLiB0aGlzIGlzIHVzZWZ1bCB3aGVuXG4gICAqIHRoZSBwYXJ0aWNpcGFudCBpcyBvZmYgc2NyZWVuLCB5b3UgbWF5IGRpc2FibGUgc3RyZWFtaW5nIGRvd24gdGhlaXIgdmlkZW9cbiAgICogdG8gcmVkdWNlIGJhbmR3aWR0aCByZXF1aXJlbWVudHNcbiAgICogQHBhcmFtIGVuYWJsZWRcbiAgICovXG4gIHNldEVuYWJsZWQoZW5hYmxlZDogYm9vbGVhbikge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB8fCB0aGlzLmRpc2FibGVkID09PSAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVkID0gIWVuYWJsZWQ7XG5cbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZvciB0cmFja3MgdGhhdCBzdXBwb3J0IHNpbXVsY2FzdGluZywgYWRqdXN0IHN1YnNjcmliZWQgcXVhbGl0eVxuICAgKlxuICAgKiBUaGlzIGluZGljYXRlcyB0aGUgaGlnaGVzdCBxdWFsaXR5IHRoZSBjbGllbnQgY2FuIGFjY2VwdC4gaWYgbmV0d29ya1xuICAgKiBiYW5kd2lkdGggZG9lcyBub3QgYWxsb3csIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHkgcmVkdWNlIHF1YWxpdHkgdG9cbiAgICogb3B0aW1pemUgZm9yIHVuaW50ZXJydXB0ZWQgdmlkZW9cbiAgICovXG4gIHNldFZpZGVvUXVhbGl0eShxdWFsaXR5OiBWaWRlb1F1YWxpdHkpIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID09PSBxdWFsaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHF1YWxpdHk7XG4gICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG5cbiAgc2V0VmlkZW9EaW1lbnNpb25zKGRpbWVuc2lvbnM6IFRyYWNrLkRpbWVuc2lvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdGhpcy52aWRlb0RpbWVuc2lvbnM/LndpZHRoID09PSBkaW1lbnNpb25zLndpZHRoICYmXG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucz8uaGVpZ2h0ID09PSBkaW1lbnNpb25zLmhlaWdodFxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICB0aGlzLnZpZGVvRGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cblxuICBzZXRWaWRlb0ZQUyhmcHM6IG51bWJlcikge1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnBzID09PSBmcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZwcyA9IGZwcztcbiAgICB0aGlzLmVtaXRUcmFja1VwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IHZpZGVvUXVhbGl0eSgpOiBWaWRlb1F1YWxpdHkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHNldFRyYWNrKHRyYWNrPzogUmVtb3RlVHJhY2spIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlRyYWNrID0gdGhpcy50cmFjaztcbiAgICBpZiAocHJldlRyYWNrID09PSB0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldlRyYWNrKSB7XG4gICAgICAvLyB1bnJlZ2lzdGVyIGxpc3RlbmVyXG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIHByZXZUcmFjay5kZXRhY2goKTtcbiAgICAgIHByZXZUcmFjay5zdG9wTW9uaXRvcigpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVW5zdWJzY3JpYmVkLCBwcmV2VHJhY2spO1xuICAgIH1cbiAgICBzdXBlci5zZXRUcmFjayh0cmFjayk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5zaWQgPSB0aGlzLnRyYWNrU2lkO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpYmVkLCB0cmFjayk7XG4gICAgfVxuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0QWxsb3dlZChhbGxvd2VkOiBib29sZWFuKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuYWxsb3dlZCA9IGFsbG93ZWQ7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gICAgdGhpcy5lbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZTdGF0dXMpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRTdWJzY3JpcHRpb25FcnJvcihlcnJvcjogU3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIGVycm9yKTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdXBkYXRlSW5mbyhpbmZvOiBUcmFja0luZm8pIHtcbiAgICBzdXBlci51cGRhdGVJbmZvKGluZm8pO1xuICAgIGNvbnN0IHByZXZNZXRhZGF0YU11dGVkID0gdGhpcy5tZXRhZGF0YU11dGVkO1xuICAgIHRoaXMubWV0YWRhdGFNdXRlZCA9IGluZm8ubXV0ZWQ7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2suc2V0TXV0ZWQoaW5mby5tdXRlZCk7XG4gICAgfSBlbHNlIGlmIChwcmV2TWV0YWRhdGFNdXRlZCAhPT0gaW5mby5tdXRlZCkge1xuICAgICAgdGhpcy5lbWl0KGluZm8ubXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldmlvdXNTdGF0dXM6IFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzKSB7XG4gICAgY29uc3QgY3VycmVudFN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGlmIChwcmV2aW91c1N0YXR1cyA9PT0gY3VycmVudFN0YXR1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkLCBjdXJyZW50U3RhdHVzLCBwcmV2aW91c1N0YXR1cyk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKFxuICAgIHByZXZpb3VzUGVybWlzc2lvblN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLFxuICApIHtcbiAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvblN0YXR1cyA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICBpZiAoY3VycmVudFBlcm1pc3Npb25TdGF0dXMgIT09IHByZXZpb3VzUGVybWlzc2lvblN0YXR1cykge1xuICAgICAgdGhpcy5lbWl0KFxuICAgICAgICBUcmFja0V2ZW50LlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLFxuICAgICAgICB0aGlzLnBlcm1pc3Npb25TdGF0dXMsXG4gICAgICAgIHByZXZpb3VzUGVybWlzc2lvblN0YXR1cyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiB0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oXG4gICAgICAgICdhZGFwdGl2ZSBzdHJlYW0gaXMgZW5hYmxlZCwgY2Fubm90IGNoYW5nZSB2aWRlbyB0cmFjayBzZXR0aW5ncycsXG4gICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0Rlc2lyZWQpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2Nhbm5vdCB1cGRhdGUgdHJhY2sgc2V0dGluZ3Mgd2hlbiBub3Qgc3Vic2NyaWJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGhhbmRsZUVuZGVkID0gKHRyYWNrOiBSZW1vdGVUcmFjaykgPT4ge1xuICAgIHRoaXMuc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdHJhY2spO1xuICB9O1xuXG4gIHByb3RlY3RlZCBnZXQgaXNBZGFwdGl2ZVN0cmVhbSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spICYmIHRoaXMudHJhY2suaXNBZGFwdGl2ZVN0cmVhbTtcbiAgfVxuXG4gIHByb3RlY3RlZCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlID0gKHZpc2libGU6IGJvb2xlYW4pID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgIGBhZGFwdGl2ZXN0cmVhbSB2aWRlbyB2aXNpYmlsaXR5ICR7dGhpcy50cmFja1NpZH0sIHZpc2libGU9JHt2aXNpYmxlfWAsXG4gICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgKTtcbiAgICB0aGlzLmRpc2FibGVkID0gIXZpc2libGU7XG4gICAgdGhpcy5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgfTtcblxuICBwcm90ZWN0ZWQgaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlID0gKGRpbWVuc2lvbnM6IFRyYWNrLkRpbWVuc2lvbnMpID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgIGBhZGFwdGl2ZXN0cmVhbSB2aWRlbyBkaW1lbnNpb25zICR7ZGltZW5zaW9ucy53aWR0aH14JHtkaW1lbnNpb25zLmhlaWdodH1gLFxuICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICk7XG4gICAgdGhpcy52aWRlb0RpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH07XG5cbiAgLyogQGludGVybmFsICovXG4gIGVtaXRUcmFja1VwZGF0ZSgpIHtcbiAgICBjb25zdCBzZXR0aW5nczogVXBkYXRlVHJhY2tTZXR0aW5ncyA9IG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICBmcHM6IHRoaXMuZnBzLFxuICAgIH0pO1xuICAgIGlmICh0aGlzLnZpZGVvRGltZW5zaW9ucykge1xuICAgICAgc2V0dGluZ3Mud2lkdGggPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgc2V0dGluZ3MuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMudmlkZW9EaW1lbnNpb25zLmhlaWdodCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dGluZ3MucXVhbGl0eSA9IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdHMgdG8gaGlnaCBxdWFsaXR5XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUge1xuICBQYXJ0aWNpcGFudEluZm8sXG4gIFN1YnNjcmlwdGlvbkVycm9yLFxuICBVcGRhdGVTdWJzY3JpcHRpb24sXG4gIFVwZGF0ZVRyYWNrU2V0dGluZ3MsXG59IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB0eXBlIHsgU2lnbmFsQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgeyBQYXJ0aWNpcGFudEV2ZW50LCBUcmFja0V2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCBSZW1vdGVBdWRpb1RyYWNrIGZyb20gJy4uL3RyYWNrL1JlbW90ZUF1ZGlvVHJhY2snO1xuaW1wb3J0IHR5cGUgUmVtb3RlVHJhY2sgZnJvbSAnLi4vdHJhY2svUmVtb3RlVHJhY2snO1xuaW1wb3J0IFJlbW90ZVRyYWNrUHVibGljYXRpb24gZnJvbSAnLi4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgUmVtb3RlVmlkZW9UcmFjayBmcm9tICcuLi90cmFjay9SZW1vdGVWaWRlb1RyYWNrJztcbmltcG9ydCB7IFRyYWNrIH0gZnJvbSAnLi4vdHJhY2svVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFja1B1YmxpY2F0aW9uIH0gZnJvbSAnLi4vdHJhY2svVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvT3V0cHV0T3B0aW9ucyB9IGZyb20gJy4uL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIH0gZnJvbSAnLi4vdHJhY2svdHlwZXMnO1xuaW1wb3J0IHsgZ2V0TG9nQ29udGV4dEZyb21UcmFjayB9IGZyb20gJy4uL3RyYWNrL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgTG9nZ2VyT3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzQXVkaW9UcmFjaywgaXNSZW1vdGVUcmFjayB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBQYXJ0aWNpcGFudCwgeyBQYXJ0aWNpcGFudEtpbmQgfSBmcm9tICcuL1BhcnRpY2lwYW50JztcbmltcG9ydCB0eXBlIHsgUGFydGljaXBhbnRFdmVudENhbGxiYWNrcyB9IGZyb20gJy4vUGFydGljaXBhbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgYXVkaW9UcmFja1B1YmxpY2F0aW9uczogTWFwPHN0cmluZywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgdmlkZW9UcmFja1B1YmxpY2F0aW9uczogTWFwPHN0cmluZywgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbj47XG5cbiAgdHJhY2tQdWJsaWNhdGlvbnM6IE1hcDxzdHJpbmcsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+O1xuXG4gIHNpZ25hbENsaWVudDogU2lnbmFsQ2xpZW50O1xuXG4gIHByaXZhdGUgdm9sdW1lTWFwOiBNYXA8VHJhY2suU291cmNlLCBudW1iZXI+O1xuXG4gIHByaXZhdGUgYXVkaW9PdXRwdXQ/OiBBdWRpb091dHB1dE9wdGlvbnM7XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZnJvbVBhcnRpY2lwYW50SW5mbyhcbiAgICBzaWduYWxDbGllbnQ6IFNpZ25hbENsaWVudCxcbiAgICBwaTogUGFydGljaXBhbnRJbmZvLFxuICAgIGxvZ2dlck9wdGlvbnM6IExvZ2dlck9wdGlvbnMsXG4gICk6IFJlbW90ZVBhcnRpY2lwYW50IHtcbiAgICByZXR1cm4gbmV3IFJlbW90ZVBhcnRpY2lwYW50KFxuICAgICAgc2lnbmFsQ2xpZW50LFxuICAgICAgcGkuc2lkLFxuICAgICAgcGkuaWRlbnRpdHksXG4gICAgICBwaS5uYW1lLFxuICAgICAgcGkubWV0YWRhdGEsXG4gICAgICBwaS5hdHRyaWJ1dGVzLFxuICAgICAgbG9nZ2VyT3B0aW9ucyxcbiAgICAgIHBpLmtpbmQsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIubG9nQ29udGV4dCxcbiAgICAgIHJwSUQ6IHRoaXMuc2lkLFxuICAgICAgcmVtb3RlUGFydGljaXBhbnQ6IHRoaXMuaWRlbnRpdHksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgc2lnbmFsQ2xpZW50OiBTaWduYWxDbGllbnQsXG4gICAgc2lkOiBzdHJpbmcsXG4gICAgaWRlbnRpdHk/OiBzdHJpbmcsXG4gICAgbmFtZT86IHN0cmluZyxcbiAgICBtZXRhZGF0YT86IHN0cmluZyxcbiAgICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgICBsb2dnZXJPcHRpb25zPzogTG9nZ2VyT3B0aW9ucyxcbiAgICBraW5kOiBQYXJ0aWNpcGFudEtpbmQgPSBQYXJ0aWNpcGFudEtpbmQuU1RBTkRBUkQsXG4gICkge1xuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHkgfHwgJycsIG5hbWUsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zLCBraW5kKTtcbiAgICB0aGlzLnNpZ25hbENsaWVudCA9IHNpZ25hbENsaWVudDtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXVkaW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52b2x1bWVNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikge1xuICAgIHN1cGVyLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuXG4gICAgLy8gcmVnaXN0ZXIgYWN0aW9uIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIChzZXR0aW5nczogVXBkYXRlVHJhY2tTZXR0aW5ncykgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NlbmQgdXBkYXRlIHNldHRpbmdzJywge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIC4uLmdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pLFxuICAgICAgfSk7XG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VcGRhdGVTdWJzY3JpcHRpb24sIChzdWI6IFVwZGF0ZVN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgc3ViLnBhcnRpY2lwYW50VHJhY2tzLmZvckVhY2goKHB0KSA9PiB7XG4gICAgICAgIHB0LnBhcnRpY2lwYW50U2lkID0gdGhpcy5zaWQ7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LnNlbmRVcGRhdGVTdWJzY3JpcHRpb24oc3ViKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihcbiAgICAgIFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsXG4gICAgICAoc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgICB9LFxuICAgICk7XG4gICAgcHVibGljYXRpb24ub24oXG4gICAgICBUcmFja0V2ZW50LlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsXG4gICAgICAoc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cykgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHB1YmxpY2F0aW9uLCBzdGF0dXMpO1xuICAgICAgfSxcbiAgICApO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaWJlZCwgKHRyYWNrOiBSZW1vdGVUcmFjaykgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVW5zdWJzY3JpYmVkLCAocHJldmlvdXNUcmFjazogUmVtb3RlVHJhY2spID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCBwcmV2aW91c1RyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25GYWlsZWQsIChlcnJvcjogU3Vic2NyaXB0aW9uRXJyb3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCBwdWJsaWNhdGlvbi50cmFja1NpZCwgZXJyb3IpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2U6IFRyYWNrLlNvdXJjZSk6IFJlbW90ZVRyYWNrUHVibGljYXRpb24gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHRyYWNrID0gc3VwZXIuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrIGFzIFJlbW90ZVRyYWNrUHVibGljYXRpb247XG4gICAgfVxuICB9XG5cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lOiBzdHJpbmcpOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb25CeU5hbWUobmFtZSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICByZXR1cm4gdHJhY2sgYXMgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIG9uIHRoZSBwYXJ0aWNpcGFudCdzIGF1ZGlvIHRyYWNrXG4gICAqIGJ5IGRlZmF1bHQsIHRoaXMgYWZmZWN0cyB0aGUgbWljcm9waG9uZSBwdWJsaWNhdGlvblxuICAgKiBhIGRpZmZlcmVudCBzb3VyY2UgY2FuIGJlIHBhc3NlZCBpbiBhcyBhIHNlY29uZCBhcmd1bWVudFxuICAgKiBpZiBubyB0cmFjayBleGlzdHMgdGhlIHZvbHVtZSB3aWxsIGJlIGFwcGxpZWQgd2hlbiB0aGUgbWljcm9waG9uZSB0cmFjayBpcyBhZGRlZFxuICAgKi9cbiAgc2V0Vm9sdW1lKFxuICAgIHZvbHVtZTogbnVtYmVyLFxuICAgIHNvdXJjZTogVHJhY2suU291cmNlLk1pY3JvcGhvbmUgfCBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyA9IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lLFxuICApIHtcbiAgICB0aGlzLnZvbHVtZU1hcC5zZXQoc291cmNlLCB2b2x1bWUpO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICBpZiAoYXVkaW9QdWJsaWNhdGlvbiAmJiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICAoYXVkaW9QdWJsaWNhdGlvbi50cmFjayBhcyBSZW1vdGVBdWRpb1RyYWNrKS5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0cyB0aGUgdm9sdW1lIG9uIHRoZSBwYXJ0aWNpcGFudCdzIG1pY3JvcGhvbmUgdHJhY2tcbiAgICovXG4gIGdldFZvbHVtZShcbiAgICBzb3VyY2U6IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lIHwgVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8gPSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSxcbiAgKSB7XG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmIChhdWRpb1B1YmxpY2F0aW9uICYmIGF1ZGlvUHVibGljYXRpb24udHJhY2spIHtcbiAgICAgIHJldHVybiAoYXVkaW9QdWJsaWNhdGlvbi50cmFjayBhcyBSZW1vdGVBdWRpb1RyYWNrKS5nZXRWb2x1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudm9sdW1lTWFwLmdldChzb3VyY2UpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBhZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHNpZDogVHJhY2suU0lELFxuICAgIG1lZGlhU3RyZWFtOiBNZWRpYVN0cmVhbSxcbiAgICByZWNlaXZlcjogUlRDUnRwUmVjZWl2ZXIsXG4gICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncz86IEFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsXG4gICAgdHJpZXNMZWZ0PzogbnVtYmVyLFxuICApIHtcbiAgICAvLyBmaW5kIHRoZSB0cmFjayBwdWJsaWNhdGlvblxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBtZWRpYSB0cmFjayB0byBhcnJpdmUgYmVmb3JlIHBhcnRpY2lwYW50IGluZm9cbiAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzaWQpO1xuXG4gICAgLy8gaXQncyBhbHNvIHBvc3NpYmxlIHRoYXQgdGhlIGJyb3dzZXIgZGlkbid0IGhvbm9yIG91ciBvcmlnaW5hbCB0cmFjayBpZFxuICAgIC8vIEZpcmVGb3ggd291bGQgdXNlIGl0cyBvd24gbG9jYWwgdXVpZCBpbnN0ZWFkIG9mIHNlcnZlciB0cmFjayBpZFxuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIGlmICghc2lkLnN0YXJ0c1dpdGgoJ1RSJykpIHtcbiAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHR5cGVcbiAgICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgaWYgKCFwdWJsaWNhdGlvbiAmJiBtZWRpYVRyYWNrLmtpbmQgPT09IHAua2luZC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBwdWJsaWNhdGlvbiA9IHA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3aGVuIHdlIGNvdWxkbid0IGxvY2F0ZSB0aGUgdHJhY2ssIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgbWV0YWRhdGEgaGFzbid0XG4gICAgLy8geWV0IGFycml2ZWQuIFdhaXQgYSBiaXQgbG9uZ2VyIGZvciBpdCB0byBhcnJpdmUsIG9yIGZpcmUgYW4gZXJyb3JcbiAgICBpZiAoIXB1YmxpY2F0aW9uKSB7XG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSAwKSB7XG4gICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZmluZCBwdWJsaXNoZWQgdHJhY2snLCB7XG4gICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgIHRyYWNrU2lkOiBzaWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJpZXNMZWZ0ID09PSB1bmRlZmluZWQpIHRyaWVzTGVmdCA9IDIwO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soXG4gICAgICAgICAgbWVkaWFUcmFjayxcbiAgICAgICAgICBzaWQsXG4gICAgICAgICAgbWVkaWFTdHJlYW0sXG4gICAgICAgICAgcmVjZWl2ZXIsXG4gICAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyxcbiAgICAgICAgICB0cmllc0xlZnQhIC0gMSxcbiAgICAgICAgKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lZGlhVHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJykge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoXG4gICAgICAgICd1bmFibGUgdG8gc3Vic2NyaWJlIGJlY2F1c2UgTWVkaWFTdHJlYW1UcmFjayBpcyBlbmRlZC4gRG8gbm90IGNhbGwgTWVkaWFTdHJlYW1UcmFjay5zdG9wKCknLFxuICAgICAgICB7IC4uLnRoaXMubG9nQ29udGV4dCwgLi4uZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikgfSxcbiAgICAgICk7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpc1ZpZGVvID0gbWVkaWFUcmFjay5raW5kID09PSAndmlkZW8nO1xuICAgIGxldCB0cmFjazogUmVtb3RlVHJhY2s7XG4gICAgaWYgKGlzVmlkZW8pIHtcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZVZpZGVvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZUF1ZGlvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgdGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXVkaW9PdXRwdXQpO1xuICAgIH1cblxuICAgIC8vIHNldCB0cmFjayBpbmZvXG4gICAgdHJhY2suc291cmNlID0gcHVibGljYXRpb24uc291cmNlO1xuICAgIC8vIGtlZXAgcHVibGljYXRpb24ncyBtdXRlZCBzdGF0dXNcbiAgICB0cmFjay5pc011dGVkID0gcHVibGljYXRpb24uaXNNdXRlZDtcbiAgICB0cmFjay5zZXRNZWRpYVN0cmVhbShtZWRpYVN0cmVhbSk7XG4gICAgdHJhY2suc3RhcnQoKTtcblxuICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHRyYWNrKTtcbiAgICAvLyBzZXQgcGFydGljaXBhbnQgdm9sdW1lcyBvbiBuZXcgYXVkaW8gdHJhY2tzXG4gICAgaWYgKHRoaXMudm9sdW1lTWFwLmhhcyhwdWJsaWNhdGlvbi5zb3VyY2UpICYmIGlzUmVtb3RlVHJhY2sodHJhY2spICYmIGlzQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgIHRyYWNrLnNldFZvbHVtZSh0aGlzLnZvbHVtZU1hcC5nZXQocHVibGljYXRpb24uc291cmNlKSEpO1xuICAgIH1cblxuICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGhhc01ldGFkYXRhKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMucGFydGljaXBhbnRJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHNpZDogVHJhY2suU0lEKTogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHNpZCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbzogUGFydGljaXBhbnRJbmZvKTogYm9vbGVhbiB7XG4gICAgaWYgKCFzdXBlci51cGRhdGVJbmZvKGluZm8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGdldHRpbmcgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgdHJhY2tzLCByZWNvbmNpbGUgaW4gaGVyZVxuICAgIC8vIGFuZCBzZW5kIG91dCBldmVudHMgZm9yIGNoYW5nZXNcblxuICAgIC8vIHJlY29uY2lsZSB0cmFjayBwdWJsaWNhdGlvbnMsIHB1Ymxpc2ggZXZlbnRzIG9ubHkgaWYgbWV0YWRhdGEgaXMgYWxyZWFkeSB0aGVyZVxuICAgIC8vIGkuZS4gY2hhbmdlcyBzaW5jZSB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGpvaW5lZFxuICAgIGNvbnN0IHZhbGlkVHJhY2tzID0gbmV3IE1hcDxzdHJpbmcsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+KCk7XG4gICAgY29uc3QgbmV3VHJhY2tzID0gbmV3IE1hcDxzdHJpbmcsIFJlbW90ZVRyYWNrUHVibGljYXRpb24+KCk7XG5cbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKCh0aSkgPT4ge1xuICAgICAgbGV0IHB1YmxpY2F0aW9uID0gdGhpcy5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQodGkuc2lkKTtcbiAgICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgICAgLy8gbmV3IHB1YmxpY2F0aW9uXG4gICAgICAgIGNvbnN0IGtpbmQgPSBUcmFjay5raW5kRnJvbVByb3RvKHRpLnR5cGUpO1xuICAgICAgICBpZiAoIWtpbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHVibGljYXRpb24gPSBuZXcgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbihcbiAgICAgICAgICBraW5kLFxuICAgICAgICAgIHRpLFxuICAgICAgICAgIHRoaXMuc2lnbmFsQ2xpZW50LmNvbm5lY3RPcHRpb25zPy5hdXRvU3Vic2NyaWJlLFxuICAgICAgICAgIHsgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsIGxvZ2dlck5hbWU6IHRoaXMubG9nZ2VyT3B0aW9ucz8ubG9nZ2VyTmFtZSB9LFxuICAgICAgICApO1xuICAgICAgICBwdWJsaWNhdGlvbi51cGRhdGVJbmZvKHRpKTtcbiAgICAgICAgbmV3VHJhY2tzLnNldCh0aS5zaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUcmFja09mU291cmNlID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5maW5kKFxuICAgICAgICAgIChwdWJsaXNoZWRUcmFjaykgPT4gcHVibGlzaGVkVHJhY2suc291cmNlID09PSBwdWJsaWNhdGlvbj8uc291cmNlLFxuICAgICAgICApO1xuICAgICAgICBpZiAoZXhpc3RpbmdUcmFja09mU291cmNlICYmIHB1YmxpY2F0aW9uLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlVua25vd24pIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgICAgICAgIGByZWNlaXZlZCBhIHNlY29uZCB0cmFjayBwdWJsaWNhdGlvbiBmb3IgJHt0aGlzLmlkZW50aXR5fSB3aXRoIHRoZSBzYW1lIHNvdXJjZTogJHtwdWJsaWNhdGlvbi5zb3VyY2V9YCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICAgICBvbGRUcmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1RyYWNrT2ZTb3VyY2UpLFxuICAgICAgICAgICAgICBuZXdUcmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1YmxpY2F0aW9uLnVwZGF0ZUluZm8odGkpO1xuICAgICAgfVxuICAgICAgdmFsaWRUcmFja3Muc2V0KHRpLnNpZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuXG4gICAgLy8gZGV0ZWN0IHJlbW92ZWQgdHJhY2tzXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgaWYgKCF2YWxpZFRyYWNrcy5oYXMocHVibGljYXRpb24udHJhY2tTaWQpKSB7XG4gICAgICAgIHRoaXMubG9nLnRyYWNlKCdkZXRlY3RlZCByZW1vdmVkIHRyYWNrIG9uIHJlbW90ZSBwYXJ0aWNpcGFudCwgdW5wdWJsaXNoaW5nJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAuLi5nZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYWx3YXlzIGVtaXQgZXZlbnRzIGZvciBuZXcgcHVibGljYXRpb25zLCBSb29tIHdpbGwgbm90IGZvcndhcmQgdGhlbSB1bmxlc3MgaXQncyByZWFkeVxuICAgIG5ld1RyYWNrcy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdW5wdWJsaXNoVHJhY2soc2lkOiBUcmFjay5TSUQsIHNlbmRVbnB1Ymxpc2g/OiBib29sZWFuKSB7XG4gICAgY29uc3QgcHVibGljYXRpb24gPSA8UmVtb3RlVHJhY2tQdWJsaWNhdGlvbj50aGlzLnRyYWNrUHVibGljYXRpb25zLmdldChzaWQpO1xuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhbHNvIHNlbmQgdW5zdWJzY3JpYmUsIGlmIHRyYWNrIGlzIGFjdGl2ZWx5IHN1YnNjcmliZWRcbiAgICBjb25zdCB7IHRyYWNrIH0gPSBwdWJsaWNhdGlvbjtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHRyYWNrIGZyb20gbWFwcyBvbmx5IGFmdGVyIHVuc3Vic2NyaWJlZCBoYXMgYmVlbiBmaXJlZFxuICAgIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XG5cbiAgICAvLyByZW1vdmUgZnJvbSB0aGUgcmlnaHQgdHlwZSBtYXBcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmRlbGV0ZShzaWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzZW5kVW5wdWJsaXNoKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgc2V0QXVkaW9PdXRwdXQob3V0cHV0OiBBdWRpb091dHB1dE9wdGlvbnMpIHtcbiAgICB0aGlzLmF1ZGlvT3V0cHV0ID0gb3V0cHV0O1xuICAgIGNvbnN0IHByb21pc2VzOiBQcm9taXNlPHZvaWQ+W10gPSBbXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCgocHViKSA9PiB7XG4gICAgICBpZiAoaXNBdWRpb1RyYWNrKHB1Yi50cmFjaykgJiYgaXNSZW1vdGVUcmFjayhwdWIudHJhY2spKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2gocHViLnRyYWNrLnNldFNpbmtJZChvdXRwdXQuZGV2aWNlSWQgPz8gJ2RlZmF1bHQnKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbWl0PEUgZXh0ZW5kcyBrZXlvZiBQYXJ0aWNpcGFudEV2ZW50Q2FsbGJhY2tzPihcbiAgICBldmVudDogRSxcbiAgICAuLi5hcmdzOiBQYXJhbWV0ZXJzPFBhcnRpY2lwYW50RXZlbnRDYWxsYmFja3NbRV0+XG4gICk6IGJvb2xlYW4ge1xuICAgIHRoaXMubG9nLnRyYWNlKCdwYXJ0aWNpcGFudCBldmVudCcsIHsgLi4udGhpcy5sb2dDb250ZXh0LCBldmVudCwgYXJncyB9KTtcbiAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IE11dGV4IH0gZnJvbSAnQGxpdmVraXQvbXV0ZXgnO1xuaW1wb3J0IHtcbiAgQ2hhdE1lc3NhZ2UgYXMgQ2hhdE1lc3NhZ2VNb2RlbCxcbiAgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsXG4gIHR5cGUgRGF0YVBhY2tldCxcbiAgRGF0YVBhY2tldF9LaW5kLFxuICBEYXRhU3RyZWFtX0NodW5rLFxuICBEYXRhU3RyZWFtX0hlYWRlcixcbiAgRGF0YVN0cmVhbV9UcmFpbGVyLFxuICBEaXNjb25uZWN0UmVhc29uLFxuICBKb2luUmVzcG9uc2UsXG4gIExlYXZlUmVxdWVzdCxcbiAgTGVhdmVSZXF1ZXN0X0FjdGlvbixcbiAgTWV0cmljc0JhdGNoLFxuICBQYXJ0aWNpcGFudEluZm8sXG4gIFBhcnRpY2lwYW50SW5mb19TdGF0ZSxcbiAgUGFydGljaXBhbnRQZXJtaXNzaW9uLFxuICBSb29tIGFzIFJvb21Nb2RlbCxcbiAgU2VydmVySW5mbyxcbiAgU2ltdWxhdGVTY2VuYXJpbyxcbiAgU2lwRFRNRixcbiAgU3BlYWtlckluZm8sXG4gIFN0cmVhbVN0YXRlVXBkYXRlLFxuICBTdWJzY3JpcHRpb25FcnJvcixcbiAgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSxcbiAgU3Vic2NyaXB0aW9uUmVzcG9uc2UsXG4gIFRyYWNrSW5mbyxcbiAgVHJhY2tTb3VyY2UsXG4gIFRyYWNrVHlwZSxcbiAgVHJhbnNjcmlwdGlvbiBhcyBUcmFuc2NyaXB0aW9uTW9kZWwsXG4gIFRyYW5zY3JpcHRpb25TZWdtZW50IGFzIFRyYW5zY3JpcHRpb25TZWdtZW50TW9kZWwsXG4gIFVzZXJQYWNrZXQsXG4gIHByb3RvSW50NjQsXG59IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEVtaXR0ZXIgZnJvbSAndHlwZWQtZW1pdHRlcic7XG5pbXBvcnQgJ3dlYnJ0Yy1hZGFwdGVyJztcbmltcG9ydCB7IEVuY3J5cHRpb25FdmVudCB9IGZyb20gJy4uL2UyZWUnO1xuaW1wb3J0IHsgdHlwZSBCYXNlRTJFRU1hbmFnZXIsIEUyRUVNYW5hZ2VyIH0gZnJvbSAnLi4vZTJlZS9FMmVlTWFuYWdlcic7XG5pbXBvcnQgbG9nLCB7IExvZ2dlck5hbWVzLCBnZXRMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHR5cGUge1xuICBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucyxcbiAgSW50ZXJuYWxSb29tT3B0aW9ucyxcbiAgUm9vbUNvbm5lY3RPcHRpb25zLFxuICBSb29tT3B0aW9ucyxcbn0gZnJvbSAnLi4vb3B0aW9ucyc7XG5pbXBvcnQgeyBnZXRCcm93c2VyIH0gZnJvbSAnLi4vdXRpbHMvYnJvd3NlclBhcnNlcic7XG5pbXBvcnQgRGV2aWNlTWFuYWdlciBmcm9tICcuL0RldmljZU1hbmFnZXInO1xuaW1wb3J0IFJUQ0VuZ2luZSBmcm9tICcuL1JUQ0VuZ2luZSc7XG5pbXBvcnQgeyBSZWdpb25VcmxQcm92aWRlciB9IGZyb20gJy4vUmVnaW9uVXJsUHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgdHlwZSBCeXRlU3RyZWFtSGFuZGxlcixcbiAgQnl0ZVN0cmVhbVJlYWRlcixcbiAgdHlwZSBUZXh0U3RyZWFtSGFuZGxlcixcbiAgVGV4dFN0cmVhbVJlYWRlcixcbn0gZnJvbSAnLi9TdHJlYW1SZWFkZXInO1xuaW1wb3J0IHtcbiAgYXVkaW9EZWZhdWx0cyxcbiAgcHVibGlzaERlZmF1bHRzLFxuICByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLFxuICByb29tT3B0aW9uRGVmYXVsdHMsXG4gIHZpZGVvRGVmYXVsdHMsXG59IGZyb20gJy4vZGVmYXVsdHMnO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24sIFVuc3VwcG9ydGVkU2VydmVyIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgRW5naW5lRXZlbnQsIFBhcnRpY2lwYW50RXZlbnQsIFJvb21FdmVudCwgVHJhY2tFdmVudCB9IGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCBMb2NhbFBhcnRpY2lwYW50IGZyb20gJy4vcGFydGljaXBhbnQvTG9jYWxQYXJ0aWNpcGFudCc7XG5pbXBvcnQgdHlwZSBQYXJ0aWNpcGFudCBmcm9tICcuL3BhcnRpY2lwYW50L1BhcnRpY2lwYW50JztcbmltcG9ydCB0eXBlIHsgQ29ubmVjdGlvblF1YWxpdHkgfSBmcm9tICcuL3BhcnRpY2lwYW50L1BhcnRpY2lwYW50JztcbmltcG9ydCBSZW1vdGVQYXJ0aWNpcGFudCBmcm9tICcuL3BhcnRpY2lwYW50L1JlbW90ZVBhcnRpY2lwYW50JztcbmltcG9ydCB7IE1BWF9QQVlMT0FEX0JZVEVTLCBScGNFcnJvciwgdHlwZSBScGNJbnZvY2F0aW9uRGF0YSwgYnl0ZUxlbmd0aCB9IGZyb20gJy4vcnBjJztcbmltcG9ydCBDcml0aWNhbFRpbWVycyBmcm9tICcuL3RpbWVycyc7XG5pbXBvcnQgTG9jYWxBdWRpb1RyYWNrIGZyb20gJy4vdHJhY2svTG9jYWxBdWRpb1RyYWNrJztcbmltcG9ydCB0eXBlIExvY2FsVHJhY2sgZnJvbSAnLi90cmFjay9Mb2NhbFRyYWNrJztcbmltcG9ydCBMb2NhbFRyYWNrUHVibGljYXRpb24gZnJvbSAnLi90cmFjay9Mb2NhbFRyYWNrUHVibGljYXRpb24nO1xuaW1wb3J0IExvY2FsVmlkZW9UcmFjayBmcm9tICcuL3RyYWNrL0xvY2FsVmlkZW9UcmFjayc7XG5pbXBvcnQgdHlwZSBSZW1vdGVUcmFjayBmcm9tICcuL3RyYWNrL1JlbW90ZVRyYWNrJztcbmltcG9ydCBSZW1vdGVUcmFja1B1YmxpY2F0aW9uIGZyb20gJy4vdHJhY2svUmVtb3RlVHJhY2tQdWJsaWNhdGlvbic7XG5pbXBvcnQgeyBUcmFjayB9IGZyb20gJy4vdHJhY2svVHJhY2snO1xuaW1wb3J0IHR5cGUgeyBUcmFja1B1YmxpY2F0aW9uIH0gZnJvbSAnLi90cmFjay9UcmFja1B1YmxpY2F0aW9uJztcbmltcG9ydCB0eXBlIHsgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICcuL3RyYWNrL3Byb2Nlc3Nvci90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IEFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgfSBmcm9tICcuL3RyYWNrL3R5cGVzJztcbmltcG9ydCB7IGdldE5ld0F1ZGlvQ29udGV4dCwgc291cmNlVG9LaW5kIH0gZnJvbSAnLi90cmFjay91dGlscyc7XG5pbXBvcnQge1xuICB0eXBlIEJ5dGVTdHJlYW1JbmZvLFxuICB0eXBlIENoYXRNZXNzYWdlLFxuICB0eXBlIFNpbXVsYXRpb25PcHRpb25zLFxuICB0eXBlIFNpbXVsYXRpb25TY2VuYXJpbyxcbiAgdHlwZSBTdHJlYW1Db250cm9sbGVyLFxuICB0eXBlIFRleHRTdHJlYW1JbmZvLFxuICB0eXBlIFRyYW5zY3JpcHRpb25TZWdtZW50LFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIEZ1dHVyZSxcbiAgYmlnSW50VG9OdW1iZXIsXG4gIGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjayxcbiAgZXh0cmFjdENoYXRNZXNzYWdlLFxuICBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzLFxuICBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcixcbiAgZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrLFxuICBpc0Jyb3dzZXJTdXBwb3J0ZWQsXG4gIGlzQ2xvdWQsXG4gIGlzTG9jYWxBdWRpb1RyYWNrLFxuICBpc0xvY2FsUGFydGljaXBhbnQsXG4gIGlzUmVhY3ROYXRpdmUsXG4gIGlzUmVtb3RlUHViLFxuICBpc1NhZmFyaSxcbiAgaXNXZWIsXG4gIG51bWJlclRvQmlnSW50LFxuICBzbGVlcCxcbiAgc3VwcG9ydHNTZXRTaW5rSWQsXG4gIHRvSHR0cFVybCxcbiAgdW5wYWNrU3RyZWFtSWQsXG4gIHVud3JhcENvbnN0cmFpbnQsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZW51bSBDb25uZWN0aW9uU3RhdGUge1xuICBEaXNjb25uZWN0ZWQgPSAnZGlzY29ubmVjdGVkJyxcbiAgQ29ubmVjdGluZyA9ICdjb25uZWN0aW5nJyxcbiAgQ29ubmVjdGVkID0gJ2Nvbm5lY3RlZCcsXG4gIFJlY29ubmVjdGluZyA9ICdyZWNvbm5lY3RpbmcnLFxuICBTaWduYWxSZWNvbm5lY3RpbmcgPSAnc2lnbmFsUmVjb25uZWN0aW5nJyxcbn1cblxuY29uc3QgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSA9IDQgKiAxMDAwO1xuXG4vKipcbiAqIEluIExpdmVLaXQsIGEgcm9vbSBpcyB0aGUgbG9naWNhbCBncm91cGluZyBmb3IgYSBsaXN0IG9mIHBhcnRpY2lwYW50cy5cbiAqIFBhcnRpY2lwYW50cyBpbiBhIHJvb20gY2FuIHB1Ymxpc2ggdHJhY2tzLCBhbmQgc3Vic2NyaWJlIHRvIG90aGVycycgdHJhY2tzLlxuICpcbiAqIGEgUm9vbSBmaXJlcyBbW1Jvb21FdmVudCB8IFJvb21FdmVudHNdXS5cbiAqXG4gKiBAbm9Jbmhlcml0RG9jXG4gKi9cbmNsYXNzIFJvb20gZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEVtaXR0ZXI8Um9vbUV2ZW50Q2FsbGJhY2tzPikge1xuICBzdGF0ZTogQ29ubmVjdGlvblN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDtcblxuICAvKipcbiAgICogbWFwIG9mIGlkZW50aXR5OiBbW1JlbW90ZVBhcnRpY2lwYW50XV1cbiAgICovXG4gIHJlbW90ZVBhcnRpY2lwYW50czogTWFwPHN0cmluZywgUmVtb3RlUGFydGljaXBhbnQ+O1xuXG4gIC8qKlxuICAgKiBsaXN0IG9mIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhY3RpdmVseSBzcGVha2luZy4gd2hlbiB0aGlzIGNoYW5nZXNcbiAgICogYSBbW1Jvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWRdXSBldmVudCBpcyBmaXJlZFxuICAgKi9cbiAgYWN0aXZlU3BlYWtlcnM6IFBhcnRpY2lwYW50W10gPSBbXTtcblxuICAvKiogQGludGVybmFsICovXG4gIGVuZ2luZSE6IFJUQ0VuZ2luZTtcblxuICAvKiogdGhlIGN1cnJlbnQgcGFydGljaXBhbnQgKi9cbiAgbG9jYWxQYXJ0aWNpcGFudDogTG9jYWxQYXJ0aWNpcGFudDtcblxuICAvKiogb3B0aW9ucyBvZiByb29tICovXG4gIG9wdGlvbnM6IEludGVybmFsUm9vbU9wdGlvbnM7XG5cbiAgLyoqIHJlZmxlY3RzIHRoZSBzZW5kZXIgZW5jcnlwdGlvbiBzdGF0dXMgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50ICovXG4gIGlzRTJFRUVuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBzZXJ2ZXJJbmZvPzogUGFydGlhbDxTZXJ2ZXJJbmZvPjtcblxuICBwcml2YXRlIHJvb21JbmZvPzogUm9vbU1vZGVsO1xuXG4gIHByaXZhdGUgc2lkVG9JZGVudGl0eTogTWFwPHN0cmluZywgc3RyaW5nPjtcblxuICAvKiogY29ubmVjdCBvcHRpb25zIG9mIHJvb20gKi9cbiAgcHJpdmF0ZSBjb25uT3B0aW9ucz86IEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zO1xuXG4gIHByaXZhdGUgYXVkaW9FbmFibGVkID0gdHJ1ZTtcblxuICBwcml2YXRlIGF1ZGlvQ29udGV4dD86IEF1ZGlvQ29udGV4dDtcblxuICAvKiogdXNlZCBmb3IgYWJvcnRpbmcgcGVuZGluZyBjb25uZWN0aW9ucyB0byBhIExpdmVLaXQgc2VydmVyICovXG4gIHByaXZhdGUgYWJvcnRDb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyO1xuXG4gIC8qKiBmdXR1cmUgaG9sZGluZyBjbGllbnQgaW5pdGlhdGVkIGNvbm5lY3Rpb24gYXR0ZW1wdCAqL1xuICBwcml2YXRlIGNvbm5lY3RGdXR1cmU/OiBGdXR1cmU8dm9pZD47XG5cbiAgcHJpdmF0ZSBkaXNjb25uZWN0TG9jazogTXV0ZXg7XG5cbiAgcHJpdmF0ZSBlMmVlTWFuYWdlcjogQmFzZUUyRUVNYW5hZ2VyIHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsPzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0SW50ZXJ2YWw+O1xuXG4gIHByaXZhdGUgcmVnaW9uVXJsUHJvdmlkZXI/OiBSZWdpb25VcmxQcm92aWRlcjtcblxuICBwcml2YXRlIHJlZ2lvblVybD86IHN0cmluZztcblxuICBwcml2YXRlIGlzVmlkZW9QbGF5YmFja0Jsb2NrZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGxvZyA9IGxvZztcblxuICBwcml2YXRlIGJ1ZmZlcmVkRXZlbnRzOiBBcnJheTxhbnk+ID0gW107XG5cbiAgcHJpdmF0ZSBpc1Jlc3VtaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIG1hcCB0byBzdG9yZSBmaXJzdCBwb2ludCBpbiB0aW1lIHdoZW4gYSBwYXJ0aWN1bGFyIHRyYW5zY3JpcHRpb24gc2VnbWVudCB3YXMgcmVjZWl2ZWRcbiAgICovXG4gIHByaXZhdGUgdHJhbnNjcmlwdGlvblJlY2VpdmVkVGltZXM6IE1hcDxzdHJpbmcsIG51bWJlcj47XG5cbiAgcHJpdmF0ZSBieXRlU3RyZWFtQ29udHJvbGxlcnMgPSBuZXcgTWFwPHN0cmluZywgU3RyZWFtQ29udHJvbGxlcjxEYXRhU3RyZWFtX0NodW5rPj4oKTtcblxuICBwcml2YXRlIHRleHRTdHJlYW1Db250cm9sbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBTdHJlYW1Db250cm9sbGVyPERhdGFTdHJlYW1fQ2h1bms+PigpO1xuXG4gIHByaXZhdGUgYnl0ZVN0cmVhbUhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIEJ5dGVTdHJlYW1IYW5kbGVyPigpO1xuXG4gIHByaXZhdGUgdGV4dFN0cmVhbUhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIFRleHRTdHJlYW1IYW5kbGVyPigpO1xuXG4gIHByaXZhdGUgcnBjSGFuZGxlcnM6IE1hcDxzdHJpbmcsIChkYXRhOiBScGNJbnZvY2F0aW9uRGF0YSkgPT4gUHJvbWlzZTxzdHJpbmc+PiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSb29tLCB0aGUgcHJpbWFyeSBjb25zdHJ1Y3QgZm9yIGEgTGl2ZUtpdCBzZXNzaW9uLlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IFJvb21PcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc2lkVG9JZGVudGl0eSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLnJvb21PcHRpb25EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuXG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIodGhpcy5vcHRpb25zLmxvZ2dlck5hbWUgPz8gTG9nZ2VyTmFtZXMuUm9vbSk7XG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcyA9IG5ldyBNYXAoKTtcblxuICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyA9IHtcbiAgICAgIC4uLmF1ZGlvRGVmYXVsdHMsXG4gICAgICAuLi5vcHRpb25zPy5hdWRpb0NhcHR1cmVEZWZhdWx0cyxcbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyA9IHtcbiAgICAgIC4uLnZpZGVvRGVmYXVsdHMsXG4gICAgICAuLi5vcHRpb25zPy52aWRlb0NhcHR1cmVEZWZhdWx0cyxcbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucy5wdWJsaXNoRGVmYXVsdHMgPSB7XG4gICAgICAuLi5wdWJsaXNoRGVmYXVsdHMsXG4gICAgICAuLi5vcHRpb25zPy5wdWJsaXNoRGVmYXVsdHMsXG4gICAgfTtcblxuICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcblxuICAgIHRoaXMuZGlzY29ubmVjdExvY2sgPSBuZXcgTXV0ZXgoKTtcblxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCA9IG5ldyBMb2NhbFBhcnRpY2lwYW50KFxuICAgICAgJycsXG4gICAgICAnJyxcbiAgICAgIHRoaXMuZW5naW5lLFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5ycGNIYW5kbGVycyxcbiAgICApO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoXG4gICAgICAgICd2aWRlb2lucHV0JyxcbiAgICAgICAgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoXG4gICAgICAgICdhdWRpb2lucHV0JyxcbiAgICAgICAgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQpLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdWRpb091dHB1dD8uZGV2aWNlSWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKFxuICAgICAgICAnYXVkaW9vdXRwdXQnLFxuICAgICAgICB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCksXG4gICAgICApLmNhdGNoKChlKSA9PiB0aGlzLmxvZy53YXJuKGBDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogJHtlLm1lc3NhZ2V9YCwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlKSB7XG4gICAgICB0aGlzLnNldHVwRTJFRSgpO1xuICAgIH1cblxuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICAgIC8vIGluIG9yZGVyIHRvIGNhdGNoIGRldmljZSBjaGFuZ2VzIHByaW9yIHRvIHJvb20gY29ubmVjdGlvbiB3ZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZSBldmVudCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXM/LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuaGFuZGxlRGV2aWNlQ2hhbmdlLCB7XG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoUm9vbS5jbGVhbnVwUmVnaXN0cnkpIHtcbiAgICAgICAgUm9vbS5jbGVhbnVwUmVnaXN0cnkucmVnaXN0ZXIodGhpcywgKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljOiBzdHJpbmcsIGNhbGxiYWNrOiBUZXh0U3RyZWFtSGFuZGxlcikge1xuICAgIGlmICh0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIHRleHQgc3RyZWFtIGhhbmRsZXIgZm9yIHRvcGljIFwiJHt0b3BpY31cIiBoYXMgYWxyZWFkeSBiZWVuIHNldC5gKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cblxuICB1bnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIodG9waWM6IHN0cmluZykge1xuICAgIHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzLmRlbGV0ZSh0b3BpYyk7XG4gIH1cblxuICByZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljOiBzdHJpbmcsIGNhbGxiYWNrOiBCeXRlU3RyZWFtSGFuZGxlcikge1xuICAgIGlmICh0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIGJ5dGUgc3RyZWFtIGhhbmRsZXIgZm9yIHRvcGljIFwiJHt0b3BpY31cIiBoYXMgYWxyZWFkeSBiZWVuIHNldC5gKTtcbiAgICB9XG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cblxuICB1bnJlZ2lzdGVyQnl0ZVN0cmVhbUhhbmRsZXIodG9waWM6IHN0cmluZykge1xuICAgIHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzLmRlbGV0ZSh0b3BpYyk7XG4gIH1cblxuICAvKipcbiAgICogRXN0YWJsaXNoZXMgdGhlIHBhcnRpY2lwYW50IGFzIGEgcmVjZWl2ZXIgZm9yIGNhbGxzIG9mIHRoZSBzcGVjaWZpZWQgUlBDIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBpbmRpY2F0ZWQgUlBDIG1ldGhvZFxuICAgKiBAcGFyYW0gaGFuZGxlciAtIFdpbGwgYmUgaW52b2tlZCB3aGVuIGFuIFJQQyByZXF1ZXN0IGZvciB0aGlzIG1ldGhvZCBpcyByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtZXRob2QgaXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWRcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGEgaGFuZGxlciBmb3IgdGhpcyBtZXRob2QgaXMgYWxyZWFkeSByZWdpc3RlcmVkIChtdXN0IGNhbGwgdW5yZWdpc3RlclJwY01ldGhvZCBmaXJzdClcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiByb29tLmxvY2FsUGFydGljaXBhbnQ/LnJlZ2lzdGVyUnBjTWV0aG9kKFxuICAgKiAgICdncmVldCcsXG4gICAqICAgYXN5bmMgKGRhdGE6IFJwY0ludm9jYXRpb25EYXRhKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgZ3JlZXRpbmcgZnJvbSAke2RhdGEuY2FsbGVySWRlbnRpdHl9OiAke2RhdGEucGF5bG9hZH1gKTtcbiAgICogICAgIHJldHVybiBgSGVsbG8sICR7ZGF0YS5jYWxsZXJJZGVudGl0eX0hYDtcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgaGFuZGxlciBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxuICAgKiBJZiB1bmFibGUgdG8gcmVzcG9uZCB3aXRoaW4gYHJlc3BvbnNlVGltZW91dGAsIHRoZSByZXF1ZXN0IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIG9uIHRoZSBjYWxsZXIncyBzaWRlLlxuICAgKlxuICAgKiBZb3UgbWF5IHRocm93IGVycm9ycyBvZiB0eXBlIGBScGNFcnJvcmAgd2l0aCBhIHN0cmluZyBgbWVzc2FnZWAgaW4gdGhlIGhhbmRsZXIsXG4gICAqIGFuZCB0aGV5IHdpbGwgYmUgcmVjZWl2ZWQgb24gdGhlIGNhbGxlcidzIHNpZGUgd2l0aCB0aGUgbWVzc2FnZSBpbnRhY3QuXG4gICAqIE90aGVyIGVycm9ycyB0aHJvd24gaW4geW91ciBoYW5kbGVyIHdpbGwgbm90IGJlIHRyYW5zbWl0dGVkIGFzLWlzLCBhbmQgd2lsbCBpbnN0ZWFkIGFycml2ZSB0byB0aGUgY2FsbGVyIGFzIGAxNTAwYCAoXCJBcHBsaWNhdGlvbiBFcnJvclwiKS5cbiAgICovXG4gIHJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZDogc3RyaW5nLCBoYW5kbGVyOiAoZGF0YTogUnBjSW52b2NhdGlvbkRhdGEpID0+IFByb21pc2U8c3RyaW5nPikge1xuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYFJQQyBoYW5kbGVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbWV0aG9kICR7bWV0aG9kfSwgdW5yZWdpc3RlclJwY01ldGhvZCBiZWZvcmUgdHJ5aW5nIHRvIHJlZ2lzdGVyIGFnYWluYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucnBjSGFuZGxlcnMuc2V0KG1ldGhvZCwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgUlBDIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBSUEMgbWV0aG9kIHRvIHVucmVnaXN0ZXJcbiAgICovXG4gIHVucmVnaXN0ZXJScGNNZXRob2QobWV0aG9kOiBzdHJpbmcpIHtcbiAgICB0aGlzLnJwY0hhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVJbmNvbWluZ1JwY1JlcXVlc3QoXG4gICAgY2FsbGVySWRlbnRpdHk6IHN0cmluZyxcbiAgICByZXF1ZXN0SWQ6IHN0cmluZyxcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBwYXlsb2FkOiBzdHJpbmcsXG4gICAgcmVzcG9uc2VUaW1lb3V0OiBudW1iZXIsXG4gICAgdmVyc2lvbjogbnVtYmVyLFxuICApIHtcbiAgICBhd2FpdCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjQWNrKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQpO1xuXG4gICAgaWYgKHZlcnNpb24gIT09IDEpIHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShcbiAgICAgICAgY2FsbGVySWRlbnRpdHksXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgUnBjRXJyb3IuYnVpbHRJbignVU5TVVBQT1JURURfVkVSU0lPTicpLFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5ycGNIYW5kbGVycy5nZXQobWV0aG9kKTtcblxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUucHVibGlzaFJwY1Jlc3BvbnNlKFxuICAgICAgICBjYWxsZXJJZGVudGl0eSxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBudWxsLFxuICAgICAgICBScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9NRVRIT0QnKSxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlc3BvbnNlRXJyb3I6IFJwY0Vycm9yIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IHJlc3BvbnNlUGF5bG9hZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBjYWxsZXJJZGVudGl0eSxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgcmVzcG9uc2VUaW1lb3V0LFxuICAgICAgfSk7XG4gICAgICBpZiAoYnl0ZUxlbmd0aChyZXNwb25zZSkgPiBNQVhfUEFZTE9BRF9CWVRFUykge1xuICAgICAgICByZXNwb25zZUVycm9yID0gUnBjRXJyb3IuYnVpbHRJbignUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0UnKTtcbiAgICAgICAgY29uc29sZS53YXJuKGBSUEMgUmVzcG9uc2UgcGF5bG9hZCB0b28gbGFyZ2UgZm9yICR7bWV0aG9kfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VQYXlsb2FkID0gcmVzcG9uc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJwY0Vycm9yKSB7XG4gICAgICAgIHJlc3BvbnNlRXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgVW5jYXVnaHQgZXJyb3IgcmV0dXJuZWQgYnkgUlBDIGhhbmRsZXIgZm9yICR7bWV0aG9kfS4gUmV0dXJuaW5nIEFQUExJQ0FUSU9OX0VSUk9SIGluc3RlYWQuYCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgKTtcbiAgICAgICAgcmVzcG9uc2VFcnJvciA9IFJwY0Vycm9yLmJ1aWx0SW4oJ0FQUExJQ0FUSU9OX0VSUk9SJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCByZXNwb25zZVBheWxvYWQsIHJlc3BvbnNlRXJyb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGFzeW5jIHNldEUyRUVFbmFibGVkKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5lMmVlTWFuYWdlcikge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRFMkVFRW5hYmxlZChlbmFibGVkKV0pO1xuICAgICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKGVuYWJsZWQsIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdlMmVlIG5vdCBjb25maWd1cmVkLCBwbGVhc2Ugc2V0IGUyZWUgc2V0dGluZ3Mgd2l0aGluIHRoZSByb29tIG9wdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldHVwRTJFRSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUpIHtcbiAgICAgIGlmICgnZTJlZU1hbmFnZXInIGluIHRoaXMub3B0aW9ucy5lMmVlKSB7XG4gICAgICAgIHRoaXMuZTJlZU1hbmFnZXIgPSB0aGlzLm9wdGlvbnMuZTJlZS5lMmVlTWFuYWdlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZTJlZU1hbmFnZXIgPSBuZXcgRTJFRU1hbmFnZXIodGhpcy5vcHRpb25zLmUyZWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5lMmVlTWFuYWdlci5vbihcbiAgICAgICAgRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsXG4gICAgICAgIChlbmFibGVkLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgIGlmIChpc0xvY2FsUGFydGljaXBhbnQocGFydGljaXBhbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmlzRTJFRUVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIGVuYWJsZWQsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyLm9uKEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIChlcnJvcikgPT5cbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGVycm9yKSxcbiAgICAgICk7XG4gICAgICB0aGlzLmUyZWVNYW5hZ2VyPy5zZXR1cCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiB0aGlzLm5hbWUsXG4gICAgICByb29tSUQ6IHRoaXMucm9vbUluZm8/LnNpZCxcbiAgICAgIHBhcnRpY2lwYW50OiB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICBwSUQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiB0aGUgY3VycmVudCByb29tIGhhcyBhIHBhcnRpY2lwYW50IHdpdGggYHJlY29yZGVyOiB0cnVlYCBpbiBpdHMgSldUIGdyYW50XG4gICAqKi9cbiAgZ2V0IGlzUmVjb3JkaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJvb21JbmZvPy5hY3RpdmVSZWNvcmRpbmcgPz8gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogc2VydmVyIGFzc2lnbmVkIHVuaXF1ZSByb29tIGlkLlxuICAgKiByZXR1cm5zIG9uY2UgYSBzaWQgaGFzIGJlZW4gaXNzdWVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAqL1xuICBhc3luYyBnZXRTaWQoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodGhpcy5yb29tSW5mbyAmJiB0aGlzLnJvb21JbmZvLnNpZCAhPT0gJycpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb21JbmZvLnNpZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZVJvb21VcGRhdGUgPSAocm9vbUluZm86IFJvb21Nb2RlbCkgPT4ge1xuICAgICAgICBpZiAocm9vbUluZm8uc2lkICE9PSAnJykge1xuICAgICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgICByZXNvbHZlKHJvb21JbmZvLnNpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW5naW5lLm9mZihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCBoYW5kbGVSb29tVXBkYXRlKTtcbiAgICAgICAgcmVqZWN0KCdSb29tIGRpc2Nvbm5lY3RlZCBiZWZvcmUgcm9vbSBzZXJ2ZXIgaWQgd2FzIGF2YWlsYWJsZScpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogdXNlciBhc3NpZ25lZCBuYW1lLCBkZXJpdmVkIGZyb20gSldUIHRva2VuICovXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucm9vbUluZm8/Lm5hbWUgPz8gJyc7XG4gIH1cblxuICAvKiogcm9vbSBtZXRhZGF0YSAqL1xuICBnZXQgbWV0YWRhdGEoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8ubWV0YWRhdGE7XG4gIH1cblxuICBnZXQgbnVtUGFydGljaXBhbnRzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucm9vbUluZm8/Lm51bVBhcnRpY2lwYW50cyA/PyAwO1xuICB9XG5cbiAgZ2V0IG51bVB1Ymxpc2hlcnMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5yb29tSW5mbz8ubnVtUHVibGlzaGVycyA/PyAwO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXliZUNyZWF0ZUVuZ2luZSgpIHtcbiAgICBpZiAodGhpcy5lbmdpbmUgJiYgIXRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbmdpbmUgPSBuZXcgUlRDRW5naW5lKHRoaXMub3B0aW9ucyk7XG5cbiAgICB0aGlzLmVuZ2luZVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlBhcnRpY2lwYW50VXBkYXRlLCB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcylcbiAgICAgIC5vbihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB0aGlzLmhhbmRsZVJvb21VcGRhdGUpXG4gICAgICAub24oRW5naW5lRXZlbnQuU3BlYWtlcnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVNwZWFrZXJzQ2hhbmdlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5TdHJlYW1TdGF0ZUNoYW5nZWQsIHRoaXMuaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUpXG4gICAgICAub24oRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUpXG4gICAgICAub24oRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uRXJyb3IsIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uRXJyb3IpXG4gICAgICAub24oRW5naW5lRXZlbnQuU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSwgdGhpcy5oYW5kbGVTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKVxuICAgICAgLm9uKFxuICAgICAgICBFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsXG4gICAgICAgIChtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLCBzdHJlYW06IE1lZGlhU3RyZWFtLCByZWNlaXZlcjogUlRDUnRwUmVjZWl2ZXIpID0+IHtcbiAgICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQsIChyZWFzb24/OiBEaXNjb25uZWN0UmVhc29uKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgcmVhc29uKTtcbiAgICAgIH0pXG4gICAgICAub24oRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIHRoaXMuaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUpXG4gICAgICAub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpXG4gICAgICAub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2cuaW5mbygnUmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5TaWduYWxSZWNvbm5lY3RpbmcpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxSZWNvbm5lY3RpbmcpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlJlc3VtZWQsICgpID0+IHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nLmluZm8oJ1Jlc3VtZWQgc2lnbmFsIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgdGhpcy5lbWl0QnVmZmVyZWRFdmVudHMoKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKEVuZ2luZUV2ZW50LlNpZ25hbFJlc3VtZWQsICgpID0+IHtcbiAgICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCB0aGlzLmlzUmVzdW1pbmcpIHtcbiAgICAgICAgICB0aGlzLnNlbmRTeW5jU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlc3RhcnRpbmcpXG4gICAgICAub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZClcbiAgICAgIC5vbihFbmdpbmVFdmVudC5PZmZsaW5lLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oRW5naW5lRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCAoc3RhdHVzLCBraW5kKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xuICAgICAgfSlcbiAgICAgIC5vbihFbmdpbmVFdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCwgKHN1YnNjcmliZWRTaWQpID0+IHtcbiAgICAgICAgY29uc3QgdHJhY2tQdWJsaWNhdGlvbiA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAgIC5nZXRUcmFja1B1YmxpY2F0aW9ucygpXG4gICAgICAgICAgLmZpbmQoKHsgdHJhY2tTaWQgfSkgPT4gdHJhY2tTaWQgPT09IHN1YnNjcmliZWRTaWQpIGFzIExvY2FsVHJhY2tQdWJsaWNhdGlvbiB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCF0cmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgICdjb3VsZCBub3QgZmluZCBsb2NhbCB0cmFjayBzdWJzY3JpcHRpb24gZm9yIHN1YnNjcmliZWQgZXZlbnQnLFxuICAgICAgICAgICAgdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrUHVibGljYXRpb24pO1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFxuICAgICAgICAgIFJvb21FdmVudC5Mb2NhbFRyYWNrU3Vic2NyaWJlZCxcbiAgICAgICAgICB0cmFja1B1YmxpY2F0aW9uLFxuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXRMb2NhbERldmljZXMgYWJzdHJhY3RzIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcy5cbiAgICogSW4gcGFydGljdWxhciwgaXQgcmVxdWVzdHMgZGV2aWNlIHBlcm1pc3Npb25zIGJ5IGRlZmF1bHQgaWYgbmVlZGVkXG4gICAqIGFuZCBtYWtlcyBzdXJlIHRoZSByZXR1cm5lZCBkZXZpY2UgZG9lcyBub3QgY29uc2lzdCBvZiBkdW1teSBkZXZpY2VzXG4gICAqIEBwYXJhbSBraW5kXG4gICAqIEByZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgbG9jYWwgZGV2aWNlc1xuICAgKi9cbiAgc3RhdGljIGdldExvY2FsRGV2aWNlcyhcbiAgICBraW5kPzogTWVkaWFEZXZpY2VLaW5kLFxuICAgIHJlcXVlc3RQZXJtaXNzaW9uczogYm9vbGVhbiA9IHRydWUsXG4gICk6IFByb21pc2U8TWVkaWFEZXZpY2VJbmZvW10+IHtcbiAgICByZXR1cm4gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldERldmljZXMoa2luZCwgcmVxdWVzdFBlcm1pc3Npb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBjbGVhbnVwUmVnaXN0cnkgPVxuICAgIHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGNsZWFudXA6ICgpID0+IHZvaWQpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9KTtcblxuICAvKipcbiAgICogcHJlcGFyZUNvbm5lY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIGxvYWRlZCwgaW4gb3JkZXJcbiAgICogdG8gc3BlZWQgdXAgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdC4gVGhpcyBmdW5jdGlvbiB3aWxsXG4gICAqIC0gcGVyZm9ybSBETlMgcmVzb2x1dGlvbiBhbmQgcHJlLXdhcm0gdGhlIEROUyBjYWNoZVxuICAgKiAtIGVzdGFibGlzaCBUTFMgY29ubmVjdGlvbiBhbmQgY2FjaGUgVExTIGtleXNcbiAgICpcbiAgICogV2l0aCBMaXZlS2l0IENsb3VkLCBpdCB3aWxsIGFsc28gZGV0ZXJtaW5lIHRoZSBiZXN0IGVkZ2UgZGF0YSBjZW50ZXIgZm9yXG4gICAqIHRoZSBjdXJyZW50IGNsaWVudCB0byBjb25uZWN0IHRvIGlmIGEgdG9rZW4gaXMgcHJvdmlkZWQuXG4gICAqL1xuICBhc3luYyBwcmVwYXJlQ29ubmVjdGlvbih1cmw6IHN0cmluZywgdG9rZW4/OiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1ZyhgcHJlcGFyZUNvbm5lY3Rpb24gdG8gJHt1cmx9YCwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB0cnkge1xuICAgICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSAmJiB0b2tlbikge1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHVybCwgdG9rZW4pO1xuICAgICAgICBjb25zdCByZWdpb25VcmwgPSBhd2FpdCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKCk7XG4gICAgICAgIC8vIHdlIHdpbGwgbm90IHJlcGxhY2UgdGhlIHJlZ2lvblVybCBpZiBhbiBhdHRlbXB0IGhhZCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgLy8gdG8gYXZvaWQgb3ZlcnJpZGluZyByZWdpb25VcmwgYWZ0ZXIgYSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0IGhhZCBzdGFydGVkXG4gICAgICAgIGlmIChyZWdpb25VcmwgJiYgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsID0gcmVnaW9uVXJsO1xuICAgICAgICAgIGF3YWl0IGZldGNoKHRvSHR0cFVybChyZWdpb25VcmwpLCB7IG1ldGhvZDogJ0hFQUQnIH0pO1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKGBwcmVwYXJlZCBjb25uZWN0aW9uIHRvICR7cmVnaW9uVXJsfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGZldGNoKHRvSHR0cFVybCh1cmwpLCB7IG1ldGhvZDogJ0hFQUQnIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBwcmVwYXJlIGNvbm5lY3Rpb24nLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdCA9IGFzeW5jICh1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZywgb3B0cz86IFJvb21Db25uZWN0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghaXNCcm93c2VyU3VwcG9ydGVkKCkpIHtcbiAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJXZWJSVEMgaXNuJ3QgZGV0ZWN0ZWQsIGhhdmUgeW91IGNhbGxlZCByZWdpc3Rlckdsb2JhbHM/XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJMaXZlS2l0IGRvZXNuJ3Qgc2VlbSB0byBiZSBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLiBUcnkgdG8gdXBkYXRlIHlvdXIgYnJvd3NlciBhbmQgbWFrZSBzdXJlIG5vIGJyb3dzZXIgZXh0ZW5zaW9ucyBhcmUgZGlzYWJsaW5nIHdlYlJUQy5cIixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIGEgZGlzY29ubmVjdCBjYWxsZWQgaGFwcGVuZWQgcmlnaHQgYmVmb3JlIHRoZSBjb25uZWN0IGNhbGwsIG1ha2Ugc3VyZSB0aGUgZGlzY29ubmVjdCBpcyBjb21wbGV0ZWQgZmlyc3QgYnkgYXdhaXRpbmcgaXRzIGxvY2tcbiAgICBjb25zdCB1bmxvY2tEaXNjb25uZWN0ID0gYXdhaXQgdGhpcy5kaXNjb25uZWN0TG9jay5sb2NrKCk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgLy8gd2hlbiB0aGUgc3RhdGUgaXMgcmVjb25uZWN0aW5nIG9yIGNvbm5lY3RlZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5XG4gICAgICB0aGlzLmxvZy5pbmZvKGBhbHJlYWR5IGNvbm5lY3RlZCB0byByb29tICR7dGhpcy5uYW1lfWAsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29ubmVjdEZ1dHVyZSkge1xuICAgICAgdW5sb2NrRGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyk7XG4gICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXI/LmdldFNlcnZlclVybCgpLnRvU3RyaW5nKCkgIT09IHVybCkge1xuICAgICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNDbG91ZChuZXcgVVJMKHVybCkpKSB7XG4gICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZVRva2VuKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IGZldGNoIHdpdGhvdXQgd2FpdGluZyBmb3IgYSByZXNwb25zZVxuICAgICAgLy8gaWYgaW5pdGlhbCBjb25uZWN0aW9uIGZhaWxzLCB0aGlzIHdpbGwgc3BlZWQgdXAgcGlja2luZyByZWdpb25hbCB1cmxcbiAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcnVuc1xuICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlclxuICAgICAgICAuZmV0Y2hSZWdpb25TZXR0aW5ncygpXG4gICAgICAgIC50aGVuKChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXI/LnNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhzZXR0aW5ncyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3MnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbm5lY3RGbiA9IGFzeW5jIChcbiAgICAgIHJlc29sdmU6ICgpID0+IHZvaWQsXG4gICAgICByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZCxcbiAgICAgIHJlZ2lvblVybD86IHN0cmluZyxcbiAgICApID0+IHtcbiAgICAgIGlmICh0aGlzLmFib3J0Q29udHJvbGxlcikge1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBleHBsaWNpdCBjcmVhdGlvbiBhcyBsb2NhbCB2YXIgbmVlZGVkIHRvIHNhdGlzZnkgVFMgY29tcGlsZXIgd2hlbiBwYXNzaW5nIGl0IHRvIGBhdHRlbXB0Q29ubmVjdGlvbmAgZnVydGhlciBkb3duXG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcblxuICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgaW50ZW50aW9uIHRvIGNvbm5lY3QgaGFzIGJlZW4gc2lnbmFsbGVkIHNvIHdlIGNhbiBhbGxvdyBjYW5jZWxsaW5nIG9mIHRoZSBjb25uZWN0aW9uIHZpYSBkaXNjb25uZWN0KCkgYWdhaW5cbiAgICAgIHVubG9ja0Rpc2Nvbm5lY3Q/LigpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmF0dGVtcHRDb25uZWN0aW9uKHJlZ2lvblVybCA/PyB1cmwsIHRva2VuLCBvcHRzLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciAmJlxuICAgICAgICAgIGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiZcbiAgICAgICAgICBlLnJlYXNvbiAhPT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCAmJlxuICAgICAgICAgIGUucmVhc29uICE9PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZFxuICAgICAgICApIHtcbiAgICAgICAgICBsZXQgbmV4dFVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5leHRVcmwgPSBhd2FpdCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKFxuICAgICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlcj8uc2lnbmFsLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJlxuICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCk7XG4gICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHRVcmwgJiYgIXRoaXMuYWJvcnRDb250cm9sbGVyPy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2cuaW5mbyhcbiAgICAgICAgICAgICAgYEluaXRpYWwgY29ubmVjdGlvbiBmYWlsZWQgd2l0aCBDb25uZWN0aW9uRXJyb3I6ICR7ZS5tZXNzYWdlfS4gUmV0cnlpbmcgd2l0aCBhbm90aGVyIHJlZ2lvbjogJHtuZXh0VXJsfWAsXG4gICAgICAgICAgICAgIHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgICAgICBhd2FpdCBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCBuZXh0VXJsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCxcbiAgICAgICAgICAgICAgZ2V0RGlzY29ubmVjdFJlYXNvbkZyb21Db25uZWN0aW9uRXJyb3IoZSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZGlzY29ubmVjdFJlYXNvbiA9IERpc2Nvbm5lY3RSZWFzb24uVU5LTk9XTl9SRUFTT047XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RSZWFzb24gPSBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBkaXNjb25uZWN0UmVhc29uKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVnaW9uVXJsID0gdGhpcy5yZWdpb25Vcmw7XG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb25uZWN0RnV0dXJlID0gbmV3IEZ1dHVyZShcbiAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdEZuKHJlc29sdmUsIHJlamVjdCwgcmVnaW9uVXJsKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uRnV0dXJlcygpO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xuICB9O1xuXG4gIHByaXZhdGUgY29ubmVjdFNpZ25hbCA9IGFzeW5jIChcbiAgICB1cmw6IHN0cmluZyxcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIGVuZ2luZTogUlRDRW5naW5lLFxuICAgIGNvbm5lY3RPcHRpb25zOiBJbnRlcm5hbFJvb21Db25uZWN0T3B0aW9ucyxcbiAgICByb29tT3B0aW9uczogSW50ZXJuYWxSb29tT3B0aW9ucyxcbiAgICBhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcixcbiAgKTogUHJvbWlzZTxKb2luUmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCBqb2luUmVzcG9uc2UgPSBhd2FpdCBlbmdpbmUuam9pbihcbiAgICAgIHVybCxcbiAgICAgIHRva2VuLFxuICAgICAge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiBjb25uZWN0T3B0aW9ucy5hdXRvU3Vic2NyaWJlLFxuICAgICAgICBhZGFwdGl2ZVN0cmVhbTpcbiAgICAgICAgICB0eXBlb2Ygcm9vbU9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnID8gdHJ1ZSA6IHJvb21PcHRpb25zLmFkYXB0aXZlU3RyZWFtLFxuICAgICAgICBtYXhSZXRyaWVzOiBjb25uZWN0T3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgICBlMmVlRW5hYmxlZDogISF0aGlzLmUyZWVNYW5hZ2VyLFxuICAgICAgICB3ZWJzb2NrZXRUaW1lb3V0OiBjb25uZWN0T3B0aW9ucy53ZWJzb2NrZXRUaW1lb3V0LFxuICAgICAgfSxcbiAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgKTtcblxuICAgIGxldCBzZXJ2ZXJJbmZvOiBQYXJ0aWFsPFNlcnZlckluZm8+IHwgdW5kZWZpbmVkID0gam9pblJlc3BvbnNlLnNlcnZlckluZm87XG4gICAgaWYgKCFzZXJ2ZXJJbmZvKSB7XG4gICAgICBzZXJ2ZXJJbmZvID0geyB2ZXJzaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyVmVyc2lvbiwgcmVnaW9uOiBqb2luUmVzcG9uc2Uuc2VydmVyUmVnaW9uIH07XG4gICAgfVxuICAgIHRoaXMuc2VydmVySW5mbyA9IHNlcnZlckluZm87XG5cbiAgICB0aGlzLmxvZy5kZWJ1ZyhcbiAgICAgIGBjb25uZWN0ZWQgdG8gTGl2ZWtpdCBTZXJ2ZXIgJHtPYmplY3QuZW50cmllcyhzZXJ2ZXJJbmZvKVxuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06ICR7dmFsdWV9YClcbiAgICAgICAgLmpvaW4oJywgJyl9YCxcbiAgICAgIHtcbiAgICAgICAgcm9vbTogam9pblJlc3BvbnNlLnJvb20/Lm5hbWUsXG4gICAgICAgIHJvb21TaWQ6IGpvaW5SZXNwb25zZS5yb29tPy5zaWQsXG4gICAgICAgIGlkZW50aXR5OiBqb2luUmVzcG9uc2UucGFydGljaXBhbnQ/LmlkZW50aXR5LFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgaWYgKCFzZXJ2ZXJJbmZvLnZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFNlcnZlcigndW5rbm93biBzZXJ2ZXIgdmVyc2lvbicpO1xuICAgIH1cblxuICAgIGlmIChzZXJ2ZXJJbmZvLnZlcnNpb24gPT09ICcwLjE1LjEnICYmIHRoaXMub3B0aW9ucy5keW5hY2FzdCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ2Rpc2FibGluZyBkeW5hY2FzdCBkdWUgdG8gc2VydmVyIHZlcnNpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgLy8gZHluYWNhc3QgaGFzIGEgYnVnIGluIDAuMTUuMSwgc28gd2UgY2Fubm90IHVzZSBpdCB0aGVuXG4gICAgICByb29tT3B0aW9ucy5keW5hY2FzdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBqb2luUmVzcG9uc2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBhcHBseUpvaW5SZXNwb25zZSA9IChqb2luUmVzcG9uc2U6IEpvaW5SZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHBpID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50ITtcblxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQgPSBwaS5zaWQ7XG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5ID0gcGkuaWRlbnRpdHk7XG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldEVuYWJsZWRQdWJsaXNoQ29kZWNzKGpvaW5SZXNwb25zZS5lbmFibGVkUHVibGlzaENvZGVjcyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUgJiYgdGhpcy5lMmVlTWFuYWdlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5lMmVlTWFuYWdlci5zZXRTaWZUcmFpbGVyKGpvaW5SZXNwb25zZS5zaWZUcmFpbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiAnQ291bGQgbm90IHNldCBTaWZUcmFpbGVyJywge1xuICAgICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcG9wdWxhdGUgcmVtb3RlIHBhcnRpY2lwYW50cywgdGhlc2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIG5ldyBldmVudHNcbiAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyhbcGksIC4uLmpvaW5SZXNwb25zZS5vdGhlclBhcnRpY2lwYW50c10pO1xuXG4gICAgaWYgKGpvaW5SZXNwb25zZS5yb29tKSB7XG4gICAgICB0aGlzLmhhbmRsZVJvb21VcGRhdGUoam9pblJlc3BvbnNlLnJvb20pO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGF0dGVtcHRDb25uZWN0aW9uID0gYXN5bmMgKFxuICAgIHVybDogc3RyaW5nLFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgb3B0czogUm9vbUNvbm5lY3RPcHRpb25zIHwgdW5kZWZpbmVkLFxuICAgIGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICApID0+IHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8XG4gICAgICB0aGlzLmlzUmVzdW1pbmcgfHxcbiAgICAgIHRoaXMuZW5naW5lPy5wZW5kaW5nUmVjb25uZWN0XG4gICAgKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCByZXBsYWNlZCBieSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbG9zZSBhbmQgcmVjcmVhdGUgdGhlIGV4aXN0aW5nIGVuZ2luZSBpbiBvcmRlciB0byBnZXQgcmlkIG9mIGFueSBwb3RlbnRpYWxseSBvbmdvaW5nIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjcmVhdGUgZW5naW5lIGlmIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkXG4gICAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlZ2lvblVybFByb3ZpZGVyPy5pc0Nsb3VkKCkpIHtcbiAgICAgIHRoaXMuZW5naW5lLnNldFJlZ2lvblVybFByb3ZpZGVyKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpO1xuICAgIH1cblxuICAgIHRoaXMuYWNxdWlyZUF1ZGlvQ29udGV4dCgpO1xuXG4gICAgdGhpcy5jb25uT3B0aW9ucyA9IHsgLi4ucm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cywgLi4ub3B0cyB9IGFzIEludGVybmFsUm9vbUNvbm5lY3RPcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucnRjQ29uZmlnKSB7XG4gICAgICB0aGlzLmVuZ2luZS5ydGNDb25maWcgPSB0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubk9wdGlvbnMucGVlckNvbm5lY3Rpb25UaW1lb3V0KSB7XG4gICAgICB0aGlzLmVuZ2luZS5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSB0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25uZWN0U2lnbmFsKFxuICAgICAgICB1cmwsXG4gICAgICAgIHRva2VuLFxuICAgICAgICB0aGlzLmVuZ2luZSxcbiAgICAgICAgdGhpcy5jb25uT3B0aW9ucyxcbiAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXIsXG4gICAgICApO1xuXG4gICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICAvLyBmb3J3YXJkIG1ldGFkYXRhIGNoYW5nZWQgZm9yIHRoZSBsb2NhbCBwYXJ0aWNpcGFudFxuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICBjb25zdCByZXN1bHRpbmdFcnJvciA9IG5ldyBDb25uZWN0aW9uRXJyb3IoXG4gICAgICAgIGBjb3VsZCBub3QgZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uYCxcbiAgICAgICAgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlLFxuICAgICAgKTtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXN1bHRpbmdFcnJvci5tZXNzYWdlID0gYCR7cmVzdWx0aW5nRXJyb3IubWVzc2FnZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgcmVzdWx0aW5nRXJyb3IucmVhc29uID0gZXJyLnJlYXNvbjtcbiAgICAgICAgcmVzdWx0aW5nRXJyb3Iuc3RhdHVzID0gZXJyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKGBlcnJvciB0cnlpbmcgdG8gZXN0YWJsaXNoIHNpZ25hbCBjb25uZWN0aW9uYCwge1xuICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9KTtcbiAgICAgIHRocm93IHJlc3VsdGluZ0Vycm9yO1xuICAgIH1cblxuICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICB0aHJvdyBuZXcgQ29ubmVjdGlvbkVycm9yKGBDb25uZWN0aW9uIGF0dGVtcHQgYWJvcnRlZGAsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmVuZ2luZS53YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbihcbiAgICAgICAgdGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgLy8gYWxzbyBob29rIHVubG9hZCBldmVudFxuICAgIGlmIChpc1dlYigpICYmIHRoaXMub3B0aW9ucy5kaXNjb25uZWN0T25QYWdlTGVhdmUpIHtcbiAgICAgIC8vIGNhcHR1cmluZyBib3RoICdwYWdlaGlkZScgYW5kICdiZWZvcmV1bmxvYWQnIHRvIGNhcHR1cmUgYnJvYWRlc3Qgc2V0IG9mIGJyb3dzZXIgYmVoYXZpb3JzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICB9XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgIH1cbiAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGRpc2Nvbm5lY3RzIHRoZSByb29tLCBlbWl0cyBbW1Jvb21FdmVudC5EaXNjb25uZWN0ZWRdXVxuICAgKi9cbiAgZGlzY29ubmVjdCA9IGFzeW5jIChzdG9wVHJhY2tzID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHVubG9jayA9IGF3YWl0IHRoaXMuZGlzY29ubmVjdExvY2subG9jaygpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnYWxyZWFkeSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5pbmZvKCdkaXNjb25uZWN0IGZyb20gcm9vbScsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgfSk7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0aW5nIHx8XG4gICAgICAgIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcgfHxcbiAgICAgICAgdGhpcy5pc1Jlc3VtaW5nXG4gICAgICApIHtcbiAgICAgICAgLy8gdHJ5IGFib3J0aW5nIHBlbmRpbmcgY29ubmVjdGlvbiBhdHRlbXB0XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2Fib3J0IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBhYm9ydCBjb250cm9sbGVyIGRpZG4ndCBtYW5hZ2UgdG8gY2FuY2VsIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQsIHJlamVjdCB0aGUgY29ubmVjdCBwcm9taXNlIGV4cGxpY2l0bHlcbiAgICAgICAgdGhpcy5jb25uZWN0RnV0dXJlPy5yZWplY3Q/LihcbiAgICAgICAgICBuZXcgQ29ubmVjdGlvbkVycm9yKCdDbGllbnQgaW5pdGlhdGVkIGRpc2Nvbm5lY3QnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKSxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgLy8gc2VuZCBsZWF2ZVxuICAgICAgaWYgKCF0aGlzLmVuZ2luZT8uY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsb3NlIGVuZ2luZSAoYWxzbyBjbG9zZXMgY2xpZW50KVxuICAgICAgaWYgKHRoaXMuZW5naW5lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3Qoc3RvcFRyYWNrcywgRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEKTtcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIHRoaXMuZW5naW5lID0gdW5kZWZpbmVkO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bmxvY2soKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJldHJpZXZlcyBhIHBhcnRpY2lwYW50IGJ5IGlkZW50aXR5XG4gICAqIEBwYXJhbSBpZGVudGl0eVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0UGFydGljaXBhbnRCeUlkZW50aXR5KGlkZW50aXR5OiBzdHJpbmcpOiBQYXJ0aWNpcGFudCB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhckNvbm5lY3Rpb25GdXR1cmVzKCkge1xuICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgZm9yIHRlc3RpbmdcbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW86IFNpbXVsYXRpb25TY2VuYXJpbywgYXJnPzogYW55KSB7XG4gICAgbGV0IHBvc3RBY3Rpb24gPSAoKSA9PiB7fTtcbiAgICBsZXQgcmVxOiBTaW11bGF0ZVNjZW5hcmlvIHwgdW5kZWZpbmVkO1xuICAgIHN3aXRjaCAoc2NlbmFyaW8pIHtcbiAgICAgIGNhc2UgJ3NpZ25hbC1yZWNvbm5lY3QnOlxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIGRpc2Nvbm5lY3QnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzcGVha2VyJzpcbiAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICBjYXNlOiAnc3BlYWtlclVwZGF0ZScsXG4gICAgICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdub2RlLWZhaWx1cmUnOlxuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdub2RlRmFpbHVyZScsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZXJ2ZXItbGVhdmUnOlxuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdzZXJ2ZXJMZWF2ZScsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWdyYXRpb24nOlxuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdtaWdyYXRpb24nLFxuICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVzdW1lLXJlY29ubmVjdCc6XG4gICAgICAgIHRoaXMuZW5naW5lLmZhaWxOZXh0KCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICBhd2FpdCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXNjb25uZWN0LXNpZ25hbC1vbi1yZXN1bWUnOlxuICAgICAgICBwb3N0QWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIGF3YWl0IHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSByZXN1bWUtZGlzY29ubmVjdCcpO1xuICAgICAgICB9O1xuICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgIGNhc2U6ICdkaXNjb25uZWN0U2lnbmFsT25SZXN1bWUnLFxuICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlzY29ubmVjdC1zaWduYWwtb24tcmVzdW1lLW5vLW1lc3NhZ2VzJzpcbiAgICAgICAgcG9zdEFjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgICBhd2FpdCB0aGlzLmVuZ2luZS5jbGllbnQuaGFuZGxlT25DbG9zZSgnc2ltdWxhdGUgcmVzdW1lLWRpc2Nvbm5lY3QnKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICBjYXNlOiAnZGlzY29ubmVjdFNpZ25hbE9uUmVzdW1lTm9NZXNzYWdlcycsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmdWxsLXJlY29ubmVjdCc6XG4gICAgICAgIHRoaXMuZW5naW5lLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIHByaXZhdGVcbiAgICAgICAgYXdhaXQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIGZ1bGwtcmVjb25uZWN0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZm9yY2UtdGNwJzpcbiAgICAgIGNhc2UgJ2ZvcmNlLXRscyc6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ3N3aXRjaENhbmRpZGF0ZVByb3RvY29sJyxcbiAgICAgICAgICAgIHZhbHVlOiBzY2VuYXJpbyA9PT0gJ2ZvcmNlLXRscycgPyAyIDogMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcG9zdEFjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBvbkxlYXZlID0gdGhpcy5lbmdpbmUuY2xpZW50Lm9uTGVhdmU7XG4gICAgICAgICAgaWYgKG9uTGVhdmUpIHtcbiAgICAgICAgICAgIG9uTGVhdmUoXG4gICAgICAgICAgICAgIG5ldyBMZWF2ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxuICAgICAgICAgICAgICAgIGFjdGlvbjogTGVhdmVSZXF1ZXN0X0FjdGlvbi5SRUNPTk5FQ1QsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3Vic2NyaWJlci1iYW5kd2lkdGgnOlxuICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGFyZyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1YnNjcmliZXItYmFuZHdpZHRoIHJlcXVpcmVzIGEgbnVtYmVyIGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICBjYXNlOiAnc3Vic2NyaWJlckJhbmR3aWR0aCcsXG4gICAgICAgICAgICB2YWx1ZTogbnVtYmVyVG9CaWdJbnQoYXJnKSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWF2ZS1mdWxsLXJlY29ubmVjdCc6XG4gICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgY2FzZTogJ2xlYXZlUmVxdWVzdEZ1bGxSZWNvbm5lY3QnLFxuICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICBpZiAocmVxKSB7XG4gICAgICBhd2FpdCB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFNpbXVsYXRlU2NlbmFyaW8ocmVxKTtcbiAgICAgIGF3YWl0IHBvc3RBY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uUGFnZUxlYXZlID0gYXN5bmMgKCkgPT4ge1xuICAgIHRoaXMubG9nLmluZm8oJ1BhZ2UgbGVhdmUgZGV0ZWN0ZWQsIGRpc2Nvbm5lY3RpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCcm93c2VycyBoYXZlIGRpZmZlcmVudCBwb2xpY2llcyByZWdhcmRpbmcgYXVkaW8gcGxheWJhY2suIE1vc3QgcmVxdWlyaW5nXG4gICAqIHNvbWUgZm9ybSBvZiB1c2VyIGludGVyYWN0aW9uIChjbGljay90YXAvZXRjKS5cbiAgICogSW4gdGhvc2UgY2FzZXMsIGF1ZGlvIHdpbGwgYmUgc2lsZW50IHVudGlsIGEgY2xpY2svdGFwIHRyaWdnZXJpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICogLSBgc3RhcnRBdWRpb2BcbiAgICogLSBgZ2V0VXNlck1lZGlhYFxuICAgKi9cbiAgc3RhcnRBdWRpbyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50czogQXJyYXk8SFRNTE1lZGlhRWxlbWVudD4gPSBbXTtcbiAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgIGlmIChicm93c2VyICYmIGJyb3dzZXIub3MgPT09ICdpT1MnKSB7XG4gICAgICAvKipcbiAgICAgICAqIGlPUyBibG9ja3MgYXVkaW8gZWxlbWVudCBwbGF5YmFjayBpZlxuICAgICAgICogLSB1c2VyIGlzIG5vdCBwdWJsaXNoaW5nIGF1ZGlvIHRoZW1zZWx2ZXMgYW5kXG4gICAgICAgKiAtIG5vIG90aGVyIGF1ZGlvIHNvdXJjZSBpcyBwbGF5aW5nXG4gICAgICAgKlxuICAgICAgICogYXMgYSB3b3JrYXJvdW5kLCB3ZSBjcmVhdGUgYW4gYXVkaW8gZWxlbWVudCB3aXRoIGFuIGVtcHR5IHRyYWNrLCBzbyB0aGF0XG4gICAgICAgKiBzaWxlbnQgYXVkaW8gaXMgYWx3YXlzIHBsYXlpbmdcbiAgICAgICAqL1xuICAgICAgY29uc3QgYXVkaW9JZCA9ICdsaXZla2l0LWR1bW15LWF1ZGlvLWVsJztcbiAgICAgIGxldCBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhdWRpb0lkKSBhcyBIVE1MQXVkaW9FbGVtZW50IHwgbnVsbDtcbiAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XG4gICAgICAgIGR1bW15QXVkaW9FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICAgIGR1bW15QXVkaW9FbC5pZCA9IGF1ZGlvSWQ7XG4gICAgICAgIGR1bW15QXVkaW9FbC5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIGR1bW15QXVkaW9FbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xuICAgICAgICB0cmFjay5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKFt0cmFja10pO1xuICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgIGlmICghZHVtbXlBdWRpb0VsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHNldCB0aGUgc3JjT2JqZWN0IHRvIG51bGwgb24gcGFnZSBoaWRlIGluIG9yZGVyIHRvIHByZXZlbnQgbG9jayBzY3JlZW4gY29udHJvbHMgdG8gc2hvdyB1cCBmb3IgaXRcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gZG9jdW1lbnQuaGlkZGVuID8gbnVsbCA6IHN0cmVhbTtcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXG4gICAgICAgICAgICAgICdwYWdlIHZpc2libGUgYWdhaW4sIHRyaWdnZXJpbmcgc3RhcnRBdWRpbyB0byByZXN1bWUgcGxheWJhY2sgYW5kIHVwZGF0ZSBwbGF5YmFjayBzdGF0dXMnLFxuICAgICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5zdGFydEF1ZGlvKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZHVtbXlBdWRpb0VsKTtcbiAgICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgICBkdW1teUF1ZGlvRWw/LnJlbW92ZSgpO1xuICAgICAgICAgIGR1bW15QXVkaW9FbCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxlbWVudHMucHVzaChkdW1teUF1ZGlvRWwpO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2goKHApID0+IHtcbiAgICAgIHAuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgIGlmICh0LnRyYWNrKSB7XG4gICAgICAgICAgdC50cmFjay5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5hY3F1aXJlQXVkaW9Db250ZXh0KCksXG4gICAgICAgIC4uLmVsZW1lbnRzLm1hcCgoZSkgPT4ge1xuICAgICAgICAgIGUubXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZS5wbGF5KCk7XG4gICAgICAgIH0pLFxuICAgICAgXSk7XG4gICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQoZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH07XG5cbiAgc3RhcnRWaWRlbyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50czogSFRNTE1lZGlhRWxlbWVudFtdID0gW107XG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICBwLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCgodHIpID0+IHtcbiAgICAgICAgdHIudHJhY2s/LmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnRzLmluY2x1ZGVzKGVsKSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoKGVsKSA9PiBlbC5wbGF5KCkpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tTdGFydGVkKCk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcbiAgICAgICAgICAgICdSZXN1bWluZyB2aWRlbyBwbGF5YmFjayBmYWlsZWQsIG1ha2Ugc3VyZSB5b3UgY2FsbCBgc3RhcnRWaWRlb2AgZGlyZWN0bHkgaW4gYSB1c2VyIGdlc3R1cmUgaGFuZGxlcicsXG4gICAgICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhdWRpbyBwbGF5YmFjayBpcyBlbmFibGVkXG4gICAqL1xuICBnZXQgY2FuUGxheWJhY2tBdWRpbygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb0VuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHZpZGVvIHBsYXliYWNrIGlzIGVuYWJsZWRcbiAgICovXG4gIGdldCBjYW5QbGF5YmFja1ZpZGVvKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkO1xuICB9XG5cbiAgZ2V0QWN0aXZlRGV2aWNlKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGtpbmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGFsbCBhY3RpdmUgZGV2aWNlcyB1c2VkIGluIHRoaXMgcm9vbSB0byB0aGUgZ2l2ZW4gZGV2aWNlLlxuICAgKlxuICAgKiBOb3RlOiBzZXR0aW5nIEF1ZGlvT3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2Vycy4gU2VlIFtzZXRTaW5rSWRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gICAqXG4gICAqIEBwYXJhbSBraW5kIHVzZSBgdmlkZW9pbnB1dGAgZm9yIGNhbWVyYSB0cmFjayxcbiAgICogIGBhdWRpb2lucHV0YCBmb3IgbWljcm9waG9uZSB0cmFjayxcbiAgICogIGBhdWRpb291dHB1dGAgdG8gc2V0IHNwZWFrZXIgZm9yIGFsbCBpbmNvbWluZyBhdWRpbyB0cmFja3NcbiAgICogQHBhcmFtIGRldmljZUlkXG4gICAqL1xuICBhc3luYyBzd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZDogTWVkaWFEZXZpY2VLaW5kLCBkZXZpY2VJZDogc3RyaW5nLCBleGFjdDogYm9vbGVhbiA9IHRydWUpIHtcbiAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgbGV0IG5lZWRzVXBkYXRlV2l0aG91dFRyYWNrcyA9IGZhbHNlO1xuICAgIGNvbnN0IGRldmljZUNvbnN0cmFpbnQgPSBleGFjdCA/IHsgZXhhY3Q6IGRldmljZUlkIH0gOiBkZXZpY2VJZDtcbiAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XG4gICAgICBuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5zaXplID09PSAwO1xuICAgICAgY29uc3QgcHJldkRldmljZUlkID1cbiAgICAgICAgdGhpcy5nZXRBY3RpdmVEZXZpY2Uoa2luZCkgPz8gdGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzIS5kZXZpY2VJZDtcbiAgICAgIHRoaXMub3B0aW9ucy5hdWRpb0NhcHR1cmVEZWZhdWx0cyEuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgY29uc3QgdHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgICAodHJhY2spID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUsXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VjY2VzcyA9IChcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFja3MubWFwKCh0KSA9PiB0LmF1ZGlvVHJhY2s/LnNldERldmljZUlkKGRldmljZUNvbnN0cmFpbnQpKSlcbiAgICAgICAgKS5ldmVyeSgodmFsKSA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMhLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICBuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5zaXplID09PSAwO1xuICAgICAgY29uc3QgcHJldkRldmljZUlkID1cbiAgICAgICAgdGhpcy5nZXRBY3RpdmVEZXZpY2Uoa2luZCkgPz8gdGhpcy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzIS5kZXZpY2VJZDtcbiAgICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyEuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgY29uc3QgdHJhY2tzID0gQXJyYXkuZnJvbSh0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgICAodHJhY2spID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSxcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBzdWNjZXNzID0gKFxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYWNrcy5tYXAoKHQpID0+IHQudmlkZW9UcmFjaz8uc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCkpKVxuICAgICAgICApLmV2ZXJ5KCh2YWwpID0+IHZhbCA9PT0gdHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyEuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSAnYXVkaW9vdXRwdXQnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghc3VwcG9ydHNTZXRTaW5rSWQoKSAmJiAhdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4KSB8fFxuICAgICAgICAodGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4ICYmIHRoaXMuYXVkaW9Db250ZXh0ICYmICEoJ3NldFNpbmtJZCcgaW4gdGhpcy5hdWRpb0NvbnRleHQpKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHN3aXRjaCBhdWRpbyBvdXRwdXQsIHNldFNpbmtJZCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XG4gICAgICAgIC8vIHNldHRpbmcgYGRlZmF1bHRgIGZvciB3ZWIgYXVkaW8gb3V0cHV0IGRvZXNuJ3Qgd29yaywgc28gd2UgbmVlZCB0byBub3JtYWxpemUgdGhlIGlkIGJlZm9yZVxuICAgICAgICBkZXZpY2VJZCA9XG4gICAgICAgICAgKGF3YWl0IERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5ub3JtYWxpemVEZXZpY2VJZCgnYXVkaW9vdXRwdXQnLCBkZXZpY2VJZCkpID8/ICcnO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0ID8/PSB7fTtcbiAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IHRoaXMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpID8/IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZDtcbiAgICAgIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IGRldmljZUlkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZXRTaW5rSWQgaXMgbm90IHlldCBpbiB0aGUgdHlwZXNjcmlwdCB0eXBlIG9mIEF1ZGlvQ29udGV4dFxuICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0Py5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsc28gc2V0IGF1ZGlvIG91dHB1dCBvbiBhbGwgYXVkaW8gZWxlbWVudHMsIGV2ZW4gaWYgd2ViQXVkaW9NaXggaXMgZW5hYmxlZCBpbiBvcmRlciB0byB3b3JrYXJvdW5kIGVjaG8gY2FuY2VsbGF0aW9uIG5vdCB3b3JraW5nIG9uIGNocm9tZSB3aXRoIG5vbi1kZWZhdWx0IG91dHB1dCBkZXZpY2VzXG4gICAgICAgIC8vIHNlZSBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQwMjUyOTExI2NvbW1lbnQ3XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLm1hcCgocCkgPT4gcC5zZXRBdWRpb091dHB1dCh7IGRldmljZUlkIH0pKSxcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzIHx8IGtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBub3QgYWN0aXZlIHRyYWNrcyB5ZXQgb3Igd2UncmUgc3dpdGNoaW5nIGF1ZGlvb3V0cHV0LCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHVwZGF0ZSB0aGUgYWN0aXZlIGRldmljZSBtYXAgaGVyZSBhcyBjaGFuZ2luZyBhdWRpbyBvdXRwdXQgd29uJ3QgcmVzdWx0IGluIGEgdHJhY2sgcmVzdGFydFxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoXG4gICAgICAgIGtpbmQsXG4gICAgICAgIChraW5kID09PSAnYXVkaW9vdXRwdXQnICYmIHRoaXMub3B0aW9ucy5hdWRpb091dHB1dD8uZGV2aWNlSWQpIHx8IGRldmljZUlkLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwga2luZCwgZGV2aWNlSWQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKSB7XG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50XG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIHRoaXMub25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tNdXRlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tQdWJsaXNoZWQpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCB0aGlzLm9uTWVkaWFEZXZpY2VzRXJyb3IpXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5BdWRpb1N0cmVhbUFjcXVpcmVkLCB0aGlzLnN0YXJ0QXVkaW8pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50KVxuICAgICAgLm9uKFxuICAgICAgICBQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCxcbiAgICAgICk7XG4gIH1cblxuICBwcml2YXRlIHJlY3JlYXRlRW5naW5lKCkge1xuICAgIHRoaXMuZW5naW5lPy5jbG9zZSgpO1xuICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICB0aGlzLmVuZ2luZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcblxuICAgIC8vIGNsZWFyIG91dCBleGlzdGluZyByZW1vdGUgcGFydGljaXBhbnRzLCBzaW5jZSB0aGV5IG1heSBoYXZlIGF0dGFjaGVkXG4gICAgLy8gdGhlIG9sZCBlbmdpbmVcbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgIHRoaXMuc2lkVG9JZGVudGl0eS5jbGVhcigpO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICB0aGlzLm1heWJlQ3JlYXRlRW5naW5lKCk7XG4gIH1cblxuICBwcml2YXRlIG9uVHJhY2tBZGRlZChcbiAgICBtZWRpYVRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrLFxuICAgIHN0cmVhbTogTWVkaWFTdHJlYW0sXG4gICAgcmVjZWl2ZXI6IFJUQ1J0cFJlY2VpdmVyLFxuICApIHtcbiAgICAvLyBkb24ndCBmaXJlIG9uU3Vic2NyaWJlZCB3aGVuIGNvbm5lY3RpbmdcbiAgICAvLyBXZWJSVEMgZmlyZXMgb25UcmFjayBhcyBzb29uIGFzIHNldFJlbW90ZURlc2NyaXB0aW9uIGlzIGNhbGxlZCBvbiB0aGUgb2ZmZXJcbiAgICAvLyBhdCB0aGF0IHRpbWUsIElDRSBjb25uZWN0aXZpdHkgaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHNvIHRoZSB0cmFjayBpcyBub3RcbiAgICAvLyB0ZWNobmljYWxseSBzdWJzY3JpYmVkLlxuICAgIC8vIFdlJ2xsIGRlZmVyIHRoZXNlIGV2ZW50cyB1bnRpbCB3aGVuIHRoZSByb29tIGlzIGNvbm5lY3RlZCBvciBldmVudHVhbGx5IGRpc2Nvbm5lY3RlZC5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcgfHwgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykge1xuICAgICAgY29uc3QgcmVjb25uZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9uVHJhY2tBZGRlZChtZWRpYVRyYWNrLCBzdHJlYW0sIHJlY2VpdmVyKTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5SZWNvbm5lY3RlZCwgcmVjb25uZWN0ZWRIYW5kbGVyKTtcbiAgICAgIHRoaXMub25jZShSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5EaXNjb25uZWN0ZWQsIGNsZWFudXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5sb2cud2Fybignc2tpcHBpbmcgaW5jb21pbmcgdHJhY2sgYWZ0ZXIgUm9vbSBkaXNjb25uZWN0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFUcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICB0aGlzLmxvZy5pbmZvKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhcyBpdCBhbHJlYWR5IGVuZGVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSB1bnBhY2tTdHJlYW1JZChzdHJlYW0uaWQpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50U2lkID0gcGFydHNbMF07XG4gICAgbGV0IHN0cmVhbUlkID0gcGFydHNbMV07XG4gICAgbGV0IHRyYWNrSWQgPSBtZWRpYVRyYWNrLmlkO1xuICAgIC8vIGZpcmVmb3ggd2lsbCBnZXQgc3RyZWFtSWQgKHBJRHx0cmFja0lkKSBpbnN0ZWFkIG9mIChwSUR8c3RyZWFtSWQpIGFzIGl0IGRvZXNuJ3Qgc3VwcG9ydCBzeW5jIHRyYWNrcyBieSBzdHJlYW1cbiAgICAvLyBhbmQgZ2VuZXJhdGVzIGl0cyBvd24gdHJhY2sgaWQgaW5zdGVhZCBvZiBpbmZlciBmcm9tIHNkcCB0cmFjayBpZC5cbiAgICBpZiAoc3RyZWFtSWQgJiYgc3RyZWFtSWQuc3RhcnRzV2l0aCgnVFInKSkgdHJhY2tJZCA9IHN0cmVhbUlkO1xuXG4gICAgaWYgKHBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd0cmllZCB0byBjcmVhdGUgUmVtb3RlUGFydGljaXBhbnQgZm9yIGxvY2FsIHBhcnRpY2lwYW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IEFycmF5LmZyb20odGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLmZpbmQoXG4gICAgICAocCkgPT4gcC5zaWQgPT09IHBhcnRpY2lwYW50U2lkLFxuICAgICkgYXMgUmVtb3RlUGFydGljaXBhbnQgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihcbiAgICAgICAgYFRyaWVkIHRvIGFkZCBhIHRyYWNrIGZvciBhIHBhcnRpY2lwYW50LCB0aGF0J3Mgbm90IHByZXNlbnQuIFNpZDogJHtwYXJ0aWNpcGFudFNpZH1gLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzOiBBZGFwdGl2ZVN0cmVhbVNldHRpbmdzIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gdGhpcy5vcHRpb25zLmFkYXB0aXZlU3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpY2lwYW50LmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKFxuICAgICAgbWVkaWFUcmFjayxcbiAgICAgIHRyYWNrSWQsXG4gICAgICBzdHJlYW0sXG4gICAgICByZWNlaXZlcixcbiAgICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlUmVzdGFydGluZyA9ICgpID0+IHtcbiAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgIC8vIGluIGNhc2Ugd2Ugd2VudCBmcm9tIHJlc3VtaW5nIHRvIGZ1bGwtcmVjb25uZWN0LCBtYWtlIHN1cmUgdG8gcmVmbGVjdCBpdCBvbiB0aGUgaXNSZXN1bWluZyBmbGFnXG4gICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG5cbiAgICAvLyBhbHNvIHVud2luZCBleGlzdGluZyBwYXJ0aWNpcGFudHMgJiBleGlzdGluZyBzdWJzY3JpcHRpb25zXG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHAuaWRlbnRpdHksIHApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZykpIHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVTaWduYWxSZXN0YXJ0ZWQgPSBhc3luYyAoam9pblJlc3BvbnNlOiBKb2luUmVzcG9uc2UpID0+IHtcbiAgICB0aGlzLmxvZy5kZWJ1Zyhgc2lnbmFsIHJlY29ubmVjdGVkIHRvIHNlcnZlciwgcmVnaW9uICR7am9pblJlc3BvbnNlLnNlcnZlclJlZ2lvbn1gLCB7XG4gICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb24sXG4gICAgfSk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuXG4gICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZShqb2luUmVzcG9uc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHVucHVibGlzaCAmIHJlcHVibGlzaCB0cmFja3NcbiAgICAgIGF3YWl0IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5yZXB1Ymxpc2hBbGxUcmFja3ModW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHRyeWluZyB0byByZS1wdWJsaXNoIHRyYWNrcyBhZnRlciByZWNvbm5lY3Rpb24nLCB7XG4gICAgICAgIC4uLnRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5lbmdpbmUud2FpdEZvclJlc3RhcnRlZCgpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoYGZ1bGx5IHJlY29ubmVjdGVkIHRvIHNlcnZlcmAsIHtcbiAgICAgICAgLi4udGhpcy5sb2dDb250ZXh0LFxuICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb24sXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIHJlY29ubmVjdGlvbiBmYWlsZWQsIGhhbmRsZURpc2Nvbm5lY3QgaXMgYmVpbmcgaW52b2tlZCBhbHJlYWR5LCBqdXN0IHJldHVybiBoZXJlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICB0aGlzLnJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgIHRoaXMuZW1pdEJ1ZmZlcmVkRXZlbnRzKCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVEaXNjb25uZWN0KHNob3VsZFN0b3BUcmFja3MgPSB0cnVlLCByZWFzb24/OiBEaXNjb25uZWN0UmVhc29uKSB7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcy5jbGVhcigpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBwLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgICAgIHAudW5wdWJsaXNoVHJhY2socHViLnRyYWNrU2lkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2goKHB1YikgPT4ge1xuICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1Yi50cmFjaywgc2hvdWxkU3RvcFRyYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFN0b3BUcmFja3MpIHtcbiAgICAgICAgICBwdWIudHJhY2s/LmRldGFjaCgpO1xuICAgICAgICAgIHB1Yi50cmFjaz8uc3RvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1Yi50cmFjaz8uc3RvcE1vbml0b3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudFxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnROYW1lQ2hhbmdlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrTXV0ZWQpXG4gICAgICAgIC5vZmYoUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrVW5tdXRlZClcbiAgICAgICAgLm9mZihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCB0aGlzLm9uTG9jYWxDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQpXG4gICAgICAgIC5vZmYoUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCwgdGhpcy5zdGFydEF1ZGlvKVxuICAgICAgICAub2ZmKFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIHRoaXMub25Mb2NhbENoYXRNZXNzYWdlU2VudClcbiAgICAgICAgLm9mZihcbiAgICAgICAgICBQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICApO1xuXG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xuXG4gICAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5jbGVhcigpO1xuICAgICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XG4gICAgICB0aGlzLmFjdGl2ZVNwZWFrZXJzID0gW107XG4gICAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzPy5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCB0aGlzLmhhbmRsZURldmljZUNoYW5nZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzID0gKHBhcnRpY2lwYW50SW5mb3M6IFBhcnRpY2lwYW50SW5mb1tdKSA9PiB7XG4gICAgLy8gaGFuZGxlIGNoYW5nZXMgdG8gcGFydGljaXBhbnQgc3RhdGUsIGFuZCBzZW5kIGV2ZW50c1xuICAgIHBhcnRpY2lwYW50SW5mb3MuZm9yRWFjaCgoaW5mbykgPT4ge1xuICAgICAgaWYgKGluZm8uaWRlbnRpdHkgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkge1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMaXZlS2l0IHNlcnZlciBkb2Vzbid0IHNlbmQgaWRlbnRpdHkgaW5mbyBwcmlvciB0byB2ZXJzaW9uIDEuNS4yIGluIGRpc2Nvbm5lY3QgdXBkYXRlc1xuICAgICAgLy8gc28gd2UgdHJ5IHRvIG1hcCBhbiBlbXB0eSBpZGVudGl0eSB0byBhbiBhbHJlYWR5IGtub3duIHNJRCBtYW51YWxseVxuICAgICAgaWYgKGluZm8uaWRlbnRpdHkgPT09ICcnKSB7XG4gICAgICAgIGluZm8uaWRlbnRpdHkgPSB0aGlzLnNpZFRvSWRlbnRpdHkuZ2V0KGluZm8uc2lkKSA/PyAnJztcbiAgICAgIH1cblxuICAgICAgbGV0IHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGluZm8uaWRlbnRpdHkpO1xuXG4gICAgICAvLyB3aGVuIGl0J3MgZGlzY29ubmVjdGVkLCBzZW5kIHVwZGF0ZXNcbiAgICAgIGlmIChpbmZvLnN0YXRlID09PSBQYXJ0aWNpcGFudEluZm9fU3RhdGUuRElTQ09OTkVDVEVEKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQoaW5mby5pZGVudGl0eSwgcmVtb3RlUGFydGljaXBhbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIHBhcnRpY2lwYW50IGlmIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChpZGVudGl0eTogc3RyaW5nLCBwYXJ0aWNpcGFudD86IFJlbW90ZVBhcnRpY2lwYW50KSB7XG4gICAgLy8gcmVtb3ZlIGFuZCBzZW5kIGV2ZW50XG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZGVsZXRlKGlkZW50aXR5KTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaCgocHVibGljYXRpb24pID0+IHtcbiAgICAgIHBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1YmxpY2F0aW9uLnRyYWNrU2lkLCB0cnVlKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50RGlzY29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50Py5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gIH1cblxuICAvLyB1cGRhdGVzIGFyZSBzZW50IG9ubHkgd2hlbiB0aGVyZSdzIGEgY2hhbmdlIHRvIHNwZWFrZXIgb3JkZXJpbmdcbiAgcHJpdmF0ZSBoYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSA9IChzcGVha2VyczogU3BlYWtlckluZm9bXSkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzOiBQYXJ0aWNpcGFudFtdID0gW107XG4gICAgY29uc3Qgc2VlblNpZHM6IGFueSA9IHt9O1xuICAgIHNwZWFrZXJzLmZvckVhY2goKHNwZWFrZXIpID0+IHtcbiAgICAgIHNlZW5TaWRzW3NwZWFrZXIuc2lkXSA9IHRydWU7XG4gICAgICBpZiAoc3BlYWtlci5zaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvTGV2ZWwgPSBzcGVha2VyLmxldmVsO1xuICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyh0cnVlKTtcbiAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaCh0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzcGVha2VyLnNpZCk7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgICAgICBwLnNldElzU3BlYWtpbmcodHJ1ZSk7XG4gICAgICAgICAgYWN0aXZlU3BlYWtlcnMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFzZWVuU2lkc1t0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkXSkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvTGV2ZWwgPSAwO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICBpZiAoIXNlZW5TaWRzW3Auc2lkXSkge1xuICAgICAgICBwLmF1ZGlvTGV2ZWwgPSAwO1xuICAgICAgICBwLnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICB9O1xuXG4gIC8vIHByb2Nlc3MgbGlzdCBvZiBjaGFuZ2VkIHNwZWFrZXJzXG4gIHByaXZhdGUgaGFuZGxlU3BlYWtlcnNDaGFuZ2VkID0gKHNwZWFrZXJVcGRhdGVzOiBTcGVha2VySW5mb1tdKSA9PiB7XG4gICAgY29uc3QgbGFzdFNwZWFrZXJzID0gbmV3IE1hcDxzdHJpbmcsIFBhcnRpY2lwYW50PigpO1xuICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgY29uc3QgcmVtb3RlUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQocC5pZGVudGl0eSk7XG4gICAgICBpZiAocmVtb3RlUGFydGljaXBhbnQgJiYgcmVtb3RlUGFydGljaXBhbnQuc2lkICE9PSBwLnNpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0U3BlYWtlcnMuc2V0KHAuc2lkLCBwKTtcbiAgICB9KTtcbiAgICBzcGVha2VyVXBkYXRlcy5mb3JFYWNoKChzcGVha2VyKSA9PiB7XG4gICAgICBsZXQgcDogUGFydGljaXBhbnQgfCB1bmRlZmluZWQgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQoc3BlYWtlci5zaWQpO1xuICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgIHAgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgIHAuc2V0SXNTcGVha2luZyhzcGVha2VyLmFjdGl2ZSk7XG5cbiAgICAgIGlmIChzcGVha2VyLmFjdGl2ZSkge1xuICAgICAgICBsYXN0U3BlYWtlcnMuc2V0KHNwZWFrZXIuc2lkLCBwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTcGVha2Vycy5kZWxldGUoc3BlYWtlci5zaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFjdGl2ZVNwZWFrZXJzID0gQXJyYXkuZnJvbShsYXN0U3BlYWtlcnMudmFsdWVzKCkpO1xuICAgIGFjdGl2ZVNwZWFrZXJzLnNvcnQoKGEsIGIpID0+IGIuYXVkaW9MZXZlbCAtIGEuYXVkaW9MZXZlbCk7XG4gICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZCwgYWN0aXZlU3BlYWtlcnMpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU3RyZWFtU3RhdGVVcGRhdGUgPSAoc3RyZWFtU3RhdGVVcGRhdGU6IFN0cmVhbVN0YXRlVXBkYXRlKSA9PiB7XG4gICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goKHN0cmVhbVN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzdHJlYW1TdGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHB1YiA9IHBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25CeVNpZChzdHJlYW1TdGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1YiB8fCAhcHViLnRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1N0cmVhbVN0YXRlID0gVHJhY2suc3RyZWFtU3RhdGVGcm9tUHJvdG8oc3RyZWFtU3RhdGUuc3RhdGUpO1xuICAgICAgaWYgKG5ld1N0cmVhbVN0YXRlICE9PSBwdWIudHJhY2suc3RyZWFtU3RhdGUpIHtcbiAgICAgICAgcHViLnRyYWNrLnN0cmVhbVN0YXRlID0gbmV3U3RyZWFtU3RhdGU7XG4gICAgICAgIHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCwgcHViLCBwdWIudHJhY2suc3RyZWFtU3RhdGUpO1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFxuICAgICAgICAgIFJvb21FdmVudC5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCxcbiAgICAgICAgICBwdWIsXG4gICAgICAgICAgcHViLnRyYWNrLnN0cmVhbVN0YXRlLFxuICAgICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9ICh1cGRhdGU6IFN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpID0+IHtcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZCh1cGRhdGUucGFydGljaXBhbnRTaWQpO1xuICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgaWYgKCFwdWIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwdWIuc2V0QWxsb3dlZCh1cGRhdGUuYWxsb3dlZCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVTdWJzY3JpcHRpb25FcnJvciA9ICh1cGRhdGU6IFN1YnNjcmlwdGlvblJlc3BvbnNlKSA9PiB7XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSBBcnJheS5mcm9tKHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5maW5kKChwKSA9PlxuICAgICAgcC50cmFja1B1YmxpY2F0aW9ucy5oYXModXBkYXRlLnRyYWNrU2lkKSxcbiAgICApO1xuICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgaWYgKCFwdWIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwdWIuc2V0U3Vic2NyaXB0aW9uRXJyb3IodXBkYXRlLmVycik7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVEYXRhUGFja2V0ID0gKHBhY2tldDogRGF0YVBhY2tldCkgPT4ge1xuICAgIC8vIGZpbmQgdGhlIHBhcnRpY2lwYW50XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQocGFja2V0LnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3VzZXInKSB7XG4gICAgICB0aGlzLmhhbmRsZVVzZXJQYWNrZXQocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSwgcGFja2V0LmtpbmQpO1xuICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICd0cmFuc2NyaXB0aW9uJykge1xuICAgICAgdGhpcy5oYW5kbGVUcmFuc2NyaXB0aW9uKHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzaXBEdG1mJykge1xuICAgICAgdGhpcy5oYW5kbGVTaXBEdG1mKHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdjaGF0TWVzc2FnZScpIHtcbiAgICAgIHRoaXMuaGFuZGxlQ2hhdE1lc3NhZ2UocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ21ldHJpY3MnKSB7XG4gICAgICB0aGlzLmhhbmRsZU1ldHJpY3MocGFja2V0LnZhbHVlLnZhbHVlLCBwYXJ0aWNpcGFudCk7XG4gICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbUhlYWRlcicpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3RyZWFtSGVhZGVyKHBhY2tldC52YWx1ZS52YWx1ZSwgcGFja2V0LnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1DaHVuaycpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3RyZWFtQ2h1bmsocGFja2V0LnZhbHVlLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnc3RyZWFtVHJhaWxlcicpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3RyZWFtVHJhaWxlcihwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdycGNSZXF1ZXN0Jykge1xuICAgICAgY29uc3QgcnBjID0gcGFja2V0LnZhbHVlLnZhbHVlO1xuICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1JwY1JlcXVlc3QoXG4gICAgICAgIHBhY2tldC5wYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAgICBycGMuaWQsXG4gICAgICAgIHJwYy5tZXRob2QsXG4gICAgICAgIHJwYy5wYXlsb2FkLFxuICAgICAgICBycGMucmVzcG9uc2VUaW1lb3V0TXMsXG4gICAgICAgIHJwYy52ZXJzaW9uLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTdHJlYW1IZWFkZXIoc3RyZWFtSGVhZGVyOiBEYXRhU3RyZWFtX0hlYWRlciwgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nKSB7XG4gICAgaWYgKHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLmNhc2UgPT09ICdieXRlSGVhZGVyJykge1xuICAgICAgY29uc3Qgc3RyZWFtSGFuZGxlckNhbGxiYWNrID0gdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuZ2V0KHN0cmVhbUhlYWRlci50b3BpYyk7XG5cbiAgICAgIGlmICghc3RyZWFtSGFuZGxlckNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFxuICAgICAgICAgICdpZ25vcmluZyBpbmNvbWluZyBieXRlIHN0cmVhbSBkdWUgdG8gbm8gaGFuZGxlciBmb3IgdG9waWMnLFxuICAgICAgICAgIHN0cmVhbUhlYWRlci50b3BpYyxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8RGF0YVN0cmVhbV9DaHVuaz47XG4gICAgICBjb25zdCBpbmZvOiBCeXRlU3RyZWFtSW5mbyA9IHtcbiAgICAgICAgaWQ6IHN0cmVhbUhlYWRlci5zdHJlYW1JZCxcbiAgICAgICAgbmFtZTogc3RyZWFtSGVhZGVyLmNvbnRlbnRIZWFkZXIudmFsdWUubmFtZSA/PyAndW5rbm93bicsXG4gICAgICAgIG1pbWVUeXBlOiBzdHJlYW1IZWFkZXIubWltZVR5cGUsXG4gICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxuICAgICAgICB0b3BpYzogc3RyZWFtSGVhZGVyLnRvcGljLFxuICAgICAgICB0aW1lc3RhbXA6IGJpZ0ludFRvTnVtYmVyKHN0cmVhbUhlYWRlci50aW1lc3RhbXApLFxuICAgICAgICBhdHRyaWJ1dGVzOiBzdHJlYW1IZWFkZXIuYXR0cmlidXRlcyxcbiAgICAgIH07XG4gICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydDogKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5zZXQoc3RyZWFtSGVhZGVyLnN0cmVhbUlkLCB7XG4gICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgY29udHJvbGxlcjogc3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgc3RyZWFtSGFuZGxlckNhbGxiYWNrKFxuICAgICAgICBuZXcgQnl0ZVN0cmVhbVJlYWRlcihpbmZvLCBzdHJlYW0sIGJpZ0ludFRvTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCkpLFxuICAgICAgICB7XG4gICAgICAgICAgaWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtSGVhZGVyLmNvbnRlbnRIZWFkZXIuY2FzZSA9PT0gJ3RleHRIZWFkZXInKSB7XG4gICAgICBjb25zdCBzdHJlYW1IYW5kbGVyQ2FsbGJhY2sgPSB0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5nZXQoc3RyZWFtSGVhZGVyLnRvcGljKTtcblxuICAgICAgaWYgKCFzdHJlYW1IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXG4gICAgICAgICAgJ2lnbm9yaW5nIGluY29taW5nIHRleHQgc3RyZWFtIGR1ZSB0byBubyBoYW5kbGVyIGZvciB0b3BpYycsXG4gICAgICAgICAgc3RyZWFtSGVhZGVyLnRvcGljLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyZWFtQ29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxEYXRhU3RyZWFtX0NodW5rPjtcbiAgICAgIGNvbnN0IGluZm86IFRleHRTdHJlYW1JbmZvID0ge1xuICAgICAgICBpZDogc3RyZWFtSGVhZGVyLnN0cmVhbUlkLFxuICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxuICAgICAgICBzaXplOiBzdHJlYW1IZWFkZXIudG90YWxMZW5ndGggPyBOdW1iZXIoc3RyZWFtSGVhZGVyLnRvdGFsTGVuZ3RoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdG9waWM6IHN0cmVhbUhlYWRlci50b3BpYyxcbiAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoc3RyZWFtSGVhZGVyLnRpbWVzdGFtcCksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHN0cmVhbUhlYWRlci5hdHRyaWJ1dGVzLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtPERhdGFTdHJlYW1fQ2h1bms+KHtcbiAgICAgICAgc3RhcnQ6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuc2V0KHN0cmVhbUhlYWRlci5zdHJlYW1JZCwge1xuICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IHN0cmVhbUNvbnRyb2xsZXIsXG4gICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIHN0cmVhbUhhbmRsZXJDYWxsYmFjayhcbiAgICAgICAgbmV3IFRleHRTdHJlYW1SZWFkZXIoaW5mbywgc3RyZWFtLCBiaWdJbnRUb051bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpKSxcbiAgICAgICAgeyBpZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSB9LFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVN0cmVhbUNodW5rKGNodW5rOiBEYXRhU3RyZWFtX0NodW5rKSB7XG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldChjaHVuay5zdHJlYW1JZCk7XG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcbiAgICAgIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0QnVmZmVyID0gdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZ2V0KGNodW5rLnN0cmVhbUlkKTtcbiAgICBpZiAodGV4dEJ1ZmZlcikge1xuICAgICAgaWYgKGNodW5rLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZXh0QnVmZmVyLmNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTdHJlYW1UcmFpbGVyKHRyYWlsZXI6IERhdGFTdHJlYW1fVHJhaWxlcikge1xuICAgIGNvbnN0IHRleHRCdWZmZXIgPSB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5nZXQodHJhaWxlci5zdHJlYW1JZCk7XG4gICAgaWYgKHRleHRCdWZmZXIpIHtcbiAgICAgIHRleHRCdWZmZXIuaW5mby5hdHRyaWJ1dGVzID0ge1xuICAgICAgICAuLi50ZXh0QnVmZmVyLmluZm8uYXR0cmlidXRlcyxcbiAgICAgICAgLi4udHJhaWxlci5hdHRyaWJ1dGVzLFxuICAgICAgfTtcbiAgICAgIHRleHRCdWZmZXIuY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZGVsZXRlKHRyYWlsZXIuc3RyZWFtSWQpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGVCdWZmZXIgPSB0aGlzLmJ5dGVTdHJlYW1Db250cm9sbGVycy5nZXQodHJhaWxlci5zdHJlYW1JZCk7XG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcbiAgICAgIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMgPSB7IC4uLmZpbGVCdWZmZXIuaW5mby5hdHRyaWJ1dGVzLCAuLi50cmFpbGVyLmF0dHJpYnV0ZXMgfTtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZSh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVVzZXJQYWNrZXQgPSAoXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50IHwgdW5kZWZpbmVkLFxuICAgIHVzZXJQYWNrZXQ6IFVzZXJQYWNrZXQsXG4gICAga2luZDogRGF0YVBhY2tldF9LaW5kLFxuICApID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkRhdGFSZWNlaXZlZCwgdXNlclBhY2tldC5wYXlsb2FkLCBwYXJ0aWNpcGFudCwga2luZCwgdXNlclBhY2tldC50b3BpYyk7XG5cbiAgICAvLyBhbHNvIGVtaXQgb24gdGhlIHBhcnRpY2lwYW50XG4gICAgcGFydGljaXBhbnQ/LmVtaXQoUGFydGljaXBhbnRFdmVudC5EYXRhUmVjZWl2ZWQsIHVzZXJQYWNrZXQucGF5bG9hZCwga2luZCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVTaXBEdG1mID0gKHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCB8IHVuZGVmaW5lZCwgZHRtZjogU2lwRFRNRikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lwRFRNRlJlY2VpdmVkLCBkdG1mLCBwYXJ0aWNpcGFudCk7XG5cbiAgICAvLyBhbHNvIGVtaXQgb24gdGhlIHBhcnRpY2lwYW50XG4gICAgcGFydGljaXBhbnQ/LmVtaXQoUGFydGljaXBhbnRFdmVudC5TaXBEVE1GUmVjZWl2ZWQsIGR0bWYpO1xuICB9O1xuXG4gIGJ1ZmZlcmVkU2VnbWVudHM6IE1hcDxzdHJpbmcsIFRyYW5zY3JpcHRpb25TZWdtZW50TW9kZWw+ID0gbmV3IE1hcCgpO1xuXG4gIHByaXZhdGUgaGFuZGxlVHJhbnNjcmlwdGlvbiA9IChcbiAgICBfcmVtb3RlUGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50IHwgdW5kZWZpbmVkLFxuICAgIHRyYW5zY3JpcHRpb246IFRyYW5zY3JpcHRpb25Nb2RlbCxcbiAgKSA9PiB7XG4gICAgLy8gZmluZCB0aGUgcGFydGljaXBhbnRcbiAgICBjb25zdCBwYXJ0aWNpcGFudCA9XG4gICAgICB0cmFuc2NyaXB0aW9uLnRyYW5zY3JpYmVkUGFydGljaXBhbnRJZGVudGl0eSA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5XG4gICAgICAgID8gdGhpcy5sb2NhbFBhcnRpY2lwYW50XG4gICAgICAgIDogdGhpcy5nZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkodHJhbnNjcmlwdGlvbi50cmFuc2NyaWJlZFBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgIGNvbnN0IHB1YmxpY2F0aW9uID0gcGFydGljaXBhbnQ/LnRyYWNrUHVibGljYXRpb25zLmdldCh0cmFuc2NyaXB0aW9uLnRyYWNrSWQpO1xuXG4gICAgY29uc3Qgc2VnbWVudHMgPSBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzKHRyYW5zY3JpcHRpb24sIHRoaXMudHJhbnNjcmlwdGlvblJlY2VpdmVkVGltZXMpO1xuXG4gICAgcHVibGljYXRpb24/LmVtaXQoVHJhY2tFdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQsIHNlZ21lbnRzKTtcbiAgICBwYXJ0aWNpcGFudD8uZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCwgc2VnbWVudHMsIHB1YmxpY2F0aW9uKTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCwgc2VnbWVudHMsIHBhcnRpY2lwYW50LCBwdWJsaWNhdGlvbik7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVDaGF0TWVzc2FnZSA9IChcbiAgICBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQgfCB1bmRlZmluZWQsXG4gICAgY2hhdE1lc3NhZ2U6IENoYXRNZXNzYWdlTW9kZWwsXG4gICkgPT4ge1xuICAgIGNvbnN0IG1zZyA9IGV4dHJhY3RDaGF0TWVzc2FnZShjaGF0TWVzc2FnZSk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5DaGF0TWVzc2FnZSwgbXNnLCBwYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVNZXRyaWNzID0gKG1ldHJpY3M6IE1ldHJpY3NCYXRjaCwgcGFydGljaXBhbnQ/OiBQYXJ0aWNpcGFudCkgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWV0cmljc1JlY2VpdmVkLCBtZXRyaWNzLCBwYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXVkaW9FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQgPSAoZTogYW55KSA9PiB7XG4gICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHBsYXliYWNrIGF1ZGlvJywgeyAuLi50aGlzLmxvZ0NvbnRleHQsIGVycm9yOiBlIH0pO1xuICAgIGlmICghdGhpcy5jYW5QbGF5YmFja0F1ZGlvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXVkaW9FbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrQmxvY2tlZCkge1xuICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkKSB7XG4gICAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGhhbmRsZURldmljZUNoYW5nZSA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c0RldmljZXMgPSBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkucHJldmlvdXNEZXZpY2VzO1xuICAgIC8vIGNoZWNrIGZvciBhdmFpbGFibGUgZGV2aWNlcywgYnV0IGRvbid0IHJlcXVlc3QgcGVybWlzc2lvbnMgaW4gb3JkZXIgdG8gYXZvaWQgcHJvbXB0cyBmb3Iga2luZHMgdGhhdCBoYXZlbid0IGJlZW4gdXNlZCBiZWZvcmVcbiAgICBjb25zdCBhdmFpbGFibGVEZXZpY2VzID0gYXdhaXQgRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldERldmljZXModW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBpZiAoYnJvd3Nlcj8ubmFtZSA9PT0gJ0Nocm9tZScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcbiAgICAgIGZvciAobGV0IGF2YWlsYWJsZURldmljZSBvZiBhdmFpbGFibGVEZXZpY2VzKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRGV2aWNlID0gcHJldmlvdXNEZXZpY2VzLmZpbmQoXG4gICAgICAgICAgKGluZm8pID0+IGluZm8uZGV2aWNlSWQgPT09IGF2YWlsYWJsZURldmljZS5kZXZpY2VJZCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXZpb3VzRGV2aWNlICYmXG4gICAgICAgICAgcHJldmlvdXNEZXZpY2UubGFiZWwgIT09ICcnICYmXG4gICAgICAgICAgcHJldmlvdXNEZXZpY2Uua2luZCA9PT0gYXZhaWxhYmxlRGV2aWNlLmtpbmQgJiZcbiAgICAgICAgICBwcmV2aW91c0RldmljZS5sYWJlbCAhPT0gYXZhaWxhYmxlRGV2aWNlLmxhYmVsXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGxhYmVsIGhhcyBjaGFuZ2VkIG9uIGRldmljZSB0aGUgc2FtZSBkZXZpY2VJZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBkZWZhdWx0IGRldmljZSBoYXMgY2hhbmdlZCBvbiB0aGUgT1MgbGV2ZWxcbiAgICAgICAgICBpZiAodGhpcy5nZXRBY3RpdmVEZXZpY2UoYXZhaWxhYmxlRGV2aWNlLmtpbmQpID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIC8vIGVtaXQgYW4gYWN0aXZlIGRldmljZSBjaGFuZ2UgZXZlbnQgb25seSBpZiB0aGUgc2VsZWN0ZWQgb3V0cHV0IGRldmljZSBpcyBhY3R1YWxseSBvbiBgZGVmYXVsdGBcbiAgICAgICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICAgICAgUm9vbUV2ZW50LkFjdGl2ZURldmljZUNoYW5nZWQsXG4gICAgICAgICAgICAgIGF2YWlsYWJsZURldmljZS5raW5kLFxuICAgICAgICAgICAgICBhdmFpbGFibGVEZXZpY2UuZGV2aWNlSWQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlucHV0cyBhcmUgYXV0b21hdGljYWxseSBoYW5kbGVkIHZpYSBUcmFja0V2ZW50LkVuZGVkIGNhdXNpbmcgYSBUcmFja0V2ZW50LlJlc3RhcnRlZC4gSGVyZSB3ZSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgYXVkaW9vdXRwdXRzIGNoYW5naW5nXG4gICAgY29uc3Qga2luZHM6IE1lZGlhRGV2aWNlS2luZFtdID0gWydhdWRpb291dHB1dCcsICdhdWRpb2lucHV0JywgJ3ZpZGVvaW5wdXQnXTtcbiAgICBmb3IgKGxldCBraW5kIG9mIGtpbmRzKSB7XG4gICAgICBjb25zdCBkZXZpY2VzT2ZLaW5kID0gYXZhaWxhYmxlRGV2aWNlcy5maWx0ZXIoKGQpID0+IGQua2luZCA9PT0ga2luZCk7XG4gICAgICBjb25zdCBhY3RpdmVEZXZpY2UgPSB0aGlzLmdldEFjdGl2ZURldmljZShraW5kKTtcblxuICAgICAgaWYgKGFjdGl2ZURldmljZSA9PT0gcHJldmlvdXNEZXZpY2VzLmZpbHRlcigoaW5mbykgPT4gaW5mby5raW5kID09PSBraW5kKVswXT8uZGV2aWNlSWQpIHtcbiAgICAgICAgLy8gaW4gIFNhZmFyaSB0aGUgZmlyc3QgZGV2aWNlIGlzIGFsd2F5cyB0aGUgZGVmYXVsdCwgc28gd2UgYXNzdW1lIGEgdXNlciBvbiB0aGUgZGVmYXVsdCBkZXZpY2Ugd291bGQgbGlrZSB0byBzd2l0Y2ggdG8gdGhlIGRlZmF1bHQgb25jZSBpdCBjaGFuZ2VzXG4gICAgICAgIC8vIEZGIGRvZXNuJ3QgZW1pdCBhbiBldmVudCB3aGVuIHRoZSBkZWZhdWx0IGRldmljZSBjaGFuZ2VzLCBzbyB3ZSBwZXJmb3JtIHRoZSBzYW1lIGJlc3QgZWZmb3J0IGFuZCBzd2l0Y2ggdG8gdGhlIG5ldyBkZXZpY2Ugb25jZSBjb25uZWN0ZWQgYW5kIGlmIGl0J3MgdGhlIGZpcnN0IGluIHRoZSBhcnJheVxuICAgICAgICBpZiAoZGV2aWNlc09mS2luZC5sZW5ndGggPiAwICYmIGRldmljZXNPZktpbmRbMF0/LmRldmljZUlkICE9PSBhY3RpdmVEZXZpY2UpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VzT2ZLaW5kWzBdLmRldmljZUlkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGtpbmQgPT09ICdhdWRpb2lucHV0JyAmJiAhaXNTYWZhcmkoKSkgfHwga2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgIC8vIGFpcnBvZHMgb24gU2FmYXJpIG5lZWQgc3BlY2lhbCBoYW5kbGluZyBmb3IgYXVkaW9pbnB1dCBhcyB0aGUgdHJhY2sgZG9lc24ndCBlbmQgYXMgc29vbiBhcyB5b3UgdGFrZSB0aGVtIG91dFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIHN3aXRjaCB0byBmaXJzdCBhdmFpbGFibGUgZGV2aWNlIGlmIHByZXZpb3VzbHkgYWN0aXZlIGRldmljZSBpcyBub3QgYXZhaWxhYmxlIGFueSBtb3JlXG4gICAgICBpZiAoXG4gICAgICAgIGRldmljZXNPZktpbmQubGVuZ3RoID4gMCAmJlxuICAgICAgICAhZGV2aWNlc09mS2luZC5maW5kKChkZXZpY2VJbmZvKSA9PiBkZXZpY2VJbmZvLmRldmljZUlkID09PSB0aGlzLmdldEFjdGl2ZURldmljZShraW5kKSlcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VzT2ZLaW5kWzBdLmRldmljZUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0NoYW5nZWQpO1xuICB9O1xuXG4gIHByaXZhdGUgaGFuZGxlUm9vbVVwZGF0ZSA9IChyb29tOiBSb29tTW9kZWwpID0+IHtcbiAgICBjb25zdCBvbGRSb29tID0gdGhpcy5yb29tSW5mbztcbiAgICB0aGlzLnJvb21JbmZvID0gcm9vbTtcbiAgICBpZiAob2xkUm9vbSAmJiBvbGRSb29tLm1ldGFkYXRhICE9PSByb29tLm1ldGFkYXRhKSB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Sb29tTWV0YWRhdGFDaGFuZ2VkLCByb29tLm1ldGFkYXRhKTtcbiAgICB9XG4gICAgaWYgKG9sZFJvb20/LmFjdGl2ZVJlY29yZGluZyAhPT0gcm9vbS5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlJlY29yZGluZ1N0YXR1c0NoYW5nZWQsIHJvb20uYWN0aXZlUmVjb3JkaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSA9ICh1cGRhdGU6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlKSA9PiB7XG4gICAgdXBkYXRlLnVwZGF0ZXMuZm9yRWFjaCgoaW5mbykgPT4ge1xuICAgICAgaWYgKGluZm8ucGFydGljaXBhbnRTaWQgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKGluZm8ucGFydGljaXBhbnRTaWQpO1xuICAgICAgaWYgKHBhcnRpY2lwYW50KSB7XG4gICAgICAgIHBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcHJpdmF0ZSBhc3luYyBhY3F1aXJlQXVkaW9Db250ZXh0KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4ICE9PSAnYm9vbGVhbicgJiYgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dCkge1xuICAgICAgLy8gb3ZlcnJpZGUgYXVkaW8gY29udGV4dCB3aXRoIGN1c3RvbSBhdWRpbyBjb250ZXh0IGlmIHN1cHBsaWVkIGJ5IHVzZXJcbiAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmF1ZGlvQ29udGV4dCB8fCB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIC8vIGJ5IHVzaW5nIGFuIEF1ZGlvQ29udGV4dCwgaXQgcmVkdWNlcyBsYWcgb24gYXVkaW8gZWxlbWVudHNcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk4MTE0MjkvaHRtbDUtYXVkaW8tdGFnLW9uLXNhZmFyaS1oYXMtYS1kZWxheS81NDExOTg1NCM1NDExOTg1NFxuICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSBnZXROZXdBdWRpb0NvbnRleHQoKSA/PyB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCkge1xuICAgICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZm9yRWFjaCgocGFydGljaXBhbnQpID0+XG4gICAgICAgIHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCksXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRBdWRpb0NvbnRleHQodGhpcy5hdWRpb0NvbnRleHQpO1xuXG4gICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0ICYmIHRoaXMuYXVkaW9Db250ZXh0LnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgLy8gZm9yIGlPUyBhIG5ld2x5IGNyZWF0ZWQgQXVkaW9Db250ZXh0IGlzIGFsd2F5cyBpbiBgc3VzcGVuZGVkYCBzdGF0ZS5cbiAgICAgIC8vIHdlIHRyeSBvdXIgYmVzdCB0byByZXN1bWUgdGhlIGNvbnRleHQgaGVyZSwgaWYgdGhhdCBkb2Vzbid0IHdvcmssIHdlIGp1c3QgY29udGludWUgd2l0aCByZWd1bGFyIHByb2Nlc3NpbmdcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbdGhpcy5hdWRpb0NvbnRleHQucmVzdW1lKCksIHNsZWVwKDIwMCldKTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdDb3VsZCBub3QgcmVzdW1lIGF1ZGlvIGNvbnRleHQnLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXJyb3I6IGUgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmV3Q29udGV4dElzUnVubmluZyA9IHRoaXMuYXVkaW9Db250ZXh0Py5zdGF0ZSA9PT0gJ3J1bm5pbmcnO1xuICAgIGlmIChuZXdDb250ZXh0SXNSdW5uaW5nICE9PSB0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgIHRoaXMuYXVkaW9FbmFibGVkID0gbmV3Q29udGV4dElzUnVubmluZztcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIG5ld0NvbnRleHRJc1J1bm5pbmcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUGFydGljaXBhbnQoaWRlbnRpdHk6IHN0cmluZywgaW5mbz86IFBhcnRpY2lwYW50SW5mbyk6IFJlbW90ZVBhcnRpY2lwYW50IHtcbiAgICBsZXQgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50O1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IFJlbW90ZVBhcnRpY2lwYW50LmZyb21QYXJ0aWNpcGFudEluZm8odGhpcy5lbmdpbmUuY2xpZW50LCBpbmZvLCB7XG4gICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0LFxuICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWNpcGFudCA9IG5ldyBSZW1vdGVQYXJ0aWNpcGFudChcbiAgICAgICAgdGhpcy5lbmdpbmUuY2xpZW50LFxuICAgICAgICAnJyxcbiAgICAgICAgaWRlbnRpdHksXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHtcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgIHBhcnRpY2lwYW50LnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQ/LmRldmljZUlkKSB7XG4gICAgICBwYXJ0aWNpcGFudFxuICAgICAgICAuc2V0QXVkaW9PdXRwdXQodGhpcy5vcHRpb25zLmF1ZGlvT3V0cHV0KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHRoaXMubG9nLndhcm4oYENvdWxkIG5vdCBzZXQgYXVkaW8gb3V0cHV0OiAke2UubWVzc2FnZX1gLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpY2lwYW50O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRPckNyZWF0ZVBhcnRpY2lwYW50KGlkZW50aXR5OiBzdHJpbmcsIGluZm86IFBhcnRpY2lwYW50SW5mbyk6IFJlbW90ZVBhcnRpY2lwYW50IHtcbiAgICBpZiAodGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuaGFzKGlkZW50aXR5KSkge1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJ0aWNpcGFudCA9IHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChpZGVudGl0eSkhO1xuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgY29uc3Qgd2FzVXBkYXRlZCA9IGV4aXN0aW5nUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgaWYgKHdhc1VwZGF0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNpZFRvSWRlbnRpdHkuc2V0KGluZm8uc2lkLCBpbmZvLmlkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nUGFydGljaXBhbnQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5jcmVhdGVQYXJ0aWNpcGFudChpZGVudGl0eSwgaW5mbyk7XG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuc2V0KGlkZW50aXR5LCBwYXJ0aWNpcGFudCk7XG5cbiAgICB0aGlzLnNpZFRvSWRlbnRpdHkuc2V0KGluZm8uc2lkLCBpbmZvLmlkZW50aXR5KTtcbiAgICAvLyBpZiB3ZSBoYXZlIHZhbGlkIGluZm8gYW5kIHRoZSBwYXJ0aWNpcGFudCB3YXNuJ3QgaW4gdGhlIG1hcCBiZWZvcmUsIHdlIGNhbiBhc3N1bWUgdGhlIHBhcnRpY2lwYW50IGlzIG5ld1xuICAgIC8vIGZpcmluZyBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IGBQYXJ0aWNpcGFudENvbm5lY3RlZGAgZmlyZXMgYmVmb3JlIHRoZSBpbml0aWFsIHRyYWNrIGV2ZW50c1xuICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50Q29ubmVjdGVkLCBwYXJ0aWNpcGFudCk7XG5cbiAgICAvLyBhbHNvIGZvcndhcmQgZXZlbnRzXG4gICAgLy8gdHJhY2tQdWJsaXNoZWQgaXMgb25seSBmaXJlZCBmb3IgdHJhY2tzIGFkZGVkIGFmdGVyIGJvdGggbG9jYWwgcGFydGljaXBhbnRcbiAgICAvLyBhbmQgcmVtb3RlIHBhcnRpY2lwYW50IGpvaW5lZCB0aGUgcm9vbVxuICAgIHBhcnRpY2lwYW50XG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1B1Ymxpc2hlZCwgKHRyYWNrUHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIHRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oXG4gICAgICAgIFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpYmVkLFxuICAgICAgICAodHJhY2s6IFJlbW90ZVRyYWNrLCBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgIC8vIG1vbml0b3IgcGxheWJhY2sgc3RhdHVzXG4gICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrRmFpbGVkLCB0aGlzLmhhbmRsZVZpZGVvUGxheWJhY2tGYWlsZWQpO1xuICAgICAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCwgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCB0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIChwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrVW5wdWJsaXNoZWQsIHB1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFxuICAgICAgICBQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLFxuICAgICAgICAodHJhY2s6IFJlbW90ZVRyYWNrLCBwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgICAgICB9LFxuICAgICAgKVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgKHB1YjogVHJhY2tQdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja011dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1VubXV0ZWQsIChwdWI6IFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgKG1ldGFkYXRhOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIG1ldGFkYXRhLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KVxuICAgICAgLm9uKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgKG5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSwgcGFydGljaXBhbnQpO1xuICAgICAgfSlcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCAoY2hhbmdlZEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChcbiAgICAgICAgICBSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCxcbiAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlcyxcbiAgICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIChxdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eSkgPT4ge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHksIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oXG4gICAgICAgIFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsXG4gICAgICAgIChwcmV2UGVybWlzc2lvbnM/OiBQYXJ0aWNpcGFudFBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFxuICAgICAgICAgICAgUm9vbUV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLFxuICAgICAgICAgICAgcHJldlBlcm1pc3Npb25zLFxuICAgICAgICAgICAgcGFydGljaXBhbnQsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIC5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHViLCBzdGF0dXMsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgKHRyYWNrU2lkLCBlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkLCB0cmFja1NpZCwgcGFydGljaXBhbnQsIGVycm9yKTtcbiAgICAgIH0pXG4gICAgICAub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChcbiAgICAgICAgICBSb29tRXZlbnQuVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCxcbiAgICAgICAgICBwdWIsXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHBhcnRpY2lwYW50LFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgaW5mbyBhdCB0aGUgZW5kIGFmdGVyIGNhbGxiYWNrcyBoYXZlIGJlZW4gc2V0IHVwXG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHBhcnRpY2lwYW50LnVwZGF0ZUluZm8oaW5mbyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgfVxuXG4gIHByaXZhdGUgc2VuZFN5bmNTdGF0ZSgpIHtcbiAgICBjb25zdCByZW1vdGVUcmFja3MgPSBBcnJheS5mcm9tKHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5yZWR1Y2UoKGFjYywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIGFjYy5wdXNoKC4uLihwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpIGFzIFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSkpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdIGFzIFJlbW90ZVRyYWNrUHVibGljYXRpb25bXSk7XG4gICAgY29uc3QgbG9jYWxUcmFja3MgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKSBhcyBMb2NhbFRyYWNrUHVibGljYXRpb25bXTsgLy8gRklYTUUgd291bGQgYmUgbmljZSB0byBoYXZlIHRoaXMgcmV0dXJuIExvY2FsVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgdGhpcy5lbmdpbmUuc2VuZFN5bmNTdGF0ZShyZW1vdGVUcmFja3MsIGxvY2FsVHJhY2tzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciByZXN1bWluZywgd2UnbGwgbmVlZCB0byBub3RpZnkgdGhlIHNlcnZlciBvZiB0aGUgY3VycmVudFxuICAgKiBzdWJzY3JpcHRpb24gc2V0dGluZ3MuXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IHB1YiBvZiBwLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHB1Yi5pc1N1YnNjcmliZWQgJiYgaXNSZW1vdGVQdWIocHViKSkge1xuICAgICAgICAgIHB1Yi5lbWl0VHJhY2tVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzaWQ6IHN0cmluZyk6IFJlbW90ZVBhcnRpY2lwYW50IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpZGVudGl0eSA9IHRoaXMuc2lkVG9JZGVudGl0eS5nZXQoc2lkKTtcbiAgICBpZiAoaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xuICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgbGV0IGNvbnNlY3V0aXZlRmFpbHVyZXMgPSAwO1xuICAgIHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBlbnN1cmUgd2UgZGlkbid0IHRlYXIgaXQgZG93blxuICAgICAgICAhdGhpcy5lbmdpbmUgfHxcbiAgICAgICAgLy8gZW5naW5lIGRldGVjdGVkIGNsb3NlLCBidXQgUm9vbSBtaXNzZWQgaXRcbiAgICAgICAgdGhpcy5lbmdpbmUuaXNDbG9zZWQgfHxcbiAgICAgICAgLy8gdHJhbnNwb3J0cyBmYWlsZWQgd2l0aG91dCBub3RpZnlpbmcgZW5naW5lXG4gICAgICAgICF0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMrKztcbiAgICAgICAgdGhpcy5sb2cud2FybignZGV0ZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZSBtaXNtYXRjaCcsIHtcbiAgICAgICAgICAuLi50aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgICAgbnVtRmFpbHVyZXM6IGNvbnNlY3V0aXZlRmFpbHVyZXMsXG4gICAgICAgICAgZW5naW5lOiB0aGlzLmVuZ2luZVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY2xvc2VkOiB0aGlzLmVuZ2luZS5pc0Nsb3NlZCxcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzQ29ubmVjdGVkOiB0aGlzLmVuZ2luZS52ZXJpZnlUcmFuc3BvcnQoKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uc2VjdXRpdmVGYWlsdXJlcyA+PSAzKSB7XG4gICAgICAgICAgdGhpcy5yZWNyZWF0ZUVuZ2luZSgpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdChcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLFxuICAgICAgICAgICAgRGlzY29ubmVjdFJlYXNvbi5TVEFURV9NSVNNQVRDSCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgIH1cbiAgICB9LCBjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5KTtcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJDb25uZWN0aW9uUmVjb25jaWxlKCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCkge1xuICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJJbnRlcnZhbCh0aGlzLmNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKHN0YXRlOiBDb25uZWN0aW9uU3RhdGUpOiBib29sZWFuIHtcbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIC8vIHVuY2hhbmdlZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLCB0aGlzLnN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEJ1ZmZlcmVkRXZlbnRzKCkge1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMuZm9yRWFjaCgoW2V2LCBhcmdzXSkgPT4ge1xuICAgICAgdGhpcy5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9KTtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gIH1cblxuICBwcml2YXRlIGVtaXRXaGVuQ29ubmVjdGVkPEUgZXh0ZW5kcyBrZXlvZiBSb29tRXZlbnRDYWxsYmFja3M+KFxuICAgIGV2ZW50OiBFLFxuICAgIC4uLmFyZ3M6IFBhcmFtZXRlcnM8Um9vbUV2ZW50Q2FsbGJhY2tzW0VdPlxuICApOiBib29sZWFuIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8XG4gICAgICB0aGlzLmlzUmVzdW1pbmcgfHxcbiAgICAgICF0aGlzLmVuZ2luZSB8fFxuICAgICAgdGhpcy5lbmdpbmUucGVuZGluZ1JlY29ubmVjdFxuICAgICkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgcm9vbSBpcyByZWNvbm5lY3RpbmcsIGJ1ZmZlciB0aGUgZXZlbnRzIGJ5IGZpcmluZyB0aGVtIGxhdGVyIGFmdGVyIGVtaXR0aW5nIFJvb21FdmVudC5SZWNvbm5lY3RlZFxuICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cy5wdXNoKFtldmVudCwgYXJnc10pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgb25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gKG1ldGFkYXRhOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCA9IChjaGFuZ2VkQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxvY2FsVHJhY2tNdXRlZCA9IChwdWI6IFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxUcmFja1VubXV0ZWQgPSAocHViOiBUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VubXV0ZWQsIHB1YiwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uVHJhY2tQcm9jZXNzb3JVcGRhdGUgPSAocHJvY2Vzc29yPzogVHJhY2tQcm9jZXNzb3I8VHJhY2suS2luZCwgYW55PikgPT4ge1xuICAgIHByb2Nlc3Nvcj8ub25QdWJsaXNoPy4odGhpcyk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxvY2FsVHJhY2tQdWJsaXNoZWQgPSBhc3luYyAocHViOiBMb2NhbFRyYWNrUHVibGljYXRpb24pID0+IHtcbiAgICBwdWIudHJhY2s/Lm9uKFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XG4gICAgcHViLnRyYWNrPy5vbihUcmFja0V2ZW50LlJlc3RhcnRlZCwgdGhpcy5vbkxvY2FsVHJhY2tSZXN0YXJ0ZWQpO1xuICAgIHB1Yi50cmFjaz8uZ2V0UHJvY2Vzc29yKCk/Lm9uUHVibGlzaD8uKHRoaXMpO1xuXG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG5cbiAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrKSkge1xuICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IGF3YWl0IHB1Yi50cmFjay5jaGVja0ZvclNpbGVuY2UoKTtcbiAgICAgIGlmICh0cmFja0lzU2lsZW50KSB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCwgcHViKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGV2aWNlSWQgPSBhd2FpdCBwdWIudHJhY2s/LmdldERldmljZUlkKGZhbHNlKTtcbiAgICBjb25zdCBkZXZpY2VLaW5kID0gc291cmNlVG9LaW5kKHB1Yi5zb3VyY2UpO1xuICAgIGlmIChcbiAgICAgIGRldmljZUtpbmQgJiZcbiAgICAgIGRldmljZUlkICYmXG4gICAgICBkZXZpY2VJZCAhPT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5nZXQoZGV2aWNlS2luZClcbiAgICApIHtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwgZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxUcmFja1VucHVibGlzaGVkID0gKHB1YjogTG9jYWxUcmFja1B1YmxpY2F0aW9uKSA9PiB7XG4gICAgcHViLnRyYWNrPy5vZmYoVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSwgdGhpcy5vblRyYWNrUHJvY2Vzc29yVXBkYXRlKTtcbiAgICBwdWIudHJhY2s/Lm9mZihUcmFja0V2ZW50LlJlc3RhcnRlZCwgdGhpcy5vbkxvY2FsVHJhY2tSZXN0YXJ0ZWQpO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBvbkxvY2FsVHJhY2tSZXN0YXJ0ZWQgPSBhc3luYyAodHJhY2s6IExvY2FsVHJhY2spID0+IHtcbiAgICBjb25zdCBkZXZpY2VJZCA9IGF3YWl0IHRyYWNrLmdldERldmljZUlkKGZhbHNlKTtcbiAgICBjb25zdCBkZXZpY2VLaW5kID0gc291cmNlVG9LaW5kKHRyYWNrLnNvdXJjZSk7XG4gICAgaWYgKFxuICAgICAgZGV2aWNlS2luZCAmJlxuICAgICAgZGV2aWNlSWQgJiZcbiAgICAgIGRldmljZUlkICE9PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLmdldChkZXZpY2VLaW5kKVxuICAgICkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXG4gICAgICAgIGBsb2NhbCB0cmFjayByZXN0YXJ0ZWQsIHNldHRpbmcgJHtkZXZpY2VLaW5kfSAke2RldmljZUlkfSBhY3RpdmVgLFxuICAgICAgICB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICApO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoZGV2aWNlS2luZCwgZGV2aWNlSWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCA9IChxdWFsaXR5OiBDb25uZWN0aW9uUXVhbGl0eSkgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICB9O1xuXG4gIHByaXZhdGUgb25NZWRpYURldmljZXNFcnJvciA9IChlOiBFcnJvcikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIGUpO1xuICB9O1xuXG4gIHByaXZhdGUgb25Mb2NhbFBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkID0gKHByZXZQZXJtaXNzaW9ucz86IFBhcnRpY2lwYW50UGVybWlzc2lvbikgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICBwcml2YXRlIG9uTG9jYWxDaGF0TWVzc2FnZVNlbnQgPSAobXNnOiBDaGF0TWVzc2FnZSkgPT4ge1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZywgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsb3dzIHRvIHBvcHVsYXRlIGEgcm9vbSB3aXRoIHNpbXVsYXRlZCBwYXJ0aWNpcGFudHMuXG4gICAqIE5vIGFjdHVhbCBjb25uZWN0aW9uIHRvIGEgc2VydmVyIHdpbGwgYmUgZXN0YWJsaXNoZWQsIGFsbCBzdGF0ZSBpc1xuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBhc3luYyBzaW11bGF0ZVBhcnRpY2lwYW50cyhvcHRpb25zOiBTaW11bGF0aW9uT3B0aW9ucykge1xuICAgIGNvbnN0IHB1Ymxpc2hPcHRpb25zID0ge1xuICAgICAgYXVkaW86IHRydWUsXG4gICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9ucy5wdWJsaXNoLFxuICAgIH07XG4gICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0ge1xuICAgICAgY291bnQ6IDksXG4gICAgICBhdWRpbzogZmFsc2UsXG4gICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgIGFzcGVjdFJhdGlvczogWzEuNjYsIDEuNywgMS4zXSxcbiAgICAgIC4uLm9wdGlvbnMucGFydGljaXBhbnRzLFxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tTW9kZWwoe1xuICAgICAgc2lkOiAnUk1fU0lNVUxBVEVEJyxcbiAgICAgIG5hbWU6ICdzaW11bGF0ZWQtcm9vbScsXG4gICAgICBlbXB0eVRpbWVvdXQ6IDAsXG4gICAgICBtYXhQYXJ0aWNpcGFudHM6IDAsXG4gICAgICBjcmVhdGlvblRpbWU6IHByb3RvSW50NjQucGFyc2UobmV3IERhdGUoKS5nZXRUaW1lKCkpLFxuICAgICAgbWV0YWRhdGE6ICcnLFxuICAgICAgbnVtUGFydGljaXBhbnRzOiAxLFxuICAgICAgbnVtUHVibGlzaGVyczogMSxcbiAgICAgIHR1cm5QYXNzd29yZDogJycsXG4gICAgICBlbmFibGVkQ29kZWNzOiBbXSxcbiAgICAgIGFjdGl2ZVJlY29yZGluZzogZmFsc2UsXG4gICAgfSk7XG5cbiAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudXBkYXRlSW5mbyhcbiAgICAgIG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJyxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCk7XG4gICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICBpZiAocHVibGlzaE9wdGlvbnMudmlkZW8pIHtcbiAgICAgIGNvbnN0IGNhbVB1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oXG4gICAgICAgIFRyYWNrLktpbmQuVmlkZW8sXG4gICAgICAgIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTBfMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgICBuYW1lOiAndmlkZW8tZHVtbXknLFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IExvY2FsVmlkZW9UcmFjayhcbiAgICAgICAgICBwdWJsaXNoT3B0aW9ucy51c2VSZWFsVHJhY2tzXG4gICAgICAgICAgICA/IChcbiAgICAgICAgICAgICAgICBhd2FpdCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KVxuICAgICAgICAgICAgICApLmdldFZpZGVvVHJhY2tzKClbMF1cbiAgICAgICAgICAgIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKFxuICAgICAgICAgICAgICAgIDE2MCAqIChwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zWzBdID8/IDEpLFxuICAgICAgICAgICAgICAgIDE2MCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICAgICksXG4gICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICApO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oY2FtUHViKTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgY2FtUHViKTtcbiAgICB9XG4gICAgaWYgKHB1Ymxpc2hPcHRpb25zLmF1ZGlvKSB7XG4gICAgICBjb25zdCBhdWRpb1B1YiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24oXG4gICAgICAgIFRyYWNrLktpbmQuQXVkaW8sXG4gICAgICAgIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuTUlDUk9QSE9ORSxcbiAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwXzAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU8sXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTG9jYWxBdWRpb1RyYWNrKFxuICAgICAgICAgIHB1Ymxpc2hPcHRpb25zLnVzZVJlYWxUcmFja3NcbiAgICAgICAgICAgID8gKGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSkpLmdldEF1ZGlvVHJhY2tzKClbMF1cbiAgICAgICAgICAgIDogZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LFxuICAgICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICAgICksXG4gICAgICAgIHsgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0IH0sXG4gICAgICApO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oYXVkaW9QdWIpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhdWRpb1B1Yik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWNpcGFudE9wdGlvbnMuY291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgIGxldCBpbmZvOiBQYXJ0aWNpcGFudEluZm8gPSBuZXcgUGFydGljaXBhbnRJbmZvKHtcbiAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMF8wMDApLnRvU3RyaW5nKCksXG4gICAgICAgIGlkZW50aXR5OiBgc2ltdWxhdGVkLSR7aX1gLFxuICAgICAgICBzdGF0ZTogUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSxcbiAgICAgICAgdHJhY2tzOiBbXSxcbiAgICAgICAgam9pbmVkQXQ6IHByb3RvSW50NjQucGFyc2UoRGF0ZS5ub3coKSksXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLmdldE9yQ3JlYXRlUGFydGljaXBhbnQoaW5mby5pZGVudGl0eSwgaW5mbyk7XG4gICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgIGNvbnN0IGR1bW15VmlkZW8gPSBjcmVhdGVEdW1teVZpZGVvU3RyZWFtVHJhY2soXG4gICAgICAgICAgMTYwICogKHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3NbaSAlIHBhcnRpY2lwYW50T3B0aW9ucy5hc3BlY3RSYXRpb3MubGVuZ3RoXSA/PyAxKSxcbiAgICAgICAgICAxNjAsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTBfMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgIHR5cGU6IFRyYWNrVHlwZS5BVURJTyxcbiAgICAgICAgfSk7XG4gICAgICAgIHAuYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2soXG4gICAgICAgICAgZHVtbXlWaWRlbyxcbiAgICAgICAgICB2aWRlb1RyYWNrLnNpZCxcbiAgICAgICAgICBuZXcgTWVkaWFTdHJlYW0oW2R1bW15VmlkZW9dKSxcbiAgICAgICAgICBuZXcgUlRDUnRwUmVjZWl2ZXIoKSxcbiAgICAgICAgKTtcbiAgICAgICAgaW5mby50cmFja3MgPSBbLi4uaW5mby50cmFja3MsIHZpZGVvVHJhY2tdO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy5hdWRpbykge1xuICAgICAgICBjb25zdCBkdW1teVRyYWNrID0gZ2V0RW1wdHlBdWRpb1N0cmVhbVRyYWNrKCk7XG4gICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMF8wMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICB9KTtcbiAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhcbiAgICAgICAgICBkdW1teVRyYWNrLFxuICAgICAgICAgIGF1ZGlvVHJhY2suc2lkLFxuICAgICAgICAgIG5ldyBNZWRpYVN0cmVhbShbZHVtbXlUcmFja10pLFxuICAgICAgICAgIG5ldyBSVENSdHBSZWNlaXZlcigpLFxuICAgICAgICApO1xuICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgYXVkaW9UcmFja107XG4gICAgICB9XG5cbiAgICAgIHAudXBkYXRlSW5mbyhpbmZvKTtcbiAgICB9XG4gIH1cblxuICAvLyAvKiogQGludGVybmFsICovXG4gIGVtaXQ8RSBleHRlbmRzIGtleW9mIFJvb21FdmVudENhbGxiYWNrcz4oXG4gICAgZXZlbnQ6IEUsXG4gICAgLi4uYXJnczogUGFyYW1ldGVyczxSb29tRXZlbnRDYWxsYmFja3NbRV0+XG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIGFjdGl2ZSBzcGVha2VyIHVwZGF0ZXMgYXJlIHRvbyBzcGFtbXlcbiAgICBpZiAoZXZlbnQgIT09IFJvb21FdmVudC5BY3RpdmVTcGVha2Vyc0NoYW5nZWQgJiYgZXZlbnQgIT09IFJvb21FdmVudC5UcmFuc2NyaXB0aW9uUmVjZWl2ZWQpIHtcbiAgICAgIC8vIG9ubHkgZXh0cmFjdCBsb2dDb250ZXh0IGZyb20gYXJndW1lbnRzIGluIG9yZGVyIHRvIGF2b2lkIGxvZ2dpbmcgdGhlIHdob2xlIG9iamVjdCB0cmVlXG4gICAgICBjb25zdCBtaW5pbWl6ZWRBcmdzID0gbWFwQXJncyhhcmdzKS5maWx0ZXIoKGFyZzogdW5rbm93bikgPT4gYXJnICE9PSB1bmRlZmluZWQpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoYHJvb20gZXZlbnQgJHtldmVudH1gLCB7IC4uLnRoaXMubG9nQ29udGV4dCwgZXZlbnQsIGFyZ3M6IG1pbmltaXplZEFyZ3MgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBBcmdzKGFyZ3M6IHVua25vd25bXSk6IGFueSB7XG4gIHJldHVybiBhcmdzLm1hcCgoYXJnOiB1bmtub3duKSA9PiB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgcmV0dXJuIG1hcEFyZ3MoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gJ2xvZ0NvbnRleHQnIGluIGFyZyA/IGFyZy5sb2dDb250ZXh0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUm9vbTtcblxuZXhwb3J0IHR5cGUgUm9vbUV2ZW50Q2FsbGJhY2tzID0ge1xuICBjb25uZWN0ZWQ6ICgpID0+IHZvaWQ7XG4gIHJlY29ubmVjdGluZzogKCkgPT4gdm9pZDtcbiAgc2lnbmFsUmVjb25uZWN0aW5nOiAoKSA9PiB2b2lkO1xuICByZWNvbm5lY3RlZDogKCkgPT4gdm9pZDtcbiAgZGlzY29ubmVjdGVkOiAocmVhc29uPzogRGlzY29ubmVjdFJlYXNvbikgPT4gdm9pZDtcbiAgY29ubmVjdGlvblN0YXRlQ2hhbmdlZDogKHN0YXRlOiBDb25uZWN0aW9uU3RhdGUpID0+IHZvaWQ7XG4gIG1lZGlhRGV2aWNlc0NoYW5nZWQ6ICgpID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50Q29ubmVjdGVkOiAocGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICBwYXJ0aWNpcGFudERpc2Nvbm5lY3RlZDogKHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgdHJhY2tQdWJsaXNoZWQ6IChwdWJsaWNhdGlvbjogUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmliZWQ6IChcbiAgICB0cmFjazogUmVtb3RlVHJhY2ssXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkOiAoXG4gICAgdHJhY2tTaWQ6IHN0cmluZyxcbiAgICBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQsXG4gICAgcmVhc29uPzogU3Vic2NyaXB0aW9uRXJyb3IsXG4gICkgPT4gdm9pZDtcbiAgdHJhY2tVbnB1Ymxpc2hlZDogKHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLCBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHRyYWNrVW5zdWJzY3JpYmVkOiAoXG4gICAgdHJhY2s6IFJlbW90ZVRyYWNrLFxuICAgIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICB0cmFja011dGVkOiAocHVibGljYXRpb246IFRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgdHJhY2tVbm11dGVkOiAocHVibGljYXRpb246IFRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgbG9jYWxUcmFja1B1Ymxpc2hlZDogKHB1YmxpY2F0aW9uOiBMb2NhbFRyYWNrUHVibGljYXRpb24sIHBhcnRpY2lwYW50OiBMb2NhbFBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICBsb2NhbFRyYWNrVW5wdWJsaXNoZWQ6IChcbiAgICBwdWJsaWNhdGlvbjogTG9jYWxUcmFja1B1YmxpY2F0aW9uLFxuICAgIHBhcnRpY2lwYW50OiBMb2NhbFBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIGxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQ6IChwdWJsaWNhdGlvbjogTG9jYWxUcmFja1B1YmxpY2F0aW9uKSA9PiB2b2lkO1xuICBwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZDogKFxuICAgIG1ldGFkYXRhOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50IHwgTG9jYWxQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICBwYXJ0aWNpcGFudE5hbWVDaGFuZ2VkOiAobmFtZTogc3RyaW5nLCBwYXJ0aWNpcGFudDogUmVtb3RlUGFydGljaXBhbnQgfCBMb2NhbFBhcnRpY2lwYW50KSA9PiB2b2lkO1xuICBwYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZDogKFxuICAgIHByZXZQZXJtaXNzaW9uczogUGFydGljaXBhbnRQZXJtaXNzaW9uIHwgdW5kZWZpbmVkLFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCB8IExvY2FsUGFydGljaXBhbnQsXG4gICkgPT4gdm9pZDtcbiAgcGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZDogKFxuICAgIGNoYW5nZWRBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCB8IExvY2FsUGFydGljaXBhbnQsXG4gICkgPT4gdm9pZDtcbiAgYWN0aXZlU3BlYWtlcnNDaGFuZ2VkOiAoc3BlYWtlcnM6IEFycmF5PFBhcnRpY2lwYW50PikgPT4gdm9pZDtcbiAgcm9vbU1ldGFkYXRhQ2hhbmdlZDogKG1ldGFkYXRhOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGRhdGFSZWNlaXZlZDogKFxuICAgIHBheWxvYWQ6IFVpbnQ4QXJyYXksXG4gICAgcGFydGljaXBhbnQ/OiBSZW1vdGVQYXJ0aWNpcGFudCxcbiAgICBraW5kPzogRGF0YVBhY2tldF9LaW5kLFxuICAgIHRvcGljPzogc3RyaW5nLFxuICApID0+IHZvaWQ7XG4gIHNpcERUTUZSZWNlaXZlZDogKGR0bWY6IFNpcERUTUYsIHBhcnRpY2lwYW50PzogUmVtb3RlUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIHRyYW5zY3JpcHRpb25SZWNlaXZlZDogKFxuICAgIHRyYW5zY3JpcHRpb246IFRyYW5zY3JpcHRpb25TZWdtZW50W10sXG4gICAgcGFydGljaXBhbnQ/OiBQYXJ0aWNpcGFudCxcbiAgICBwdWJsaWNhdGlvbj86IFRyYWNrUHVibGljYXRpb24sXG4gICkgPT4gdm9pZDtcbiAgY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkOiAocXVhbGl0eTogQ29ubmVjdGlvblF1YWxpdHksIHBhcnRpY2lwYW50OiBQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbiAgbWVkaWFEZXZpY2VzRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIHRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RyZWFtU3RhdGU6IFRyYWNrLlN0cmVhbVN0YXRlLFxuICAgIHBhcnRpY2lwYW50OiBSZW1vdGVQYXJ0aWNpcGFudCxcbiAgKSA9PiB2b2lkO1xuICB0cmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkOiAoXG4gICAgcHVibGljYXRpb246IFJlbW90ZVRyYWNrUHVibGljYXRpb24sXG4gICAgc3RhdHVzOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIHRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZDogKFxuICAgIHB1YmxpY2F0aW9uOiBSZW1vdGVUcmFja1B1YmxpY2F0aW9uLFxuICAgIHN0YXR1czogVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMsXG4gICAgcGFydGljaXBhbnQ6IFJlbW90ZVBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIGF1ZGlvUGxheWJhY2tDaGFuZ2VkOiAocGxheWluZzogYm9vbGVhbikgPT4gdm9pZDtcbiAgdmlkZW9QbGF5YmFja0NoYW5nZWQ6IChwbGF5aW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICBzaWduYWxDb25uZWN0ZWQ6ICgpID0+IHZvaWQ7XG4gIHJlY29yZGluZ1N0YXR1c0NoYW5nZWQ6IChyZWNvcmRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQ6IChlbmNyeXB0ZWQ6IGJvb2xlYW4sIHBhcnRpY2lwYW50PzogUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIGVuY3J5cHRpb25FcnJvcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgZGNCdWZmZXJTdGF0dXNDaGFuZ2VkOiAoaXNMb3c6IGJvb2xlYW4sIGtpbmQ6IERhdGFQYWNrZXRfS2luZCkgPT4gdm9pZDtcbiAgYWN0aXZlRGV2aWNlQ2hhbmdlZDogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgY2hhdE1lc3NhZ2U6IChtZXNzYWdlOiBDaGF0TWVzc2FnZSwgcGFydGljaXBhbnQ/OiBSZW1vdGVQYXJ0aWNpcGFudCB8IExvY2FsUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIGxvY2FsVHJhY2tTdWJzY3JpYmVkOiAocHVibGljYXRpb246IExvY2FsVHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQ6IExvY2FsUGFydGljaXBhbnQpID0+IHZvaWQ7XG4gIG1ldHJpY3NSZWNlaXZlZDogKG1ldHJpY3M6IE1ldHJpY3NCYXRjaCwgcGFydGljaXBhbnQ/OiBQYXJ0aWNpcGFudCkgPT4gdm9pZDtcbn07XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBSb29tQ29ubmVjdE9wdGlvbnMsIFJvb21PcHRpb25zIH0gZnJvbSAnLi4vLi4vb3B0aW9ucyc7XG5pbXBvcnQgdHlwZSBSVENFbmdpbmUgZnJvbSAnLi4vLi4vcm9vbS9SVENFbmdpbmUnO1xuaW1wb3J0IFJvb20sIHsgQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vcm9vbS9Sb29tJztcbmltcG9ydCB7IFJvb21FdmVudCB9IGZyb20gJy4uLy4uL3Jvb20vZXZlbnRzJztcbmltcG9ydCB0eXBlIHsgU2ltdWxhdGlvblNjZW5hcmlvIH0gZnJvbSAnLi4vLi4vcm9vbS90eXBlcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uLy4uL3Jvb20vdXRpbHMnO1xuXG50eXBlIExvZ01lc3NhZ2UgPSB7XG4gIGxldmVsOiAnaW5mbycgfCAnd2FybmluZycgfCAnZXJyb3InO1xuICBtZXNzYWdlOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgZW51bSBDaGVja1N0YXR1cyB7XG4gIElETEUsXG4gIFJVTk5JTkcsXG4gIFNLSVBQRUQsXG4gIFNVQ0NFU1MsXG4gIEZBSUxFRCxcbn1cblxuZXhwb3J0IHR5cGUgQ2hlY2tJbmZvID0ge1xuICBuYW1lOiBzdHJpbmc7XG4gIGxvZ3M6IEFycmF5PExvZ01lc3NhZ2U+O1xuICBzdGF0dXM6IENoZWNrU3RhdHVzO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBkYXRhPzogYW55O1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2VyT3B0aW9ucyB7XG4gIGVycm9yc0FzV2FybmluZ3M/OiBib29sZWFuO1xuICByb29tT3B0aW9ucz86IFJvb21PcHRpb25zO1xuICBjb25uZWN0T3B0aW9ucz86IFJvb21Db25uZWN0T3B0aW9ucztcbiAgcHJvdG9jb2w/OiAndWRwJyB8ICd0Y3AnO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2hlY2tlciBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRW1pdHRlcjxDaGVja2VyQ2FsbGJhY2tzPikge1xuICBwcm90ZWN0ZWQgdXJsOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIHRva2VuOiBzdHJpbmc7XG5cbiAgcm9vbTogUm9vbTtcblxuICBjb25uZWN0T3B0aW9ucz86IFJvb21Db25uZWN0T3B0aW9ucztcblxuICBzdGF0dXM6IENoZWNrU3RhdHVzID0gQ2hlY2tTdGF0dXMuSURMRTtcblxuICBsb2dzOiBBcnJheTxMb2dNZXNzYWdlPiA9IFtdO1xuXG4gIG5hbWU6IHN0cmluZztcblxuICBvcHRpb25zOiBDaGVja2VyT3B0aW9ucyA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCB0b2tlbjogc3RyaW5nLCBvcHRpb25zOiBDaGVja2VyT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMucm9vbSA9IG5ldyBSb29tKG9wdGlvbnMucm9vbU9wdGlvbnMpO1xuICAgIHRoaXMuY29ubmVjdE9wdGlvbnMgPSBvcHRpb25zLmNvbm5lY3RPcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBhYnN0cmFjdCBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nO1xuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD47XG5cbiAgYXN5bmMgcnVuKG9uQ29tcGxldGU/OiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBDaGVja1N0YXR1cy5JRExFKSB7XG4gICAgICB0aHJvdyBFcnJvcignY2hlY2sgaXMgcnVubmluZyBhbHJlYWR5Jyk7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdHVzKENoZWNrU3RhdHVzLlJVTk5JTkcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucGVyZm9ybSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXJyb3JzQXNXYXJuaW5ncykge1xuICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhlcnIubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcblxuICAgIC8vIHNsZWVwIGZvciBhIGJpdCB0byBlbnN1cmUgZGlzY29ubmVjdFxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuU0tJUFBFRCkge1xuICAgICAgdGhpcy5zZXRTdGF0dXModGhpcy5pc1N1Y2Nlc3MoKSA/IENoZWNrU3RhdHVzLlNVQ0NFU1MgOiBDaGVja1N0YXR1cy5GQUlMRUQpO1xuICAgIH1cblxuICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICBvbkNvbXBsZXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEluZm8oKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpc1N1Y2Nlc3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmxvZ3Muc29tZSgobCkgPT4gbC5sZXZlbCA9PT0gJ2Vycm9yJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgY29ubmVjdCh1cmw/OiBzdHJpbmcpOiBQcm9taXNlPFJvb20+IHtcbiAgICBpZiAodGhpcy5yb29tLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb29tO1xuICAgIH1cbiAgICBpZiAoIXVybCkge1xuICAgICAgdXJsID0gdGhpcy51cmw7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucm9vbS5jb25uZWN0KHVybCwgdGhpcy50b2tlbiwgdGhpcy5jb25uZWN0T3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMucm9vbTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnJvb20gJiYgdGhpcy5yb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLnJvb20uZGlzY29ubmVjdCgpO1xuICAgICAgLy8gd2FpdCBmb3IgaXQgdG8gZ28gdGhyb3VnaFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHNraXAoKSB7XG4gICAgdGhpcy5zZXRTdGF0dXMoQ2hlY2tTdGF0dXMuU0tJUFBFRCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgc3dpdGNoUHJvdG9jb2wocHJvdG9jb2w6ICd1ZHAnIHwgJ3RjcCcgfCAndGxzJykge1xuICAgIGxldCBoYXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBsZXQgaGFzUmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJvb20ub24oUm9vbUV2ZW50LlJlY29ubmVjdGluZywgKCkgPT4ge1xuICAgICAgaGFzUmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLnJvb20ub25jZShSb29tRXZlbnQuUmVjb25uZWN0ZWQsICgpID0+IHtcbiAgICAgIGhhc1JlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLnJvb20uc2ltdWxhdGVTY2VuYXJpbyhgZm9yY2UtJHtwcm90b2NvbH1gIGFzIFNpbXVsYXRpb25TY2VuYXJpbyk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgIGlmICghaGFzUmVjb25uZWN0aW5nKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIHdhaXQgZm9yIHJlY29ubmVjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdhaXQgZm9yIDEwIHNlY29uZHMgZm9yIHJlY29ubmVjdGlvblxuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgMTAwMDA7XG4gICAgd2hpbGUgKERhdGUubm93KCkgPCB0aW1lb3V0KSB7XG4gICAgICBpZiAoaGFzUmVjb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmVjb25uZWN0IHVzaW5nICR7cHJvdG9jb2x9IHByb3RvY29sIGFmdGVyIDEwIHNlY29uZHNgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMubG9ncy5wdXNoKHsgbGV2ZWw6ICdpbmZvJywgbWVzc2FnZSB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRXYXJuaW5nKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHRoaXMubG9ncy5wdXNoKHsgbGV2ZWw6ICd3YXJuaW5nJywgbWVzc2FnZSB9KTtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcHBlbmRFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7IGxldmVsOiAnZXJyb3InLCBtZXNzYWdlIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFN0YXR1cyhzdGF0dXM6IENoZWNrU3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IGVuZ2luZSgpOiBSVENFbmdpbmUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJvb20/LmVuZ2luZTtcbiAgfVxuXG4gIGdldEluZm8oKTogQ2hlY2tJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9nczogdGhpcy5sb2dzLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCB0eXBlIEluc3RhbnRpYWJsZUNoZWNrPFQgZXh0ZW5kcyBDaGVja2VyPiA9IHtcbiAgbmV3ICh1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZywgb3B0aW9ucz86IENoZWNrZXJPcHRpb25zKTogVDtcbn07XG5cbnR5cGUgQ2hlY2tlckNhbGxiYWNrcyA9IHtcbiAgdXBkYXRlOiAoaW5mbzogQ2hlY2tJbmZvKSA9PiB2b2lkO1xufTtcbiIsImltcG9ydCB7IFJlZ2lvblVybFByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vcm9vbS9SZWdpb25VcmxQcm92aWRlcic7XG5pbXBvcnQgeyB0eXBlIENoZWNrSW5mbywgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaW9uU3RhdHMge1xuICByZWdpb246IHN0cmluZztcbiAgcnR0OiBudW1iZXI7XG4gIGR1cmF0aW9uOiBudW1iZXI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGZvciBjb25uZWN0aW9ucyBxdWFsaXR5IHRvIGNsb3Nlc3RzIENsb3VkIHJlZ2lvbnMgYW5kIGRldGVybWluaW5nIHRoZSBiZXN0IHF1YWxpdHlcbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkUmVnaW9uQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgcHJpdmF0ZSBiZXN0U3RhdHM/OiBSZWdpb25TdGF0cztcblxuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0Nsb3VkIHJlZ2lvbnMnO1xuICB9XG5cbiAgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByZWdpb25Qcm92aWRlciA9IG5ldyBSZWdpb25VcmxQcm92aWRlcih0aGlzLnVybCwgdGhpcy50b2tlbik7XG4gICAgaWYgKCFyZWdpb25Qcm92aWRlci5pc0Nsb3VkKCkpIHtcbiAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZ2lvblN0YXRzOiBSZWdpb25TdGF0c1tdID0gW107XG4gICAgY29uc3Qgc2VlblVybHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBjb25zdCByZWdpb25VcmwgPSBhd2FpdCByZWdpb25Qcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgaWYgKCFyZWdpb25VcmwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2VlblVybHMuaGFzKHJlZ2lvblVybCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzZWVuVXJscy5hZGQocmVnaW9uVXJsKTtcbiAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgdGhpcy5jaGVja0Nsb3VkUmVnaW9uKHJlZ2lvblVybCk7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoYCR7c3RhdHMucmVnaW9ufSBSVFQ6ICR7c3RhdHMucnR0fW1zLCBkdXJhdGlvbjogJHtzdGF0cy5kdXJhdGlvbn1tc2ApO1xuICAgICAgcmVnaW9uU3RhdHMucHVzaChzdGF0cyk7XG4gICAgfVxuXG4gICAgcmVnaW9uU3RhdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIChhLmR1cmF0aW9uIC0gYi5kdXJhdGlvbikgKiAwLjUgKyAoYS5ydHQgLSBiLnJ0dCkgKiAwLjU7XG4gICAgfSk7XG4gICAgY29uc3QgYmVzdFJlZ2lvbiA9IHJlZ2lvblN0YXRzWzBdO1xuICAgIHRoaXMuYmVzdFN0YXRzID0gYmVzdFJlZ2lvbjtcbiAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoYGJlc3QgQ2xvdWQgcmVnaW9uOiAke2Jlc3RSZWdpb24ucmVnaW9ufWApO1xuICB9XG5cbiAgZ2V0SW5mbygpOiBDaGVja0luZm8ge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRJbmZvKCk7XG4gICAgaW5mby5kYXRhID0gdGhpcy5iZXN0U3RhdHM7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNoZWNrQ2xvdWRSZWdpb24odXJsOiBzdHJpbmcpOiBQcm9taXNlPFJlZ2lvblN0YXRzPiB7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0KHVybCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcm90b2NvbCA9PT0gJ3RjcCcpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3dpdGNoUHJvdG9jb2woJ3RjcCcpO1xuICAgIH1cbiAgICBjb25zdCByZWdpb24gPSB0aGlzLnJvb20uc2VydmVySW5mbz8ucmVnaW9uO1xuICAgIGlmICghcmVnaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZ2lvbiBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB3cml0ZXIgPSBhd2FpdCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5zdHJlYW1UZXh0KHsgdG9waWM6ICd0ZXN0JyB9KTtcbiAgICBjb25zdCBjaHVua1NpemUgPSAxMDAwOyAvLyBlYWNoIGNodW5rIGlzIGFib3V0IDEwMDAgYnl0ZXNcbiAgICBjb25zdCB0b3RhbFNpemUgPSAxXzAwMF8wMDA7IC8vIGFwcHJveGltYXRlbHkgMU1CIG9mIGRhdGFcbiAgICBjb25zdCBudW1DaHVua3MgPSB0b3RhbFNpemUgLyBjaHVua1NpemU7IC8vIHdpbGwgeWllbGQgMTAwMCBjaHVua3NcbiAgICBjb25zdCBjaHVua0RhdGEgPSAnQScucmVwZWF0KGNodW5rU2l6ZSk7IC8vIGNyZWF0ZSBhIHN0cmluZyBvZiAxMDAwICdBJyBjaGFyYWN0ZXJzXG5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2h1bmtzOyBpKyspIHtcbiAgICAgIGF3YWl0IHdyaXRlci53cml0ZShjaHVua0RhdGEpO1xuICAgIH1cbiAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMucm9vbS5lbmdpbmUucGNNYW5hZ2VyPy5wdWJsaXNoZXIuZ2V0U3RhdHMoKTtcbiAgICBjb25zdCByZWdpb25TdGF0czogUmVnaW9uU3RhdHMgPSB7XG4gICAgICByZWdpb246IHJlZ2lvbixcbiAgICAgIHJ0dDogMTAwMDAsXG4gICAgICBkdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZSxcbiAgICB9O1xuICAgIHN0YXRzPy5mb3JFYWNoKChzdGF0KSA9PiB7XG4gICAgICBpZiAoc3RhdC50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInICYmIHN0YXQubm9taW5hdGVkKSB7XG4gICAgICAgIHJlZ2lvblN0YXRzLnJ0dCA9IHN0YXQuY3VycmVudFJvdW5kVHJpcFRpbWUgKiAxMDAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXdhaXQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlZ2lvblN0YXRzO1xuICB9XG59XG4iLCJpbXBvcnQgeyB0eXBlIENoZWNrSW5mbywgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvdG9jb2xTdGF0cyB7XG4gIHByb3RvY29sOiAndWRwJyB8ICd0Y3AnO1xuICBwYWNrZXRzTG9zdDogbnVtYmVyO1xuICBwYWNrZXRzU2VudDogbnVtYmVyO1xuICBxdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9uczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgLy8gdG90YWwgbWV0cmljcyBtZWFzdXJlIHN1bSBvZiBhbGwgbWVhc3VyZW1lbnRzLCBhbG9uZyB3aXRoIGEgY291bnRcbiAgcnR0VG90YWw6IG51bWJlcjtcbiAgaml0dGVyVG90YWw6IG51bWJlcjtcbiAgYml0cmF0ZVRvdGFsOiBudW1iZXI7XG4gIGNvdW50OiBudW1iZXI7XG59XG5cbmNvbnN0IFRFU1RfRFVSQVRJT04gPSAxMDAwMDtcblxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25Qcm90b2NvbENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIHByaXZhdGUgYmVzdFN0YXRzPzogUHJvdG9jb2xTdGF0cztcblxuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0Nvbm5lY3Rpb24gdmlhIFVEUCB2cyBUQ1AnO1xuICB9XG5cbiAgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB1ZHBTdGF0cyA9IGF3YWl0IHRoaXMuY2hlY2tDb25uZWN0aW9uUHJvdG9jb2woJ3VkcCcpO1xuICAgIGNvbnN0IHRjcFN0YXRzID0gYXdhaXQgdGhpcy5jaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgndGNwJyk7XG4gICAgdGhpcy5iZXN0U3RhdHMgPSB1ZHBTdGF0cztcbiAgICAvLyB1ZHAgc2hvdWxkIGlzIHRoZSBiZXR0ZXIgcHJvdG9jb2wgdHlwaWNhbGx5LiBob3dldmVyLCB3ZSdkIHByZWZlciBUQ1Agd2hlbiBlaXRoZXIgb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgdHJ1ZTpcbiAgICAvLyAxLiB0aGUgYmFuZHdpZHRoIGxpbWl0YXRpb24gaXMgd29yc2Ugb24gVURQIGJ5IDUwMG1zXG4gICAgLy8gMi4gdGhlIHBhY2tldCBsb3NzIGlzIGhpZ2hlciBvbiBVRFAgYnkgMSVcbiAgICBpZiAoXG4gICAgICB1ZHBTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggLVxuICAgICAgICB0Y3BTdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5iYW5kd2lkdGggPlxuICAgICAgICAwLjUgfHxcbiAgICAgICh1ZHBTdGF0cy5wYWNrZXRzTG9zdCAtIHRjcFN0YXRzLnBhY2tldHNMb3N0KSAvIHVkcFN0YXRzLnBhY2tldHNTZW50ID4gMC4wMVxuICAgICkge1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdiZXN0IGNvbm5lY3Rpb24gcXVhbGl0eSB2aWEgdGNwJyk7XG4gICAgICB0aGlzLmJlc3RTdGF0cyA9IHRjcFN0YXRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2Jlc3QgY29ubmVjdGlvbiBxdWFsaXR5IHZpYSB1ZHAnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuYmVzdFN0YXRzO1xuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcbiAgICAgIGB1cHN0cmVhbSBiaXRyYXRlOiAkeyhzdGF0cy5iaXRyYXRlVG90YWwgLyBzdGF0cy5jb3VudCAvIDEwMDAgLyAxMDAwKS50b0ZpeGVkKDIpfSBtYnBzYCxcbiAgICApO1xuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgUlRUOiAkeygoc3RhdHMucnR0VG90YWwgLyBzdGF0cy5jb3VudCkgKiAxMDAwKS50b0ZpeGVkKDIpfSBtc2ApO1xuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgaml0dGVyOiAkeygoc3RhdHMuaml0dGVyVG90YWwgLyBzdGF0cy5jb3VudCkgKiAxMDAwKS50b0ZpeGVkKDIpfSBtc2ApO1xuXG4gICAgaWYgKHN0YXRzLnBhY2tldHNMb3N0ID4gMCkge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFxuICAgICAgICBgcGFja2V0cyBsb3N0OiAkeygoc3RhdHMucGFja2V0c0xvc3QgLyBzdGF0cy5wYWNrZXRzU2VudCkgKiAxMDApLnRvRml4ZWQoMil9JWAsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoID4gMSkge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFxuICAgICAgICBgYmFuZHdpZHRoIGxpbWl0ZWQgJHsoKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCAvIChURVNUX0RVUkFUSU9OIC8gMTAwMCkpICogMTAwKS50b0ZpeGVkKDIpfSVgLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmNwdSA+IDApIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcbiAgICAgICAgYGNwdSBsaW1pdGVkICR7KChzdGF0cy5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucy5jcHUgLyAoVEVTVF9EVVJBVElPTiAvIDEwMDApKSAqIDEwMCkudG9GaXhlZCgyKX0lYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZ2V0SW5mbygpOiBDaGVja0luZm8ge1xuICAgIGNvbnN0IGluZm8gPSBzdXBlci5nZXRJbmZvKCk7XG4gICAgaW5mby5kYXRhID0gdGhpcy5iZXN0U3RhdHM7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNoZWNrQ29ubmVjdGlvblByb3RvY29sKHByb3RvY29sOiAndGNwJyB8ICd1ZHAnKTogUHJvbWlzZTxQcm90b2NvbFN0YXRzPiB7XG4gICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgaWYgKHByb3RvY29sID09PSAndGNwJykge1xuICAgICAgYXdhaXQgdGhpcy5zd2l0Y2hQcm90b2NvbCgndGNwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuc3dpdGNoUHJvdG9jb2woJ3VkcCcpO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIGNhbnZhcyB3aXRoIGFuaW1hdGVkIGNvbnRlbnRcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSAxMjgwO1xuICAgIGNhbnZhcy5oZWlnaHQgPSA3MjA7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgIH1cblxuICAgIGxldCBodWUgPSAwO1xuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICBodWUgPSAoaHVlICsgMSkgJSAzNjA7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYGhzbCgke2h1ZX0sIDEwMCUsIDUwJSlgO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgfTtcbiAgICBhbmltYXRlKCk7XG5cbiAgICAvLyBjcmVhdGUgdmlkZW8gdHJhY2sgZnJvbSBjYW52YXNcbiAgICBjb25zdCBzdHJlYW0gPSBjYW52YXMuY2FwdHVyZVN0cmVhbSgzMCk7IC8vIDMwZnBzXG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuXG4gICAgLy8gcHVibGlzaCB0byByb29tXG4gICAgY29uc3QgcHViID0gYXdhaXQgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHZpZGVvVHJhY2ssIHtcbiAgICAgIHNpbXVsY2FzdDogZmFsc2UsXG4gICAgICBkZWdyYWRhdGlvblByZWZlcmVuY2U6ICdtYWludGFpbi1yZXNvbHV0aW9uJyxcbiAgICAgIHZpZGVvRW5jb2Rpbmc6IHtcbiAgICAgICAgbWF4Qml0cmF0ZTogMjAwMDAwMCxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgdHJhY2sgPSBwdWIhLnRyYWNrITtcblxuICAgIGNvbnN0IHByb3RvY29sU3RhdHM6IFByb3RvY29sU3RhdHMgPSB7XG4gICAgICBwcm90b2NvbCxcbiAgICAgIHBhY2tldHNMb3N0OiAwLFxuICAgICAgcGFja2V0c1NlbnQ6IDAsXG4gICAgICBxdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9uczoge30sXG4gICAgICBydHRUb3RhbDogMCxcbiAgICAgIGppdHRlclRvdGFsOiAwLFxuICAgICAgYml0cmF0ZVRvdGFsOiAwLFxuICAgICAgY291bnQ6IDAsXG4gICAgfTtcbiAgICAvLyBnYXRoZXIgc3RhdHMgb25jZSBhIHNlY29uZFxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0cmFjay5nZXRSVENTdGF0c1JlcG9ydCgpO1xuICAgICAgc3RhdHM/LmZvckVhY2goKHN0YXQpID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICBwcm90b2NvbFN0YXRzLnBhY2tldHNTZW50ID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgICBwcm90b2NvbFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zID0gc3RhdC5xdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucztcbiAgICAgICAgICBwcm90b2NvbFN0YXRzLmJpdHJhdGVUb3RhbCArPSBzdGF0LnRhcmdldEJpdHJhdGU7XG4gICAgICAgICAgcHJvdG9jb2xTdGF0cy5jb3VudCsrO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXQudHlwZSA9PT0gJ3JlbW90ZS1pbmJvdW5kLXJ0cCcpIHtcbiAgICAgICAgICBwcm90b2NvbFN0YXRzLnBhY2tldHNMb3N0ID0gc3RhdC5wYWNrZXRzTG9zdDtcbiAgICAgICAgICBwcm90b2NvbFN0YXRzLnJ0dFRvdGFsICs9IHN0YXQucm91bmRUcmlwVGltZTtcbiAgICAgICAgICBwcm90b2NvbFN0YXRzLmppdHRlclRvdGFsICs9IHN0YXQuaml0dGVyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCAxMDAwKTtcblxuICAgIC8vIHdhaXQgYSBiaXQgdG8gZ2F0aGVyIHN0YXRzXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgVEVTVF9EVVJBVElPTikpO1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuXG4gICAgdmlkZW9UcmFjay5zdG9wKCk7XG4gICAgY2FudmFzLnJlbW92ZSgpO1xuICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIHJldHVybiBwcm90b2NvbFN0YXRzO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVMb2NhbEF1ZGlvVHJhY2sgfSBmcm9tICcuLi8uLi9yb29tL3RyYWNrL2NyZWF0ZSc7XG5pbXBvcnQgeyBkZXRlY3RTaWxlbmNlIH0gZnJvbSAnLi4vLi4vcm9vbS90cmFjay91dGlscyc7XG5pbXBvcnQgeyBDaGVja2VyIH0gZnJvbSAnLi9DaGVja2VyJztcblxuZXhwb3J0IGNsYXNzIFB1Ymxpc2hBdWRpb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggYXVkaW8nO1xuICB9XG5cbiAgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByb29tID0gYXdhaXQgdGhpcy5jb25uZWN0KCk7XG5cbiAgICBjb25zdCB0cmFjayA9IGF3YWl0IGNyZWF0ZUxvY2FsQXVkaW9UcmFjaygpO1xuXG4gICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IGF3YWl0IGRldGVjdFNpbGVuY2UodHJhY2ssIDEwMDApO1xuICAgIGlmICh0cmFja0lzU2lsZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlY3QgYXVkaW8gZnJvbSBtaWNyb3Bob25lJyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kTWVzc2FnZSgnZGV0ZWN0ZWQgYXVkaW8gZnJvbSBtaWNyb3Bob25lJyk7XG5cbiAgICByb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRyYWNrKTtcbiAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG5cbiAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCB0cmFjay5zZW5kZXI/LmdldFN0YXRzKCk7XG4gICAgaWYgKCFzdGF0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IFJUQ1N0YXRzJyk7XG4gICAgfVxuICAgIGxldCBudW1QYWNrZXRzID0gMDtcbiAgICBzdGF0cy5mb3JFYWNoKChzdGF0KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiZcbiAgICAgICAgKHN0YXQua2luZCA9PT0gJ2F1ZGlvJyB8fCAoIXN0YXQua2luZCAmJiBzdGF0Lm1lZGlhVHlwZSA9PT0gJ2F1ZGlvJykpXG4gICAgICApIHtcbiAgICAgICAgbnVtUGFja2V0cyA9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgcHVibGlzaGVkICR7bnVtUGFja2V0c30gYXVkaW8gcGFja2V0c2ApO1xuICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVMb2NhbFZpZGVvVHJhY2sgfSBmcm9tICcuLi8uLi9yb29tL3RyYWNrL2NyZWF0ZSc7XG5pbXBvcnQgeyBDaGVja2VyIH0gZnJvbSAnLi9DaGVja2VyJztcblxuZXhwb3J0IGNsYXNzIFB1Ymxpc2hWaWRlb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggdmlkZW8nO1xuICB9XG5cbiAgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCByb29tID0gYXdhaXQgdGhpcy5jb25uZWN0KCk7XG5cbiAgICBjb25zdCB0cmFjayA9IGF3YWl0IGNyZWF0ZUxvY2FsVmlkZW9UcmFjaygpO1xuXG4gICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBmcm9tIGNhbWVyYVxuICAgIGF3YWl0IHRoaXMuY2hlY2tGb3JWaWRlbyh0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcblxuICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodHJhY2spO1xuICAgIC8vIHdhaXQgZm9yIGEgZmV3IHNlY29uZHMgdG8gcHVibGlzaFxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcblxuICAgIC8vIHZlcmlmeSBSVEMgc3RhdHMgdGhhdCBpdCdzIHB1Ymxpc2hpbmdcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRyYWNrLnNlbmRlcj8uZ2V0U3RhdHMoKTtcbiAgICBpZiAoIXN0YXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgUlRDU3RhdHMnKTtcbiAgICB9XG4gICAgbGV0IG51bVBhY2tldHMgPSAwO1xuICAgIHN0YXRzLmZvckVhY2goKHN0YXQpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdC50eXBlID09PSAnb3V0Ym91bmQtcnRwJyAmJlxuICAgICAgICAoc3RhdC5raW5kID09PSAndmlkZW8nIHx8ICghc3RhdC5raW5kICYmIHN0YXQubWVkaWFUeXBlID09PSAndmlkZW8nKSlcbiAgICAgICkge1xuICAgICAgICBudW1QYWNrZXRzICs9IHN0YXQucGFja2V0c1NlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG51bVBhY2tldHMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgcHVibGlzaGVkICR7bnVtUGFja2V0c30gdmlkZW8gcGFja2V0c2ApO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tGb3JWaWRlbyh0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgIHN0cmVhbS5hZGRUcmFjayh0cmFjay5jbG9uZSgpKTtcblxuICAgIC8vIENyZWF0ZSB2aWRlbyBlbGVtZW50IHRvIGNoZWNrIGZyYW1lc1xuICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgdmlkZW8ubXV0ZWQgPSB0cnVlO1xuXG4gICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgIHZpZGVvLm9ucGxheSA9ICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gc2V0dGluZ3Mud2lkdGggPz8gdmlkZW8udmlkZW9XaWR0aCA/PyAxMjgwO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHNldHRpbmdzLmhlaWdodCA/PyB2aWRlby52aWRlb0hlaWdodCA/PyA3MjA7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSE7XG5cbiAgICAgICAgICAvLyBEcmF3IHZpZGVvIGZyYW1lIHRvIGNhbnZhc1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDApO1xuXG4gICAgICAgICAgLy8gR2V0IGltYWdlIGRhdGEgYW5kIGNoZWNrIGlmIGFsbCBwaXhlbHMgYXJlIGJsYWNrXG4gICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICBsZXQgaXNBbGxCbGFjayA9IHRydWU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMCB8fCBkYXRhW2kgKyAxXSAhPT0gMCB8fCBkYXRhW2kgKyAyXSAhPT0gMCkge1xuICAgICAgICAgICAgICBpc0FsbEJsYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0FsbEJsYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEVycm9yKCdjYW1lcmEgYXBwZWFycyB0byBiZSBwcm9kdWNpbmcgb25seSBibGFjayBmcmFtZXMnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdyZWNlaXZlZCB2aWRlbyBmcmFtZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgIH07XG4gICAgICB2aWRlby5wbGF5KCk7XG4gICAgfSk7XG5cbiAgICB2aWRlby5yZW1vdmUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vcm9vbS9Sb29tJztcbmltcG9ydCB7IFJvb21FdmVudCB9IGZyb20gJy4uLy4uL3Jvb20vZXZlbnRzJztcbmltcG9ydCB7IENoZWNrZXIgfSBmcm9tICcuL0NoZWNrZXInO1xuXG5leHBvcnQgY2xhc3MgUmVjb25uZWN0Q2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdSZXN1bWluZyBjb25uZWN0aW9uIGFmdGVyIGludGVycnVwdGlvbic7XG4gIH1cblxuICBhc3luYyBwZXJmb3JtKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHJvb20gPSBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcbiAgICBsZXQgcmVjb25uZWN0aW5nVHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgbGV0IHJlY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICBsZXQgcmVjb25uZWN0UmVzb2x2ZXI6ICh2YWx1ZTogdW5rbm93bikgPT4gdm9pZDtcbiAgICBjb25zdCByZWNvbm5lY3RUaW1lb3V0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCk7XG4gICAgICByZWNvbm5lY3RSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBoYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgICByZWNvbm5lY3RpbmdUcmlnZ2VyZWQgPSB0cnVlO1xuICAgIH07XG5cbiAgICByb29tXG4gICAgICAub24oUm9vbUV2ZW50LlNpZ25hbFJlY29ubmVjdGluZywgaGFuZGxlUmVjb25uZWN0aW5nKVxuICAgICAgLm9uKFJvb21FdmVudC5SZWNvbm5lY3RpbmcsIGhhbmRsZVJlY29ubmVjdGluZylcbiAgICAgIC5vbihSb29tRXZlbnQuUmVjb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgcmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZWNvbm5lY3RSZXNvbHZlcih0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgcm9vbS5lbmdpbmUuY2xpZW50LndzPy5jbG9zZSgpO1xuICAgIGNvbnN0IG9uQ2xvc2UgPSByb29tLmVuZ2luZS5jbGllbnQub25DbG9zZTtcbiAgICBpZiAob25DbG9zZSkge1xuICAgICAgb25DbG9zZSgnJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgcmVjb25uZWN0VGltZW91dDtcblxuICAgIGlmICghcmVjb25uZWN0aW5nVHJpZ2dlcmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3QnKTtcbiAgICB9IGVsc2UgaWYgKCFyZWNvbm5lY3RlZCB8fCByb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ3JlY29ubmVjdGlvbiBpcyBvbmx5IHBvc3NpYmxlIGluIFJlZGlzLWJhc2VkIGNvbmZpZ3VyYXRpb25zJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIHJlY29ubmVjdCcpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgU2lnbmFsQ2xpZW50IH0gZnJvbSAnLi4vLi4vYXBpL1NpZ25hbENsaWVudCc7XG5pbXBvcnQgeyBDaGVja2VyIH0gZnJvbSAnLi9DaGVja2VyJztcblxuZXhwb3J0IGNsYXNzIFRVUk5DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0NhbiBjb25uZWN0IHZpYSBUVVJOJztcbiAgfVxuXG4gIGFzeW5jIHBlcmZvcm0oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2lnbmFsQ2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCgpO1xuICAgIGNvbnN0IGpvaW5SZXMgPSBhd2FpdCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgYXV0b1N1YnNjcmliZTogdHJ1ZSxcbiAgICAgIG1heFJldHJpZXM6IDAsXG4gICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICB3ZWJzb2NrZXRUaW1lb3V0OiAxNV8wMDAsXG4gICAgfSk7XG5cbiAgICBsZXQgaGFzVExTID0gZmFsc2U7XG4gICAgbGV0IGhhc1RVUk4gPSBmYWxzZTtcbiAgICBsZXQgaGFzU1RVTiA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaWNlU2VydmVyIG9mIGpvaW5SZXMuaWNlU2VydmVycykge1xuICAgICAgZm9yIChsZXQgdXJsIG9mIGljZVNlcnZlci51cmxzKSB7XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgndHVybjonKSkge1xuICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xuICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHVybC5zdGFydHNXaXRoKCd0dXJuczonKSkge1xuICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xuICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgIGhhc1RMUyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKCdzdHVuOicpKSB7XG4gICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFoYXNTVFVOKSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ05vIFNUVU4gc2VydmVycyBjb25maWd1cmVkIG9uIHNlcnZlciBzaWRlLicpO1xuICAgIH0gZWxzZSBpZiAoaGFzVFVSTiAmJiAhaGFzVExTKSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1RVUk4gaXMgY29uZmlndXJlZCBzZXJ2ZXIgc2lkZSwgYnV0IFRVUk4vVExTIGlzIHVuYXZhaWxhYmxlLicpO1xuICAgIH1cbiAgICBhd2FpdCBzaWduYWxDbGllbnQuY2xvc2UoKTtcbiAgICBpZiAodGhpcy5jb25uZWN0T3B0aW9ucz8ucnRjQ29uZmlnPy5pY2VTZXJ2ZXJzIHx8IGhhc1RVUk4pIHtcbiAgICAgIGF3YWl0IHRoaXMucm9vbSEuY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICBydGNDb25maWc6IHtcbiAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdyZWxheScsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBUVVJOIHNlcnZlcnMgY29uZmlndXJlZC4nKTtcbiAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgUm9vbUV2ZW50IH0gZnJvbSAnLi4vLi4vcm9vbS9ldmVudHMnO1xuaW1wb3J0IHsgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBjbGFzcyBXZWJSVENDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0VzdGFibGlzaGluZyBXZWJSVEMgY29ubmVjdGlvbic7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgaGFzVGNwID0gZmFsc2U7XG4gICAgbGV0IGhhc0lwdjRVZHAgPSBmYWxzZTtcbiAgICB0aGlzLnJvb20ub24oUm9vbUV2ZW50LlNpZ25hbENvbm5lY3RlZCwgKCkgPT4ge1xuICAgICAgY29uc3QgcHJldlRyaWNrbGUgPSB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGU7XG5cbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXM6IFJUQ0ljZUNhbmRpZGF0ZVtdID0gW107XG4gICAgICB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGUgPSAoc2QsIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAoc2QuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShzZCk7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgbGV0IHN0ciA9IGAke2NhbmRpZGF0ZS5wcm90b2NvbH0gJHtjYW5kaWRhdGUuYWRkcmVzc306JHtjYW5kaWRhdGUucG9ydH0gJHtjYW5kaWRhdGUudHlwZX1gO1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUuYWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKGlzSVBQcml2YXRlKGNhbmRpZGF0ZS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICBzdHIgKz0gJyAocHJpdmF0ZSknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3RjcCcgJiYgY2FuZGlkYXRlLnRjcFR5cGUgPT09ICdwYXNzaXZlJykge1xuICAgICAgICAgICAgICAgIGhhc1RjcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcgKHBhc3NpdmUpJztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUucHJvdG9jb2wgPT09ICd1ZHAnKSB7XG4gICAgICAgICAgICAgICAgaGFzSXB2NFVkcCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZUcmlja2xlKSB7XG4gICAgICAgICAgcHJldlRyaWNrbGUoc2QsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlcikge1xuICAgICAgICB0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlci5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlRXJyb3IgPSAoZXYpID0+IHtcbiAgICAgICAgICBpZiAoZXYgaW5zdGFuY2VvZiBSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcbiAgICAgICAgICAgICAgYGVycm9yIHdpdGggSUNFIGNhbmRpZGF0ZTogJHtldi5lcnJvckNvZGV9ICR7ZXYuZXJyb3JUZXh0fSAke2V2LnVybH1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdCgpO1xuICAgICAgbG9nLmluZm8oJ25vdyB0aGUgcm9vbSBpcyBjb25uZWN0ZWQnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZygncG9ydHMgbmVlZCB0byBiZSBvcGVuIG9uIGZpcmV3YWxsIGluIG9yZGVyIHRvIGNvbm5lY3QuJyk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGlmICghaGFzVGNwKSB7XG4gICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBub3QgY29uZmlndXJlZCBmb3IgSUNFL1RDUCcpO1xuICAgIH1cbiAgICBpZiAoIWhhc0lwdjRVZHApIHtcbiAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhcbiAgICAgICAgJ05vIHB1YmxpYyBJUHY0IFVEUCBjYW5kaWRhdGVzIHdlcmUgZm91bmQuIFlvdXIgc2VydmVyIGlzIGxpa2VseSBub3QgY29uZmlndXJlZCBjb3JyZWN0bHknLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJUFByaXZhdGUoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHBhcnRzID0gYWRkcmVzcy5zcGxpdCgnLicpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7XG4gICAgaWYgKHBhcnRzWzBdID09PSAnMTAnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTkyJyAmJiBwYXJ0c1sxXSA9PT0gJzE2OCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxNzInKSB7XG4gICAgICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuICAgICAgaWYgKHNlY29uZCA+PSAxNiAmJiBzZWNvbmQgPD0gMzEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IFNlcnZlckluZm9fRWRpdGlvbiB9IGZyb20gJ0BsaXZla2l0L3Byb3RvY29sJztcbmltcG9ydCB7IFNpZ25hbENsaWVudCB9IGZyb20gJy4uLy4uL2FwaS9TaWduYWxDbGllbnQnO1xuaW1wb3J0IHsgQ2hlY2tlciB9IGZyb20gJy4vQ2hlY2tlcic7XG5cbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRDaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0Nvbm5lY3RpbmcgdG8gc2lnbmFsIGNvbm5lY3Rpb24gdmlhIFdlYlNvY2tldCc7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgcGVyZm9ybSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy51cmwuc3RhcnRzV2l0aCgnd3M6JykgfHwgdGhpcy51cmwuc3RhcnRzV2l0aCgnaHR0cDonKSkge1xuICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdTZXJ2ZXIgaXMgaW5zZWN1cmUsIGNsaWVudHMgbWF5IGJsb2NrIGNvbm5lY3Rpb25zIHRvIGl0Jyk7XG4gICAgfVxuXG4gICAgbGV0IHNpZ25hbENsaWVudCA9IG5ldyBTaWduYWxDbGllbnQoKTtcbiAgICBjb25zdCBqb2luUmVzID0gYXdhaXQgc2lnbmFsQ2xpZW50LmpvaW4odGhpcy51cmwsIHRoaXMudG9rZW4sIHtcbiAgICAgIGF1dG9TdWJzY3JpYmU6IHRydWUsXG4gICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgZTJlZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgd2Vic29ja2V0VGltZW91dDogMTVfMDAwLFxuICAgIH0pO1xuICAgIHRoaXMuYXBwZW5kTWVzc2FnZShgQ29ubmVjdGVkIHRvIHNlcnZlciwgdmVyc2lvbiAke2pvaW5SZXMuc2VydmVyVmVyc2lvbn0uYCk7XG4gICAgaWYgKGpvaW5SZXMuc2VydmVySW5mbz8uZWRpdGlvbiA9PT0gU2VydmVySW5mb19FZGl0aW9uLkNsb3VkICYmIGpvaW5SZXMuc2VydmVySW5mbz8ucmVnaW9uKSB7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoYExpdmVLaXQgQ2xvdWQ6ICR7am9pblJlcy5zZXJ2ZXJJbmZvPy5yZWdpb259YCk7XG4gICAgfVxuICAgIGF3YWl0IHNpZ25hbENsaWVudC5jbG9zZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHR5cGUgVHlwZWRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBDaGVja0luZm8sIENoZWNrZXJPcHRpb25zLCBJbnN0YW50aWFibGVDaGVjayB9IGZyb20gJy4vY2hlY2tzL0NoZWNrZXInO1xuaW1wb3J0IHsgQ2hlY2tTdGF0dXMsIENoZWNrZXIgfSBmcm9tICcuL2NoZWNrcy9DaGVja2VyJztcbmltcG9ydCB7IENsb3VkUmVnaW9uQ2hlY2sgfSBmcm9tICcuL2NoZWNrcy9jbG91ZFJlZ2lvbic7XG5pbXBvcnQgeyBDb25uZWN0aW9uUHJvdG9jb2xDaGVjaywgdHlwZSBQcm90b2NvbFN0YXRzIH0gZnJvbSAnLi9jaGVja3MvY29ubmVjdGlvblByb3RvY29sJztcbmltcG9ydCB7IFB1Ymxpc2hBdWRpb0NoZWNrIH0gZnJvbSAnLi9jaGVja3MvcHVibGlzaEF1ZGlvJztcbmltcG9ydCB7IFB1Ymxpc2hWaWRlb0NoZWNrIH0gZnJvbSAnLi9jaGVja3MvcHVibGlzaFZpZGVvJztcbmltcG9ydCB7IFJlY29ubmVjdENoZWNrIH0gZnJvbSAnLi9jaGVja3MvcmVjb25uZWN0JztcbmltcG9ydCB7IFRVUk5DaGVjayB9IGZyb20gJy4vY2hlY2tzL3R1cm4nO1xuaW1wb3J0IHsgV2ViUlRDQ2hlY2sgfSBmcm9tICcuL2NoZWNrcy93ZWJydGMnO1xuaW1wb3J0IHsgV2ViU29ja2V0Q2hlY2sgfSBmcm9tICcuL2NoZWNrcy93ZWJzb2NrZXQnO1xuXG5leHBvcnQgdHlwZSB7IENoZWNrSW5mbywgQ2hlY2tTdGF0dXMgfTtcblxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25DaGVjayBleHRlbmRzIChFdmVudEVtaXR0ZXIgYXMgbmV3ICgpID0+IFR5cGVkRW1pdHRlcjxDb25uZWN0aW9uQ2hlY2tDYWxsYmFja3M+KSB7XG4gIHRva2VuOiBzdHJpbmc7XG5cbiAgdXJsOiBzdHJpbmc7XG5cbiAgb3B0aW9uczogQ2hlY2tlck9wdGlvbnMgPSB7fTtcblxuICBwcml2YXRlIGNoZWNrUmVzdWx0czogTWFwPG51bWJlciwgQ2hlY2tJbmZvPiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3Rvcih1cmw6IHN0cmluZywgdG9rZW46IHN0cmluZywgb3B0aW9uczogQ2hlY2tlck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBwcml2YXRlIGdldE5leHRDaGVja0lkKCkge1xuICAgIGNvbnN0IG5leHRJZCA9IHRoaXMuY2hlY2tSZXN1bHRzLnNpemU7XG4gICAgdGhpcy5jaGVja1Jlc3VsdHMuc2V0KG5leHRJZCwge1xuICAgICAgbG9nczogW10sXG4gICAgICBzdGF0dXM6IENoZWNrU3RhdHVzLklETEUsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dElkO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDaGVjayhjaGVja0lkOiBudW1iZXIsIGluZm86IENoZWNrSW5mbykge1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChjaGVja0lkLCBpbmZvKTtcbiAgICB0aGlzLmVtaXQoJ2NoZWNrVXBkYXRlJywgY2hlY2tJZCwgaW5mbyk7XG4gIH1cblxuICBpc1N1Y2Nlc3MoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpLmV2ZXJ5KChyKSA9PiByLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuRkFJTEVEKTtcbiAgfVxuXG4gIGdldFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jaGVja1Jlc3VsdHMudmFsdWVzKCkpO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQW5kUnVuQ2hlY2s8VCBleHRlbmRzIENoZWNrZXI+KGNoZWNrOiBJbnN0YW50aWFibGVDaGVjazxUPikge1xuICAgIGNvbnN0IGNoZWNrSWQgPSB0aGlzLmdldE5leHRDaGVja0lkKCk7XG4gICAgY29uc3QgdGVzdCA9IG5ldyBjaGVjayh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCBoYW5kbGVVcGRhdGUgPSAoaW5mbzogQ2hlY2tJbmZvKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUNoZWNrKGNoZWNrSWQsIGluZm8pO1xuICAgIH07XG4gICAgdGVzdC5vbigndXBkYXRlJywgaGFuZGxlVXBkYXRlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0LnJ1bigpO1xuICAgIHRlc3Qub2ZmKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyBjaGVja1dlYnNvY2tldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJTb2NrZXRDaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1dlYlJUQygpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJSVENDaGVjayk7XG4gIH1cblxuICBhc3luYyBjaGVja1RVUk4oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soVFVSTkNoZWNrKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrUmVjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFJlY29ubmVjdENoZWNrKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrUHVibGlzaEF1ZGlvKCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hBdWRpb0NoZWNrKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrUHVibGlzaFZpZGVvKCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFB1Ymxpc2hWaWRlb0NoZWNrKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrQ29ubmVjdGlvblByb3RvY29sKCkge1xuICAgIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKENvbm5lY3Rpb25Qcm90b2NvbENoZWNrKTtcbiAgICBpZiAoaW5mby5kYXRhICYmICdwcm90b2NvbCcgaW4gaW5mby5kYXRhKSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGluZm8uZGF0YSBhcyBQcm90b2NvbFN0YXRzO1xuICAgICAgdGhpcy5vcHRpb25zLnByb3RvY29sID0gc3RhdHMucHJvdG9jb2w7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tDbG91ZFJlZ2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhDbG91ZFJlZ2lvbkNoZWNrKTtcbiAgfVxufVxuXG50eXBlIENvbm5lY3Rpb25DaGVja0NhbGxiYWNrcyA9IHtcbiAgY2hlY2tVcGRhdGU6IChpZDogbnVtYmVyLCBpbmZvOiBDaGVja0luZm8pID0+IHZvaWQ7XG59O1xuIiwiaW1wb3J0IGxvZyBmcm9tICcuLi8uLi9sb2dnZXInO1xuaW1wb3J0IHsgaXNMb2NhbFRyYWNrIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IExvY2FsVHJhY2sgZnJvbSAnLi9Mb2NhbFRyYWNrJztcbmltcG9ydCB0eXBlIHsgVmlkZW9DYXB0dXJlT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XG5cbnR5cGUgRmFjaW5nTW9kZSA9IE5vbk51bGxhYmxlPFZpZGVvQ2FwdHVyZU9wdGlvbnNbJ2ZhY2luZ01vZGUnXT47XG50eXBlIEZhY2luZ01vZGVGcm9tTG9jYWxUcmFja09wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBJZiBubyBmYWNpbmcgbW9kZSBjYW4gYmUgZGV0ZXJtaW5lZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWQuXG4gICAqIEBkZWZhdWx0VmFsdWUgJ3VzZXInXG4gICAqL1xuICBkZWZhdWx0RmFjaW5nTW9kZT86IEZhY2luZ01vZGU7XG59O1xudHlwZSBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZSA9IHtcbiAgLyoqXG4gICAqIFRoZSAocHJvYmFibGUpIGZhY2luZ01vZGUgb2YgdGhlIHRyYWNrLlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzL2ZhY2luZ01vZGUgfCBNRE4gZG9jcyBvbiBmYWNpbmdNb2RlfVxuICAgKi9cbiAgZmFjaW5nTW9kZTogRmFjaW5nTW9kZTtcbiAgLyoqXG4gICAqIFRoZSBjb25maWRlbmNlIHRoYXQgdGhlIHJldHVybmVkIGZhY2luZ01vZGUgaXMgY29ycmVjdC5cbiAgICovXG4gIGNvbmZpZGVuY2U6ICdoaWdoJyB8ICdtZWRpdW0nIHwgJ2xvdyc7XG59O1xuXG4vKipcbiAqIFRyeSB0byBhbmFseXplIHRoZSBsb2NhbCB0cmFjayB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlIG9mIGEgdHJhY2suXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZXJlIGlzIG5vIHByb3BlcnR5IHN1cHBvcnRlZCBieSBhbGwgYnJvd3NlcnMgdG8gZGV0ZWN0IHdoZXRoZXIgYSB2aWRlbyB0cmFjayBvcmlnaW5hdGVkIGZyb20gYSB1c2VyLSBvciBlbnZpcm9ubWVudC1mYWNpbmcgY2FtZXJhIGRldmljZS5cbiAqIEZvciB0aGlzIHJlYXNvbiwgd2UgdXNlIHRoZSBgZmFjaW5nTW9kZWAgcHJvcGVydHkgd2hlbiBhdmFpbGFibGUsIGJ1dCB3aWxsIGZhbGwgYmFjayBvbiBhIHN0cmluZy1iYXNlZCBhbmFseXNpcyBvZiB0aGUgZGV2aWNlIGxhYmVsIHRvIGRldGVybWluZSB0aGUgZmFjaW5nIG1vZGUuXG4gKiBJZiBib3RoIG1ldGhvZHMgZmFpbCwgdGhlIGRlZmF1bHQgZmFjaW5nIG1vZGUgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVRyYWNrQ29uc3RyYWludHMvZmFjaW5nTW9kZSB8IE1ETiBkb2NzIG9uIGZhY2luZ01vZGV9XG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2soXG4gIGxvY2FsVHJhY2s6IExvY2FsVHJhY2sgfCBNZWRpYVN0cmVhbVRyYWNrLFxuICBvcHRpb25zOiBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tPcHRpb25zID0ge30sXG4pOiBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZSB7XG4gIGNvbnN0IHRyYWNrID0gaXNMb2NhbFRyYWNrKGxvY2FsVHJhY2spID8gbG9jYWxUcmFjay5tZWRpYVN0cmVhbVRyYWNrIDogbG9jYWxUcmFjaztcbiAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGxldCByZXN1bHQ6IEZhY2luZ01vZGVGcm9tTG9jYWxUcmFja1JldHVyblZhbHVlID0ge1xuICAgIGZhY2luZ01vZGU6IG9wdGlvbnMuZGVmYXVsdEZhY2luZ01vZGUgPz8gJ3VzZXInLFxuICAgIGNvbmZpZGVuY2U6ICdsb3cnLFxuICB9O1xuXG4gIC8vIDEuIFRyeSB0byBnZXQgZmFjaW5nTW9kZSBmcm9tIHRyYWNrIHNldHRpbmdzLlxuICBpZiAoJ2ZhY2luZ01vZGUnIGluIHRyYWNrU2V0dGluZ3MpIHtcbiAgICBjb25zdCByYXdGYWNpbmdNb2RlID0gdHJhY2tTZXR0aW5ncy5mYWNpbmdNb2RlO1xuICAgIGxvZy50cmFjZSgncmF3RmFjaW5nTW9kZScsIHsgcmF3RmFjaW5nTW9kZSB9KTtcbiAgICBpZiAocmF3RmFjaW5nTW9kZSAmJiB0eXBlb2YgcmF3RmFjaW5nTW9kZSA9PT0gJ3N0cmluZycgJiYgaXNGYWNpbmdNb2RlVmFsdWUocmF3RmFjaW5nTW9kZSkpIHtcbiAgICAgIHJlc3VsdCA9IHsgZmFjaW5nTW9kZTogcmF3RmFjaW5nTW9kZSwgY29uZmlkZW5jZTogJ2hpZ2gnIH07XG4gICAgfVxuICB9XG5cbiAgLy8gMi4gSWYgd2UgZG9uJ3QgaGF2ZSBhIGhpZ2ggY29uZmlkZW5jZSB3ZSB0cnkgdG8gZ2V0IHRoZSBmYWNpbmcgbW9kZSBmcm9tIHRoZSBkZXZpY2UgbGFiZWwuXG4gIGlmIChbJ2xvdycsICdtZWRpdW0nXS5pbmNsdWRlcyhyZXN1bHQuY29uZmlkZW5jZSkpIHtcbiAgICBsb2cudHJhY2UoYFRyeSB0byBnZXQgZmFjaW5nIG1vZGUgZnJvbSBkZXZpY2UgbGFiZWw6ICgke3RyYWNrLmxhYmVsfSlgKTtcbiAgICBjb25zdCBsYWJlbEFuYWx5c2lzUmVzdWx0ID0gZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbCh0cmFjay5sYWJlbCk7XG4gICAgaWYgKGxhYmVsQW5hbHlzaXNSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0ID0gbGFiZWxBbmFseXNpc1Jlc3VsdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBrbm93bkRldmljZUxhYmVscyA9IG5ldyBNYXA8c3RyaW5nLCBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZT4oW1xuICBbJ29icyB2aXJ0dWFsIGNhbWVyYScsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG5dKTtcbmNvbnN0IGtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBGYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2tSZXR1cm5WYWx1ZT4oW1xuICBbJ2lwaG9uZScsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG4gIFsnaXBhZCcsIHsgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JywgY29uZmlkZW5jZTogJ21lZGl1bScgfV0sXG5dKTtcbi8qKlxuICogQXR0ZW1wdCB0byBhbmFseXplIHRoZSBkZXZpY2UgbGFiZWwgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKFxuICBkZXZpY2VMYWJlbDogc3RyaW5nLFxuKTogRmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrUmV0dXJuVmFsdWUgfCB1bmRlZmluZWQge1xuICBjb25zdCBsYWJlbCA9IGRldmljZUxhYmVsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBFbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCBkZXZpY2UgbGFiZWwgYnV0IHdlIGNhbid0IGluZmVyIGFueXRoaW5nIGZyb20gaXQuXG4gIGlmIChsYWJlbCA9PT0gJycpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gQ2FuIHdlIG1hdGNoIGFnYWluc3Qgd2lkZWx5IGtub3duIGRldmljZSBsYWJlbHMuXG4gIGlmIChrbm93bkRldmljZUxhYmVscy5oYXMobGFiZWwpKSB7XG4gICAgcmV0dXJuIGtub3duRGV2aWNlTGFiZWxzLmdldChsYWJlbCk7XG4gIH1cblxuICAvLyBDYW4gd2UgbWF0Y2ggYWdhaW5zdCBzZWN0aW9ucyBvZiB0aGUgZGV2aWNlIGxhYmVsLlxuICByZXR1cm4gQXJyYXkuZnJvbShrbm93bkRldmljZUxhYmVsU2VjdGlvbnMuZW50cmllcygpKS5maW5kKChbc2VjdGlvbl0pID0+XG4gICAgbGFiZWwuaW5jbHVkZXMoc2VjdGlvbiksXG4gICk/LlsxXTtcbn1cblxuZnVuY3Rpb24gaXNGYWNpbmdNb2RlVmFsdWUoaXRlbTogc3RyaW5nKTogaXRlbSBpcyBGYWNpbmdNb2RlIHtcbiAgY29uc3QgYWxsb3dlZFZhbHVlczogRmFjaW5nTW9kZVtdID0gWyd1c2VyJywgJ2Vudmlyb25tZW50JywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKGl0ZW0gYXMgRmFjaW5nTW9kZSk7XG59XG4iXSwibmFtZXMiOlsiXyIsImNvbnN0cnVjdG9yIiwibyIsIl9sb2NraW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfbG9ja3MiLCJpc0xvY2tlZCIsImxvY2siLCJzIiwidCIsImwiLCJ1bmxvY2tOZXh0IiwiYyIsInRoZW4iLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtc2ciLCJFcnJvciIsIkZMT0FUMzJfTUFYIiwiRkxPQVQzMl9NSU4iLCJVSU5UMzJfTUFYIiwiSU5UMzJfTUFYIiwiSU5UMzJfTUlOIiwiYXNzZXJ0SW50MzIiLCJhcmciLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJhc3NlcnRVSW50MzIiLCJhc3NlcnRGbG9hdDMyIiwiaXNGaW5pdGUiLCJlbnVtVHlwZVN5bWJvbCIsIlN5bWJvbCIsImdldEVudW1UeXBlIiwiZW51bU9iamVjdCIsInNldEVudW1UeXBlIiwidHlwZU5hbWUiLCJ2YWx1ZXMiLCJvcHQiLCJtYWtlRW51bVR5cGUiLCJtYXAiLCJ2Iiwibm8iLCJuYW1lIiwibG9jYWxOYW1lIiwiX29wdCIsIm5hbWVzIiwiT2JqZWN0IiwiY3JlYXRlIiwibnVtYmVycyIsIm5vcm1hbFZhbHVlcyIsInZhbHVlIiwibiIsIm5vcm1hbGl6ZUVudW1WYWx1ZSIsInB1c2giLCJmaW5kTmFtZSIsImZpbmROdW1iZXIiLCJtYWtlRW51bSIsImFzc2lnbiIsIk1lc3NhZ2UiLCJlcXVhbHMiLCJvdGhlciIsImdldFR5cGUiLCJydW50aW1lIiwidXRpbCIsImNsb25lIiwiZnJvbUJpbmFyeSIsImJ5dGVzIiwib3B0aW9ucyIsInR5cGUiLCJmb3JtYXQiLCJiaW4iLCJtYWtlUmVhZE9wdGlvbnMiLCJyZWFkTWVzc2FnZSIsInJlYWRlckZhY3RvcnkiLCJieXRlTGVuZ3RoIiwiZnJvbUpzb24iLCJqc29uVmFsdWUiLCJqc29uIiwiZnJvbUpzb25TdHJpbmciLCJqc29uU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwiZSIsImNvbmNhdCIsIm1lc3NhZ2UiLCJTdHJpbmciLCJ0b0JpbmFyeSIsIm1ha2VXcml0ZU9wdGlvbnMiLCJ3cml0ZXIiLCJ3cml0ZXJGYWN0b3J5Iiwid3JpdGVNZXNzYWdlIiwiZmluaXNoIiwidG9Kc29uIiwidG9Kc29uU3RyaW5nIiwiX2EiLCJzdHJpbmdpZnkiLCJwcmV0dHlTcGFjZXMiLCJ0b0pTT04iLCJlbWl0RGVmYXVsdFZhbHVlcyIsImdldFByb3RvdHlwZU9mIiwibWFrZU1lc3NhZ2VUeXBlIiwiZmllbGRzIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJkYXRhIiwiaW5pdEZpZWxkcyIsImluaXRQYXJ0aWFsIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJuZXdGaWVsZExpc3QiLCJhIiwiYiIsInZhcmludDY0cmVhZCIsImxvd0JpdHMiLCJoaWdoQml0cyIsInNoaWZ0IiwiYnVmIiwicG9zIiwiYXNzZXJ0Qm91bmRzIiwibWlkZGxlQnl0ZSIsInZhcmludDY0d3JpdGUiLCJsbyIsImhpIiwiaSIsImhhc05leHQiLCJieXRlIiwic3BsaXRCaXRzIiwiaGFzTW9yZUJpdHMiLCJUV09fUFdSXzMyX0RCTCIsImludDY0RnJvbVN0cmluZyIsImRlYyIsIm1pbnVzIiwic2xpY2UiLCJiYXNlIiwiYWRkMWU2ZGlnaXQiLCJiZWdpbiIsImVuZCIsImRpZ2l0MWU2IiwibmVnYXRlIiwibmV3Qml0cyIsImludDY0VG9TdHJpbmciLCJiaXRzIiwibmVnYXRpdmUiLCJyZXN1bHQiLCJ1SW50NjRUb1N0cmluZyIsInRvVW5zaWduZWQiLCJsb3ciLCJtaWQiLCJoaWdoIiwiZGlnaXRBIiwiZGlnaXRCIiwiZGlnaXRDIiwiTWF0aCIsImZsb29yIiwidG9TdHJpbmciLCJkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MiLCJkaWdpdDFlNyIsInBhcnRpYWwiLCJsZW5ndGgiLCJ2YXJpbnQzMndyaXRlIiwidmFyaW50MzJyZWFkIiwicmVhZEJ5dGVzIiwibWFrZUludDY0U3VwcG9ydCIsImR2IiwiRGF0YVZpZXciLCJBcnJheUJ1ZmZlciIsIm9rIiwiQmlnSW50IiwiZ2V0QmlnSW50NjQiLCJnZXRCaWdVaW50NjQiLCJzZXRCaWdJbnQ2NCIsInNldEJpZ1VpbnQ2NCIsInByb2Nlc3MiLCJlbnYiLCJCVUZfQklHSU5UX0RJU0FCTEUiLCJNSU4iLCJNQVgiLCJVTUlOIiwiVU1BWCIsInplcm8iLCJzdXBwb3J0ZWQiLCJiaSIsInVQYXJzZSIsImVuYyIsImdldEludDMyIiwidUVuYyIsInNldEludDMyIiwidURlYyIsImFzc2VydEludDY0U3RyaW5nIiwidGVzdCIsImFzc2VydFVJbnQ2NFN0cmluZyIsInByb3RvSW50NjQiLCJTY2FsYXJUeXBlIiwiTG9uZ1R5cGUiLCJzY2FsYXJFcXVhbHMiLCJCWVRFUyIsIlVpbnQ4QXJyYXkiLCJVSU5UNjQiLCJGSVhFRDY0IiwiSU5UNjQiLCJTRklYRUQ2NCIsIlNJTlQ2NCIsInNjYWxhclplcm9WYWx1ZSIsImxvbmdUeXBlIiwiQk9PTCIsIkRPVUJMRSIsIkZMT0FUIiwiU1RSSU5HIiwiaXNTY2FsYXJaZXJvVmFsdWUiLCJXaXJlVHlwZSIsIkJpbmFyeVdyaXRlciIsInRleHRFbmNvZGVyIiwic3RhY2siLCJUZXh0RW5jb2RlciIsImNodW5rcyIsImxlbiIsIm9mZnNldCIsInNldCIsImZvcmsiLCJqb2luIiwiY2h1bmsiLCJwcmV2IiwicG9wIiwidWludDMyIiwicmF3IiwidGFnIiwiZmllbGRObyIsImludDMyIiwiYm9vbCIsInN0cmluZyIsImVuY29kZSIsImZsb2F0IiwiYnVmZmVyIiwic2V0RmxvYXQzMiIsImRvdWJsZSIsInNldEZsb2F0NjQiLCJmaXhlZDMyIiwic2V0VWludDMyIiwic2ZpeGVkMzIiLCJzaW50MzIiLCJzZml4ZWQ2NCIsInZpZXciLCJ0YyIsImZpeGVkNjQiLCJpbnQ2NCIsInNpbnQ2NCIsInNpZ24iLCJ1aW50NjQiLCJCaW5hcnlSZWFkZXIiLCJ0ZXh0RGVjb2RlciIsInZhcmludDY0IiwiYnl0ZU9mZnNldCIsIlRleHREZWNvZGVyIiwid2lyZVR5cGUiLCJza2lwIiwic3RhcnQiLCJWYXJpbnQiLCJCaXQ2NCIsIkJpdDMyIiwiTGVuZ3RoRGVsaW1pdGVkIiwiU3RhcnRHcm91cCIsImZuIiwid3QiLCJFbmRHcm91cCIsInVuZGVmaW5lZCIsInN1YmFycmF5IiwiUmFuZ2VFcnJvciIsInp6ZSIsImdldFVpbnQzMiIsImdldEZsb2F0MzIiLCJnZXRGbG9hdDY0IiwiZGVjb2RlIiwibWFrZUV4dGVuc2lvbiIsImV4dGVuZGVlIiwiZmllbGQiLCJmaSIsInNwbGl0IiwianNvbk5hbWUiLCJsaXN0IiwiY3JlYXRlRXh0ZW5zaW9uQ29udGFpbmVyIiwiZXh0ZW5zaW9uIiwiY29udGFpbmVyIiwiaW5pdEV4dGVuc2lvbkZpZWxkIiwiZXh0IiwicmVwZWF0ZWQiLCJkZWZhdWx0Iiwia2luZCIsIlQiLCJMIiwiZmllbGRXcmFwcGVyIiwidW53cmFwRmllbGQiLCJmaWx0ZXJVbmtub3duRmllbGRzIiwidW5rbm93bkZpZWxkcyIsImZpbHRlciIsInVmIiwiZW5jVGFibGUiLCJkZWNUYWJsZSIsImNoYXJDb2RlQXQiLCJpbmRleE9mIiwicHJvdG9CYXNlNjQiLCJiYXNlNjRTdHIiLCJlcyIsImJ5dGVQb3MiLCJncm91cFBvcyIsInAiLCJiYXNlNjQiLCJnZXRFeHRlbnNpb24iLCJhc3NlcnRFeHRlbmRlZSIsInVmcyIsImxpc3RVbmtub3duRmllbGRzIiwiZ2V0IiwicmVhZEZpZWxkIiwic2V0RXh0ZW5zaW9uIiwicmVhZE9wdCIsIndyaXRlT3B0IiwiaGFzRXh0ZW5zaW9uIiwiZGlzY2FyZFVua25vd25GaWVsZHMiLCJvblVua25vd25GaWVsZCIsImYiLCJ3cml0ZUZpZWxkIiwicmVhZGVyIiwibWVzc2FnZVR5cGUiLCJmaW5kIiwiaXNGaWVsZFNldCIsInRhcmdldCIsIm9uZW9mIiwiY2FzZSIsInJlcSIsImtleXMiLCJjbGVhckZpZWxkIiwiaW1wbGljaXRQcmVzZW5jZSIsImlzTWVzc2FnZSIsImdldE93blByb3BlcnR5TmFtZXMiLCJldmVyeSIsIm0iLCJhY3R1YWxUeXBlIiwid3JhcEZpZWxkIiwiSU5UMzIiLCJVSU5UMzIiLCJqc29uUmVhZERlZmF1bHRzIiwiaWdub3JlVW5rbm93bkZpZWxkcyIsImpzb25Xcml0ZURlZmF1bHRzIiwiZW51bUFzSW50ZWdlciIsInVzZVByb3RvRmllbGROYW1lIiwidG9rZW5OdWxsIiwidG9rZW5JZ25vcmVkVW5rbm93bkVudW0iLCJtYWtlSnNvbkZvcm1hdCIsIkFycmF5IiwiaXNBcnJheSIsImRlYnVnSnNvblZhbHVlIiwib25lb2ZTZWVuIiwiTWFwIiwicmVnaXN0cnkiLCJ0eXBlUmVnaXN0cnkiLCJqc29uS2V5IiwiZW50cmllcyIsImZpbmRKc29uTmFtZSIsInNlZW4iLCJmb3VuZCIsImZpbmRFeHRlbnNpb24iLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJieU51bWJlciIsImNhbkVtaXRGaWVsZERlZmF1bHRWYWx1ZSIsImZpbmRFeHRlbnNpb25Gb3IiLCJyIiwicmVhZFNjYWxhciIsIkJJR0lOVCIsIndyaXRlU2NhbGFyIiwiZGVidWciLCJwYXJlbnRUeXBlIiwidGFyZ2V0QXJyYXkiLCJqc29uSXRlbSIsImVudW1WYWx1ZSIsInJlYWRFbnVtIiwidGFyZ2V0TWFwIiwianNvbk1hcEtleSIsImpzb25NYXBWYWx1ZSIsImtleSIsInJlYWRNYXBLZXkiLCJLIiwiViIsImN1cnJlbnRWYWx1ZSIsInNjYWxhclZhbHVlIiwibnVsbEFzWmVyb1ZhbHVlIiwiTmFOIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9JTkZJTklUWSIsInRyaW0iLCJpc05hTiIsIkZJWEVEMzIiLCJTRklYRUQzMiIsIlNJTlQzMiIsImxvbmciLCJ1TG9uZyIsImVuY29kZVVSSUNvbXBvbmVudCIsImpzb25PYmoiLCJlbnRyeUtleSIsImVudHJ5VmFsdWUiLCJlbnVtVHlwZSIsIndyaXRlRW51bSIsImpzb25BcnIiLCJ2YWwiLCJ1bmtub3duRmllbGRzU3ltYm9sIiwicmVhZERlZmF1bHRzIiwicmVhZFVua25vd25GaWVsZHMiLCJ3cml0ZURlZmF1bHRzIiwid3JpdGVVbmtub3duRmllbGRzIiwibWFrZUJpbmFyeUZvcm1hdCIsImxlbmd0aE9yRW5kVGFnRmllbGRObyIsImRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyIsInNjYWxhclR5cGUiLCJyZWFkIiwicmVhZFNjYWxhckxUU3RyaW5nIiwiYXJyIiwiaXNQYWNrZWQiLCJyZWFkTWVzc2FnZUZpZWxkIiwibWFwS2V5IiwibWFwVmFsIiwicmVhZE1hcEVudHJ5IiwiZGVsaW1pdGVkIiwicGFja2VkIiwid3JpdGVQYWNrZWQiLCJpdGVtIiwid3JpdGVNZXNzYWdlRmllbGQiLCJ3cml0ZU1hcEVudHJ5Iiwia2V5VmFsdWUiLCJwYXJzZUludCIsIm1ldGhvZCIsInNjYWxhclR5cGVJbmZvIiwidG9Mb3dlckNhc2UiLCJtYWtlVXRpbENvbW1vbiIsInNvdXJjZSIsIm1lbWJlciIsImJ5TWVtYmVyIiwic2siLCJzb3VyY2VGaWVsZCIsImZpbmRGaWVsZCIsInRvVThBcnIiLCJjb3B5IiwiayIsIm10IiwidmEiLCJ2YiIsImFueSIsImNsb25lU2luZ3VsYXJGaWVsZCIsImlucHV0IiwibWFrZVByb3RvUnVudGltZSIsInN5bnRheCIsIkludGVybmFsRmllbGRMaXN0Iiwibm9ybWFsaXplciIsIl9maWVsZHMiLCJfbm9ybWFsaXplciIsImpzb25OYW1lcyIsImFsbCIsIm51bWJlcnNBc2MiLCJzb3J0IiwibWVtYmVycyIsImxvY2FsRmllbGROYW1lIiwicHJvdG9OYW1lIiwiaW5PbmVvZiIsInByb3RvQ2FtZWxDYXNlIiwic2FmZU9iamVjdFByb3BlcnR5Iiwic2FmZU1lc3NhZ2VQcm9wZXJ0eSIsImxvY2FsT25lb2ZOYW1lIiwiZmllbGRKc29uTmFtZSIsInNuYWtlQ2FzZSIsImNhcE5leHQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInJlc2VydmVkT2JqZWN0UHJvcGVydGllcyIsIlNldCIsInJlc2VydmVkTWVzc2FnZVByb3BlcnRpZXMiLCJmYWxsYmFjayIsImhhcyIsIkludGVybmFsT25lb2ZJbmZvIiwiYWRkRmllbGQiLCJfbG9va3VwIiwibm9ybWFsaXplRmllbGRJbmZvcyIsImZpZWxkSW5mb3MiLCJwYWNrZWRCeURlZmF1bHQiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwib29uYW1lIiwicHJvdG8zIiwiVGltZXN0YW1wIiwic2Vjb25kcyIsIm5hbm9zIiwibWF0Y2hlcyIsIm1hdGNoIiwibXMiLCJEYXRlIiwicmVwZWF0IiwieiIsIm5hbm9zU3RyIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwidG9EYXRlIiwiY2VpbCIsIm5vdyIsImZyb21EYXRlIiwiZGF0ZSIsImdldFRpbWUiLCJNZXRyaWNzQmF0Y2giLCJUaW1lU2VyaWVzTWV0cmljIiwiRXZlbnRNZXRyaWMiLCJNZXRyaWNTYW1wbGUiLCJyb290IiwiZGVmaW5pdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJsb2ciLCJ0aGlzIiwibm9vcCIsInVuZGVmaW5lZFR5cGUiLCJpc0lFIiwid2luZG93IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibG9nTWV0aG9kcyIsIl9sb2dnZXJzQnlOYW1lIiwiZGVmYXVsdExvZ2dlciIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwiYmluZCIsIkZ1bmN0aW9uIiwiY2FsbCIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImdldExldmVsIiwibWV0aG9kRmFjdG9yeSIsImxldmVscyIsIlNJTEVOVCIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIl9sZXZlbCIsIl9sb2dnZXJOYW1lIiwiTG9nZ2VyIiwiZmFjdG9yeSIsInNlbGYiLCJpbmhlcml0ZWRMZXZlbCIsImRlZmF1bHRMZXZlbCIsInVzZXJMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJjb29raWVOYW1lIiwibG9jYXRpb24iLCJleGVjIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJub3JtYWxpemVMZXZlbCIsIlR5cGVFcnJvciIsInNldExldmVsIiwicGVyc2lzdCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJyZWJ1aWxkIiwiY2hpbGROYW1lIiwiaW5pdGlhbExldmVsIiwiZ2V0TG9nZ2VyIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIiwiTG9nTGV2ZWwiLCJMb2dnZXJOYW1lcyIsImxpdmVraXRMb2dnZXIiLCJsaXZla2l0TG9nZ2VycyIsImluZm8iLCJzZXRMb2dMZXZlbCIsImxvZ2dlck5hbWUiLCJzZXRMb2dFeHRlbnNpb24iLCJsb2dnZXJzIiwiZm9yRWFjaCIsImxvZ1IiLCJvcmlnaW5hbEZhY3RvcnkiLCJjb25maWdMZXZlbCIsInJhd01ldGhvZCIsImxvZ0xldmVsIiwibmVlZExvZyIsInNpbGVudCIsImNvbnRleHQiLCJ3b3JrZXJMb2dnZXIiLCJtYXhSZXRyeURlbGF5IiwiREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVMiLCJEZWZhdWx0UmVjb25uZWN0UG9saWN5IiwicmV0cnlEZWxheXMiLCJfcmV0cnlEZWxheXMiLCJuZXh0UmV0cnlEZWxheUluTXMiLCJyZXRyeUNvdW50IiwicmV0cnlEZWxheSIsInJhbmRvbSIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwicmVjZWl2ZXIiLCJhcmdzIiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIndhcm4iLCJOdW1iZXJJc05hTiIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJldmVudHNNb2R1bGUiLCJvbmNlIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwiZG9FcnJvciIsImV2ZW50cyIsImVycm9yIiwiZXIiLCJlcnIiLCJoYW5kbGVyIiwibGlzdGVuZXJzIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNwbGljZU9uZSIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJpbmRleCIsInJldCIsInJlamVjdCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiZmxhZ3MiLCJhZGRFdmVudExpc3RlbmVyIiwid3JhcExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxvZ0Rpc2FibGVkXyIsImRlcHJlY2F0aW9uV2FybmluZ3NfIiwiZXh0cmFjdFZlcnNpb24iLCJ1YXN0cmluZyIsImV4cHIiLCJ3cmFwUGVlckNvbm5lY3Rpb25FdmVudCIsImV2ZW50TmFtZVRvV3JhcCIsIndyYXBwZXIiLCJSVENQZWVyQ29ubmVjdGlvbiIsInByb3RvIiwibmF0aXZlQWRkRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50TmFtZSIsImNiIiwid3JhcHBlZENhbGxiYWNrIiwibW9kaWZpZWRFdmVudCIsImhhbmRsZUV2ZW50IiwiX2V2ZW50TWFwIiwibmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVud3JhcHBlZENiIiwiZGVsZXRlIiwic2l6ZSIsImNvbmZpZ3VyYWJsZSIsImRpc2FibGVMb2ciLCJkaXNhYmxlV2FybmluZ3MiLCJkZXByZWNhdGVkIiwib2xkTWV0aG9kIiwibmV3TWV0aG9kIiwiZGV0ZWN0QnJvd3NlciIsImJyb3dzZXIiLCJ2ZXJzaW9uIiwidXNlckFnZW50RGF0YSIsImJyYW5kcyIsImNocm9taXVtIiwiYnJhbmQiLCJtb3pHZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJpc1NlY3VyZUNvbnRleHQiLCJ3ZWJraXRSVENQZWVyQ29ubmVjdGlvbiIsInN1cHBvcnRzVW5pZmllZFBsYW4iLCJSVENSdHBUcmFuc2NlaXZlciIsImlzT2JqZWN0IiwiY29tcGFjdE9iamVjdCIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiaXNPYmoiLCJpc0VtcHR5T2JqZWN0Iiwid2Fsa1N0YXRzIiwic3RhdHMiLCJyZXN1bHRTZXQiLCJpZCIsImZpbHRlclN0YXRzIiwidHJhY2siLCJvdXRib3VuZCIsInN0cmVhbVN0YXRzVHlwZSIsImZpbHRlcmVkUmVzdWx0IiwidHJhY2tTdGF0cyIsInRyYWNrSWRlbnRpZmllciIsInRyYWNrU3RhdCIsInRyYWNrSWQiLCJsb2dnaW5nIiwidXRpbHMiLCJzaGltR2V0VXNlck1lZGlhIiwiYnJvd3NlckRldGFpbHMiLCJtZWRpYURldmljZXMiLCJjb25zdHJhaW50c1RvQ2hyb21lXyIsIm1hbmRhdG9yeSIsIm9wdGlvbmFsIiwiY2MiLCJpZGVhbCIsImV4YWN0IiwibWluIiwibWF4Iiwib2xkbmFtZV8iLCJwcmVmaXgiLCJvYyIsIm1peCIsImFkdmFuY2VkIiwic2hpbUNvbnN0cmFpbnRzXyIsImNvbnN0cmFpbnRzIiwiZnVuYyIsImF1ZGlvIiwicmVtYXAiLCJ2aWRlbyIsImZhY2UiLCJmYWNpbmdNb2RlIiwiZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMiLCJnZXRTdXBwb3J0ZWRDb25zdHJhaW50cyIsImVudW1lcmF0ZURldmljZXMiLCJkZXZpY2VzIiwiZCIsImRldiIsInNvbWUiLCJsYWJlbCIsImluY2x1ZGVzIiwiZGV2aWNlSWQiLCJzaGltRXJyb3JfIiwiUGVybWlzc2lvbkRlbmllZEVycm9yIiwiUGVybWlzc2lvbkRpc21pc3NlZEVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJEZXZpY2VzTm90Rm91bmRFcnJvciIsIkNvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvciIsIlRyYWNrU3RhcnRFcnJvciIsIk1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93biIsIk1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uIiwiVGFiQ2FwdHVyZUVycm9yIiwiU2NyZWVuQ2FwdHVyZUVycm9yIiwiRGV2aWNlQ2FwdHVyZUVycm9yIiwiY29uc3RyYWludCIsImNvbnN0cmFpbnROYW1lIiwiZ2V0VXNlck1lZGlhXyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJnZXRVc2VyTWVkaWEiLCJvcmlnR2V0VXNlck1lZGlhIiwiY3MiLCJzdHJlYW0iLCJnZXRBdWRpb1RyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiZ2V0VHJhY2tzIiwic3RvcCIsIkRPTUV4Y2VwdGlvbiIsInNoaW1NZWRpYVN0cmVhbSIsIk1lZGlhU3RyZWFtIiwid2Via2l0TWVkaWFTdHJlYW0iLCJzaGltT25UcmFjayIsIl9vbnRyYWNrIiwib3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJfb250cmFja3BvbHkiLCJ0ZSIsImdldFJlY2VpdmVycyIsImV2ZW50IiwiRXZlbnQiLCJ0cmFuc2NlaXZlciIsInN0cmVhbXMiLCJkaXNwYXRjaEV2ZW50Iiwic2hpbUdldFNlbmRlcnNXaXRoRHRtZiIsInNoaW1TZW5kZXJXaXRoRHRtZiIsInBjIiwiZHRtZiIsIl9kdG1mIiwiY3JlYXRlRFRNRlNlbmRlciIsIl9wYyIsImdldFNlbmRlcnMiLCJfc2VuZGVycyIsIm9yaWdBZGRUcmFjayIsImFkZFRyYWNrIiwic2VuZGVyIiwib3JpZ1JlbW92ZVRyYWNrIiwicmVtb3ZlVHJhY2siLCJpZHgiLCJzcGxpY2UiLCJvcmlnQWRkU3RyZWFtIiwiYWRkU3RyZWFtIiwib3JpZ1JlbW92ZVN0cmVhbSIsInJlbW92ZVN0cmVhbSIsIlJUQ1J0cFNlbmRlciIsIm9yaWdHZXRTZW5kZXJzIiwic2VuZGVycyIsInNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzIiwiUlRDUnRwUmVjZWl2ZXIiLCJnZXRTdGF0cyIsIm9yaWdHZXRSZWNlaXZlcnMiLCJyZWNlaXZlcnMiLCJzcmNFbGVtZW50Iiwib3JpZ0dldFN0YXRzIiwiTWVkaWFTdHJlYW1UcmFjayIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSIsImdldExvY2FsU3RyZWFtcyIsIl9zaGltbWVkTG9jYWxTdHJlYW1zIiwic3RyZWFtSWQiLCJhbHJlYWR5RXhpc3RzIiwiZXhpc3RpbmdTZW5kZXJzIiwibmV3U2VuZGVycyIsIm5ld1NlbmRlciIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrIiwib3JpZ0dldExvY2FsU3RyZWFtcyIsIm5hdGl2ZVN0cmVhbXMiLCJfcmV2ZXJzZVN0cmVhbXMiLCJfc3RyZWFtcyIsIm5ld1N0cmVhbSIsInNpZ25hbGluZ1N0YXRlIiwib2xkU3RyZWFtIiwicmVwbGFjZUludGVybmFsU3RyZWFtSWQiLCJkZXNjcmlwdGlvbiIsInNkcCIsImludGVybmFsSWQiLCJleHRlcm5hbFN0cmVhbSIsImludGVybmFsU3RyZWFtIiwiUmVnRXhwIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVwbGFjZUV4dGVybmFsU3RyZWFtSWQiLCJuYXRpdmVNZXRob2QiLCJtZXRob2RPYmoiLCJpc0xlZ2FjeUNhbGwiLCJkZXNjIiwib3JpZ1NldExvY2FsRGVzY3JpcHRpb24iLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwib3JpZ0xvY2FsRGVzY3JpcHRpb24iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc0xvY2FsIiwic3RyZWFtaWQiLCJoYXNUcmFjayIsInNoaW1QZWVyQ29ubmVjdGlvbiIsIlJUQ0ljZUNhbmRpZGF0ZSIsImZpeE5lZ290aWF0aW9uTmVlZGVkIiwiZ2V0Q29uZmlndXJhdGlvbiIsInNkcFNlbWFudGljcyIsIm5hdGl2ZUdldFVzZXJNZWRpYSIsImdldFNldHRpbmdzIiwibmF0aXZlR2V0U2V0dGluZ3MiLCJhcHBseUNvbnN0cmFpbnRzIiwibmF0aXZlQXBwbHlDb25zdHJhaW50cyIsInNoaW1HZXREaXNwbGF5TWVkaWEiLCJwcmVmZXJyZWRNZWRpYVNvdXJjZSIsImdldERpc3BsYXlNZWRpYSIsImNvZGUiLCJtZWRpYVNvdXJjZSIsIlJUQ1RyYWNrRXZlbnQiLCJtb3pSVENQZWVyQ29ubmVjdGlvbiIsIm1vZGVyblN0YXRzVHlwZXMiLCJpbmJvdW5kcnRwIiwib3V0Ym91bmRydHAiLCJjYW5kaWRhdGVwYWlyIiwibG9jYWxjYW5kaWRhdGUiLCJyZW1vdGVjYW5kaWRhdGUiLCJuYXRpdmVHZXRTdGF0cyIsInNlbGVjdG9yIiwib25TdWNjIiwib25FcnIiLCJzdGF0Iiwic2hpbVNlbmRlckdldFN0YXRzIiwic2hpbVJlY2VpdmVyR2V0U3RhdHMiLCJzaGltUmVtb3ZlU3RyZWFtIiwic2hpbVJUQ0RhdGFDaGFubmVsIiwiRGF0YUNoYW5uZWwiLCJSVENEYXRhQ2hhbm5lbCIsInNoaW1BZGRUcmFuc2NlaXZlciIsIm9yaWdBZGRUcmFuc2NlaXZlciIsImFkZFRyYW5zY2VpdmVyIiwic2V0UGFyYW1ldGVyc1Byb21pc2VzIiwic2VuZEVuY29kaW5ncyIsInNob3VsZFBlcmZvcm1DaGVjayIsImVuY29kaW5nUGFyYW0iLCJyaWRSZWdleCIsInJpZCIsInBhcnNlRmxvYXQiLCJzY2FsZVJlc29sdXRpb25Eb3duQnkiLCJtYXhGcmFtZXJhdGUiLCJwYXJhbXMiLCJnZXRQYXJhbWV0ZXJzIiwiZW5jb2RpbmdzIiwic2V0UGFyYW1ldGVycyIsImNhdGNoIiwic2hpbUdldFBhcmFtZXRlcnMiLCJvcmlnR2V0UGFyYW1ldGVycyIsInNoaW1DcmVhdGVPZmZlciIsIm9yaWdDcmVhdGVPZmZlciIsImNyZWF0ZU9mZmVyIiwiZmluYWxseSIsInNoaW1DcmVhdGVBbnN3ZXIiLCJvcmlnQ3JlYXRlQW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwic2hpbUxvY2FsU3RyZWFtc0FQSSIsIl9sb2NhbFN0cmVhbXMiLCJfYWRkVHJhY2siLCJfbGVuIiwiX2tleSIsInRyYWNrcyIsInNoaW1SZW1vdGVTdHJlYW1zQVBJIiwiZ2V0UmVtb3RlU3RyZWFtcyIsIl9yZW1vdGVTdHJlYW1zIiwiX29uYWRkc3RyZWFtIiwiX29uYWRkc3RyZWFtcG9seSIsInNoaW1DYWxsYmFja3NBUEkiLCJhZGRJY2VDYW5kaWRhdGUiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJwcm9taXNlIiwid2l0aENhbGxiYWNrIiwiY2FuZGlkYXRlIiwiX2dldFVzZXJNZWRpYSIsInNoaW1Db25zdHJhaW50cyIsImVycmNiIiwic2hpbVJUQ0ljZVNlcnZlclVybHMiLCJPcmlnUGVlckNvbm5lY3Rpb24iLCJwY0NvbmZpZyIsInBjQ29uc3RyYWludHMiLCJpY2VTZXJ2ZXJzIiwibmV3SWNlU2VydmVycyIsInNlcnZlciIsInVybHMiLCJ1cmwiLCJnZW5lcmF0ZUNlcnRpZmljYXRlIiwic2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlciIsInNoaW1DcmVhdGVPZmZlckxlZ2FjeSIsIm9mZmVyT3B0aW9ucyIsIm9mZmVyVG9SZWNlaXZlQXVkaW8iLCJhdWRpb1RyYW5zY2VpdmVyIiwiZ2V0VHJhbnNjZWl2ZXJzIiwiZGlyZWN0aW9uIiwic2V0RGlyZWN0aW9uIiwib2ZmZXJUb1JlY2VpdmVWaWRlbyIsInZpZGVvVHJhbnNjZWl2ZXIiLCJzaGltQXVkaW9Db250ZXh0IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0IiwiU0RQVXRpbHMiLCJnZW5lcmF0ZUlkZW50aWZpZXIiLCJsb2NhbENOYW1lIiwic3BsaXRMaW5lcyIsImJsb2IiLCJsaW5lIiwic3BsaXRTZWN0aW9ucyIsInBhcnRzIiwicGFydCIsImdldERlc2NyaXB0aW9uIiwic2VjdGlvbnMiLCJnZXRNZWRpYVNlY3Rpb25zIiwibWF0Y2hQcmVmaXgiLCJwYXJzZUNhbmRpZGF0ZSIsImZvdW5kYXRpb24iLCJjb21wb25lbnQiLCJwcm90b2NvbCIsInByaW9yaXR5IiwiaXAiLCJhZGRyZXNzIiwicG9ydCIsInJlbGF0ZWRBZGRyZXNzIiwicmVsYXRlZFBvcnQiLCJ0Y3BUeXBlIiwidWZyYWciLCJ1c2VybmFtZUZyYWdtZW50Iiwid3JpdGVDYW5kaWRhdGUiLCJwYXJzZUljZU9wdGlvbnMiLCJwYXJzZVJ0cE1hcCIsInBhcnNlZCIsInBheWxvYWRUeXBlIiwiY2xvY2tSYXRlIiwiY2hhbm5lbHMiLCJudW1DaGFubmVscyIsIndyaXRlUnRwTWFwIiwiY29kZWMiLCJwdCIsInByZWZlcnJlZFBheWxvYWRUeXBlIiwicGFyc2VFeHRtYXAiLCJ1cmkiLCJhdHRyaWJ1dGVzIiwid3JpdGVFeHRtYXAiLCJoZWFkZXJFeHRlbnNpb24iLCJwcmVmZXJyZWRJZCIsInBhcnNlRm10cCIsImt2IiwiaiIsIndyaXRlRm10cCIsInBhcmFtZXRlcnMiLCJwYXJhbSIsInBhcnNlUnRjcEZiIiwicGFyYW1ldGVyIiwid3JpdGVSdGNwRmIiLCJsaW5lcyIsInJ0Y3BGZWVkYmFjayIsImZiIiwicGFyc2VTc3JjTWVkaWEiLCJzcCIsInNzcmMiLCJjb2xvbiIsImF0dHJpYnV0ZSIsInBhcnNlU3NyY0dyb3VwIiwic2VtYW50aWNzIiwic3NyY3MiLCJnZXRNaWQiLCJtZWRpYVNlY3Rpb24iLCJwYXJzZUZpbmdlcnByaW50IiwiYWxnb3JpdGhtIiwiZ2V0RHRsc1BhcmFtZXRlcnMiLCJzZXNzaW9ucGFydCIsInJvbGUiLCJmaW5nZXJwcmludHMiLCJ3cml0ZUR0bHNQYXJhbWV0ZXJzIiwic2V0dXBUeXBlIiwiZnAiLCJwYXJzZUNyeXB0b0xpbmUiLCJjcnlwdG9TdWl0ZSIsImtleVBhcmFtcyIsInNlc3Npb25QYXJhbXMiLCJ3cml0ZUNyeXB0b0xpbmUiLCJ3cml0ZUNyeXB0b0tleVBhcmFtcyIsInBhcnNlQ3J5cHRvS2V5UGFyYW1zIiwia2V5TWV0aG9kIiwia2V5U2FsdCIsImxpZmVUaW1lIiwibWtpVmFsdWUiLCJta2lMZW5ndGgiLCJnZXRDcnlwdG9QYXJhbWV0ZXJzIiwiZ2V0SWNlUGFyYW1ldGVycyIsInB3ZCIsInBhc3N3b3JkIiwid3JpdGVJY2VQYXJhbWV0ZXJzIiwiaWNlTGl0ZSIsInBhcnNlUnRwUGFyYW1ldGVycyIsImNvZGVjcyIsImhlYWRlckV4dGVuc2lvbnMiLCJmZWNNZWNoYW5pc21zIiwicnRjcCIsIm1saW5lIiwicHJvZmlsZSIsInJ0cG1hcGxpbmUiLCJmbXRwcyIsIndpbGRjYXJkUnRjcEZiIiwiZHVwbGljYXRlIiwiZXhpc3RpbmdGZWVkYmFjayIsIndyaXRlUnRwRGVzY3JpcHRpb24iLCJjYXBzIiwibWF4cHRpbWUiLCJwYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyIsImVuY29kaW5nUGFyYW1ldGVycyIsImhhc1JlZCIsImhhc1VscGZlYyIsInByaW1hcnlTc3JjIiwic2Vjb25kYXJ5U3NyYyIsImZsb3dzIiwiYXB0IiwiZW5jUGFyYW0iLCJjb2RlY1BheWxvYWRUeXBlIiwicnR4IiwiZmVjIiwibWVjaGFuaXNtIiwiYmFuZHdpZHRoIiwibWF4Qml0cmF0ZSIsInBhcnNlUnRjcFBhcmFtZXRlcnMiLCJydGNwUGFyYW1ldGVycyIsInJlbW90ZVNzcmMiLCJjbmFtZSIsInJzaXplIiwicmVkdWNlZFNpemUiLCJjb21wb3VuZCIsIm11eCIsIndyaXRlUnRjcFBhcmFtZXRlcnMiLCJwYXJzZU1zaWQiLCJzcGVjIiwicGxhbkIiLCJtc2lkUGFydHMiLCJwYXJzZVNjdHBEZXNjcmlwdGlvbiIsInBhcnNlTUxpbmUiLCJtYXhTaXplTGluZSIsIm1heE1lc3NhZ2VTaXplIiwic2N0cFBvcnQiLCJmbXQiLCJzY3RwTWFwTGluZXMiLCJ3cml0ZVNjdHBEZXNjcmlwdGlvbiIsIm1lZGlhIiwic2N0cCIsIm91dHB1dCIsImdlbmVyYXRlU2Vzc2lvbklkIiwic3Vic3RyIiwid3JpdGVTZXNzaW9uQm9pbGVycGxhdGUiLCJzZXNzSWQiLCJzZXNzVmVyIiwic2Vzc1VzZXIiLCJzZXNzaW9uSWQiLCJ1c2VyIiwiZ2V0RGlyZWN0aW9uIiwiZ2V0S2luZCIsImlzUmVqZWN0ZWQiLCJwYXJzZU9MaW5lIiwidXNlcm5hbWUiLCJzZXNzaW9uVmVyc2lvbiIsIm5ldFR5cGUiLCJhZGRyZXNzVHlwZSIsImlzVmFsaWRTRFAiLCJzaGltUlRDSWNlQ2FuZGlkYXRlIiwiTmF0aXZlUlRDSWNlQ2FuZGlkYXRlIiwibmF0aXZlQ2FuZGlkYXRlIiwicGFyc2VkQ2FuZGlkYXRlIiwic2RwTWlkIiwic2RwTUxpbmVJbmRleCIsIndyaXRhYmxlIiwic2hpbVJUQ0ljZUNhbmRpZGF0ZVJlbGF5UHJvdG9jb2wiLCJyZWxheVByb3RvY29sIiwic2hpbU1heE1lc3NhZ2VTaXplIiwiX3NjdHAiLCJzY3RwSW5EZXNjcmlwdGlvbiIsIm1MaW5lIiwiZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24iLCJnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJyZW1vdGVJc0ZpcmVmb3giLCJjYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJnZXRNYXhNZXNzYWdlU2l6ZSIsImlzRmlyZWZveCIsImNhblNlbmRNTVMiLCJyZW1vdGVNTVMiLCJzaGltU2VuZFRocm93VHlwZUVycm9yIiwid3JhcERjU2VuZCIsImRjIiwib3JpZ0RhdGFDaGFubmVsU2VuZCIsInNlbmQiLCJyZWFkeVN0YXRlIiwib3JpZ0NyZWF0ZURhdGFDaGFubmVsIiwiY3JlYXRlRGF0YUNoYW5uZWwiLCJkYXRhQ2hhbm5lbCIsImNoYW5uZWwiLCJzaGltQ29ubmVjdGlvblN0YXRlIiwiY29tcGxldGVkIiwiY2hlY2tpbmciLCJpY2VDb25uZWN0aW9uU3RhdGUiLCJfb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvcmlnTWV0aG9kIiwiX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkiLCJfbGFzdENvbm5lY3Rpb25TdGF0ZSIsImNvbm5lY3Rpb25TdGF0ZSIsIm5ld0V2ZW50IiwicmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCIsIm5hdGl2ZVNSRCIsInNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSIsIm5hdGl2ZUFkZEljZUNhbmRpZGF0ZSIsInNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbiIsIm5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24iLCJhZGFwdGVyRmFjdG9yeSIsInNoaW1DaHJvbWUiLCJzaGltRmlyZWZveCIsInNoaW1TYWZhcmkiLCJhZGFwdGVyIiwiY29tbW9uU2hpbSIsImNocm9tZVNoaW0iLCJicm93c2VyU2hpbSIsImZpcmVmb3hTaGltIiwic2FmYXJpU2hpbSIsIkVOQ1JZUFRJT05fQUxHT1JJVEhNIiwiREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSIsIkUyRUVfRkxBRyIsIlNBTFQiLCJLRVlfUFJPVklERVJfREVGQVVMVFMiLCJzaGFyZWRLZXkiLCJyYXRjaGV0U2FsdCIsInJhdGNoZXRXaW5kb3dTaXplIiwiZmFpbHVyZVRvbGVyYW5jZSIsImtleXJpbmdTaXplIiwiS2V5UHJvdmlkZXJFdmVudCIsIktleUhhbmRsZXJFdmVudCIsIkVuY3J5cHRpb25FdmVudCIsIkNyeXB0b3JFdmVudCIsImlzRTJFRVN1cHBvcnRlZCIsImlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCIsImlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkIiwiUlRDUnRwU2NyaXB0VHJhbnNmb3JtIiwiY3JlYXRlRW5jb2RlZFN0cmVhbXMiLCJpc1ZpZGVvRnJhbWUiLCJmcmFtZSIsImltcG9ydEtleSIsImtleUJ5dGVzXzEiLCJrZXlCeXRlcyIsInVzYWdlIiwiY3J5cHRvIiwic3VidGxlIiwiY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nIiwia2V5TWF0ZXJpYWwiLCJjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIiLCJjcnlwdG9CdWZmZXIiLCJnZXRBbGdvT3B0aW9ucyIsImFsZ29yaXRobU5hbWUiLCJzYWx0IiwiZW5jb2RlZFNhbHQiLCJoYXNoIiwiaXRlcmF0aW9ucyIsImRlcml2ZUtleXMiLCJtYXRlcmlhbCIsImFsZ29yaXRobU9wdGlvbnMiLCJlbmNyeXB0aW9uS2V5IiwiZGVyaXZlS2V5IiwiY3JlYXRlRTJFRUtleSIsImdldFJhbmRvbVZhbHVlcyIsInJhdGNoZXQiLCJkZXJpdmVCaXRzIiwibmVlZHNSYnNwVW5lc2NhcGluZyIsImZyYW1lRGF0YSIsInBhcnNlUmJzcCIsImRhdGFPdXQiLCJrWmVyb3NJblN0YXJ0U2VxdWVuY2UiLCJrRW11bGF0aW9uQnl0ZSIsIndyaXRlUmJzcCIsImRhdGFfaW4iLCJudW1Db25zZWN1dGl2ZVplcm9zIiwiQmFzZUtleVByb3ZpZGVyIiwib25LZXlSYXRjaGV0ZWQiLCJrZXlJbmRleCIsImtleUluZm9NYXAiLCJLZXlSYXRjaGV0ZWQiLCJvblNldEVuY3J5cHRpb25LZXkiLCJwYXJ0aWNpcGFudElkZW50aXR5Iiwia2V5SW5mbyIsIlNldEtleSIsImdldEtleXMiLCJmcm9tIiwiZ2V0T3B0aW9ucyIsInJhdGNoZXRLZXkiLCJSYXRjaGV0UmVxdWVzdCIsIkV4dGVybmFsRTJFRUtleVByb3ZpZGVyIiwib3B0cyIsInNldEtleSIsImRlcml2ZWRLZXkiLCJMaXZla2l0RXJyb3IiLCJDb25uZWN0aW9uRXJyb3JSZWFzb24iLCJDb25uZWN0aW9uRXJyb3IiLCJyZWFzb24iLCJzdGF0dXMiLCJyZWFzb25OYW1lIiwiRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciIsIlRyYWNrSW52YWxpZEVycm9yIiwiVW5zdXBwb3J0ZWRTZXJ2ZXIiLCJVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlIiwiTmVnb3RpYXRpb25FcnJvciIsIlB1Ymxpc2hEYXRhRXJyb3IiLCJQdWJsaXNoVHJhY2tFcnJvciIsIlNpZ25hbFJlcXVlc3RFcnJvciIsIlJlcXVlc3RSZXNwb25zZV9SZWFzb24iLCJNZWRpYURldmljZUZhaWx1cmUiLCJnZXRGYWlsdXJlIiwiTm90Rm91bmQiLCJQZXJtaXNzaW9uRGVuaWVkIiwiRGV2aWNlSW5Vc2UiLCJPdGhlciIsIkNyeXB0b3JFcnJvclJlYXNvbiIsIkNyeXB0b3JFcnJvciIsIkludGVybmFsRXJyb3IiLCJSb29tRXZlbnQiLCJQYXJ0aWNpcGFudEV2ZW50IiwiRW5naW5lRXZlbnQiLCJUcmFja0V2ZW50IiwiY2xvbmVEZWVwIiwic3RydWN0dXJlZENsb25lIiwiY29tbW9uVmVyc2lvbklkZW50aWZpZXIiLCJnZXRCcm93c2VyIiwiZm9yY2UiLCJ1YSIsImJyb3dzZXJzTGlzdCIsIl9yZWYiLCJkZXNjcmliZSIsImdldE1hdGNoIiwib3MiLCJvc1ZlcnNpb24iLCJnZXRPU1ZlcnNpb24iLCJleHAiLCJwcm90b2NvbFZlcnNpb24iLCJDcml0aWNhbFRpbWVycyIsInNldFRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFyVGltZW91dCIsImNsZWFySW50ZXJ2YWwiLCJCQUNLR1JPVU5EX1JFQUNUSU9OX0RFTEFZIiwicmVjeWNsZWRFbGVtZW50cyIsIlZpZGVvUXVhbGl0eSIsIlRyYWNrIiwibWVkaWFUcmFjayIsImxvZ2dlck9wdGlvbnMiLCJhdHRhY2hlZEVsZW1lbnRzIiwiaXNNdXRlZCIsInN0cmVhbVN0YXRlIiwiU3RyZWFtU3RhdGUiLCJBY3RpdmUiLCJpc0luQmFja2dyb3VuZCIsIl9jdXJyZW50Qml0cmF0ZSIsImFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIiLCJiYWNrZ3JvdW5kVGltZW91dCIsInZpc2liaWxpdHlTdGF0ZSIsImhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkIiwibG9nZ2VyQ29udGV4dENiIiwiX21lZGlhU3RyZWFtVHJhY2siLCJfbWVkaWFTdHJlYW1JRCIsIlNvdXJjZSIsIlVua25vd24iLCJsb2dDb250ZXh0IiwiZ2V0TG9nQ29udGV4dEZyb21UcmFjayIsImN1cnJlbnRCaXRyYXRlIiwibWVkaWFTdHJlYW1UcmFjayIsIm1lZGlhU3RyZWFtSUQiLCJhdHRhY2giLCJlbGVtZW50IiwiZWxlbWVudFR5cGUiLCJLaW5kIiwiVmlkZW8iLCJhZGRBcHBWaXNpYmlsaXR5TGlzdGVuZXIiLCJwYXJlbnRFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImF0dGFjaFRvRWxlbWVudCIsImFsbE1lZGlhU3RyZWFtVHJhY2tzIiwic3JjT2JqZWN0IiwiaGFzQXVkaW8iLCJ0ciIsInBsYXkiLCJBdWRpb1BsYXliYWNrU3RhcnRlZCIsIlZpZGVvUGxheWJhY2tTdGFydGVkIiwiQXVkaW9QbGF5YmFja0ZhaWxlZCIsIlZpZGVvUGxheWJhY2tGYWlsZWQiLCJtdXRlZCIsIkVsZW1lbnRBdHRhY2hlZCIsImRldGFjaCIsImRldGFjaFRyYWNrIiwicmVjeWNsZUVsZW1lbnQiLCJFbGVtZW50RGV0YWNoZWQiLCJkZXRhY2hlZCIsImVsbSIsInJlbW92ZUFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInN0b3BNb25pdG9yIiwiZW5hYmxlIiwiZW5hYmxlZCIsImRpc2FibGUiLCJtb25pdG9ySW50ZXJ2YWwiLCJ0aW1lU3luY0hhbmRsZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlTG9nZ2VyT3B0aW9ucyIsIkhUTUxBdWRpb0VsZW1lbnQiLCJzaG91bGRDYWNoZSIsInBhdXNlIiwiZWwiLCJpc1dlYiIsIm1lZGlhU3RyZWFtIiwiZXhpc3RpbmdUcmFja3MiLCJldCIsImlzU2FmYXJpIiwiSFRNTFZpZGVvRWxlbWVudCIsImF1dG9wbGF5IiwicGxheXNJbmxpbmUiLCJpc0ZpcmVGb3giLCJraW5kVG9Qcm90byIsIkF1ZGlvIiwiVHJhY2tUeXBlIiwiQVVESU8iLCJWSURFTyIsIkRBVEEiLCJraW5kRnJvbVByb3RvIiwic291cmNlVG9Qcm90byIsIkNhbWVyYSIsIlRyYWNrU291cmNlIiwiQ0FNRVJBIiwiTWljcm9waG9uZSIsIk1JQ1JPUEhPTkUiLCJTY3JlZW5TaGFyZSIsIlNDUkVFTl9TSEFSRSIsIlNjcmVlblNoYXJlQXVkaW8iLCJTQ1JFRU5fU0hBUkVfQVVESU8iLCJVTktOT1dOIiwic291cmNlRnJvbVByb3RvIiwic3RyZWFtU3RhdGVGcm9tUHJvdG8iLCJQcm90b1N0cmVhbVN0YXRlIiwiQUNUSVZFIiwiUEFVU0VEIiwiUGF1c2VkIiwiVmlkZW9QcmVzZXQiLCJ3aWR0aE9yT3B0aW9ucyIsImhlaWdodCIsIndpZHRoIiwiYXNwZWN0UmF0aW8iLCJlbmNvZGluZyIsInJlc29sdXRpb24iLCJmcmFtZVJhdGUiLCJiYWNrdXBDb2RlY3MiLCJ2aWRlb0NvZGVjcyIsImlzQmFja3VwQ29kZWMiLCJiYWNrdXAiLCJCYWNrdXBDb2RlY1BvbGljeSIsIkF1ZGlvUHJlc2V0cyIsInRlbGVwaG9uZSIsInNwZWVjaCIsIm11c2ljIiwibXVzaWNTdGVyZW8iLCJtdXNpY0hpZ2hRdWFsaXR5IiwibXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyIsIlZpZGVvUHJlc2V0cyIsImg5MCIsImgxODAiLCJoMjE2IiwiaDM2MCIsImg1NDAiLCJoNzIwIiwiaDEwODAiLCJoMTQ0MCIsImgyMTYwIiwiVmlkZW9QcmVzZXRzNDMiLCJoMTIwIiwiaDI0MCIsImg0ODAiLCJTY3JlZW5TaGFyZVByZXNldHMiLCJoMzYwZnBzMyIsImgzNjBmcHMxNSIsImg3MjBmcHM1IiwiaDcyMGZwczE1IiwiaDcyMGZwczMwIiwiaDEwODBmcHMxNSIsImgxMDgwZnBzMzAiLCJvcmlnaW5hbCIsInNlcGFyYXRvciIsImRkRXh0ZW5zaW9uVVJJIiwidW5wYWNrU3RyZWFtSWQiLCJzbGVlcCIsImR1cmF0aW9uIiwic3VwcG9ydHNUcmFuc2NlaXZlciIsInN1cHBvcnRzQWRkVHJhY2siLCJzdXBwb3J0c0FkYXB0aXZlU3RyZWFtIiwiUmVzaXplT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInN1cHBvcnRzRHluYWNhc3QiLCJzdXBwb3J0c0FWMSIsImNhcGFiaWxpdGllcyIsImdldENhcGFiaWxpdGllcyIsImhhc0FWMSIsIm1pbWVUeXBlIiwic3VwcG9ydHNWUDkiLCJjb21wYXJlVmVyc2lvbnMiLCJoYXNWUDkiLCJpc1NWQ0NvZGVjIiwic3VwcG9ydHNTZXRTaW5rSWQiLCJpc0Jyb3dzZXJTdXBwb3J0ZWQiLCJpc1NhZmFyaTE3IiwiaXNNb2JpbGUiLCJtb2JpbGUiLCJpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQiLCJzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uIiwiaXNSZWFjdE5hdGl2ZSIsInByb2R1Y3QiLCJpc0Nsb3VkIiwic2VydmVyVXJsIiwiaG9zdG5hbWUiLCJnZXRMS1JlYWN0TmF0aXZlSW5mbyIsImdsb2JhbCIsIkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCIsImdldFJlYWN0TmF0aXZlT3MiLCJwbGF0Zm9ybSIsImdldERldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwidjEiLCJ2MiIsInBhcnRzMSIsInBhcnRzMiIsInAxIiwicDIiLCJyb0Rpc3BhdGNoQ2FsbGJhY2siLCJlbnRyeSIsImhhbmRsZVJlc2l6ZSIsImlvRGlzcGF0Y2hDYWxsYmFjayIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkIiwicmVzaXplT2JzZXJ2ZXIiLCJnZXRSZXNpemVPYnNlcnZlciIsImludGVyc2VjdGlvbk9ic2VydmVyIiwiZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyb290TWFyZ2luIiwiZ2V0Q2xpZW50SW5mbyIsIkNsaWVudEluZm8iLCJzZGsiLCJDbGllbnRJbmZvX1NESyIsIkpTIiwiZW1wdHlWaWRlb1N0cmVhbVRyYWNrIiwiZ2V0RW1wdHlWaWRlb1N0cmVhbVRyYWNrIiwiY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrIiwicGFpbnRDb250ZW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxSZWN0IiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJjbG9zZVBhdGgiLCJmaWxsU3R5bGUiLCJmaWxsIiwiZHVtbXlTdHJlYW0iLCJjYXB0dXJlU3RyZWFtIiwiZHVtbXlUcmFjayIsImVtcHR5QXVkaW9TdHJlYW1UcmFjayIsImdldEVtcHR5QXVkaW9TdHJlYW1UcmFjayIsIm9zY2lsbGF0b3IiLCJjcmVhdGVPc2NpbGxhdG9yIiwiZ2FpbiIsImNyZWF0ZUdhaW4iLCJzZXRWYWx1ZUF0VGltZSIsImRzdCIsImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24iLCJjb25uZWN0IiwiRnV0dXJlIiwiZnV0dXJlQmFzZSIsIm9uRmluYWxseSIsIl9fYXdhaXRlciIsImNyZWF0ZUF1ZGlvQW5hbHlzZXIiLCJjbG9uZVRyYWNrIiwiZmZ0U2l6ZSIsInNtb290aGluZ1RpbWVDb25zdGFudCIsIm1pbkRlY2liZWxzIiwibWF4RGVjaWJlbHMiLCJhdWRpb0NvbnRleHQiLCJnZXROZXdBdWRpb0NvbnRleHQiLCJzdHJlYW1UcmFjayIsIm1lZGlhU3RyZWFtU291cmNlIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJhbmFseXNlciIsImNyZWF0ZUFuYWx5c2VyIiwiZGF0YUFycmF5IiwiZnJlcXVlbmN5QmluQ291bnQiLCJjYWxjdWxhdGVWb2x1bWUiLCJnZXRCeXRlRnJlcXVlbmN5RGF0YSIsInN1bSIsImFtcGxpdHVkZSIsInBvdyIsInZvbHVtZSIsInNxcnQiLCJjbGVhbnVwIiwiY2xvc2UiLCJpc1ZpZGVvQ29kZWMiLCJtYXliZUNvZGVjIiwidW53cmFwQ29uc3RyYWludCIsInRvSHR0cFVybCIsImV4dHJhY3RUcmFuc2NyaXB0aW9uU2VnbWVudHMiLCJ0cmFuc2NyaXB0aW9uIiwiZmlyc3RSZWNlaXZlZFRpbWVzTWFwIiwic2VnbWVudHMiLCJ0ZXh0IiwibGFuZ3VhZ2UiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZmluYWwiLCJmaXJzdFJlY2VpdmVkVGltZSIsImxhc3RSZWNlaXZlZFRpbWUiLCJleHRyYWN0Q2hhdE1lc3NhZ2UiLCJ0aW1lc3RhbXAiLCJlZGl0VGltZXN0YW1wIiwiZ2V0RGlzY29ubmVjdFJlYXNvbkZyb21Db25uZWN0aW9uRXJyb3IiLCJMZWF2ZVJlcXVlc3QiLCJDYW5jZWxsZWQiLCJEaXNjb25uZWN0UmVhc29uIiwiQ0xJRU5UX0lOSVRJQVRFRCIsIk5vdEFsbG93ZWQiLCJVU0VSX1JFSkVDVEVEIiwiU2VydmVyVW5yZWFjaGFibGUiLCJKT0lOX0ZBSUxVUkUiLCJVTktOT1dOX1JFQVNPTiIsImJpZ0ludFRvTnVtYmVyIiwibnVtYmVyVG9CaWdJbnQiLCJpc0xvY2FsVHJhY2siLCJpc0F1ZGlvVHJhY2siLCJpc1ZpZGVvVHJhY2siLCJpc0xvY2FsVmlkZW9UcmFjayIsImlzTG9jYWxBdWRpb1RyYWNrIiwiaXNSZW1vdGVUcmFjayIsImlzUmVtb3RlUHViIiwicHViIiwiaXNSZW1vdGVWaWRlb1RyYWNrIiwiaXNMb2NhbFBhcnRpY2lwYW50IiwiaXNSZW1vdGVQYXJ0aWNpcGFudCIsInNwbGl0VXRmOCIsImVuY29kZWQiLCJtZXJnZURlZmF1bHRPcHRpb25zIiwiYXVkaW9EZWZhdWx0cyIsInZpZGVvRGVmYXVsdHMiLCJvcHRpb25zV2l0aG91dFByb2Nlc3NvciIsImF1ZGlvUHJvY2Vzc29yIiwidmlkZW9Qcm9jZXNzb3IiLCJleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zIiwiZGVmYXVsdEF1ZGlvUHJvY2Vzc29yIiwicHJvY2Vzc29yIiwiZGVmYXVsdFZpZGVvUHJvY2Vzc29yIiwiY2xvbmVkT3B0aW9ucyIsIm1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nIiwibWFpbk9iamVjdCIsIm9iamVjdFRvTWVyZ2UiLCJjb25zdHJhaW50c0Zvck9wdGlvbnMiLCJ2aWRlb09wdGlvbnMiLCJkZXRlY3RTaWxlbmNlIiwidHJhY2tfMSIsInRpbWVPZmZzZXQiLCJidWZmZXJMZW5ndGgiLCJnZXRCeXRlVGltZURvbWFpbkRhdGEiLCJzb21lTm9pc2UiLCJzYW1wbGUiLCJsYXRlbmN5SGludCIsImJvZHkiLCJoYW5kbGVSZXN1bWUiLCJyZXN1bWUiLCJzb3VyY2VUb0tpbmQiLCJzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zIiwidmlkZW9Db25zdHJhaW50cyIsImNvbnRyb2xsZXIiLCJzZWxmQnJvd3NlclN1cmZhY2UiLCJzdXJmYWNlU3dpdGNoaW5nIiwic3lzdGVtQXVkaW8iLCJwcmVmZXJDdXJyZW50VGFiIiwibWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmciLCJnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyIsImluZm9zIiwiVHJhY2tQdWJsaXNoZWRSZXNwb25zZSIsImNpZCIsInRyYWNrSW5mbyIsInRyYWNrSUQiLCJzaWQiLCJzdHJlYW1JRCIsInN0cmVhbVRyYWNrSUQiLCJ0cmFja1NpZCIsImlzRW5hYmxlZCIsInRyYWNrTmFtZSIsImVuY3J5cHRlZCIsImlzRW5jcnlwdGVkIiwic3VwcG9ydHNTeW5jaHJvbml6YXRpb25Tb3VyY2VzIiwiZGlmZkF0dHJpYnV0ZXMiLCJvbGRWYWx1ZXMiLCJuZXdWYWx1ZXMiLCJhbGxLZXlzIiwiZGlmZiIsIm5ld09wdGlvbnMiLCJnZXRUcmFja1NvdXJjZUZyb21Qcm90byIsIkUyRUVNYW5hZ2VyIiwib25Xb3JrZXJNZXNzYWdlIiwiZXYiLCJFbmNyeXB0aW9uRXJyb3IiLCJrZXlQcm92aWRlciIsInBvc3RLZXkiLCJlbmNyeXB0aW9uRW5hYmxlZCIsInJvb20iLCJsb2NhbFBhcnRpY2lwYW50IiwiaWRlbnRpdHkiLCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkIiwicGFydGljaXBhbnQiLCJnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkiLCJvbldvcmtlckVycm9yIiwid29ya2VyIiwic2V0dXAiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwia2V5UHJvdmlkZXJPcHRpb25zIiwibG9nbGV2ZWwiLCJvbm1lc3NhZ2UiLCJvbmVycm9yIiwicG9zdE1lc3NhZ2UiLCJzZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkIiwicG9zdEVuYWJsZSIsInNldFNpZlRyYWlsZXIiLCJ0cmFpbGVyIiwicG9zdFNpZlRyYWlsZXIiLCJzZXR1cEVuZ2luZSIsImVuZ2luZSIsIlJUUFZpZGVvTWFwVXBkYXRlIiwicnRwTWFwIiwicG9zdFJUUE1hcCIsIlRyYWNrUHVibGlzaGVkIiwiZW5jcnlwdGlvbiIsIkVuY3J5cHRpb25fVHlwZSIsIk5PTkUiLCJDb25uZWN0aW9uU3RhdGVDaGFuZ2VkIiwiQ29ubmVjdGlvblN0YXRlIiwiQ29ubmVjdGVkIiwicmVtb3RlUGFydGljaXBhbnRzIiwidHJhY2tQdWJsaWNhdGlvbnMiLCJUcmFja1Vuc3Vic2NyaWJlZCIsIlRyYWNrU3Vic2NyaWJlZCIsInNldHVwRTJFRVJlY2VpdmVyIiwiU2lnbmFsQ29ubmVjdGVkIiwiaXNFMkVFRW5hYmxlZCIsIkxvY2FsVHJhY2tQdWJsaXNoZWQiLCJwdWJsaWNhdGlvbiIsInNldHVwRTJFRVNlbmRlciIsInBhcnRpY2lwYW50SWQiLCJwb3N0UmF0Y2hldFJlcXVlc3QiLCJpc1B1Ymxpc2hlciIsImVuYWJsZU1zZyIsIlJlZmVyZW5jZUVycm9yIiwicmVtb3RlSWQiLCJoYW5kbGVSZWNlaXZlciIsImhhbmRsZVNlbmRlciIsInRyYW5zZm9ybSIsIndyaXRhYmxlU3RyZWFtIiwicmVhZGFibGUiLCJyZWFkYWJsZVN0cmVhbSIsInJlY2VpdmVyU3RyZWFtcyIsInNlbmRlclN0cmVhbXMiLCJkZWZhdWx0SWQiLCJEZXZpY2VNYW5hZ2VyIiwiX3ByZXZpb3VzRGV2aWNlcyIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJwcmV2aW91c0RldmljZXMiLCJnZXREZXZpY2VzIiwia2luZF8xIiwiX3RoaXMiLCJyZXF1ZXN0UGVybWlzc2lvbnMiLCJ1c2VyTWVkaWFQcm9taXNlTWFwIiwiaGFzRGV2aWNlSW5Vc2UiLCJpc0R1bW15RGV2aWNlT3JFbXB0eSIsImRldmljZSIsIm5vTGFiZWwiLCJpc1JlbGV2YW50IiwicGVybWlzc2lvbnNUb0FjcXVpcmUiLCJub3JtYWxpemVEZXZpY2VJZCIsImdyb3VwSWQiLCJkZWZhdWx0RGV2aWNlIiwibWVkaWFEZXZpY2VLaW5kcyIsIlF1ZXVlVGFza1N0YXR1cyIsIkFzeW5jUXVldWUiLCJwZW5kaW5nVGFza3MiLCJ0YXNrTXV0ZXgiLCJNdXRleCIsIm5leHRUYXNrSW5kZXgiLCJydW4iLCJ0YXNrIiwidGFza0luZm8iLCJlbnF1ZXVlZEF0IiwiV0FJVElORyIsInVubG9jayIsImV4ZWN1dGVkQXQiLCJSVU5OSU5HIiwiQ09NUExFVEVEIiwiZmx1c2giLCJzbmFwc2hvdCIsImNyZWF0ZVJ0Y1VybCIsInNlYXJjaFBhcmFtcyIsInVybE9iaiIsIlVSTCIsImFwcGVuZFVybFBhdGgiLCJjcmVhdGVWYWxpZGF0ZVVybCIsInJ0Y1dzVXJsIiwiZW5zdXJlVHJhaWxpbmdTbGFzaCIsInBhdGgiLCJwYXRobmFtZSIsInBhc3NUaHJvdWdoUXVldWVTaWduYWxzIiwiY2FuUGFzc1Rocm91Z2hRdWV1ZSIsImNhblBhc3MiLCJTaWduYWxDb25uZWN0aW9uU3RhdGUiLCJTaWduYWxDbGllbnQiLCJjdXJyZW50U3RhdGUiLCJpc0Rpc2Nvbm5lY3RlZCIsIkRJU0NPTk5FQ1RJTkciLCJESVNDT05ORUNURUQiLCJpc0VzdGFibGlzaGluZ0Nvbm5lY3Rpb24iLCJDT05ORUNUSU5HIiwiUkVDT05ORUNUSU5HIiwiZ2V0TmV4dFJlcXVlc3RJZCIsIl9yZXF1ZXN0SWQiLCJ1c2VKU09OIiwicnR0IiwicmVzZXRDYWxsYmFja3MiLCJvbkFuc3dlciIsIm9uTGVhdmUiLCJvbkxvY2FsVHJhY2tQdWJsaXNoZWQiLCJvbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsIm9uTmVnb3RpYXRlUmVxdWVzdGVkIiwib25PZmZlciIsIm9uUmVtb3RlTXV0ZUNoYW5nZWQiLCJvblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIiwib25Ub2tlblJlZnJlc2giLCJvblRyaWNrbGUiLCJvbkNsb3NlIiwiU2lnbmFsIiwicmVxdWVzdFF1ZXVlIiwicXVldWVkUmVxdWVzdHMiLCJjbG9zaW5nTG9jayIsImNvbm5lY3Rpb25Mb2NrIiwidG9rZW4iLCJhYm9ydFNpZ25hbCIsInJlcyIsInJlY29ubmVjdCIsImNsZWFyUGluZ0ludGVydmFsIiwicmVjb25uZWN0UmVhc29uIiwiY29ubmVjdE9wdGlvbnMiLCJjbGllbnRJbmZvIiwiY3JlYXRlQ29ubmVjdGlvblBhcmFtcyIsInJ0Y1VybCIsInZhbGlkYXRlVXJsIiwiYWJvcnRIYW5kbGVyIiwid3NUaW1lb3V0Iiwid2Vic29ja2V0VGltZW91dCIsImFib3J0ZWQiLCJyZWRhY3RlZFVybCIsIndzIiwiV2ViU29ja2V0IiwiYmluYXJ5VHlwZSIsIm9ub3BlbiIsIkNPTk5FQ1RFRCIsInJlc3AiLCJmZXRjaCIsInRvRml4ZWQiLCJoYW5kbGVXU0Vycm9yIiwiU2lnbmFsUmVzcG9uc2UiLCJzaG91bGRQcm9jZXNzTWVzc2FnZSIsInBpbmdUaW1lb3V0RHVyYXRpb24iLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbER1cmF0aW9uIiwicGluZ0ludGVydmFsIiwidGltZW91dCIsImludGVydmFsIiwic3RhcnRQaW5nSW50ZXJ2YWwiLCJzaWduYWxMYXRlbmN5IiwiaGFuZGxlU2lnbmFsUmVzcG9uc2UiLCJvbmNsb3NlIiwid2FzQ2xlYW4iLCJoYW5kbGVPbkNsb3NlIiwidXBkYXRlU3RhdGUiLCJjbG9zZVByb21pc2UiLCJDTE9TSU5HIiwicmFjZSIsInNlbmRPZmZlciIsIm9mZmVyIiwib2ZmZXJTZHAiLCJzZW5kUmVxdWVzdCIsInRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24iLCJzZW5kQW5zd2VyIiwiYW5zd2VyIiwiYW5zd2VyU2RwIiwic2VuZEljZUNhbmRpZGF0ZSIsIlRyaWNrbGVSZXF1ZXN0IiwiY2FuZGlkYXRlSW5pdCIsInNlbmRNdXRlVHJhY2siLCJNdXRlVHJhY2tSZXF1ZXN0Iiwic2VuZEFkZFRyYWNrIiwic2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEiLCJtZXRhZGF0YV8xIiwibmFtZV8xIiwibWV0YWRhdGEiLCJfdGhpczIiLCJyZXF1ZXN0SWQiLCJVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhIiwic2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3MiLCJzZXR0aW5ncyIsInNlbmRVcGRhdGVTdWJzY3JpcHRpb24iLCJzdWIiLCJzZW5kU3luY1N0YXRlIiwic3luYyIsInNlbmRVcGRhdGVWaWRlb0xheWVycyIsImxheWVycyIsIlVwZGF0ZVZpZGVvTGF5ZXJzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwiYWxsUGFydGljaXBhbnRzIiwidHJhY2tQZXJtaXNzaW9ucyIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb24iLCJzZW5kU2ltdWxhdGVTY2VuYXJpbyIsInNjZW5hcmlvIiwic2VuZFBpbmciLCJQaW5nIiwic2VuZFVwZGF0ZUxvY2FsQXVkaW9UcmFjayIsImZlYXR1cmVzIiwiVXBkYXRlTG9jYWxBdWRpb1RyYWNrIiwic2VuZExlYXZlIiwiYWN0aW9uIiwiTGVhdmVSZXF1ZXN0X0FjdGlvbiIsIkRJU0NPTk5FQ1QiLCJtZXNzYWdlXzEiLCJfdGhpczMiLCJmcm9tUXVldWUiLCJjYW5RdWV1ZSIsIk9QRU4iLCJTaWduYWxSZXF1ZXN0IiwicGluZ0hhbmRsZWQiLCJzZCIsImZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbiIsIm9uUGFydGljaXBhbnRVcGRhdGUiLCJwYXJ0aWNpcGFudHMiLCJvblNwZWFrZXJzQ2hhbmdlZCIsInNwZWFrZXJzIiwib25Sb29tVXBkYXRlIiwib25Db25uZWN0aW9uUXVhbGl0eSIsIm9uU3RyZWFtU3RhdGVVcGRhdGUiLCJvblN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUiLCJvblN1YnNjcmlwdGlvbkVycm9yIiwibGFzdFBpbmdUaW1lc3RhbXAiLCJyZXNldFBpbmdUaW1lb3V0Iiwib25SZXF1ZXN0UmVzcG9uc2UiLCJvbkxvY2FsVHJhY2tTdWJzY3JpYmVkIiwibXNnQ2FzZSIsInNldFJlY29ubmVjdGVkIiwib25DbG9zZUNhbGxiYWNrIiwiY2xlYXJQaW5nVGltZW91dCIsInRvVVRDU3RyaW5nIiwicnNkIiwiU2Vzc2lvbkRlc2NyaXB0aW9uIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXV0b1N1YnNjcmliZSIsImRldmljZU1vZGVsIiwiYnJvd3NlclZlcnNpb24iLCJhZGFwdGl2ZVN0cmVhbSIsImNvbm5lY3Rpb24iLCJncmFtbWFyIiwiZ3JhbW1hck1vZHVsZSIsInJlZyIsInUiLCJyYXRlIiwic3VidHlwZSIsImNvbmZpZyIsInNlc3Npb25Db25maWciLCJzdHIiLCJyYWRkciIsInRjcHR5cGUiLCJnZW5lcmF0aW9uIiwiZGlyMiIsImNsa3NyY0V4dCIsIm1lZGlhQ2xvY2tWYWx1ZSIsInJhdGVOdW1lcmF0b3IiLCJyYXRlRGVub21pbmF0b3IiLCJvYmpzIiwidG9JbnRJZkludCIsImF0dGFjaFByb3BlcnRpZXMiLCJyYXdOYW1lIiwicGFyc2VSZWciLCJjb250ZW50IiwibmVlZHNCbGFuayIsImtleUxvY2F0aW9uIiwicmVxdWlyZSQkMCIsInZhbGlkTGluZSIsInNlc3Npb24iLCJydHAiLCJmbXRwIiwicGFyYW1SZWR1Y2VyIiwiYWNjIiwicGFyc2VQYXJhbXMiLCJwYXJzZUZtdHBDb25maWciLCJwYXJzZVBheWxvYWRzIiwicGFyc2VSZW1vdGVDYW5kaWRhdGVzIiwiY2FuZGlkYXRlcyIsInBhcnNlSW1hZ2VBdHRyaWJ1dGVzIiwicGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0Iiwic2NpZCIsInBhdXNlZCIsImZvcm1hdFJlZ0V4cCIsImZvcm1hdFN0ciIsIngiLCJtYWtlTGluZSIsImRlZmF1bHRPdXRlck9yZGVyIiwiZGVmYXVsdElubmVyT3JkZXIiLCJwYXlsb2FkcyIsIm91dGVyT3JkZXIiLCJpbm5lck9yZGVyIiwicGFyc2VyIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJsaWIiLCJ3cml0ZSIsImlzSW1tZWRpYXRlIiwiY2FsbGJhY2siLCJtYXhXYWl0IiwiY2FuY2VsIiwic3RhcnRCaXRyYXRlRm9yU1ZDIiwiZGVib3VuY2VJbnRlcnZhbCIsIlBDRXZlbnRzIiwiTmVnb3RpYXRpb25TdGFydGVkIiwiTmVnb3RpYXRpb25Db21wbGV0ZSIsIlJUUFZpZGVvUGF5bG9hZFR5cGVzIiwiUENUcmFuc3BvcnQiLCJjcmVhdGVQQyIsImRkRXh0SUQiLCJwZW5kaW5nQ2FuZGlkYXRlcyIsInJlc3RhcnRpbmdJY2UiLCJyZW5lZ290aWF0ZSIsInRyYWNrQml0cmF0ZXMiLCJyZW1vdGVTdGVyZW9NaWRzIiwicmVtb3RlTmFja01pZHMiLCJuZWdvdGlhdGUiLCJkZWJvdW5jZSIsImNyZWF0ZUFuZFNlbmRPZmZlciIsIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UiLCJvbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlIiwib25kYXRhY2hhbm5lbCIsIm9ubmVnb3RpYXRpb25uZWVkZWQiLCJvbnNpZ25hbGluZ3N0YXRlY2hhbmdlIiwib25pY2VjYW5kaWRhdGUiLCJvbnRyYWNrIiwib25JY2VDYW5kaWRhdGUiLCJvbmljZWNhbmRpZGF0ZWVycm9yIiwib25JY2VDYW5kaWRhdGVFcnJvciIsIm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwib25TaWduYWxpbmdTdGF0ZWNoYW5nZSIsIm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlIiwib25EYXRhQ2hhbm5lbCIsIm9uVHJhY2siLCJpc0lDRUNvbm5lY3RlZCIsInJlbW90ZURlc2NyaXB0aW9uIiwibXVuZ2VkU0RQIiwic3RlcmVvTWlkcyIsIm5hY2tNaWRzIiwiZXh0cmFjdFN0ZXJlb0FuZE5hY2tBdWRpb0Zyb21PZmZlciIsInNkcFBhcnNlZCIsInRyYWNrYnIiLCJjb2RlY1BheWxvYWQiLCJwYXlsb2FkIiwiZm10cEZvdW5kIiwiYXR0ciIsIm1heGJyIiwic2V0TXVuZ2VkU0RQIiwiaWNlUmVzdGFydCIsImN1cnJlbnRTRCIsImVuc3VyZUlQQWRkck1hdGNoVmVyc2lvbiIsImVuc3VyZUF1ZGlvTmFja0FuZFN0ZXJlbyIsIm1zaWQiLCJlbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDIiwic3RhcnRCaXRyYXRlIiwicm91bmQiLCJjcmVhdGVBbmRTZXRBbnN3ZXIiLCJkYXRhQ2hhbm5lbERpY3QiLCJ0cmFuc2NlaXZlckluaXQiLCJzZXRUcmFja0NvZGVjQml0cmF0ZSIsInNldENvbmZpZ3VyYXRpb24iLCJydGNDb25maWciLCJjYW5SZW1vdmVUcmFjayIsImdldENvbm5lY3Rpb25TdGF0ZSIsImdldElDRUNvbm5lY3Rpb25TdGF0ZSIsImdldFNpZ25hbGxpbmdTdGF0ZSIsImdldExvY2FsRGVzY3JpcHRpb24iLCJsb2NhbERlc2NyaXB0aW9uIiwiZ2V0UmVtb3RlRGVzY3JpcHRpb24iLCJnZXRDb25uZWN0ZWRBZGRyZXNzIiwic2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQiLCJjYW5kaWRhdGVQYWlycyIsInNlbGVjdGVkIiwic2VsZWN0ZWRJRCIsInJlbW90ZUNhbmRpZGF0ZUlkIiwibXVuZ2VkIiwicmVtb3RlIiwib3JpZ2luYWxTZHAiLCJyZW1vdGVTZHAiLCJkZEZvdW5kIiwibWF4SUQiLCJvcHVzUGF5bG9hZCIsInJ0Y3BGYiIsImlzVjYiLCJkZWZhdWx0VmlkZW9Db2RlYyIsInB1Ymxpc2hEZWZhdWx0cyIsImF1ZGlvUHJlc2V0IiwiZHR4IiwicmVkIiwiZm9yY2VTdGVyZW8iLCJzaW11bGNhc3QiLCJzY3JlZW5TaGFyZUVuY29kaW5nIiwic3RvcE1pY1RyYWNrT25NdXRlIiwidmlkZW9Db2RlYyIsImJhY2t1cENvZGVjIiwiYXV0b0dhaW5Db250cm9sIiwiZWNob0NhbmNlbGxhdGlvbiIsIm5vaXNlU3VwcHJlc3Npb24iLCJ2b2ljZUlzb2xhdGlvbiIsInJvb21PcHRpb25EZWZhdWx0cyIsImR5bmFjYXN0Iiwic3RvcExvY2FsVHJhY2tPblVucHVibGlzaCIsInJlY29ubmVjdFBvbGljeSIsImRpc2Nvbm5lY3RPblBhZ2VMZWF2ZSIsIndlYkF1ZGlvTWl4Iiwicm9vbUNvbm5lY3RPcHRpb25EZWZhdWx0cyIsIm1heFJldHJpZXMiLCJwZWVyQ29ubmVjdGlvblRpbWVvdXQiLCJQQ1RyYW5zcG9ydFN0YXRlIiwiUENUcmFuc3BvcnRNYW5hZ2VyIiwibmVlZHNQdWJsaXNoZXIiLCJpc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCIsIm5lZWRzU3Vic2NyaWJlciIsImlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCIsInN1YnNjcmliZXJQcmltYXJ5IiwicHJldmlvdXNTdGF0ZSIsImNvbm5lY3Rpb25TdGF0ZXMiLCJyZXF1aXJlZFRyYW5zcG9ydHMiLCJzdCIsIkZBSUxFRCIsIkNMT1NFRCIsIk5FVyIsIm9uU3RhdGVDaGFuZ2UiLCJwdWJsaXNoZXIiLCJzdWJzY3JpYmVyIiwiUENNYW5hZ2VyIiwiU2lnbmFsVGFyZ2V0IiwiUFVCTElTSEVSIiwiU1VCU0NSSUJFUiIsIm9uUHVibGlzaGVyT2ZmZXIiLCJyZW1vdGVPZmZlckxvY2siLCJyZXF1aXJlUHVibGlzaGVyIiwicmVxdWlyZSIsInJlcXVpcmVTdWJzY3JpYmVyIiwiY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyIiwic2V0UHVibGlzaGVyQW5zd2VyIiwidHJpZ2dlckljZVJlc3RhcnQiLCJjcmVhdGVTdWJzY3JpYmVyQW5zd2VyRnJvbU9mZmVyIiwiUlRDU2RwVHlwZSIsInVwZGF0ZUNvbmZpZ3VyYXRpb24iLCJlbnN1cmVQQ1RyYW5zcG9ydENvbm5lY3Rpb24iLCJhYm9ydENvbnRyb2xsZXIiLCJ0cmFuc3BvcnQiLCJlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQiLCJuZWdvdGlhdGlvblRpbWVvdXQiLCJzaWduYWwiLCJhZGRQdWJsaXNoZXJUcmFuc2NlaXZlciIsImFkZFB1Ymxpc2hlclRyYWNrIiwiY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwiLCJ0cmFuc3BvcnRzIiwicGNUcmFuc3BvcnRfMSIsImFib3J0Q29udHJvbGxlcl8xIiwicGNUcmFuc3BvcnQiLCJjb25uZWN0VGltZW91dCIsIlJwY0Vycm9yIiwidHJ1bmNhdGVCeXRlcyIsIk1BWF9NRVNTQUdFX0JZVEVTIiwiTUFYX0RBVEFfQllURVMiLCJmcm9tUHJvdG8iLCJ0b1Byb3RvIiwiUnBjRXJyb3JfUHJvdG8iLCJidWlsdEluIiwiRXJyb3JDb2RlIiwiRXJyb3JNZXNzYWdlIiwiQVBQTElDQVRJT05fRVJST1IiLCJDT05ORUNUSU9OX1RJTUVPVVQiLCJSRVNQT05TRV9USU1FT1VUIiwiUkVDSVBJRU5UX0RJU0NPTk5FQ1RFRCIsIlJFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFIiwiU0VORF9GQUlMRUQiLCJVTlNVUFBPUlRFRF9NRVRIT0QiLCJSRUNJUElFTlRfTk9UX0ZPVU5EIiwiUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRSIsIlVOU1VQUE9SVEVEX1NFUlZFUiIsIlVOU1VQUE9SVEVEX1ZFUlNJT04iLCJNQVhfUEFZTE9BRF9CWVRFUyIsImVuY29kZXIiLCJtYXhCeXRlcyIsIm1vbml0b3JGcmVxdWVuY3kiLCJjb21wdXRlQml0cmF0ZSIsImN1cnJlbnRTdGF0cyIsInByZXZTdGF0cyIsImJ5dGVzTm93IiwiYnl0ZXNQcmV2IiwiYnl0ZXNSZWNlaXZlZCIsImJ5dGVzU2VudCIsImRlZmF1bHREaW1lbnNpb25zVGltZW91dCIsIkxvY2FsVHJhY2siLCJfc2VuZGVyIiwiX2NvbnN0cmFpbnRzIiwidXNlclByb3ZpZGVkVHJhY2siLCJtYW51YWxseVN0b3BwZWQiLCJfaXNVcHN0cmVhbVBhdXNlZCIsImhhbmRsZVRyYWNrTXV0ZUV2ZW50IiwiZGVib3VuY2VkVHJhY2tNdXRlSGFuZGxlciIsInBhdXNlVXBzdHJlYW0iLCJoYW5kbGVUcmFja1VubXV0ZUV2ZW50IiwicmVzdW1lVXBzdHJlYW0iLCJoYW5kbGVFbmRlZCIsInJlYWNxdWlyZVRyYWNrIiwiRW5kZWQiLCJwcm92aWRlZEJ5VXNlciIsIm11dGVMb2NrIiwicGF1c2VVcHN0cmVhbUxvY2siLCJwcm9jZXNzb3JMb2NrIiwicmVzdGFydExvY2siLCJzZXRNZWRpYVN0cmVhbVRyYWNrIiwiZ2V0Q29uc3RyYWludHMiLCJkaW1lbnNpb25zIiwiaXNVcHN0cmVhbVBhdXNlZCIsImlzVXNlclByb3ZpZGVkIiwicHJvY2Vzc2VkVHJhY2siLCJnZXRTb3VyY2VUcmFja1NldHRpbmdzIiwibmV3VHJhY2siLCJwcm9jZXNzb3JFbGVtZW50IiwicmVzdGFydCIsInJlcGxhY2VUcmFjayIsIndhaXRGb3JEaW1lbnNpb25zIiwic3RhcnRlZCIsImRpbXMiLCJzZXREZXZpY2VJZCIsInJlc3RhcnRUcmFjayIsImdldERldmljZUlkIiwibm9ybWFsaXplIiwibXV0ZSIsInNldFRyYWNrTXV0ZWQiLCJ1bm11dGUiLCJ1c2VyUHJvdmlkZWRPck9wdGlvbnMiLCJzdG9wUHJvY2Vzc29yIiwib3RoZXJDb25zdHJhaW50cyIsIl9fcmVzdCIsInN0cmVhbUNvbnN0cmFpbnRzIiwiUmVzdGFydGVkIiwiTXV0ZWQiLCJVbm11dGVkIiwibmVlZHNSZUFjcXVpc2l0aW9uIiwiX3N1cGVyIiwiZGVzdHJveSIsIlVwc3RyZWFtUGF1c2VkIiwiVXBzdHJlYW1SZXN1bWVkIiwiZ2V0UlRDU3RhdHNSZXBvcnQiLCJzdGF0c1JlcG9ydCIsInNldFByb2Nlc3NvciIsInByb2Nlc3Nvcl8xIiwic2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkiLCJwcm9jZXNzb3JPcHRpb25zIiwiVHJhY2tQcm9jZXNzb3JVcGRhdGUiLCJnZXRQcm9jZXNzb3IiLCJfdGhpczQiLCJrZWVwRWxlbWVudCIsInJlbW92ZSIsIkxvY2FsQXVkaW9UcmFjayIsImVuaGFuY2VkTm9pc2VDYW5jZWxsYXRpb24iLCJpc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkIiwic3RvcE9uTXV0ZSIsIm1vbml0b3JTZW5kZXIiLCJnZXRTZW5kZXJTdGF0cyIsImhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJFbmFibGUiLCJBdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSIsIkF1ZGlvVHJhY2tGZWF0dXJlIiwiVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OIiwiaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUiLCJjaGVja0ZvclNpbGVuY2UiLCJkZXZpY2VIYXNDaGFuZ2VkIiwic3RhcnRNb25pdG9yIiwic2V0QXVkaW9Db250ZXh0IiwiYXVkaW9TdGF0cyIsInBhY2tldHNTZW50IiwicGFja2V0c0xvc3QiLCJyb3VuZFRyaXBUaW1lIiwiaml0dGVyIiwidHJhY2tJc1NpbGVudCIsIkF1ZGlvU2lsZW5jZURldGVjdGVkIiwibWVkaWFUcmFja1RvTG9jYWxUcmFjayIsIkxvY2FsVmlkZW9UcmFjayIsInByZXNldHMxNjkiLCJwcmVzZXRzNDMiLCJwcmVzZXRzU2NyZWVuU2hhcmUiLCJkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSIsImRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDMiLCJjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyIsImZyb21QcmVzZXQiLCJmcHMiLCJ2aWRlb1JpZHMiLCJjb21wdXRlVmlkZW9FbmNvZGluZ3MiLCJpc1NjcmVlblNoYXJlIiwidmlkZW9FbmNvZGluZyIsInVzZVNpbXVsY2FzdCIsInNjYWxhYmlsaXR5TW9kZSIsImRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmciLCJzb3VyY2VGcmFtZXJhdGUiLCJzbSIsIlNjYWxhYmlsaXR5TW9kZSIsInNwYXRpYWwiLCJiaXRyYXRlc1JhdGlvIiwic3VmZml4IiwibmV0d29ya1ByaW9yaXR5IiwicHJlc2V0cyIsInNvcnRQcmVzZXRzIiwic2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMiLCJkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzIiwidmlkZW9TaW11bGNhc3RMYXllcnMiLCJtaWRQcmVzZXQiLCJsb3dQcmVzZXQiLCJlbmNvZGluZ3NGcm9tUHJlc2V0cyIsImNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyIsInNlcnZlclJlcXVlc3RlZCIsInByZXNldHNGb3JSZXNvbHV0aW9uIiwicHJlc2V0IiwiYXNwZWN0IiwiYWJzIiwiY2FuU2V0UHJpb3JpdHkiLCJ0b3BGcmFtZXJhdGUiLCJub3RpZnlPbmNlIiwiYUVuYyIsImJFbmMiLCJyZXN1bHRzIiwidGVtcG9yYWwiLCJnZXREZWZhdWx0RGVncmFkYXRpb25QcmVmZXJlbmNlIiwicmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMiLCJkZWdyYWRhdGlvblByZWZlcmVuY2UiLCJzZXREZWdyYWRhdGlvblByZWZlcmVuY2UiLCJzaW11bGNhc3RDb2RlY3MiLCJzdGF0c01hcCIsInRvdGFsQml0cmF0ZSIsInNlbmRlckxvY2siLCJpc1NpbXVsY2FzdCIsInNpZ25hbENsaWVudCIsIl9fYXN5bmNWYWx1ZXMiLCJfZyIsIm5leHQiLCJkb25lIiwic2MiLCJpdGVtcyIsInZzIiwiZnJhbWVIZWlnaHQiLCJmcmFtZVdpZHRoIiwiZnJhbWVzUGVyU2Vjb25kIiwiZnJhbWVzU2VudCIsImZpckNvdW50IiwicGxpQ291bnQiLCJuYWNrQ291bnQiLCJxdWFsaXR5TGltaXRhdGlvblJlYXNvbiIsInF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zIiwicXVhbGl0eUxpbWl0YXRpb25SZXNvbHV0aW9uQ2hhbmdlcyIsInJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCIsInRhcmdldEJpdHJhdGUiLCJzZXRQdWJsaXNoaW5nUXVhbGl0eSIsIm1heFF1YWxpdHkiLCJxdWFsaXRpZXMiLCJxIiwiTE9XIiwiSElHSCIsIlN1YnNjcmliZWRRdWFsaXR5IiwicXVhbGl0eSIsInNldFB1Ymxpc2hpbmdMYXllcnMiLCJfaCIsInByZWZlcmVuY2UiLCJhZGRTaW11bGNhc3RUcmFjayIsInNpbXVsY2FzdENvZGVjSW5mbyIsInNldFNpbXVsY2FzdFRyYWNrU2VuZGVyIiwic3Vic2NyaWJlZENvZGVjcyIsInNldFB1Ymxpc2hpbmdDb2RlY3MiLCJjdXJyZW50Q29kZWMiLCJuZXdDb2RlY3MiLCJjb2RlY3NfMSIsImNvZGVjc18xXzEiLCJzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyIiwic2VuZGVyRW5jb2RpbmdzIiwiaGFzQ2hhbmdlZCIsImNsb3NhYmxlU3BhdGlhbCIsIm1vZGUiLCJQcm90b1ZpZGVvUXVhbGl0eSIsIk9GRiIsImFjdGl2ZSIsIm9yaWdpbmFsTW9kZSIsInZpZGVvUXVhbGl0eUZvclJpZCIsInN1YnNjcmliZWRRdWFsaXR5IiwibWF4RnJhbWVSYXRlIiwiTUVESVVNIiwidmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzIiwic3ZjIiwiVmlkZW9MYXllciIsImJpdHJhdGUiLCJlbmNvZGluZ1NNIiwicmVzUmF0aW8iLCJzY2FsZSIsImxvc3N5RGF0YUNoYW5uZWwiLCJyZWxpYWJsZURhdGFDaGFubmVsIiwibWluUmVjb25uZWN0V2FpdCIsImxlYXZlUmVjb25uZWN0IiwiUENTdGF0ZSIsIlJUQ0VuZ2luZSIsImlzQ2xvc2VkIiwiX2lzQ2xvc2VkIiwicGVuZGluZ1JlY29ubmVjdCIsInJlY29ubmVjdFRpbWVvdXQiLCJmdWxsUmVjb25uZWN0T25OZXh0IiwicGNTdGF0ZSIsIk5ldyIsInBlbmRpbmdUcmFja1Jlc29sdmVycyIsInJlY29ubmVjdEF0dGVtcHRzIiwicmVjb25uZWN0U3RhcnQiLCJhdHRlbXB0aW5nUmVjb25uZWN0Iiwiam9pbkF0dGVtcHRzIiwibWF4Sm9pbkF0dGVtcHRzIiwic2hvdWxkRmFpbE5leHQiLCJoYW5kbGVEYXRhQ2hhbm5lbCIsInJlbGlhYmxlRENTdWIiLCJsb3NzeURDU3ViIiwiaGFuZGxlRGF0YU1lc3NhZ2UiLCJkYXRhUHJvY2Vzc0xvY2siLCJCbG9iIiwiYXJyYXlCdWZmZXIiLCJkcCIsIkRhdGFQYWNrZXQiLCJBY3RpdmVTcGVha2Vyc1VwZGF0ZSIsImFwcGx5VXNlckRhdGFDb21wYXQiLCJEYXRhUGFja2V0UmVjZWl2ZWQiLCJoYW5kbGVEYXRhRXJyb3IiLCJjdXJyZW50VGFyZ2V0IiwiY2hhbm5lbEtpbmQiLCJtYXhSZXRyYW5zbWl0cyIsIkVycm9yRXZlbnQiLCJoYW5kbGVCdWZmZXJlZEFtb3VudExvdyIsIkRhdGFQYWNrZXRfS2luZCIsIkxPU1NZIiwiUkVMSUFCTEUiLCJ1cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMiLCJoYW5kbGVEaXNjb25uZWN0IiwiZGlzY29ubmVjdFJlYXNvbiIsImRpc2Nvbm5lY3QiLCJEaXNjb25uZWN0ZWQiLCJkZWxheSIsImdldE5leHRSZXRyeURlbGF5IiwiZWxhcHNlZE1zIiwiY2xlYXJSZWNvbm5lY3RUaW1lb3V0IiwicmVnaW9uVXJsUHJvdmlkZXIiLCJ1cGRhdGVUb2tlbiIsImF0dGVtcHRSZWNvbm5lY3QiLCJ3YWl0Rm9yUmVzdGFydGVkIiwib25SZXN0YXJ0ZWQiLCJvbkRpc2Nvbm5lY3RlZCIsImlzQnVmZmVyU3RhdHVzTG93IiwiZGNCdWZmZXJTdGF0dXMiLCJEQ0J1ZmZlclN0YXR1c0NoYW5nZWQiLCJkYXRhQ2hhbm5lbEZvcktpbmQiLCJidWZmZXJlZEFtb3VudCIsImJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkIiwiaGFuZGxlQnJvd3Nlck9uTGluZSIsImNsaWVudCIsIlJlY29ubmVjdFJlYXNvbiIsIlJSX1NJR05BTF9ESVNDT05ORUNURUQiLCJFbmdpbmUiLCJleHBTaWduYWxMYXRlbmN5IiwicmVnaXN0ZXJPbkxpbmVMaXN0ZW5lciIsInVwZGF0ZXMiLCJQYXJ0aWNpcGFudFVwZGF0ZSIsInVwZGF0ZSIsIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlIiwiUm9vbVVwZGF0ZSIsIlN1YnNjcmlwdGlvbkVycm9yIiwiU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsIlNwZWFrZXJzQ2hhbmdlZCIsIlN0cmVhbVN0YXRlQ2hhbmdlZCIsInJlc3BvbnNlIiwiU2lnbmFsUmVxdWVzdFJlc3BvbnNlIiwibGF0ZXN0Sm9pblJlc3BvbnNlIiwicm9vbUlEIiwicElEIiwic2lnbmFsT3B0cyIsInNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzIiwiam9pblJlc3BvbnNlIiwicGNNYW5hZ2VyIiwiY29uZmlndXJlIiwiZmFzdFB1Ymxpc2giLCJjbGllbnRDb25maWd1cmF0aW9uIiwiQ2xvc2luZyIsImRlcmVnaXN0ZXJPbkxpbmVMaXN0ZW5lciIsImNsZWFyUGVuZGluZ1JlY29ubmVjdCIsImNsZWFudXBQZWVyQ29ubmVjdGlvbnMiLCJjbGVhbnVwQ2xpZW50IiwiZGNDbGVhbnVwIiwib25idWZmZXJlZGFtb3VudGxvdyIsIm9uY2xvc2luZyIsImxvc3N5REMiLCJyZWxpYWJsZURDIiwicHVibGljYXRpb25UaW1lb3V0IiwidXBkYXRlTXV0ZVN0YXR1cyIsImRhdGFTdWJzY3JpYmVyUmVhZHlTdGF0ZSIsImdldENvbm5lY3RlZFNlcnZlckFkZHJlc3MiLCJzZXRSZWdpb25VcmxQcm92aWRlciIsInByb3ZpZGVyIiwicGFydGljaXBhbnRTaWQiLCJtYWtlUlRDQ29uZmlndXJhdGlvbiIsIlRyYW5zcG9ydHNDcmVhdGVkIiwicHVibGlzaGVyU3RhdGUiLCJzdWJzY3JpYmVyU3RhdGUiLCJwdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZSIsInNob3VsZEVtaXQiLCJSUl9TVUJTQ1JJQkVSX0ZBSUxFRCIsIlJSX1BVQkxJU0hFUl9GQUlMRUQiLCJpc1NpZ25hbFNldmVyZWQiLCJpc1BDU2V2ZXJlZCIsIk9mZmxpbmUiLCJNZWRpYVRyYWNrQWRkZWQiLCJzdXBwb3J0T3B0aW9uYWxEYXRhY2hhbm5lbCIsInNlcnZlckluZm8iLCJjcmVhdGVEYXRhQ2hhbm5lbHMiLCJMb2NhbFRyYWNrVW5wdWJsaXNoZWQiLCJMb2NhbFRyYWNrU3Vic2NyaWJlZCIsIlJlbW90ZU11dGUiLCJTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsImxlYXZlIiwicmVnaW9ucyIsInNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyIsIlJFQ09OTkVDVCIsIlJFU1VNRSIsInNlcnZlclJlc3BvbnNlIiwiZTJlZUVuYWJsZWQiLCJlbmNvZGVkSW5zZXJ0YWJsZVN0cmVhbXMiLCJydGNJY2VTZXJ2ZXJzIiwiaWNlU2VydmVyIiwicnRjSWNlU2VydmVyIiwiY3JlZGVudGlhbCIsImZvcmNlUmVsYXkiLCJDbGllbnRDb25maWdTZXR0aW5nIiwiRU5BQkxFRCIsImljZVRyYW5zcG9ydFBvbGljeSIsImNvbnRpbnVhbEdhdGhlcmluZ1BvbGljeSIsIm9yZGVyZWQiLCJjcmVhdGVTZW5kZXIiLCJjcmVhdGVUcmFuc2NlaXZlclJUQ1J0cFNlbmRlciIsImNyZWF0ZVJUQ1J0cFNlbmRlciIsImNyZWF0ZVNpbXVsY2FzdFNlbmRlciIsInNpbXVsY2FzdFRyYWNrIiwiY3JlYXRlU2ltdWxjYXN0VHJhbnNjZWl2ZXJTZW5kZXIiLCJyZXN1bWVDb25uZWN0aW9uIiwiRElTQUJMRUQiLCJyZXN0YXJ0Q29ubmVjdGlvbiIsInJlY292ZXJhYmxlIiwiU2lnbmFsUmVjb25uZWN0RXJyb3IiLCJSUl9VTktOT1dOIiwicmVnaW9uVXJsIiwiUmVzdGFydGluZyIsIlNpZ25hbFJlc3RhcnRlZCIsIndhaXRGb3JQQ1JlY29ubmVjdGVkIiwicmVzZXRBdHRlbXB0cyIsIm5leHRSZWdpb25VcmwiLCJnZXROZXh0QmVzdFJlZ2lvblVybCIsIlJlc3VtaW5nIiwiU2lnbmFsUmVzdW1lZCIsIlJlc3VtZWQiLCJ3YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbiIsIlJlY29ubmVjdGluZyIsInB1Ymxpc2hScGNSZXNwb25zZSIsImRlc3RpbmF0aW9uSWRlbnRpdHkiLCJwYWNrZXQiLCJkZXN0aW5hdGlvbklkZW50aXRpZXMiLCJScGNSZXNwb25zZSIsInNlbmREYXRhUGFja2V0IiwicHVibGlzaFJwY0FjayIsIlJwY0FjayIsImVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZCIsIndhaXRGb3JCdWZmZXJTdGF0dXNMb3ciLCJvbkNsb3NpbmciLCJlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkIiwidHJhbnNwb3J0TmFtZSIsIm5lZWROZWdvdGlhdGlvbiIsInRhcmdldENoYW5uZWwiLCJ2ZXJpZnlUcmFuc3BvcnQiLCJBYm9ydENvbnRyb2xsZXIiLCJoYW5kbGVDbG9zZWQiLCJhYm9ydCIsInJ0cFR5cGVzIiwicmVtb3RlVHJhY2tzIiwibG9jYWxUcmFja3MiLCJwcmV2aW91c0Fuc3dlciIsInByZXZpb3VzT2ZmZXIiLCJ0cmFja1NpZHMiLCJ0cmFja1NpZHNEaXNhYmxlZCIsImlzRGVzaXJlZCIsIlN5bmNTdGF0ZSIsInN1YnNjcmlwdGlvbiIsIlVwZGF0ZVN1YnNjcmlwdGlvbiIsInN1YnNjcmliZSIsInBhcnRpY2lwYW50VHJhY2tzIiwicHVibGlzaFRyYWNrcyIsImRhdGFDaGFubmVscyIsImRhdGFDaGFubmVsc0luZm8iLCJmYWlsTmV4dCIsImdldEluZm8iLCJEYXRhQ2hhbm5lbEluZm8iLCJuZXdPYmoiLCJvbGRPYmoiLCJSZWdpb25VcmxQcm92aWRlciIsImxhc3RVcGRhdGVBdCIsInNldHRpbmdzQ2FjaGVUaW1lIiwiYXR0ZW1wdGVkUmVnaW9ucyIsImdldFNlcnZlclVybCIsInJlZ2lvblNldHRpbmdzIiwiZmV0Y2hSZWdpb25TZXR0aW5ncyIsInJlZ2lvbnNMZWZ0IiwicmVnaW9uIiwiYXR0ZW1wdGVkIiwibmV4dFJlZ2lvbiIsInJlZ2lvblNldHRpbmdzUmVzcG9uc2UiLCJnZXRDbG91ZENvbmZpZ1VybCIsImhlYWRlcnMiLCJhdXRob3JpemF0aW9uIiwic3RhdHVzVGV4dCIsImhvc3QiLCJCYXNlU3RyZWFtUmVhZGVyIiwiX2luZm8iLCJ0b3RhbEJ5dGVTaXplIiwiQnl0ZVN0cmVhbVJlYWRlciIsImhhbmRsZUNodW5rUmVjZWl2ZWQiLCJjdXJyZW50UHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwiYXN5bmNJdGVyYXRvciIsImdldFJlYWRlciIsInJldHVybiIsInJlbGVhc2VMb2NrIiwicmVhZEFsbCIsImFkZCIsIlRleHRTdHJlYW1SZWFkZXIiLCJ0b3RhbENodW5rQ291bnQiLCJyZWNlaXZlZENodW5rcyIsImNodW5rSW5kZXgiLCJwcmV2aW91c0NodW5rQXRJbmRleCIsImRlY29kZXIiLCJmaW5hbFN0cmluZyIsIkJhc2VTdHJlYW1Xcml0ZXIiLCJkZWZhdWx0V3JpdGVyIiwiZ2V0V3JpdGVyIiwiVGV4dFN0cmVhbVdyaXRlciIsIkJ5dGVTdHJlYW1Xcml0ZXIiLCJSZW1vdGVUcmFjayIsInNldE11dGVkIiwic2V0TWVkaWFTdHJlYW0iLCJvblJlbW92ZVRyYWNrIiwicGxheW91dERlbGF5SGludCIsInNldFBsYXlvdXREZWxheSIsImRlbGF5SW5TZWNvbmRzIiwiZ2V0UGxheW91dERlbGF5IiwibW9uaXRvclJlY2VpdmVyIiwicmVnaXN0ZXJUaW1lU3luY1VwZGF0ZSIsImxvb3AiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzb3VyY2VzIiwiZ2V0U3luY2hyb25pemF0aW9uU291cmNlcyIsInJ0cFRpbWVzdGFtcCIsIlRpbWVTeW5jVXBkYXRlIiwiUmVtb3RlQXVkaW9UcmFjayIsImF1ZGlvT3V0cHV0IiwiZ2V0UmVjZWl2ZXJTdGF0cyIsIndlYkF1ZGlvUGx1Z2luTm9kZXMiLCJzaW5rSWQiLCJzZXRWb2x1bWUiLCJnYWluTm9kZSIsInNldFRhcmdldEF0VGltZSIsIl9zZXRWb2x1bWUiLCJlbGVtZW50Vm9sdW1lIiwiZ2V0Vm9sdW1lIiwiaGlnaGVzdFZvbHVtZSIsInNldFNpbmtJZCIsIm5lZWRzTmV3V2ViQXVkaW9Db25uZWN0aW9uIiwiY29ubmVjdFdlYkF1ZGlvIiwiZGlzY29ubmVjdFdlYkF1ZGlvIiwic2V0V2ViQXVkaW9QbHVnaW5zIiwibm9kZXMiLCJzb3VyY2VOb2RlIiwibGFzdE5vZGUiLCJub2RlIiwiZGVzdGluYXRpb24iLCJyZWNlaXZlclN0YXRzIiwiY29uY2VhbGVkU2FtcGxlcyIsImNvbmNlYWxtZW50RXZlbnRzIiwic2lsZW50Q29uY2VhbGVkU2FtcGxlcyIsInNpbGVudENvbmNlYWxtZW50RXZlbnRzIiwidG90YWxBdWRpb0VuZXJneSIsInRvdGFsU2FtcGxlc0R1cmF0aW9uIiwiUkVBQ1RJT05fREVMQVkiLCJSZW1vdGVWaWRlb1RyYWNrIiwiYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyIsImVsZW1lbnRJbmZvcyIsImRlYm91bmNlZEhhbmRsZVJlc2l6ZSIsInVwZGF0ZURpbWVuc2lvbnMiLCJpc0FkYXB0aXZlU3RyZWFtIiwiZWxlbWVudEluZm8iLCJIVE1MRWxlbWVudEluZm8iLCJvYnNlcnZlRWxlbWVudEluZm8iLCJ1cGRhdGVWaXNpYmlsaXR5Iiwib2JzZXJ2ZSIsInN0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyIsInN0b3BFbGVtZW50SW5mb3MiLCJzdG9wT2JzZXJ2aW5nIiwiZGV0YWNoZWRFbGVtZW50cyIsInN0b3BPYnNlcnZpbmdFbGVtZW50IiwiZ2V0RGVjb2RlckltcGxlbWVudGF0aW9uIiwiZGVjb2RlckltcGxlbWVudGF0aW9uIiwiY29kZWNJRCIsImNvZGVjSWQiLCJmcmFtZXNEZWNvZGVkIiwiZnJhbWVzRHJvcHBlZCIsImZyYW1lc1JlY2VpdmVkIiwicGFja2V0c1JlY2VpdmVkIiwibGFzdFZpc2liaWxpdHlDaGFuZ2UiLCJ2aXNpYmlsaXR5Q2hhbmdlZEF0IiwiYmFja2dyb3VuZFBhdXNlIiwicGF1c2VWaWRlb0luQmFja2dyb3VuZCIsImlzUGlQTW9kZSIsInBpY3R1cmVJblBpY3R1cmUiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwibGFzdFZpc2libGUiLCJWaXNpYmlsaXR5Q2hhbmdlZCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwicGl4ZWxEZW5zaXR5IiwiZ2V0UGl4ZWxEZW5zaXR5IiwiY3VycmVudEVsZW1lbnRXaWR0aCIsImN1cnJlbnRFbGVtZW50SGVpZ2h0IiwibGFzdERpbWVuc2lvbnMiLCJWaWRlb0RpbWVuc2lvbnNDaGFuZ2VkIiwiaXNQaVAiLCJpc0ludGVyc2VjdGluZyIsIm9uVmlzaWJpbGl0eUNoYW5nZWQiLCJpc0VsZW1lbnRJblBpUCIsIm9uRW50ZXJQaVAiLCJkb2N1bWVudFBpY3R1cmVJblBpY3R1cmUiLCJvbkxlYXZlUGlQIiwiaXNFbGVtZW50SW5WaWV3cG9ydCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwidW5vYnNlcnZlIiwicGljdHVyZUluUGljdHVyZUVsZW1lbnQiLCJ3aW4iLCJ2aWV3cG9ydFdpbmRvdyIsInRvcCIsIm9mZnNldFRvcCIsImxlZnQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJoaWRkZW4iLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9mZnNldFBhcmVudCIsInBhZ2VZT2Zmc2V0IiwiaW5uZXJIZWlnaHQiLCJwYWdlWE9mZnNldCIsImlubmVyV2lkdGgiLCJUcmFja1B1YmxpY2F0aW9uIiwibWV0YWRhdGFNdXRlZCIsImhhbmRsZU11dGVkIiwiaGFuZGxlVW5tdXRlZCIsIlB1YmxpY2F0aW9uIiwic2V0VHJhY2siLCJpc1N1YnNjcmliZWQiLCJhdWRpb1RyYWNrIiwidmlkZW9UcmFjayIsInVwZGF0ZUluZm8iLCJzaW11bGNhc3RlZCIsIlN1YnNjcmlwdGlvblN0YXR1cyIsIlBlcm1pc3Npb25TdGF0dXMiLCJMb2NhbFRyYWNrUHVibGljYXRpb24iLCJ0aSIsImhhbmRsZVRyYWNrRW5kZWQiLCJnZXRUcmFja0ZlYXR1cmVzIiwiVEZfQVVUT19HQUlOX0NPTlRST0wiLCJURl9FQ0hPX0NBTkNFTExBVElPTiIsIlRGX05PSVNFX1NVUFBSRVNTSU9OIiwiY2hhbm5lbENvdW50IiwiVEZfU1RFUkVPIiwiVEZfTk9fRFRYIiwiY3JlYXRlTG9jYWxUcmFja3MiLCJpbnRlcm5hbE9wdGlvbnMiLCJhdHRlbXB0RXhhY3RNYXRjaCIsInJldHJ5QXVkaW9PcHRpb25zIiwicmV0cnlWaWRlb09wdGlvbnMiLCJtZWRpYVByb21pc2UiLCJpc0F1ZGlvIiwidHJhY2tPcHRpb25zIiwidHJhY2tDb25zdHJhaW50cyIsImNvbk9yQm9vbCIsIm5ld0RldmljZUlkIiwiY3JlYXRlTG9jYWxWaWRlb1RyYWNrIiwiY3JlYXRlTG9jYWxBdWRpb1RyYWNrIiwiY3JlYXRlTG9jYWxTY3JlZW5UcmFja3MiLCJzY3JlZW5WaWRlbyIsInNjcmVlbkF1ZGlvIiwiQ29ubmVjdGlvblF1YWxpdHkiLCJxdWFsaXR5RnJvbVByb3RvIiwiUHJvdG9RdWFsaXR5IiwiRVhDRUxMRU5UIiwiRXhjZWxsZW50IiwiR09PRCIsIkdvb2QiLCJQT09SIiwiUG9vciIsIkxPU1QiLCJMb3N0IiwiUGFydGljaXBhbnQiLCJpc0FnZW50IiwicGVybWlzc2lvbnMiLCJhZ2VudCIsIlBhcnRpY2lwYW50S2luZCIsIkFHRU5UIiwiX2tpbmQiLCJmcmVlemUiLCJfYXR0cmlidXRlcyIsIlNUQU5EQVJEIiwiYXVkaW9MZXZlbCIsImlzU3BlYWtpbmciLCJfY29ubmVjdGlvblF1YWxpdHkiLCJhdWRpb1RyYWNrUHVibGljYXRpb25zIiwidmlkZW9UcmFja1B1YmxpY2F0aW9ucyIsImdldFRyYWNrUHVibGljYXRpb25zIiwiZ2V0VHJhY2tQdWJsaWNhdGlvbiIsImdldFRyYWNrUHVibGljYXRpb25CeU5hbWUiLCJjb25uZWN0aW9uUXVhbGl0eSIsImlzQ2FtZXJhRW5hYmxlZCIsImlzTWljcm9waG9uZUVuYWJsZWQiLCJpc1NjcmVlblNoYXJlRW5hYmxlZCIsImpvaW5lZEF0IiwicGFydGljaXBhbnRJbmZvIiwiX3NldE5hbWUiLCJfc2V0TWV0YWRhdGEiLCJfc2V0QXR0cmlidXRlcyIsInBlcm1pc3Npb24iLCJzZXRQZXJtaXNzaW9ucyIsIm1kIiwiY2hhbmdlZCIsInByZXZNZXRhZGF0YSIsIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkIiwiUGFydGljaXBhbnROYW1lQ2hhbmdlZCIsIkF0dHJpYnV0ZXNDaGFuZ2VkIiwicHJldlBlcm1pc3Npb25zIiwiY2FuUHVibGlzaCIsImNhblN1YnNjcmliZSIsImNhblB1Ymxpc2hEYXRhIiwicmVjb3JkZXIiLCJjYW5QdWJsaXNoU291cmNlcyIsImNhblN1YnNjcmliZU1ldHJpY3MiLCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCIsInNldElzU3BlYWtpbmciLCJzcGVha2luZyIsImxhc3RTcG9rZUF0IiwiSXNTcGVha2luZ0NoYW5nZWQiLCJzZXRDb25uZWN0aW9uUXVhbGl0eSIsInByZXZRdWFsaXR5IiwiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwiYWRkVHJhY2tQdWJsaWNhdGlvbiIsIlRyYWNrTXV0ZWQiLCJUcmFja1VubXV0ZWQiLCJ0cmFja1Blcm1pc3Npb25Ub1Byb3RvIiwicGVybXMiLCJUcmFja1Blcm1pc3Npb24iLCJhbGxUcmFja3MiLCJhbGxvd0FsbCIsImFsbG93ZWRUcmFja1NpZHMiLCJTVFJFQU1fQ0hVTktfU0laRSIsIkxvY2FsUGFydGljaXBhbnQiLCJyb29tUnBjSGFuZGxlcnMiLCJwZW5kaW5nUHVibGlzaGluZyIsInBlbmRpbmdQdWJsaXNoUHJvbWlzZXMiLCJwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMiLCJhbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUiLCJlbmNyeXB0aW9uVHlwZSIsImVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MiLCJwZW5kaW5nQWNrcyIsInBlbmRpbmdSZXNwb25zZXMiLCJoYW5kbGVSZWNvbm5lY3RpbmciLCJyZWNvbm5lY3RGdXR1cmUiLCJoYW5kbGVSZWNvbm5lY3RlZCIsInVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJoYW5kbGVEaXNjb25uZWN0ZWQiLCJoYW5kbGVTaWduYWxSZXF1ZXN0UmVzcG9uc2UiLCJ0YXJnZXRSZXF1ZXN0IiwicGVuZGluZ1NpZ25hbFJlcXVlc3RzIiwiT0siLCJoYW5kbGVEYXRhUGFja2V0IiwicnBjUmVzcG9uc2UiLCJoYW5kbGVJbmNvbWluZ1JwY1Jlc3BvbnNlIiwicnBjQWNrIiwiaGFuZGxlSW5jb21pbmdScGNBY2siLCJhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIiwib25UcmFja1VubXV0ZWQiLCJvblRyYWNrTXV0ZWQiLCJvblRyYWNrVXBzdHJlYW1QYXVzZWQiLCJvblRyYWNrVXBzdHJlYW1SZXN1bWVkIiwib25UcmFja0ZlYXR1cmVVcGRhdGUiLCJoYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSIsInJvb21PcHRpb25zIiwibmV3Q29kZWNzXzEiLCJuZXdDb2RlY3NfMV8xIiwicHVibGlzaEFkZGl0aW9uYWxDb2RlY0ZvclRyYWNrIiwic3Vic2NyaWJlZFF1YWxpdGllcyIsImhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsInVucHVibGlzaGVkIiwidW5wdWJsaXNoVHJhY2siLCJjdXJyZW50UGVybWlzc2lvbnMiLCJxdWVyeSIsIm9uY2hhbmdlIiwiYWN0aXZlRGV2aWNlTWFwIiwicnBjSGFuZGxlcnMiLCJsYXN0Q2FtZXJhRXJyb3IiLCJjYW1lcmFFcnJvciIsImxhc3RNaWNyb3Bob25lRXJyb3IiLCJtaWNyb3Bob25lRXJyb3IiLCJzZXRNZXRhZGF0YSIsInJlcXVlc3RNZXRhZGF0YVVwZGF0ZSIsInNldE5hbWUiLCJzZXRBdHRyaWJ1dGVzIiwicGVyZm9ybWFuY2UiLCJfcmVmMiIsInNldENhbWVyYUVuYWJsZWQiLCJwdWJsaXNoT3B0aW9ucyIsInNldFRyYWNrRW5hYmxlZCIsInNldE1pY3JvcGhvbmVFbmFibGVkIiwic2V0U2NyZWVuU2hhcmVFbmFibGVkIiwic2V0RTJFRUVuYWJsZWQiLCJHQ00iLCJyZXB1Ymxpc2hBbGxUcmFja3MiLCJyZXB1Ymxpc2hQcm9taXNlIiwicGVuZGluZ1RyYWNrIiwid2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlIiwiY3JlYXRlVHJhY2tzIiwiY3JlYXRlU2NyZWVuVHJhY2tzIiwiTWVkaWFEZXZpY2VzRXJyb3IiLCJwdWJsaXNoUHJvbWlzZXMiLCJsb2NhbFRyYWNrIiwicHVibGlzaFRyYWNrIiwicHVibGlzaGVkVHJhY2tzIiwic2NyZWVuQXVkaW9UcmFjayIsImVuYWJsZUNhbWVyYUFuZE1pY3JvcGhvbmUiLCJtZXJnZWRPcHRpb25zV2l0aFByb2Nlc3NvcnMiLCJhdWRpb0NhcHR1cmVEZWZhdWx0cyIsInZpZGVvQ2FwdHVyZURlZmF1bHRzIiwiQXVkaW9TdHJlYW1BY3F1aXJlZCIsImNvbnRlbnRIaW50IiwicHVibGlzaE9yUmVwdWJsaXNoVHJhY2siLCJvcHRpb25zXzEiLCJpc1JlcHVibGlzaCIsImRlZmF1bHRDb25zdHJhaW50cyIsImRldmljZUtpbmQiLCJleGlzdGluZ1B1YmxpY2F0aW9uIiwiaXNTdGVyZW9JbnB1dCIsImlzU3RlcmVvIiwiZTJlZSIsInB1Ymxpc2hQcm9taXNlIiwib25TaWduYWxDb25uZWN0ZWQiLCJwdWJsaXNoIiwiaGFzUGVybWlzc2lvbnNUb1B1Ymxpc2giLCJleGlzdGluZ1RyYWNrT2ZTb3VyY2UiLCJwdWJsaXNoZWRUcmFjayIsIm1pbWUiLCJBZGRUcmFja1JlcXVlc3QiLCJkaXNhYmxlRHR4Iiwic3RlcmVvIiwiZGlzYWJsZVJlZCIsImJhY2t1cENvZGVjUG9saWN5IiwiZGVmYXVsdFJlcyIsIlNpbXVsY2FzdENvZGVjIiwiX2siLCJfaiIsInRyYWNrVHJhbnNjZWl2ZXIiLCJyZXRzIiwicHJpbWFyeUNvZGVjTWltZSIsInVwZGF0ZWRDb2RlYyIsInN0b3BPblVucHVibGlzaCIsImdldFB1YmxpY2F0aW9uRm9yVHJhY2siLCJwdWJMb2dDb250ZXh0IiwibmVnb3RpYXRpb25OZWVkZWQiLCJ0cmFja1NlbmRlciIsImNsZWFyIiwidW5wdWJsaXNoVHJhY2tzIiwicmVzdGFydFRyYWNrcyIsImxvY2FsUHVicyIsInB1Ymxpc2hEYXRhIiwiZGF0YV8xIiwicmVsaWFibGUiLCJ0b3BpYyIsIlVzZXJQYWNrZXQiLCJwdWJsaXNoRHRtZiIsImRpZ2l0IiwiU2lwRFRNRiIsInNlbmRDaGF0TWVzc2FnZSIsInJhbmRvbVVVSUQiLCJhdHRhY2hlZEZpbGVzIiwiYXR0YWNobWVudHMiLCJDaGF0TWVzc2FnZU1vZGVsIiwiQ2hhdE1lc3NhZ2UiLCJlZGl0Q2hhdE1lc3NhZ2UiLCJlZGl0VGV4dCIsIm9yaWdpbmFsTWVzc2FnZSIsInNlbmRUZXh0IiwidGV4dEluQnl0ZXMiLCJ0b3RhbFRleHRMZW5ndGgiLCJmaWxlSWRzIiwicHJvZ3Jlc3NlcyIsImhhbmRsZVByb2dyZXNzIiwicHJvZ3Jlc3MiLCJ0b3RhbFByb2dyZXNzIiwic3RyZWFtVGV4dCIsInRvdGFsU2l6ZSIsImF0dGFjaGVkU3RyZWFtSWRzIiwiZmlsZSIsIl9zZW5kRmlsZSIsImhlYWRlciIsIkRhdGFTdHJlYW1fSGVhZGVyIiwidG90YWxMZW5ndGgiLCJjb250ZW50SGVhZGVyIiwiRGF0YVN0cmVhbV9UZXh0SGVhZGVyIiwicmVwbHlUb1N0cmVhbUlkIiwib3BlcmF0aW9uVHlwZSIsIkRhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSIsIlVQREFURSIsIkNSRUFURSIsImNodW5rSWQiLCJsb2NhbFAiLCJXcml0YWJsZVN0cmVhbSIsInRleHRCeXRlQ2h1bmsiLCJEYXRhU3RyZWFtX0NodW5rIiwiY2h1bmtQYWNrZXQiLCJEYXRhU3RyZWFtX1RyYWlsZXIiLCJ0cmFpbGVyUGFja2V0Iiwib25FbmdpbmVDbG9zZSIsInNlbmRGaWxlIiwic3RyZWFtQnl0ZXMiLCJEYXRhU3RyZWFtX0J5dGVIZWFkZXIiLCJ3cml0ZU11dGV4Iiwic3ViQ2h1bmsiLCJieXRlV3JpdGVyIiwicGVyZm9ybVJwYyIsInJlc3BvbnNlVGltZW91dCIsIl9yZWYzIiwibWF4Um91bmRUcmlwTGF0ZW5jeSIsIl90aGlzNSIsInB1Ymxpc2hScGNSZXF1ZXN0IiwiYWNrVGltZW91dElkIiwicmVzcG9uc2VUaW1lb3V0SWQiLCJyZXNwb25zZVBheWxvYWQiLCJyZXNwb25zZUVycm9yIiwicmVnaXN0ZXJScGNNZXRob2QiLCJ1bnJlZ2lzdGVyUnBjTWV0aG9kIiwic2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsIlJwY1JlcXVlc3QiLCJyZXNwb25zZVRpbWVvdXRNcyIsImhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkIiwicGVuZGluZ0lkZW50aXR5Iiwic2V0RW5hYmxlZFB1Ymxpc2hDb2RlY3MiLCJtdXRlZE9uU2VydmVyIiwid2FpdEZvclBlbmRpbmdUaW1lb3V0IiwicHVibGlzaFByb21pc2VFbnRyeSIsIl9yZWY0IiwiUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiIsImFsbG93ZWQiLCJkaXNhYmxlZCIsImN1cnJlbnRWaWRlb1F1YWxpdHkiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwiZW1pdFRyYWNrVXBkYXRlIiwiaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlIiwidmlkZW9EaW1lbnNpb25zIiwic3Vic2NyaWJlZCIsInNldFN1YnNjcmliZWQiLCJwcmV2U3RhdHVzIiwic3Vic2NyaXB0aW9uU3RhdHVzIiwicHJldlBlcm1pc3Npb24iLCJwZXJtaXNzaW9uU3RhdHVzIiwiUGFydGljaXBhbnRUcmFja3MiLCJlbWl0U3Vic2NyaXB0aW9uVXBkYXRlSWZDaGFuZ2VkIiwiZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQiLCJVbnN1YnNjcmliZWQiLCJEZXNpcmVkIiwiU3Vic2NyaWJlZCIsIkFsbG93ZWQiLCJzZXRFbmFibGVkIiwiaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkIiwic2V0VmlkZW9RdWFsaXR5Iiwic2V0VmlkZW9EaW1lbnNpb25zIiwic2V0VmlkZW9GUFMiLCJ2aWRlb1F1YWxpdHkiLCJwcmV2VHJhY2siLCJzZXRBbGxvd2VkIiwic2V0U3Vic2NyaXB0aW9uRXJyb3IiLCJTdWJzY3JpcHRpb25GYWlsZWQiLCJwcmV2TWV0YWRhdGFNdXRlZCIsInByZXZpb3VzU3RhdHVzIiwiY3VycmVudFN0YXR1cyIsIlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQiLCJwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMiLCJjdXJyZW50UGVybWlzc2lvblN0YXR1cyIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkIiwiVXBkYXRlVHJhY2tTZXR0aW5ncyIsIlVwZGF0ZVNldHRpbmdzIiwiUmVtb3RlUGFydGljaXBhbnQiLCJmcm9tUGFydGljaXBhbnRJbmZvIiwicGkiLCJycElEIiwicmVtb3RlUGFydGljaXBhbnQiLCJ2b2x1bWVNYXAiLCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkIiwiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkIiwicHJldmlvdXNUcmFjayIsIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkIiwiYXVkaW9QdWJsaWNhdGlvbiIsImFkZFN1YnNjcmliZWRNZWRpYVRyYWNrIiwidHJpZXNMZWZ0IiwiZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkIiwiaXNWaWRlbyIsImhhc01ldGFkYXRhIiwidmFsaWRUcmFja3MiLCJuZXdUcmFja3MiLCJvbGRUcmFjayIsInNlbmRVbnB1Ymxpc2giLCJUcmFja1VucHVibGlzaGVkIiwic2V0QXVkaW9PdXRwdXQiLCJwcm9taXNlcyIsImNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kiLCJSb29tIiwiYWN0aXZlU3BlYWtlcnMiLCJhdWRpb0VuYWJsZWQiLCJpc1ZpZGVvUGxheWJhY2tCbG9ja2VkIiwiYnVmZmVyZWRFdmVudHMiLCJpc1Jlc3VtaW5nIiwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJzIiwidGV4dFN0cmVhbUNvbnRyb2xsZXJzIiwiYnl0ZVN0cmVhbUhhbmRsZXJzIiwidGV4dFN0cmVhbUhhbmRsZXJzIiwidW5sb2NrRGlzY29ubmVjdCIsImRpc2Nvbm5lY3RMb2NrIiwiY29ubmVjdEZ1dHVyZSIsInNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUiLCJDb25uZWN0aW5nIiwiY29ubmVjdEZuIiwiYXR0ZW1wdENvbm5lY3Rpb24iLCJuZXh0VXJsIiwicmVjcmVhdGVFbmdpbmUiLCJjbGVhckNvbm5lY3Rpb25GdXR1cmVzIiwiY29ubmVjdFNpZ25hbCIsImUyZWVNYW5hZ2VyIiwic2VydmVyVmVyc2lvbiIsInNlcnZlclJlZ2lvbiIsInJvb21TaWQiLCJhcHBseUpvaW5SZXNwb25zZSIsImVuYWJsZWRQdWJsaXNoQ29kZWNzIiwic2lmVHJhaWxlciIsImhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyIsIm90aGVyUGFydGljaXBhbnRzIiwiaGFuZGxlUm9vbVVwZGF0ZSIsIm1heWJlQ3JlYXRlRW5naW5lIiwiYWNxdWlyZUF1ZGlvQ29udGV4dCIsImNvbm5PcHRpb25zIiwic2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzIiwicmVzdWx0aW5nRXJyb3IiLCJvblBhZ2VMZWF2ZSIsInJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSIsImFyZ3NfMSIsInN0b3BUcmFja3MiLCJzdGFydEF1ZGlvIiwiZWxlbWVudHMiLCJhdWRpb0lkIiwiZHVtbXlBdWRpb0VsIiwiZ2V0RWxlbWVudEJ5SWQiLCJhcHBlbmQiLCJoYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCIsImhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQiLCJzdGFydFZpZGVvIiwiaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJoYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkIiwiaGFuZGxlUmVzdGFydGluZyIsImNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSIsImhhbmRsZVNpZ25hbFJlc3RhcnRlZCIsIlJlY29ubmVjdGVkIiwiZW1pdEJ1ZmZlcmVkRXZlbnRzIiwicGFydGljaXBhbnRJbmZvcyIsInNpZFRvSWRlbnRpdHkiLCJQYXJ0aWNpcGFudEluZm9fU3RhdGUiLCJnZXRPckNyZWF0ZVBhcnRpY2lwYW50IiwiaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUiLCJzZWVuU2lkcyIsInNwZWFrZXIiLCJnZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkIiwiZW1pdFdoZW5Db25uZWN0ZWQiLCJBY3RpdmVTcGVha2Vyc0NoYW5nZWQiLCJoYW5kbGVTcGVha2Vyc0NoYW5nZWQiLCJzcGVha2VyVXBkYXRlcyIsImxhc3RTcGVha2VycyIsImhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlIiwic3RyZWFtU3RhdGVVcGRhdGUiLCJzdHJlYW1TdGF0ZXMiLCJuZXdTdHJlYW1TdGF0ZSIsIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIiwiaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsImhhbmRsZVN1YnNjcmlwdGlvbkVycm9yIiwiaGFuZGxlVXNlclBhY2tldCIsImhhbmRsZVRyYW5zY3JpcHRpb24iLCJoYW5kbGVTaXBEdG1mIiwiaGFuZGxlQ2hhdE1lc3NhZ2UiLCJoYW5kbGVNZXRyaWNzIiwiaGFuZGxlU3RyZWFtSGVhZGVyIiwiaGFuZGxlU3RyZWFtQ2h1bmsiLCJoYW5kbGVTdHJlYW1UcmFpbGVyIiwicnBjIiwiaGFuZGxlSW5jb21pbmdScGNSZXF1ZXN0IiwidXNlclBhY2tldCIsIkRhdGFSZWNlaXZlZCIsIlNpcERUTUZSZWNlaXZlZCIsImJ1ZmZlcmVkU2VnbWVudHMiLCJfcmVtb3RlUGFydGljaXBhbnQiLCJ0cmFuc2NyaWJlZFBhcnRpY2lwYW50SWRlbnRpdHkiLCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcyIsIlRyYW5zY3JpcHRpb25SZWNlaXZlZCIsImNoYXRNZXNzYWdlIiwibWV0cmljcyIsIk1ldHJpY3NSZWNlaXZlZCIsImNhblBsYXliYWNrQXVkaW8iLCJBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCIsIlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkIiwiaGFuZGxlRGV2aWNlQ2hhbmdlIiwiYXZhaWxhYmxlRGV2aWNlcyIsImF2YWlsYWJsZURldmljZSIsInByZXZpb3VzRGV2aWNlIiwiZ2V0QWN0aXZlRGV2aWNlIiwiQWN0aXZlRGV2aWNlQ2hhbmdlZCIsImtpbmRzIiwiZGV2aWNlc09mS2luZCIsImFjdGl2ZURldmljZSIsInN3aXRjaEFjdGl2ZURldmljZSIsImRldmljZUluZm8iLCJNZWRpYURldmljZXNDaGFuZ2VkIiwib2xkUm9vbSIsInJvb21JbmZvIiwiUm9vbU1ldGFkYXRhQ2hhbmdlZCIsImFjdGl2ZVJlY29yZGluZyIsIlJlY29yZGluZ1N0YXR1c0NoYW5nZWQiLCJoYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSIsIm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCIsIm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkIiwib25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJQYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkIiwib25Mb2NhbFRyYWNrTXV0ZWQiLCJvbkxvY2FsVHJhY2tVbm11dGVkIiwib25UcmFja1Byb2Nlc3NvclVwZGF0ZSIsIm9uUHVibGlzaCIsIm9uTG9jYWxUcmFja1Jlc3RhcnRlZCIsIkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQiLCJvbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwib25NZWRpYURldmljZXNFcnJvciIsIm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCIsIm9uTG9jYWxDaGF0TWVzc2FnZVNlbnQiLCJzZXR1cEUyRUUiLCJjbGVhbnVwUmVnaXN0cnkiLCJyZWdpc3RlciIsInJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIiLCJ1bnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIiLCJyZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyIiwidW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyIiwiY2FsbGVySWRlbnRpdHkiLCJpc1JlY29yZGluZyIsImdldFNpZCIsIm51bVBhcnRpY2lwYW50cyIsIm51bVB1Ymxpc2hlcnMiLCJvblRyYWNrQWRkZWQiLCJTaWduYWxSZWNvbm5lY3RpbmciLCJ1cGRhdGVTdWJzY3JpcHRpb25zIiwic3Vic2NyaWJlZFNpZCIsInRyYWNrUHVibGljYXRpb24iLCJnZXRMb2NhbERldmljZXMiLCJwcmVwYXJlQ29ubmVjdGlvbiIsInNpbXVsYXRlU2NlbmFyaW8iLCJwb3N0QWN0aW9uIiwiU2ltdWxhdGVTY2VuYXJpbyIsImNhblBsYXliYWNrVmlkZW8iLCJkZXZpY2VJZF8xIiwic3VjY2VzcyIsIm5lZWRzVXBkYXRlV2l0aG91dFRyYWNrcyIsImRldmljZUNvbnN0cmFpbnQiLCJwcmV2RGV2aWNlSWQiLCJyZWNvbm5lY3RlZEhhbmRsZXIiLCJzaG91bGRTdG9wVHJhY2tzIiwiUGFydGljaXBhbnREaXNjb25uZWN0ZWQiLCJzdHJlYW1IZWFkZXIiLCJzdHJlYW1IYW5kbGVyQ2FsbGJhY2siLCJzdHJlYW1Db250cm9sbGVyIiwiUmVhZGFibGVTdHJlYW0iLCJmaWxlQnVmZmVyIiwiZW5xdWV1ZSIsInRleHRCdWZmZXIiLCJuZXdDb250ZXh0SXNSdW5uaW5nIiwiY3JlYXRlUGFydGljaXBhbnQiLCJleGlzdGluZ1BhcnRpY2lwYW50Iiwid2FzVXBkYXRlZCIsIlBhcnRpY2lwYW50Q29ubmVjdGVkIiwiY29uc2VjdXRpdmVGYWlsdXJlcyIsImNvbm5lY3Rpb25SZWNvbmNpbGVJbnRlcnZhbCIsIm51bUZhaWx1cmVzIiwiY2xvc2VkIiwidHJhbnNwb3J0c0Nvbm5lY3RlZCIsIlNUQVRFX01JU01BVENIIiwiX2xlbjIiLCJfa2V5MiIsInNpbXVsYXRlUGFydGljaXBhbnRzIiwidXNlUmVhbFRyYWNrcyIsInBhcnRpY2lwYW50T3B0aW9ucyIsImFzcGVjdFJhdGlvcyIsIlJvb21Nb2RlbCIsImVtcHR5VGltZW91dCIsIm1heFBhcnRpY2lwYW50cyIsImNyZWF0aW9uVGltZSIsInR1cm5QYXNzd29yZCIsImVuYWJsZWRDb2RlY3MiLCJQYXJ0aWNpcGFudEluZm8iLCJjYW1QdWIiLCJUcmFja0luZm8iLCJhdWRpb1B1YiIsImR1bW15VmlkZW8iLCJfbGVuMyIsIl9rZXkzIiwibWluaW1pemVkQXJncyIsIm1hcEFyZ3MiLCJGaW5hbGl6YXRpb25SZWdpc3RyeSIsIkNoZWNrU3RhdHVzIiwiQ2hlY2tlciIsIklETEUiLCJsb2dzIiwib25Db21wbGV0ZSIsInNldFN0YXR1cyIsInBlcmZvcm0iLCJlcnJvcnNBc1dhcm5pbmdzIiwiYXBwZW5kV2FybmluZyIsImFwcGVuZEVycm9yIiwiU0tJUFBFRCIsImlzU3VjY2VzcyIsIlNVQ0NFU1MiLCJzd2l0Y2hQcm90b2NvbCIsImhhc1JlY29ubmVjdGluZyIsImhhc1JlY29ubmVjdGVkIiwiYXBwZW5kTWVzc2FnZSIsIkNsb3VkUmVnaW9uQ2hlY2siLCJyZWdpb25Qcm92aWRlciIsInJlZ2lvblN0YXRzIiwic2VlblVybHMiLCJjaGVja0Nsb3VkUmVnaW9uIiwiYmVzdFJlZ2lvbiIsImJlc3RTdGF0cyIsImNodW5rU2l6ZSIsIm51bUNodW5rcyIsImNodW5rRGF0YSIsIm5vbWluYXRlZCIsImN1cnJlbnRSb3VuZFRyaXBUaW1lIiwiVEVTVF9EVVJBVElPTiIsIkNvbm5lY3Rpb25Qcm90b2NvbENoZWNrIiwidWRwU3RhdHMiLCJjaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCIsInRjcFN0YXRzIiwiYml0cmF0ZVRvdGFsIiwicnR0VG90YWwiLCJqaXR0ZXJUb3RhbCIsImNwdSIsImh1ZSIsImFuaW1hdGUiLCJwcm90b2NvbFN0YXRzIiwiUHVibGlzaEF1ZGlvQ2hlY2siLCJudW1QYWNrZXRzIiwibWVkaWFUeXBlIiwiUHVibGlzaFZpZGVvQ2hlY2siLCJjaGVja0ZvclZpZGVvIiwib25wbGF5IiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiZHJhd0ltYWdlIiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiaXNBbGxCbGFjayIsIlJlY29ubmVjdENoZWNrIiwicmVjb25uZWN0aW5nVHJpZ2dlcmVkIiwicmVjb25uZWN0ZWQiLCJyZWNvbm5lY3RSZXNvbHZlciIsIlRVUk5DaGVjayIsImpvaW5SZXMiLCJoYXNUTFMiLCJoYXNUVVJOIiwiaGFzU1RVTiIsIldlYlJUQ0NoZWNrIiwiaGFzVGNwIiwiaGFzSXB2NFVkcCIsInByZXZUcmlja2xlIiwiaXNJUFByaXZhdGUiLCJSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQiLCJlcnJvckNvZGUiLCJlcnJvclRleHQiLCJzZWNvbmQiLCJXZWJTb2NrZXRDaGVjayIsImVkaXRpb24iLCJTZXJ2ZXJJbmZvX0VkaXRpb24iLCJDbG91ZCIsIkNvbm5lY3Rpb25DaGVjayIsImNoZWNrUmVzdWx0cyIsImdldE5leHRDaGVja0lkIiwibmV4dElkIiwidXBkYXRlQ2hlY2siLCJjaGVja0lkIiwiZ2V0UmVzdWx0cyIsImNyZWF0ZUFuZFJ1bkNoZWNrIiwiY2hlY2siLCJoYW5kbGVVcGRhdGUiLCJjaGVja1dlYnNvY2tldCIsImNoZWNrV2ViUlRDIiwiY2hlY2tUVVJOIiwiY2hlY2tSZWNvbm5lY3QiLCJjaGVja1B1Ymxpc2hBdWRpbyIsImNoZWNrUHVibGlzaFZpZGVvIiwiZmFjaW5nTW9kZUZyb21Mb2NhbFRyYWNrIiwidHJhY2tTZXR0aW5ncyIsImRlZmF1bHRGYWNpbmdNb2RlIiwiY29uZmlkZW5jZSIsInJhd0ZhY2luZ01vZGUiLCJpc0ZhY2luZ01vZGVWYWx1ZSIsImxhYmVsQW5hbHlzaXNSZXN1bHQiLCJmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsIiwia25vd25EZXZpY2VMYWJlbHMiLCJrbm93bkRldmljZUxhYmVsU2VjdGlvbnMiLCJkZXZpY2VMYWJlbCIsInNlY3Rpb24iLCJhbGxvd2VkVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/livekit-client@2.11.2/node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;