"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@livekit+track-processors@0.5.4_livekit-client@2.11.2";
exports.ids = ["vendor-chunks/@livekit+track-processors@0.5.4_livekit-client@2.11.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@livekit+track-processors@0.5.4_livekit-client@2.11.2/node_modules/@livekit/track-processors/dist/index.mjs":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@livekit+track-processors@0.5.4_livekit-client@2.11.2/node_modules/@livekit/track-processors/dist/index.mjs ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BackgroundBlur: () => (/* binding */ BackgroundBlur),\n/* harmony export */   BackgroundProcessor: () => (/* binding */ BackgroundProcessor2),\n/* harmony export */   BackgroundTransformer: () => (/* binding */ BackgroundProcessor),\n/* harmony export */   ProcessorWrapper: () => (/* binding */ ProcessorWrapper),\n/* harmony export */   VideoTransformer: () => (/* binding */ VideoTransformer),\n/* harmony export */   VirtualBackground: () => (/* binding */ VirtualBackground),\n/* harmony export */   supportsBackgroundProcessors: () => (/* binding */ supportsBackgroundProcessors),\n/* harmony export */   supportsModernBackgroundProcessors: () => (/* binding */ supportsModernBackgroundProcessors)\n/* harmony export */ });\n/* harmony import */ var _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mediapipe/tasks-vision */ \"(ssr)/./node_modules/.pnpm/@mediapipe+tasks-vision@0.10.14/node_modules/@mediapipe/tasks-vision/vision_bundle.mjs\");\n// src/utils.ts\nasync function sleep(time) {\n    return new Promise((resolve)=>setTimeout(resolve, time));\n}\nasync function waitForTrackResolution(track) {\n    const timeout = 500;\n    await sleep(10);\n    const started = Date.now();\n    while(Date.now() - started < timeout){\n        const { width, height } = track.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        await sleep(50);\n    }\n    return {\n        width: void 0,\n        height: void 0\n    };\n}\n// src/ProcessorWrapper.ts\nvar ProcessorWrapper = class _ProcessorWrapper {\n    constructor(transformer, name, options = {}){\n        // For tracking whether we're using the stream API fallback\n        this.useStreamFallback = false;\n        this.processingEnabled = false;\n        var _a;\n        this.name = name;\n        this.transformer = transformer;\n        this.maxFps = (_a = options.maxFps) != null ? _a : 30;\n    }\n    /**\n   * Determines if the Processor is supported on the current browser\n   */ static get isSupported() {\n        const hasStreamProcessor = typeof MediaStreamTrackGenerator !== \"undefined\" && typeof MediaStreamTrackProcessor !== \"undefined\";\n        const hasFallbackSupport = typeof HTMLCanvasElement !== \"undefined\" && typeof VideoFrame !== \"undefined\" && \"captureStream\" in HTMLCanvasElement.prototype;\n        return hasStreamProcessor || hasFallbackSupport;\n    }\n    /**\n   * Determines if modern browser APIs are supported, which yield better performance\n   */ static get hasModernApiSupport() {\n        return typeof MediaStreamTrackGenerator !== \"undefined\" && typeof MediaStreamTrackProcessor !== \"undefined\";\n    }\n    async setup(opts) {\n        this.source = opts.track;\n        const { width, height } = await waitForTrackResolution(this.source);\n        this.sourceDummy = opts.element;\n        if (!(this.sourceDummy instanceof HTMLVideoElement)) {\n            throw TypeError(\"Currently only video transformers are supported\");\n        }\n        if (this.sourceDummy instanceof HTMLVideoElement) {\n            this.sourceDummy.height = height != null ? height : 300;\n            this.sourceDummy.width = width != null ? width : 300;\n        }\n        this.useStreamFallback = !_ProcessorWrapper.hasModernApiSupport;\n        if (this.useStreamFallback) {\n            const existingCanvas = document.querySelector('canvas[data-livekit-processor=\"' + this.name + '\"]');\n            if (existingCanvas) {\n                this.displayCanvas = existingCanvas;\n                this.displayCanvas.width = width != null ? width : 300;\n                this.displayCanvas.height = height != null ? height : 300;\n            } else {\n                this.displayCanvas = document.createElement(\"canvas\");\n                this.displayCanvas.width = width != null ? width : 300;\n                this.displayCanvas.height = height != null ? height : 300;\n                this.displayCanvas.style.display = \"none\";\n                this.displayCanvas.dataset.livekitProcessor = this.name;\n                document.body.appendChild(this.displayCanvas);\n            }\n            this.renderContext = this.displayCanvas.getContext(\"2d\");\n            this.capturedStream = this.displayCanvas.captureStream();\n            this.canvas = new OffscreenCanvas(width != null ? width : 300, height != null ? height : 300);\n        } else {\n            this.processor = new MediaStreamTrackProcessor({\n                track: this.source\n            });\n            this.trackGenerator = new MediaStreamTrackGenerator({\n                kind: \"video\",\n                signalTarget: this.source\n            });\n            this.canvas = new OffscreenCanvas(width != null ? width : 300, height != null ? height : 300);\n        }\n    }\n    async init(opts) {\n        await this.setup(opts);\n        if (!this.canvas) {\n            throw new TypeError(\"Expected canvas to be defined after setup\");\n        }\n        await this.transformer.init({\n            outputCanvas: this.canvas,\n            inputElement: this.sourceDummy\n        });\n        if (this.useStreamFallback) {\n            this.initFallbackPath();\n        } else {\n            this.initStreamProcessorPath();\n        }\n    }\n    initStreamProcessorPath() {\n        if (!this.processor || !this.trackGenerator) {\n            throw new TypeError(\"Expected processor and trackGenerator to be defined for stream processor path\");\n        }\n        const readableStream = this.processor.readable;\n        const pipedStream = readableStream.pipeThrough(this.transformer.transformer);\n        pipedStream.pipeTo(this.trackGenerator.writable).catch((e)=>console.error(\"error when trying to pipe\", e)).finally(()=>this.destroy());\n        this.processedTrack = this.trackGenerator;\n    }\n    initFallbackPath() {\n        if (!this.capturedStream || !this.source || !this.canvas || !this.renderContext) {\n            throw new TypeError(\"Missing required components for fallback implementation\");\n        }\n        this.processedTrack = this.capturedStream.getVideoTracks()[0];\n        this.processingEnabled = true;\n        this.frameCallback = (frame)=>{\n            if (!this.processingEnabled || !frame) {\n                frame.close();\n                return;\n            }\n            const controller = {\n                enqueue: (processedFrame)=>{\n                    if (this.renderContext && this.displayCanvas) {\n                        this.renderContext.drawImage(processedFrame, 0, 0, this.displayCanvas.width, this.displayCanvas.height);\n                        processedFrame.close();\n                    }\n                }\n            };\n            try {\n                this.transformer.transform(frame, controller);\n            } catch (e) {\n                console.error(\"Error in transform:\", e);\n                frame.close();\n            }\n        };\n        this.startRenderLoop();\n    }\n    startRenderLoop() {\n        if (!this.sourceDummy || !(this.sourceDummy instanceof HTMLVideoElement)) {\n            return;\n        }\n        let lastVideoTimestamp = -1;\n        let lastFrameTime = 0;\n        const videoElement = this.sourceDummy;\n        const minFrameInterval = 1e3 / this.maxFps;\n        let estimatedVideoFps = this.maxFps;\n        let frameTimeHistory = [];\n        let lastVideoTimeChange = 0;\n        let frameCount = 0;\n        let lastFpsLog = 0;\n        const renderLoop = ()=>{\n            if (!this.processingEnabled || !this.sourceDummy || !(this.sourceDummy instanceof HTMLVideoElement)) {\n                return;\n            }\n            if (this.sourceDummy.paused) {\n                console.warn(\"Video is paused, trying to play\");\n                this.sourceDummy.play();\n                return;\n            }\n            const videoTime = videoElement.currentTime;\n            const now = performance.now();\n            const timeSinceLastFrame = now - lastFrameTime;\n            const hasNewFrame = videoTime !== lastVideoTimestamp;\n            if (hasNewFrame) {\n                if (lastVideoTimeChange > 0) {\n                    const timeBetweenFrames = now - lastVideoTimeChange;\n                    frameTimeHistory.push(timeBetweenFrames);\n                    if (frameTimeHistory.length > 10) {\n                        frameTimeHistory.shift();\n                    }\n                    if (frameTimeHistory.length > 2) {\n                        const avgFrameTime = frameTimeHistory.reduce((sum, time)=>sum + time, 0) / frameTimeHistory.length;\n                        estimatedVideoFps = 1e3 / avgFrameTime;\n                        const isDevelopment =  false || window.location.hostname === \"127.0.0.1\";\n                        if (isDevelopment && now - lastFpsLog > 5e3) {\n                            console.debug(`[${this.name}] Estimated video FPS: ${estimatedVideoFps.toFixed(1)}, Processing at: ${(frameCount / 5).toFixed(1)} FPS`);\n                            frameCount = 0;\n                            lastFpsLog = now;\n                        }\n                    }\n                }\n                lastVideoTimeChange = now;\n            }\n            const timeThresholdMet = timeSinceLastFrame >= minFrameInterval;\n            if (hasNewFrame && timeThresholdMet) {\n                lastVideoTimestamp = videoTime;\n                lastFrameTime = now;\n                frameCount++;\n                try {\n                    if (videoElement.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {\n                        const frame = new VideoFrame(videoElement);\n                        if (this.frameCallback) {\n                            this.frameCallback(frame);\n                        } else {\n                            frame.close();\n                        }\n                    }\n                } catch (e) {\n                    console.error(\"Error in render loop:\", e);\n                }\n            }\n            this.animationFrameId = requestAnimationFrame(renderLoop);\n        };\n        this.animationFrameId = requestAnimationFrame(renderLoop);\n    }\n    async restart(opts) {\n        await this.destroy();\n        await this.init(opts);\n    }\n    async restartTransformer(...options) {\n        await this.transformer.restart(options[0]);\n    }\n    async updateTransformerOptions(...options) {\n        await this.transformer.update(options[0]);\n    }\n    async destroy() {\n        var _a, _b, _c, _d;\n        if (this.useStreamFallback) {\n            this.processingEnabled = false;\n            if (this.animationFrameId) {\n                cancelAnimationFrame(this.animationFrameId);\n                this.animationFrameId = void 0;\n            }\n            if (this.displayCanvas && this.displayCanvas.parentNode) {\n                this.displayCanvas.parentNode.removeChild(this.displayCanvas);\n            }\n            (_a = this.capturedStream) == null ? void 0 : _a.getTracks().forEach((track)=>track.stop());\n        } else {\n            await ((_c = (_b = this.processor) == null ? void 0 : _b.writableControl) == null ? void 0 : _c.close());\n            (_d = this.trackGenerator) == null ? void 0 : _d.stop();\n        }\n        await this.transformer.destroy();\n    }\n};\n// src/transformers/BackgroundTransformer.ts\n\n// package.json\nvar dependencies = {\n    \"@mediapipe/tasks-vision\": \"0.10.14\"\n};\n// src/webgl/utils.ts\nfunction initTexture(gl, texIndex) {\n    const texRef = gl.TEXTURE0 + texIndex;\n    gl.activeTexture(texRef);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    return texture;\n}\nfunction createFramebuffer(gl, texture, width, height) {\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error(\"Framebuffer not complete\");\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return framebuffer;\n}\nfunction createVertexBuffer(gl) {\n    const vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        -1,\n        -1,\n        -1,\n        1,\n        1,\n        1,\n        -1,\n        -1,\n        1,\n        1,\n        1,\n        -1\n    ]), gl.STATIC_DRAW);\n    return vertexBuffer;\n}\nasync function resizeImageToCover(image, targetWidth, targetHeight) {\n    const imgAspect = image.width / image.height;\n    const targetAspect = targetWidth / targetHeight;\n    let sx = 0;\n    let sy = 0;\n    let sWidth = image.width;\n    let sHeight = image.height;\n    if (imgAspect > targetAspect) {\n        sWidth = Math.round(image.height * targetAspect);\n        sx = Math.round((image.width - sWidth) / 2);\n    } else if (imgAspect < targetAspect) {\n        sHeight = Math.round(image.width / targetAspect);\n        sy = Math.round((image.height - sHeight) / 2);\n    }\n    return createImageBitmap(image, sx, sy, sWidth, sHeight, {\n        resizeWidth: targetWidth,\n        resizeHeight: targetHeight,\n        resizeQuality: \"medium\"\n    });\n}\nvar emptyImageData = new ImageData(2, 2);\nemptyImageData.data[0] = 0;\nemptyImageData.data[1] = 0;\nemptyImageData.data[2] = 0;\nemptyImageData.data[3] = 0;\nvar glsl = (source)=>source;\n// src/webgl/shader-programs/vertexShader.ts\nvar vertexShaderSource = (flipY = true)=>`#version 300 es\n  in vec2 position;\n  out vec2 texCoords;\n\n  void main() {\n    texCoords = (position + 1.0) / 2.0;\n    texCoords.y = ${flipY ? \"1.0 - texCoords.y\" : \"texCoords.y\"};\n    gl_Position = vec4(position, 0, 1.0);\n  }\n`;\n// src/webgl/shader-programs/blurShader.ts\nvar blurFragmentShader = glsl`#version 300 es\n  precision highp float;\n  in vec2 texCoords;\n  uniform sampler2D u_texture;\n  uniform vec2 u_texelSize;\n  uniform vec2 u_direction;\n  uniform float u_radius;\n  out vec4 fragColor;\n\n  void main() {\n    float sigma = u_radius;\n    float twoSigmaSq = 2.0 * sigma * sigma;\n    float totalWeight = 0.0;\n    vec3 result = vec3(0.0);\n    const int MAX_SAMPLES = 16;\n    int radius = int(min(float(MAX_SAMPLES), ceil(u_radius)));\n\n    for (int i = -MAX_SAMPLES; i <= MAX_SAMPLES; ++i) {\n      float offset = float(i);\n      if (abs(offset) > float(radius)) continue;\n      float weight = exp(-(offset * offset) / twoSigmaSq);\n      vec2 sampleCoord = texCoords + u_direction * u_texelSize * offset;\n      result += texture(u_texture, sampleCoord).rgb * weight;\n      totalWeight += weight;\n    }\n\n    fragColor = vec4(result / totalWeight, 1.0);\n  }\n`;\nfunction createBlurProgram(gl) {\n    const blurFrag = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!blurFrag) {\n        throw Error(\"cannot create blur shader\");\n    }\n    gl.shaderSource(blurFrag, blurFragmentShader);\n    gl.compileShader(blurFrag);\n    if (!gl.getShaderParameter(blurFrag, gl.COMPILE_STATUS)) {\n        const info = gl.getShaderInfoLog(blurFrag);\n        throw Error(`Failed to compile blur shader: ${info}`);\n    }\n    const blurVertexShader = gl.createShader(gl.VERTEX_SHADER);\n    if (!blurVertexShader) {\n        throw Error(\"cannot create blur vertex shader\");\n    }\n    gl.shaderSource(blurVertexShader, vertexShaderSource());\n    gl.compileShader(blurVertexShader);\n    const blurProgram = gl.createProgram();\n    if (!blurProgram) {\n        throw Error(\"cannot create blur program\");\n    }\n    gl.attachShader(blurProgram, blurVertexShader);\n    gl.attachShader(blurProgram, blurFrag);\n    gl.linkProgram(blurProgram);\n    if (!gl.getProgramParameter(blurProgram, gl.LINK_STATUS)) {\n        const info = gl.getProgramInfoLog(blurProgram);\n        throw Error(`Failed to link blur program: ${info}`);\n    }\n    const blurUniforms = {\n        position: gl.getAttribLocation(blurProgram, \"position\"),\n        texture: gl.getUniformLocation(blurProgram, \"u_texture\"),\n        texelSize: gl.getUniformLocation(blurProgram, \"u_texelSize\"),\n        direction: gl.getUniformLocation(blurProgram, \"u_direction\"),\n        radius: gl.getUniformLocation(blurProgram, \"u_radius\")\n    };\n    return {\n        program: blurProgram,\n        shader: blurFrag,\n        vertexShader: blurVertexShader,\n        uniforms: blurUniforms\n    };\n}\nfunction applyBlur(gl, sourceTexture, width, height, blurRadius, blurProgram, blurUniforms, vertexBuffer, processFramebuffers, processTextures) {\n    gl.useProgram(blurProgram);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.vertexAttribPointer(blurUniforms.position, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(blurUniforms.position);\n    const texelWidth = 1 / width;\n    const texelHeight = 1 / height;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, processFramebuffers[0]);\n    gl.viewport(0, 0, width, height);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, sourceTexture);\n    gl.uniform1i(blurUniforms.texture, 0);\n    gl.uniform2f(blurUniforms.texelSize, texelWidth, texelHeight);\n    gl.uniform2f(blurUniforms.direction, 1, 0);\n    gl.uniform1f(blurUniforms.radius, blurRadius);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, processFramebuffers[1]);\n    gl.viewport(0, 0, width, height);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, processTextures[0]);\n    gl.uniform1i(blurUniforms.texture, 0);\n    gl.uniform2f(blurUniforms.direction, 0, 1);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return processTextures[1];\n}\n// src/webgl/shader-programs/boxBlurShader.ts\nvar boxBlurFragmentShader = glsl`#version 300 es\nprecision mediump float;\n\nin vec2 texCoords;\n\nuniform sampler2D u_texture;\nuniform vec2 u_texelSize;    // 1.0 / texture size\nuniform vec2 u_direction;    // (1.0, 0.0) for horizontal, (0.0, 1.0) for vertical\nuniform float u_radius;      // blur radius in texels\n\nout vec4 fragColor;\n\nvoid main() {\n    vec3 sum = vec3(0.0);\n    float count = 0.0;\n\n    // Limit radius to avoid excessive loop cost\n    const int MAX_RADIUS = 16;\n    int radius = int(min(float(MAX_RADIUS), u_radius));\n\n    for (int i = -MAX_RADIUS; i <= MAX_RADIUS; ++i) {\n        if (abs(i) > radius) continue;\n\n        vec2 offset = u_direction * u_texelSize * float(i);\n        sum += texture(u_texture, texCoords + offset).rgb;\n        count += 1.0;\n  }\n\n  fragColor = vec4(sum / count, 1.0);\n}\n`;\nfunction createBoxBlurProgram(gl) {\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    if (!vertexShader) {\n        throw Error(\"cannot create vertex shader\");\n    }\n    gl.shaderSource(vertexShader, vertexShaderSource());\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n        const info = gl.getShaderInfoLog(vertexShader);\n        throw Error(`Failed to compile vertex shader: ${info}`);\n    }\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!fragmentShader) {\n        throw Error(\"cannot create fragment shader\");\n    }\n    gl.shaderSource(fragmentShader, boxBlurFragmentShader);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n        const info = gl.getShaderInfoLog(fragmentShader);\n        throw Error(`Failed to compile box blur shader: ${info}`);\n    }\n    const program = gl.createProgram();\n    if (!program) {\n        throw Error(\"cannot create box blur program\");\n    }\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        const info = gl.getProgramInfoLog(program);\n        throw Error(`Failed to link box blur program: ${info}`);\n    }\n    const uniforms = {\n        position: gl.getAttribLocation(program, \"position\"),\n        texture: gl.getUniformLocation(program, \"u_texture\"),\n        texelSize: gl.getUniformLocation(program, \"u_texelSize\"),\n        direction: gl.getUniformLocation(program, \"u_direction\"),\n        radius: gl.getUniformLocation(program, \"u_radius\")\n    };\n    return {\n        program,\n        vertexShader,\n        fragmentShader,\n        uniforms\n    };\n}\n// src/webgl/shader-programs/compositeShader.ts\nvar compositeFragmentShader = glsl`#version 300 es\n  precision highp float;\n  in vec2 texCoords;\n  uniform sampler2D background;\n  uniform sampler2D frame;\n  uniform sampler2D mask;\n  out vec4 fragColor;\n  \n  void main() {\n      \n    vec4 frameTex = texture(frame, texCoords);\n    vec4 bgTex = texture(background, texCoords);\n\n    float maskVal = texture(mask, texCoords).r;\n\n    // Compute screen-space gradient to detect edge sharpness\n    float grad = length(vec2(dFdx(maskVal), dFdy(maskVal)));\n\n    float edgeSoftness = 2.0; // higher = softer\n    \n    // Create a smooth edge around binary transition\n    float smoothAlpha = smoothstep(0.5 - grad * edgeSoftness, 0.5 + grad * edgeSoftness, maskVal);\n\n    // Optional: preserve frame alpha, or override as fully opaque\n    vec4 blended = mix(bgTex, vec4(frameTex.rgb, 1.0), 1.0 - smoothAlpha);\n    \n    fragColor = blended;\n  \n  }\n`;\nfunction createCompositeProgram(gl) {\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    if (!vertexShader) {\n        throw Error(\"cannot create vertex shader\");\n    }\n    gl.shaderSource(vertexShader, vertexShaderSource());\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n        const info = gl.getShaderInfoLog(vertexShader);\n        throw Error(`Failed to compile vertex shader: ${info}`);\n    }\n    const compositeShader = gl.createShader(gl.FRAGMENT_SHADER);\n    if (!compositeShader) {\n        throw Error(\"cannot create fragment shader\");\n    }\n    gl.shaderSource(compositeShader, compositeFragmentShader);\n    gl.compileShader(compositeShader);\n    if (!gl.getShaderParameter(compositeShader, gl.COMPILE_STATUS)) {\n        const info = gl.getShaderInfoLog(compositeShader);\n        throw Error(`Failed to compile composite shader: ${info}`);\n    }\n    const compositeProgram = gl.createProgram();\n    if (!compositeProgram) {\n        throw Error(\"cannot create composite program\");\n    }\n    gl.attachShader(compositeProgram, vertexShader);\n    gl.attachShader(compositeProgram, compositeShader);\n    gl.linkProgram(compositeProgram);\n    if (!gl.getProgramParameter(compositeProgram, gl.LINK_STATUS)) {\n        const info = gl.getProgramInfoLog(compositeProgram);\n        throw Error(`Failed to link composite program: ${info}`);\n    }\n    const attribLocations = {\n        position: gl.getAttribLocation(compositeProgram, \"position\")\n    };\n    const uniformLocations = {\n        mask: gl.getUniformLocation(compositeProgram, \"mask\"),\n        frame: gl.getUniformLocation(compositeProgram, \"frame\"),\n        background: gl.getUniformLocation(compositeProgram, \"background\"),\n        stepWidth: gl.getUniformLocation(compositeProgram, \"u_stepWidth\")\n    };\n    return {\n        program: compositeProgram,\n        vertexShader,\n        fragmentShader: compositeShader,\n        attribLocations,\n        uniformLocations\n    };\n}\n// src/webgl/index.ts\nvar setupWebGL = (canvas)=>{\n    const gl = canvas.getContext(\"webgl2\", {\n        antialias: true,\n        premultipliedAlpha: true\n    });\n    let blurRadius = null;\n    if (!gl) {\n        console.error(\"Failed to create WebGL context\");\n        return void 0;\n    }\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    const composite = createCompositeProgram(gl);\n    const compositeProgram = composite.program;\n    const positionLocation = composite.attribLocations.position;\n    const { mask: maskTextureLocation, frame: frameTextureLocation, background: bgTextureLocation } = composite.uniformLocations;\n    const blur = createBlurProgram(gl);\n    const blurProgram = blur.program;\n    const blurUniforms = blur.uniforms;\n    const boxBlur = createBoxBlurProgram(gl);\n    const boxBlurProgram = boxBlur.program;\n    const boxBlurUniforms = boxBlur.uniforms;\n    const bgTexture = initTexture(gl, 0);\n    const frameTexture = initTexture(gl, 1);\n    const vertexBuffer = createVertexBuffer(gl);\n    if (!vertexBuffer) {\n        throw new Error(\"Failed to create vertex buffer\");\n    }\n    let bgBlurTextures = [];\n    let bgBlurFrameBuffers = [];\n    let maskBlurTextures = [];\n    let maskBlurFrameBuffers = [];\n    bgBlurTextures.push(initTexture(gl, 3));\n    bgBlurTextures.push(initTexture(gl, 4));\n    bgBlurFrameBuffers.push(createFramebuffer(gl, bgBlurTextures[0], canvas.width, canvas.height));\n    bgBlurFrameBuffers.push(createFramebuffer(gl, bgBlurTextures[1], canvas.width, canvas.height));\n    maskBlurTextures.push(initTexture(gl, 5));\n    maskBlurTextures.push(initTexture(gl, 6));\n    maskBlurFrameBuffers.push(createFramebuffer(gl, maskBlurTextures[0], canvas.width, canvas.height));\n    maskBlurFrameBuffers.push(createFramebuffer(gl, maskBlurTextures[1], canvas.width, canvas.height));\n    gl.useProgram(compositeProgram);\n    gl.uniform1i(bgTextureLocation, 0);\n    gl.uniform1i(frameTextureLocation, 1);\n    gl.uniform1i(maskTextureLocation, 2);\n    let customBackgroundImage = emptyImageData;\n    function render(frame, mask) {\n        if (frame.codedWidth === 0 || mask.width === 0) {\n            return;\n        }\n        const width = frame.displayWidth;\n        const height = frame.displayHeight;\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, frameTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, frame);\n        let backgroundTexture = bgTexture;\n        if (blurRadius) {\n            backgroundTexture = applyBlur(gl, frameTexture, width, height, blurRadius, blurProgram, blurUniforms, vertexBuffer, bgBlurFrameBuffers, bgBlurTextures);\n        } else {\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, bgTexture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, customBackgroundImage);\n            backgroundTexture = bgTexture;\n        }\n        const blurredMaskTexture = applyBlur(gl, mask.getAsWebGLTexture(), width, height, blurRadius || 1, // Use a default blur radius if not set\n        boxBlurProgram, boxBlurUniforms, vertexBuffer, maskBlurFrameBuffers, maskBlurTextures);\n        gl.viewport(0, 0, width, height);\n        gl.clearColor(1, 1, 1, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.useProgram(compositeProgram);\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.enableVertexAttribArray(positionLocation);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);\n        gl.uniform1i(bgTextureLocation, 0);\n        gl.activeTexture(gl.TEXTURE1);\n        gl.bindTexture(gl.TEXTURE_2D, frameTexture);\n        gl.uniform1i(frameTextureLocation, 1);\n        gl.activeTexture(gl.TEXTURE2);\n        gl.bindTexture(gl.TEXTURE_2D, blurredMaskTexture);\n        gl.uniform1i(maskTextureLocation, 2);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        mask.close();\n    }\n    async function setBackgroundImage(image) {\n        customBackgroundImage = emptyImageData;\n        if (image) {\n            try {\n                const croppedImage = await resizeImageToCover(image, canvas.width, canvas.height);\n                customBackgroundImage = croppedImage;\n            } catch (error) {\n                console.error(\"Error processing background image, falling back to black background:\", error);\n            }\n        }\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, bgTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, customBackgroundImage);\n    }\n    function setBlurRadius(radius) {\n        blurRadius = radius;\n        setBackgroundImage(null);\n    }\n    function cleanup() {\n        gl.deleteProgram(compositeProgram);\n        gl.deleteProgram(blurProgram);\n        gl.deleteProgram(boxBlurProgram);\n        gl.deleteTexture(bgTexture);\n        gl.deleteTexture(frameTexture);\n        for (const texture of bgBlurTextures){\n            gl.deleteTexture(texture);\n        }\n        for (const framebuffer of bgBlurFrameBuffers){\n            gl.deleteFramebuffer(framebuffer);\n        }\n        for (const texture of maskBlurTextures){\n            gl.deleteTexture(texture);\n        }\n        for (const framebuffer of maskBlurFrameBuffers){\n            gl.deleteFramebuffer(framebuffer);\n        }\n        gl.deleteBuffer(vertexBuffer);\n        if (customBackgroundImage) {\n            if (customBackgroundImage instanceof ImageBitmap) {\n                customBackgroundImage.close();\n            }\n            customBackgroundImage = emptyImageData;\n        }\n        bgBlurTextures = [];\n        bgBlurFrameBuffers = [];\n        maskBlurTextures = [];\n        maskBlurFrameBuffers = [];\n    }\n    return {\n        render,\n        setBackgroundImage,\n        setBlurRadius,\n        cleanup\n    };\n};\n// src/transformers/VideoTransformer.ts\nvar VideoTransformer = class {\n    constructor(){\n        this.isDisabled = false;\n    }\n    async init({ outputCanvas, inputElement: inputVideo }) {\n        if (!(inputVideo instanceof HTMLVideoElement)) {\n            throw TypeError(\"Video transformer needs a HTMLVideoElement as input\");\n        }\n        this.transformer = new TransformStream({\n            transform: (frame, controller)=>this.transform(frame, controller)\n        });\n        this.canvas = outputCanvas || null;\n        if (outputCanvas) {\n            this.gl = setupWebGL(this.canvas || new OffscreenCanvas(inputVideo.videoWidth, inputVideo.videoHeight));\n        }\n        this.inputVideo = inputVideo;\n        this.isDisabled = false;\n    }\n    async restart({ outputCanvas, inputElement: inputVideo }) {\n        var _a;\n        this.canvas = outputCanvas || null;\n        (_a = this.gl) == null ? void 0 : _a.cleanup();\n        this.gl = setupWebGL(this.canvas || new OffscreenCanvas(inputVideo.videoWidth, inputVideo.videoHeight));\n        this.inputVideo = inputVideo;\n        this.isDisabled = false;\n    }\n    async destroy() {\n        var _a;\n        this.isDisabled = true;\n        this.canvas = void 0;\n        (_a = this.gl) == null ? void 0 : _a.cleanup();\n        this.gl = void 0;\n    }\n};\n// src/transformers/BackgroundTransformer.ts\nvar BackgroundProcessor = class extends VideoTransformer {\n    constructor(opts){\n        super();\n        this.backgroundImage = null;\n        this.options = opts;\n        this.update(opts);\n    }\n    static get isSupported() {\n        return typeof OffscreenCanvas !== \"undefined\" && typeof VideoFrame !== \"undefined\" && typeof createImageBitmap !== \"undefined\" && !!document.createElement(\"canvas\").getContext(\"webgl2\");\n    }\n    async init({ outputCanvas, inputElement: inputVideo }) {\n        var _a, _b, _c, _d, _e, _f;\n        await super.init({\n            outputCanvas,\n            inputElement: inputVideo\n        });\n        const fileSet = await _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_0__.FilesetResolver.forVisionTasks((_b = (_a = this.options.assetPaths) == null ? void 0 : _a.tasksVisionFileSet) != null ? _b : `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${dependencies[\"@mediapipe/tasks-vision\"]}/wasm`);\n        this.imageSegmenter = await _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_0__.ImageSegmenter.createFromOptions(fileSet, {\n            baseOptions: {\n                modelAssetPath: (_d = (_c = this.options.assetPaths) == null ? void 0 : _c.modelAssetPath) != null ? _d : \"https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/latest/selfie_segmenter.tflite\",\n                delegate: \"GPU\",\n                ...this.options.segmenterOptions\n            },\n            canvas: this.canvas,\n            runningMode: \"VIDEO\",\n            outputCategoryMask: true,\n            outputConfidenceMasks: false\n        });\n        if (((_e = this.options) == null ? void 0 : _e.imagePath) && !this.backgroundImage) {\n            await this.loadBackground(this.options.imagePath).catch((err)=>console.error(\"Error while loading processor background image: \", err));\n        }\n        if (this.options.blurRadius) {\n            (_f = this.gl) == null ? void 0 : _f.setBlurRadius(this.options.blurRadius);\n        }\n    }\n    async destroy() {\n        var _a;\n        await super.destroy();\n        await ((_a = this.imageSegmenter) == null ? void 0 : _a.close());\n        this.backgroundImage = null;\n    }\n    async loadBackground(path) {\n        var _a;\n        const img = new Image();\n        await new Promise((resolve, reject)=>{\n            img.crossOrigin = \"Anonymous\";\n            img.onload = ()=>resolve(img);\n            img.onerror = (err)=>reject(err);\n            img.src = path;\n        });\n        const imageData = await createImageBitmap(img);\n        (_a = this.gl) == null ? void 0 : _a.setBackgroundImage(imageData);\n    }\n    async transform(frame, controller) {\n        var _a;\n        try {\n            if (!(frame instanceof VideoFrame) || frame.codedWidth === 0 || frame.codedHeight === 0) {\n                console.debug(\"empty frame detected, ignoring\");\n                return;\n            }\n            if (this.isDisabled) {\n                controller.enqueue(frame);\n                return;\n            }\n            if (!this.canvas) {\n                throw TypeError(\"Canvas needs to be initialized first\");\n            }\n            this.canvas.width = frame.displayWidth;\n            this.canvas.height = frame.displayHeight;\n            let startTimeMs = performance.now();\n            (_a = this.imageSegmenter) == null ? void 0 : _a.segmentForVideo(frame, startTimeMs, (result)=>{\n                var _a2, _b;\n                const segmentationTimeMs = performance.now() - startTimeMs;\n                this.segmentationResults = result;\n                this.drawFrame(frame);\n                if (this.canvas && this.canvas.width > 0 && this.canvas.height > 0) {\n                    const newFrame = new VideoFrame(this.canvas, {\n                        timestamp: frame.timestamp || Date.now()\n                    });\n                    const filterTimeMs = performance.now() - startTimeMs - segmentationTimeMs;\n                    const stats = {\n                        processingTimeMs: performance.now() - startTimeMs,\n                        segmentationTimeMs,\n                        filterTimeMs\n                    };\n                    (_b = (_a2 = this.options).onFrameProcessed) == null ? void 0 : _b.call(_a2, stats);\n                    controller.enqueue(newFrame);\n                } else {\n                    controller.enqueue(frame);\n                }\n                frame.close();\n            });\n        } catch (e) {\n            console.error(\"Error while processing frame: \", e);\n            frame == null ? void 0 : frame.close();\n        }\n    }\n    async update(opts) {\n        var _a;\n        this.options = {\n            ...this.options,\n            ...opts\n        };\n        if (opts.blurRadius) {\n            (_a = this.gl) == null ? void 0 : _a.setBlurRadius(opts.blurRadius);\n        } else if (opts.imagePath) {\n            await this.loadBackground(opts.imagePath);\n        }\n    }\n    async drawFrame(frame) {\n        if (!this.canvas || !this.gl || !this.segmentationResults || !this.inputVideo) return;\n        const mask = this.segmentationResults.categoryMask;\n        if (mask) {\n            this.gl.render(frame, mask);\n        }\n    }\n};\n// src/index.ts\nvar supportsBackgroundProcessors = ()=>BackgroundProcessor.isSupported && ProcessorWrapper.isSupported;\nvar supportsModernBackgroundProcessors = ()=>BackgroundProcessor.isSupported && ProcessorWrapper.hasModernApiSupport;\nvar BackgroundBlur = (blurRadius = 10, segmenterOptions, onFrameProcessed, processorOptions)=>{\n    return BackgroundProcessor2({\n        blurRadius,\n        segmenterOptions,\n        onFrameProcessed,\n        ...processorOptions\n    }, \"background-blur\");\n};\nvar VirtualBackground = (imagePath, segmenterOptions, onFrameProcessed, processorOptions)=>{\n    return BackgroundProcessor2({\n        imagePath,\n        segmenterOptions,\n        onFrameProcessed,\n        ...processorOptions\n    }, \"virtual-background\");\n};\nvar BackgroundProcessor2 = (options, name = \"background-processor\")=>{\n    const isTransformerSupported = BackgroundProcessor.isSupported;\n    const isProcessorSupported = ProcessorWrapper.isSupported;\n    if (!isTransformerSupported) {\n        throw new Error(\"Background transformer is not supported in this browser\");\n    }\n    if (!isProcessorSupported) {\n        throw new Error(\"Neither MediaStreamTrackProcessor nor canvas.captureStream() fallback is supported in this browser\");\n    }\n    const { blurRadius, imagePath, segmenterOptions, assetPaths, onFrameProcessed, ...processorOpts } = options;\n    const transformer = new BackgroundProcessor({\n        blurRadius,\n        imagePath,\n        segmenterOptions,\n        assetPaths,\n        onFrameProcessed\n    });\n    const processor = new ProcessorWrapper(transformer, name, processorOpts);\n    return processor;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxpdmVraXQrdHJhY2stcHJvY2Vzc29yc0AwLjUuNF9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL0BsaXZla2l0L3RyYWNrLXByb2Nlc3NvcnMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUlBLGVBQWVBLE1BQU1DLElBQUE7SUFDbkIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFVBQVlDLFdBQVdELFNBQVNGO0FBQ3REO0FBRUEsZUFBc0JJLHVCQUF1QkMsS0FBQTtJQUMzQyxNQUFNQyxVQUFVO0lBSWhCLE1BQU1QLE1BQU07SUFFWixNQUFNUSxVQUFVQyxLQUFLQyxHQUFBO0lBQ3JCLE1BQU9ELEtBQUtDLEdBQUEsS0FBUUYsVUFBVUQsUUFBUztRQUNyQyxNQUFNLEVBQUVJLEtBQUEsRUFBT0MsTUFBQSxFQUFPLEdBQUlOLE1BQU1PLFdBQUE7UUFDaEMsSUFBSUYsU0FBU0MsUUFBUTtZQUNuQixPQUFPO2dCQUFFRDtnQkFBT0M7WUFBTztRQUN6QjtRQUNBLE1BQU1aLE1BQU07SUFDZDtJQUNBLE9BQU87UUFBRVcsT0FBTztRQUFXQyxRQUFRO0lBQVU7QUFDL0M7O0FDWkEsSUFBcUJFLG1CQUFyQixNQUFxQkM7SUFtRW5CQyxZQUNFQyxXQUFBLEVBQ0FDLElBQUEsRUFDQUMsVUFBbUMsQ0FBQyxFQUNwQztRQXBCRjtRQUFBLEtBQVFDLGlCQUFBLEdBQW9CO1FBVzVCLEtBQVFDLGlCQUFBLEdBQW9CO1FBMUU5QixJQUFBQztRQW9GSSxLQUFLSixJQUFBLEdBQU9BO1FBQ1osS0FBS0QsV0FBQSxHQUFjQTtRQUNuQixLQUFLTSxNQUFBLElBQVNELEtBQUFILFFBQVFJLE1BQUEsS0FBUixPQUFBRCxLQUFrQjtJQUNsQztJQUFBOztHQUFBLEdBckVBLFdBQVdFLGNBQWM7UUFFdkIsTUFBTUMscUJBQ0osT0FBT0MsOEJBQThCLGVBQ3JDLE9BQU9DLDhCQUE4QjtRQUd2QyxN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NEIsa0JBQ0FNO0lBRUEsT0FBT2pELHFCQUNMO1FBQ0VtQjtRQUNBSjtRQUNBNEI7UUFDQSxHQUFHTSxnQkFBQTtJQUNMLEdBQ0E7QUFFSjtBQUVPLElBQU1qRCx1QkFBc0IsQ0FDakN0UyxTQUNBRCxPQUFPO0lBRVAsTUFBTTBWLHlCQUF5Qm5ELG9CQUFzQmpTLFdBQUE7SUFDckQsTUFBTXFWLHVCQUF1Qi9WLGlCQUFpQlUsV0FBQTtJQUU5QyxJQUFJLENBQUNvVix3QkFBd0I7UUFDM0IsTUFBTSxJQUFJak0sTUFBTTtJQUNsQjtJQUVBLElBQUksQ0FBQ2tNLHNCQUFzQjtRQUN6QixNQUFNLElBQUlsTSxNQUNSO0lBRUo7SUFHQSxNQUFNLEVBQ0pnRSxVQUFBLEVBQ0FpRyxTQUFBLEVBQ0FKLGdCQUFBLEVBQ0FSLFVBQUEsRUFDQW9DLGdCQUFBLEVBQ0EsR0FBR1UsZUFDTCxHQUFJM1Y7SUFFSixNQUFNRixjQUFjLElBQUl3UyxvQkFBc0I7UUFDNUM5RTtRQUNBaUc7UUFDQUo7UUFDQVI7UUFDQW9DO0lBQ0Y7SUFFQSxNQUFNM1MsWUFBWSxJQUFJM0MsaUJBQWlCRyxhQUFhQyxNQUFNNFY7SUFFMUQsT0FBT3JUO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxpdmVraXQrdHJhY2stcHJvY2Vzc29yc0AwLjUuNF9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL0BsaXZla2l0L3RyYWNrLXByb2Nlc3NvcnMvc3JjL3V0aWxzLnRzP2YxNDMiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaXZla2l0K3RyYWNrLXByb2Nlc3NvcnNAMC41LjRfbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzL3NyYy9Qcm9jZXNzb3JXcmFwcGVyLnRzP2Y5NjQiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaXZla2l0K3RyYWNrLXByb2Nlc3NvcnNAMC41LjRfbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzL3NyYy90cmFuc2Zvcm1lcnMvQmFja2dyb3VuZFRyYW5zZm9ybWVyLnRzP2U4MjciLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaXZla2l0K3RyYWNrLXByb2Nlc3NvcnNAMC41LjRfbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzL3BhY2thZ2UuanNvbj9mZGNhIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbGl2ZWtpdCt0cmFjay1wcm9jZXNzb3JzQDAuNS40X2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvQGxpdmVraXQvdHJhY2stcHJvY2Vzc29ycy9zcmMvd2ViZ2wvdXRpbHMudHM/YjQzOSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxpdmVraXQrdHJhY2stcHJvY2Vzc29yc0AwLjUuNF9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL0BsaXZla2l0L3RyYWNrLXByb2Nlc3NvcnMvc3JjL3dlYmdsL3NoYWRlci1wcm9ncmFtcy92ZXJ0ZXhTaGFkZXIudHM/ZDc3OSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxpdmVraXQrdHJhY2stcHJvY2Vzc29yc0AwLjUuNF9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL0BsaXZla2l0L3RyYWNrLXByb2Nlc3NvcnMvc3JjL3dlYmdsL3NoYWRlci1wcm9ncmFtcy9ibHVyU2hhZGVyLnRzPzM5MDEiLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaXZla2l0K3RyYWNrLXByb2Nlc3NvcnNAMC41LjRfbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzL3NyYy93ZWJnbC9zaGFkZXItcHJvZ3JhbXMvYm94Qmx1clNoYWRlci50cz84ZjEyIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbGl2ZWtpdCt0cmFjay1wcm9jZXNzb3JzQDAuNS40X2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvQGxpdmVraXQvdHJhY2stcHJvY2Vzc29ycy9zcmMvd2ViZ2wvc2hhZGVyLXByb2dyYW1zL2NvbXBvc2l0ZVNoYWRlci50cz9kYTE3Iiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbGl2ZWtpdCt0cmFjay1wcm9jZXNzb3JzQDAuNS40X2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvQGxpdmVraXQvdHJhY2stcHJvY2Vzc29ycy9zcmMvd2ViZ2wvaW5kZXgudHM/Y2ZkMSIsIndlYnBhY2s6Ly9saXZla2l0LW1lZXQvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxpdmVraXQrdHJhY2stcHJvY2Vzc29yc0AwLjUuNF9saXZla2l0LWNsaWVudEAyLjExLjIvbm9kZV9tb2R1bGVzL0BsaXZla2l0L3RyYWNrLXByb2Nlc3NvcnMvc3JjL3RyYW5zZm9ybWVycy9WaWRlb1RyYW5zZm9ybWVyLnRzP2IzOTciLCJ3ZWJwYWNrOi8vbGl2ZWtpdC1tZWV0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsaXZla2l0K3RyYWNrLXByb2Nlc3NvcnNAMC41LjRfbGl2ZWtpdC1jbGllbnRAMi4xMS4yL25vZGVfbW9kdWxlcy9AbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzL3NyYy9pbmRleC50cz85NTBhIiwid2VicGFjazovL2xpdmVraXQtbWVldC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbGl2ZWtpdCt0cmFjay1wcm9jZXNzb3JzQDAuNS40X2xpdmVraXQtY2xpZW50QDIuMTEuMi9ub2RlX21vZHVsZXMvQGxpdmVraXQvdHJhY2stcHJvY2Vzc29ycy9kaXN0L2luZGV4Lm1qcz9mNGFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzUHJvY2Vzc29yID0gdHlwZW9mIE1lZGlhU3RyZWFtVHJhY2tHZW5lcmF0b3IgIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzT2Zmc2NyZWVuQ2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCc7XG5cbmFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWU6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZSkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvclRyYWNrUmVzb2x1dGlvbih0cmFjazogTWVkaWFTdHJlYW1UcmFjaykge1xuICBjb25zdCB0aW1lb3V0ID0gNTAwO1xuXG4gIC8vIGJyb3dzZXJzIHJlcG9ydCB3cm9uZyBpbml0aWFsIHJlc29sdXRpb24gb24gaU9TLlxuICAvLyB3aGVuIHNsaWdodGx5IGRlbGF5aW5nIHRoZSBjYWxsIHRvIC5nZXRTZXR0aW5ncygpLCB0aGUgY29ycmVjdCByZXNvbHV0aW9uIGlzIGJlaW5nIHJlcG9ydGVkXG4gIGF3YWl0IHNsZWVwKDEwKTtcblxuICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydGVkIDwgdGltZW91dCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG4gICAgfVxuICAgIGF3YWl0IHNsZWVwKDUwKTtcbiAgfVxuICByZXR1cm4geyB3aWR0aDogdW5kZWZpbmVkLCBoZWlnaHQ6IHVuZGVmaW5lZCB9O1xufVxuIiwiaW1wb3J0IHR5cGUgeyBQcm9jZXNzb3JPcHRpb25zLCBUcmFjaywgVHJhY2tQcm9jZXNzb3IgfSBmcm9tICdsaXZla2l0LWNsaWVudCc7XG5pbXBvcnQgeyBUcmFja1RyYW5zZm9ybWVyIH0gZnJvbSAnLi90cmFuc2Zvcm1lcnMnO1xuaW1wb3J0IHsgd2FpdEZvclRyYWNrUmVzb2x1dGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NvcldyYXBwZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIE1heGltdW0gZnJhbWUgcmF0ZSBmb3IgZmFsbGJhY2sgY2FudmFzLmNhcHR1cmVTdHJlYW0gaW1wbGVtZW50YXRpb25cbiAgICogRGVmYXVsdDogMzBcbiAgICovXG4gIG1heEZwcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvY2Vzc29yV3JhcHBlcjxUcmFuc2Zvcm1lck9wdGlvbnMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj5cbiAgaW1wbGVtZW50cyBUcmFja1Byb2Nlc3NvcjxUcmFjay5LaW5kPlxue1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgUHJvY2Vzc29yIGlzIHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBicm93c2VyXG4gICAqL1xuICBzdGF0aWMgZ2V0IGlzU3VwcG9ydGVkKCkge1xuICAgIC8vIENoZWNrIGZvciBwcmltYXJ5IGltcGxlbWVudGF0aW9uIHN1cHBvcnRcbiAgICBjb25zdCBoYXNTdHJlYW1Qcm9jZXNzb3IgPVxuICAgICAgdHlwZW9mIE1lZGlhU3RyZWFtVHJhY2tHZW5lcmF0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVkaWFTdHJlYW1UcmFja1Byb2Nlc3NvciAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBDaGVjayBmb3IgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gc3VwcG9ydFxuICAgIGNvbnN0IGhhc0ZhbGxiYWNrU3VwcG9ydCA9XG4gICAgICB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgVmlkZW9GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICdjYXB0dXJlU3RyZWFtJyBpbiBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICAvLyBXZSBjYW4gd29yayBpZiBlaXRoZXIgaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIGhhc1N0cmVhbVByb2Nlc3NvciB8fCBoYXNGYWxsYmFja1N1cHBvcnQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBtb2Rlcm4gYnJvd3NlciBBUElzIGFyZSBzdXBwb3J0ZWQsIHdoaWNoIHlpZWxkIGJldHRlciBwZXJmb3JtYW5jZVxuICAgKi9cbiAgc3RhdGljIGdldCBoYXNNb2Rlcm5BcGlTdXBwb3J0KCkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgTWVkaWFTdHJlYW1UcmFja0dlbmVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yICE9PSAndW5kZWZpbmVkJ1xuICAgICk7XG4gIH1cblxuICBuYW1lOiBzdHJpbmc7XG5cbiAgc291cmNlPzogTWVkaWFTdHJlYW1WaWRlb1RyYWNrO1xuXG4gIHByb2Nlc3Nvcj86IE1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3I8VmlkZW9GcmFtZT47XG5cbiAgdHJhY2tHZW5lcmF0b3I/OiBNZWRpYVN0cmVhbVRyYWNrR2VuZXJhdG9yPFZpZGVvRnJhbWU+O1xuXG4gIGNhbnZhcz86IE9mZnNjcmVlbkNhbnZhcztcblxuICBkaXNwbGF5Q2FudmFzPzogSFRNTENhbnZhc0VsZW1lbnQ7XG5cbiAgc291cmNlRHVtbXk/OiBIVE1MTWVkaWFFbGVtZW50O1xuXG4gIHByb2Nlc3NlZFRyYWNrPzogTWVkaWFTdHJlYW1UcmFjaztcblxuICB0cmFuc2Zvcm1lcjogVHJhY2tUcmFuc2Zvcm1lcjxUcmFuc2Zvcm1lck9wdGlvbnM+O1xuXG4gIC8vIEZvciB0cmFja2luZyB3aGV0aGVyIHdlJ3JlIHVzaW5nIHRoZSBzdHJlYW0gQVBJIGZhbGxiYWNrXG4gIHByaXZhdGUgdXNlU3RyZWFtRmFsbGJhY2sgPSBmYWxzZTtcblxuICAvLyBGb3IgZmFsbGJhY2sgcmVuZGVyaW5nIHdpdGggY2FudmFzLmNhcHR1cmVTdHJlYW0oKVxuICBwcml2YXRlIGNhcHR1cmVkU3RyZWFtPzogTWVkaWFTdHJlYW07XG5cbiAgcHJpdmF0ZSBhbmltYXRpb25GcmFtZUlkPzogbnVtYmVyO1xuXG4gIHByaXZhdGUgcmVuZGVyQ29udGV4dD86IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICBwcml2YXRlIGZyYW1lQ2FsbGJhY2s/OiAoZnJhbWU6IFZpZGVvRnJhbWUpID0+IHZvaWQ7XG5cbiAgcHJpdmF0ZSBwcm9jZXNzaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIEZQUyBjb250cm9sIGZvciBmYWxsYmFjayBpbXBsZW1lbnRhdGlvblxuICBwcml2YXRlIG1heEZwczogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHRyYW5zZm9ybWVyOiBUcmFja1RyYW5zZm9ybWVyPFRyYW5zZm9ybWVyT3B0aW9ucz4sXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFByb2Nlc3NvcldyYXBwZXJPcHRpb25zID0ge30sXG4gICkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xuICAgIHRoaXMubWF4RnBzID0gb3B0aW9ucy5tYXhGcHMgPz8gMzA7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNldHVwKG9wdHM6IFByb2Nlc3Nvck9wdGlvbnM8VHJhY2suS2luZD4pIHtcbiAgICB0aGlzLnNvdXJjZSA9IG9wdHMudHJhY2sgYXMgTWVkaWFTdHJlYW1WaWRlb1RyYWNrO1xuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBhd2FpdCB3YWl0Rm9yVHJhY2tSZXNvbHV0aW9uKHRoaXMuc291cmNlKTtcbiAgICB0aGlzLnNvdXJjZUR1bW15ID0gb3B0cy5lbGVtZW50O1xuXG4gICAgaWYgKCEodGhpcy5zb3VyY2VEdW1teSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0N1cnJlbnRseSBvbmx5IHZpZGVvIHRyYW5zZm9ybWVycyBhcmUgc3VwcG9ydGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc291cmNlRHVtbXkgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUR1bW15LmhlaWdodCA9IGhlaWdodCA/PyAzMDA7XG4gICAgICB0aGlzLnNvdXJjZUR1bW15LndpZHRoID0gd2lkdGggPz8gMzAwO1xuICAgIH1cblxuICAgIHRoaXMudXNlU3RyZWFtRmFsbGJhY2sgPSAhUHJvY2Vzc29yV3JhcHBlci5oYXNNb2Rlcm5BcGlTdXBwb3J0O1xuXG4gICAgaWYgKHRoaXMudXNlU3RyZWFtRmFsbGJhY2spIHtcbiAgICAgIC8vIENyZWF0ZSBhIHZpc2libGUgY2FudmFzIGZvciB0aGUgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb3IgdXNlIGFuIGV4aXN0aW5nIG9uZSBpZiBwcm92aWRlZFxuICAgICAgY29uc3QgZXhpc3RpbmdDYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnY2FudmFzW2RhdGEtbGl2ZWtpdC1wcm9jZXNzb3I9XCInICsgdGhpcy5uYW1lICsgJ1wiXScsXG4gICAgICApIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuXG4gICAgICBpZiAoZXhpc3RpbmdDYW52YXMpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5Q2FudmFzID0gZXhpc3RpbmdDYW52YXM7XG4gICAgICAgIHRoaXMuZGlzcGxheUNhbnZhcy53aWR0aCA9IHdpZHRoID8/IDMwMDtcbiAgICAgICAgdGhpcy5kaXNwbGF5Q2FudmFzLmhlaWdodCA9IGhlaWdodCA/PyAzMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BsYXlDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5Q2FudmFzLndpZHRoID0gd2lkdGggPz8gMzAwO1xuICAgICAgICB0aGlzLmRpc3BsYXlDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ID8/IDMwMDtcbiAgICAgICAgdGhpcy5kaXNwbGF5Q2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuZGlzcGxheUNhbnZhcy5kYXRhc2V0LmxpdmVraXRQcm9jZXNzb3IgPSB0aGlzLm5hbWU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kaXNwbGF5Q2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJDb250ZXh0ID0gdGhpcy5kaXNwbGF5Q2FudmFzLmdldENvbnRleHQoJzJkJykhO1xuICAgICAgdGhpcy5jYXB0dXJlZFN0cmVhbSA9IHRoaXMuZGlzcGxheUNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGggPz8gMzAwLCBoZWlnaHQgPz8gMzAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIE1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3IgQVBJXG4gICAgICB0aGlzLnByb2Nlc3NvciA9IG5ldyBNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yKHsgdHJhY2s6IHRoaXMuc291cmNlIH0pO1xuICAgICAgdGhpcy50cmFja0dlbmVyYXRvciA9IG5ldyBNZWRpYVN0cmVhbVRyYWNrR2VuZXJhdG9yKHtcbiAgICAgICAga2luZDogJ3ZpZGVvJyxcbiAgICAgICAgc2lnbmFsVGFyZ2V0OiB0aGlzLnNvdXJjZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoID8/IDMwMCwgaGVpZ2h0ID8/IDMwMCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaW5pdChvcHRzOiBQcm9jZXNzb3JPcHRpb25zPFRyYWNrLktpbmQ+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zZXR1cChvcHRzKTtcblxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGNhbnZhcyB0byBiZSBkZWZpbmVkIGFmdGVyIHNldHVwJyk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy50cmFuc2Zvcm1lci5pbml0KHtcbiAgICAgIG91dHB1dENhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICBpbnB1dEVsZW1lbnQ6IHRoaXMuc291cmNlRHVtbXkgYXMgSFRNTFZpZGVvRWxlbWVudCxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnVzZVN0cmVhbUZhbGxiYWNrKSB7XG4gICAgICB0aGlzLmluaXRGYWxsYmFja1BhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0U3RyZWFtUHJvY2Vzc29yUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaW5pdFN0cmVhbVByb2Nlc3NvclBhdGgoKSB7XG4gICAgaWYgKCF0aGlzLnByb2Nlc3NvciB8fCAhdGhpcy50cmFja0dlbmVyYXRvcikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0V4cGVjdGVkIHByb2Nlc3NvciBhbmQgdHJhY2tHZW5lcmF0b3IgdG8gYmUgZGVmaW5lZCBmb3Igc3RyZWFtIHByb2Nlc3NvciBwYXRoJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLnByb2Nlc3Nvci5yZWFkYWJsZTtcbiAgICBjb25zdCBwaXBlZFN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtLnBpcGVUaHJvdWdoKHRoaXMudHJhbnNmb3JtZXIhLnRyYW5zZm9ybWVyISk7XG5cbiAgICBwaXBlZFN0cmVhbVxuICAgICAgLnBpcGVUbyh0aGlzLnRyYWNrR2VuZXJhdG9yLndyaXRhYmxlKVxuICAgICAgLmNhdGNoKChlKSA9PiBjb25zb2xlLmVycm9yKCdlcnJvciB3aGVuIHRyeWluZyB0byBwaXBlJywgZSkpXG4gICAgICAuZmluYWxseSgoKSA9PiB0aGlzLmRlc3Ryb3koKSk7XG5cbiAgICB0aGlzLnByb2Nlc3NlZFRyYWNrID0gdGhpcy50cmFja0dlbmVyYXRvciBhcyBNZWRpYVN0cmVhbVZpZGVvVHJhY2s7XG4gIH1cblxuICBwcml2YXRlIGluaXRGYWxsYmFja1BhdGgoKSB7XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkU3RyZWFtIHx8ICF0aGlzLnNvdXJjZSB8fCAhdGhpcy5jYW52YXMgfHwgIXRoaXMucmVuZGVyQ29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyByZXF1aXJlZCBjb21wb25lbnRzIGZvciBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc2VkVHJhY2sgPSB0aGlzLmNhcHR1cmVkU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgdGhpcy5wcm9jZXNzaW5nRW5hYmxlZCA9IHRydWU7XG5cbiAgICAvLyBTZXQgdXAgdGhlIGZyYW1lIGNhbGxiYWNrIGZvciB0aGUgdHJhbnNmb3JtZXJcbiAgICB0aGlzLmZyYW1lQ2FsbGJhY2sgPSAoZnJhbWU6IFZpZGVvRnJhbWUpID0+IHtcbiAgICAgIGlmICghdGhpcy5wcm9jZXNzaW5nRW5hYmxlZCB8fCAhZnJhbWUpIHtcbiAgICAgICAgZnJhbWUuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250cm9sbGVyID0ge1xuICAgICAgICBlbnF1ZXVlOiAocHJvY2Vzc2VkRnJhbWU6IFZpZGVvRnJhbWUpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJDb250ZXh0ICYmIHRoaXMuZGlzcGxheUNhbnZhcykge1xuICAgICAgICAgICAgLy8gRHJhdyB0aGUgcHJvY2Vzc2VkIGZyYW1lIHRvIHRoZSB2aXNpYmxlIGNhbnZhc1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkRnJhbWUsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHRoaXMuZGlzcGxheUNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5Q2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwcm9jZXNzZWRGcmFtZS5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0gYXMgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VmlkZW9GcmFtZT47XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFBhc3MgdGhlIGZyYW1lIHRocm91Z2ggb3VyIHRyYW5zZm9ybWVyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUaGUgY29udHJvbGxlciBleHBlY3RzIGJvdGggVmlkZW9GcmFtZSAmIEF1ZGlvRGF0YSBidXQgd2UncmUgb25seSB1c2luZyBWaWRlb0ZyYW1lXG4gICAgICAgIHRoaXMudHJhbnNmb3JtZXIudHJhbnNmb3JtKGZyYW1lLCBjb250cm9sbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdHJhbnNmb3JtOicsIGUpO1xuICAgICAgICBmcmFtZS5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTdGFydCB0aGUgcmVuZGVyaW5nIGxvb3BcbiAgICB0aGlzLnN0YXJ0UmVuZGVyTG9vcCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGFydFJlbmRlckxvb3AoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZUR1bW15IHx8ICEodGhpcy5zb3VyY2VEdW1teSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgdGhlIGxhc3QgcHJvY2Vzc2VkIHRpbWVzdGFtcCB0byBhdm9pZCBkdXBsaWNhdGUgcHJvY2Vzc2luZ1xuICAgIGxldCBsYXN0VmlkZW9UaW1lc3RhbXAgPSAtMTtcbiAgICBsZXQgbGFzdEZyYW1lVGltZSA9IDA7XG4gICAgY29uc3QgdmlkZW9FbGVtZW50ID0gdGhpcy5zb3VyY2VEdW1teSBhcyBIVE1MVmlkZW9FbGVtZW50O1xuICAgIGNvbnN0IG1pbkZyYW1lSW50ZXJ2YWwgPSAxMDAwIC8gdGhpcy5tYXhGcHM7IC8vIE1pbmltdW0gdGltZSBiZXR3ZWVuIGZyYW1lc1xuXG4gICAgLy8gRXN0aW1hdGUgdGhlIHZpZGVvJ3MgbmF0aXZlIGZyYW1lIHJhdGVcbiAgICBsZXQgZXN0aW1hdGVkVmlkZW9GcHMgPSB0aGlzLm1heEZwcztcbiAgICBsZXQgZnJhbWVUaW1lSGlzdG9yeTogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgbGFzdFZpZGVvVGltZUNoYW5nZSA9IDA7XG4gICAgbGV0IGZyYW1lQ291bnQgPSAwO1xuICAgIGxldCBsYXN0RnBzTG9nID0gMDtcblxuICAgIGNvbnN0IHJlbmRlckxvb3AgPSAoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLnByb2Nlc3NpbmdFbmFibGVkIHx8XG4gICAgICAgICF0aGlzLnNvdXJjZUR1bW15IHx8XG4gICAgICAgICEodGhpcy5zb3VyY2VEdW1teSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VEdW1teS5wYXVzZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdWaWRlbyBpcyBwYXVzZWQsIHRyeWluZyB0byBwbGF5Jyk7XG4gICAgICAgIHRoaXMuc291cmNlRHVtbXkucGxheSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgcHJvY2VzcyBhIG5ldyBmcmFtZSBpZiB0aGUgdmlkZW8gaGFzIGFjdHVhbGx5IHVwZGF0ZWRcbiAgICAgIGNvbnN0IHZpZGVvVGltZSA9IHZpZGVvRWxlbWVudC5jdXJyZW50VGltZTtcbiAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEZyYW1lID0gbm93IC0gbGFzdEZyYW1lVGltZTtcblxuICAgICAgLy8gRGV0ZWN0IGlmIHZpZGVvIGhhcyBhIG5ldyBmcmFtZVxuICAgICAgY29uc3QgaGFzTmV3RnJhbWUgPSB2aWRlb1RpbWUgIT09IGxhc3RWaWRlb1RpbWVzdGFtcDtcblxuICAgICAgLy8gVXBkYXRlIGZyYW1lIHJhdGUgZXN0aW1hdGlvbiBpZiB3ZSBoYXZlIGEgbmV3IGZyYW1lXG4gICAgICBpZiAoaGFzTmV3RnJhbWUpIHtcbiAgICAgICAgaWYgKGxhc3RWaWRlb1RpbWVDaGFuZ2UgPiAwKSB7XG4gICAgICAgICAgY29uc3QgdGltZUJldHdlZW5GcmFtZXMgPSBub3cgLSBsYXN0VmlkZW9UaW1lQ2hhbmdlO1xuICAgICAgICAgIGZyYW1lVGltZUhpc3RvcnkucHVzaCh0aW1lQmV0d2VlbkZyYW1lcyk7XG5cbiAgICAgICAgICAvLyBLZWVwIGEgcm9sbGluZyB3aW5kb3cgb2YgdGhlIGxhc3QgMTAgZnJhbWUgdGltZXNcbiAgICAgICAgICBpZiAoZnJhbWVUaW1lSGlzdG9yeS5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgZnJhbWVUaW1lSGlzdG9yeS5zaGlmdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIGZyYW1lIGludGVydmFsXG4gICAgICAgICAgaWYgKGZyYW1lVGltZUhpc3RvcnkubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29uc3QgYXZnRnJhbWVUaW1lID1cbiAgICAgICAgICAgICAgZnJhbWVUaW1lSGlzdG9yeS5yZWR1Y2UoKHN1bSwgdGltZSkgPT4gc3VtICsgdGltZSwgMCkgLyBmcmFtZVRpbWVIaXN0b3J5Lmxlbmd0aDtcbiAgICAgICAgICAgIGVzdGltYXRlZFZpZGVvRnBzID0gMTAwMCAvIGF2Z0ZyYW1lVGltZTtcblxuICAgICAgICAgICAgLy8gTG9nIGVzdGltYXRlZCBGUFMgZXZlcnkgNSBzZWNvbmRzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gVXNlIGEgc2ltcGxlciBjaGVjayB0aGF0IHdvcmtzIGluIGJyb3dzZXJzIHdpdGhvdXQgcHJvY2Vzcy5lbnZcbiAgICAgICAgICAgIGNvbnN0IGlzRGV2ZWxvcG1lbnQgPVxuICAgICAgICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JykgfHxcbiAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lID09PSAnMTI3LjAuMC4xJztcblxuICAgICAgICAgICAgaWYgKGlzRGV2ZWxvcG1lbnQgJiYgbm93IC0gbGFzdEZwc0xvZyA+IDUwMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBgWyR7dGhpcy5uYW1lfV0gRXN0aW1hdGVkIHZpZGVvIEZQUzogJHtlc3RpbWF0ZWRWaWRlb0Zwcy50b0ZpeGVkKFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICApfSwgUHJvY2Vzc2luZyBhdDogJHsoZnJhbWVDb3VudCAvIDUpLnRvRml4ZWQoMSl9IEZQU2AsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZyYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgICBsYXN0RnBzTG9nID0gbm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0VmlkZW9UaW1lQ2hhbmdlID0gbm93O1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHByb2Nlc3MgdGhpcyBmcmFtZVxuICAgICAgLy8gV2UnbGwgcHJvY2VzcyBpZjpcbiAgICAgIC8vIDEuIFRoZSB2aWRlbyBoYXMgYSBuZXcgZnJhbWVcbiAgICAgIC8vIDIuIEVub3VnaCB0aW1lIGhhcyBwYXNzZWQgc2luY2UgbGFzdCBmcmFtZSAocmVzcGVjdGluZyBtYXhGcHMpXG4gICAgICBjb25zdCB0aW1lVGhyZXNob2xkTWV0ID0gdGltZVNpbmNlTGFzdEZyYW1lID49IG1pbkZyYW1lSW50ZXJ2YWw7XG5cbiAgICAgIGlmIChoYXNOZXdGcmFtZSAmJiB0aW1lVGhyZXNob2xkTWV0KSB7XG4gICAgICAgIGxhc3RWaWRlb1RpbWVzdGFtcCA9IHZpZGVvVGltZTtcbiAgICAgICAgbGFzdEZyYW1lVGltZSA9IG5vdztcbiAgICAgICAgZnJhbWVDb3VudCsrO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgVmlkZW9GcmFtZSBmcm9tIHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5yZWFkeVN0YXRlID49IEhUTUxNZWRpYUVsZW1lbnQuSEFWRV9DVVJSRU5UX0RBVEEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFZpZGVvRnJhbWUodmlkZW9FbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5mcmFtZUNhbGxiYWNrKGZyYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyYW1lLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcmVuZGVyIGxvb3A6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJMb29wKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckxvb3ApO1xuICB9XG5cbiAgYXN5bmMgcmVzdGFydChvcHRzOiBQcm9jZXNzb3JPcHRpb25zPFRyYWNrLktpbmQ+KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5kZXN0cm95KCk7XG4gICAgYXdhaXQgdGhpcy5pbml0KG9wdHMpO1xuICB9XG5cbiAgYXN5bmMgcmVzdGFydFRyYW5zZm9ybWVyKC4uLm9wdGlvbnM6IFBhcmFtZXRlcnM8KHR5cGVvZiB0aGlzLnRyYW5zZm9ybWVyKVsncmVzdGFydCddPikge1xuICAgIC8vIEB0cy1pZ25vcmUgdW5jbGVhciB3aHkgdGhlIHJlc3RhcnQgbWV0aG9kIG9ubHkgYWNjZXB0cyBWaWRlb1RyYW5zZm9ybWVySW5pdE9wdGlvbnMgaW5zdGVhZCBvZiBlaXRoZXIgdGhvc2Ugb3IgQXVkaW9UcmFuc2Zvcm1lckluaXRPcHRpb25zXG4gICAgYXdhaXQgdGhpcy50cmFuc2Zvcm1lci5yZXN0YXJ0KG9wdGlvbnNbMF0pO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlVHJhbnNmb3JtZXJPcHRpb25zKC4uLm9wdGlvbnM6IFBhcmFtZXRlcnM8KHR5cGVvZiB0aGlzLnRyYW5zZm9ybWVyKVsndXBkYXRlJ10+KSB7XG4gICAgYXdhaXQgdGhpcy50cmFuc2Zvcm1lci51cGRhdGUob3B0aW9uc1swXSk7XG4gIH1cblxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnVzZVN0cmVhbUZhbGxiYWNrKSB7XG4gICAgICB0aGlzLnByb2Nlc3NpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5hbmltYXRpb25GcmFtZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVJZCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRpc3BsYXlDYW52YXMgJiYgdGhpcy5kaXNwbGF5Q2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5Q2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kaXNwbGF5Q2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FwdHVyZWRTdHJlYW0/LmdldFRyYWNrcygpLmZvckVhY2goKHRyYWNrKSA9PiB0cmFjay5zdG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3Nvcj8ud3JpdGFibGVDb250cm9sPy5jbG9zZSgpO1xuICAgICAgdGhpcy50cmFja0dlbmVyYXRvcj8uc3RvcCgpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnRyYW5zZm9ybWVyLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgdmlzaW9uIGZyb20gJ0BtZWRpYXBpcGUvdGFza3MtdmlzaW9uJztcbmltcG9ydCB7IGRlcGVuZGVuY2llcyB9IGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgVmlkZW9UcmFuc2Zvcm1lciBmcm9tICcuL1ZpZGVvVHJhbnNmb3JtZXInO1xuaW1wb3J0IHsgVmlkZW9UcmFuc2Zvcm1lckluaXRPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFNlZ21lbnRlck9wdGlvbnMgPSBQYXJ0aWFsPHZpc2lvbi5JbWFnZVNlZ21lbnRlck9wdGlvbnNbJ2Jhc2VPcHRpb25zJ10+O1xuXG5leHBvcnQgaW50ZXJmYWNlIEZyYW1lUHJvY2Vzc2luZ1N0YXRzIHtcbiAgcHJvY2Vzc2luZ1RpbWVNczogbnVtYmVyO1xuICBzZWdtZW50YXRpb25UaW1lTXM6IG51bWJlcjtcbiAgZmlsdGVyVGltZU1zOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIEJhY2tncm91bmRPcHRpb25zID0ge1xuICBibHVyUmFkaXVzPzogbnVtYmVyO1xuICBpbWFnZVBhdGg/OiBzdHJpbmc7XG4gIC8qKiBjYW5ub3QgYmUgdXBkYXRlZCB0aHJvdWdoIHRoZSBgdXBkYXRlYCBtZXRob2QsIG5lZWRzIGEgcmVzdGFydCAqL1xuICBzZWdtZW50ZXJPcHRpb25zPzogU2VnbWVudGVyT3B0aW9ucztcbiAgLyoqIGNhbm5vdCBiZSB1cGRhdGVkIHRocm91Z2ggdGhlIGB1cGRhdGVgIG1ldGhvZCwgbmVlZHMgYSByZXN0YXJ0ICovXG4gIGFzc2V0UGF0aHM/OiB7IHRhc2tzVmlzaW9uRmlsZVNldD86IHN0cmluZzsgbW9kZWxBc3NldFBhdGg/OiBzdHJpbmcgfTtcbiAgLyoqIGNhbGxlZCB3aGVuIGEgbmV3IGZyYW1lIGlzIHByb2Nlc3NlZCAqL1xuICBvbkZyYW1lUHJvY2Vzc2VkPzogKHN0YXRzOiBGcmFtZVByb2Nlc3NpbmdTdGF0cykgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tncm91bmRQcm9jZXNzb3IgZXh0ZW5kcyBWaWRlb1RyYW5zZm9ybWVyPEJhY2tncm91bmRPcHRpb25zPiB7XG4gIHN0YXRpYyBnZXQgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgVmlkZW9GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnd2ViZ2wyJylcbiAgICApO1xuICB9XG5cbiAgaW1hZ2VTZWdtZW50ZXI/OiB2aXNpb24uSW1hZ2VTZWdtZW50ZXI7XG5cbiAgc2VnbWVudGF0aW9uUmVzdWx0czogdmlzaW9uLkltYWdlU2VnbWVudGVyUmVzdWx0IHwgdW5kZWZpbmVkO1xuXG4gIGJhY2tncm91bmRJbWFnZTogSW1hZ2VCaXRtYXAgfCBudWxsID0gbnVsbDtcblxuICBvcHRpb25zOiBCYWNrZ3JvdW5kT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBCYWNrZ3JvdW5kT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0cztcbiAgICB0aGlzLnVwZGF0ZShvcHRzKTtcbiAgfVxuXG4gIGFzeW5jIGluaXQoeyBvdXRwdXRDYW52YXMsIGlucHV0RWxlbWVudDogaW5wdXRWaWRlbyB9OiBWaWRlb1RyYW5zZm9ybWVySW5pdE9wdGlvbnMpIHtcbiAgICAvLyBJbml0aWFsaXplIFdlYkdMIHdpdGggYXBwcm9wcmlhdGUgb3B0aW9ucyBiYXNlZCBvbiBvdXIgY3VycmVudCBzdGF0ZVxuXG4gICAgYXdhaXQgc3VwZXIuaW5pdCh7IG91dHB1dENhbnZhcywgaW5wdXRFbGVtZW50OiBpbnB1dFZpZGVvIH0pO1xuXG4gICAgY29uc3QgZmlsZVNldCA9IGF3YWl0IHZpc2lvbi5GaWxlc2V0UmVzb2x2ZXIuZm9yVmlzaW9uVGFza3MoXG4gICAgICB0aGlzLm9wdGlvbnMuYXNzZXRQYXRocz8udGFza3NWaXNpb25GaWxlU2V0ID8/XG4gICAgICAgIGBodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BtZWRpYXBpcGUvdGFza3MtdmlzaW9uQCR7ZGVwZW5kZW5jaWVzWydAbWVkaWFwaXBlL3Rhc2tzLXZpc2lvbiddfS93YXNtYCxcbiAgICApO1xuXG4gICAgdGhpcy5pbWFnZVNlZ21lbnRlciA9IGF3YWl0IHZpc2lvbi5JbWFnZVNlZ21lbnRlci5jcmVhdGVGcm9tT3B0aW9ucyhmaWxlU2V0LCB7XG4gICAgICBiYXNlT3B0aW9uczoge1xuICAgICAgICBtb2RlbEFzc2V0UGF0aDpcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYXNzZXRQYXRocz8ubW9kZWxBc3NldFBhdGggPz9cbiAgICAgICAgICAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL21lZGlhcGlwZS1tb2RlbHMvaW1hZ2Vfc2VnbWVudGVyL3NlbGZpZV9zZWdtZW50ZXIvZmxvYXQxNi9sYXRlc3Qvc2VsZmllX3NlZ21lbnRlci50ZmxpdGUnLFxuICAgICAgICBkZWxlZ2F0ZTogJ0dQVScsXG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5zZWdtZW50ZXJPcHRpb25zLFxuICAgICAgfSxcbiAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICBydW5uaW5nTW9kZTogJ1ZJREVPJyxcbiAgICAgIG91dHB1dENhdGVnb3J5TWFzazogdHJ1ZSxcbiAgICAgIG91dHB1dENvbmZpZGVuY2VNYXNrczogZmFsc2UsXG4gICAgfSk7XG5cbiAgICAvLyBTa2lwIGxvYWRpbmcgdGhlIGltYWdlIGhlcmUgaWYgdXBkYXRlIGFscmVhZHkgbG9hZGVkIHRoZSBpbWFnZSBiZWxvd1xuICAgIGlmICh0aGlzLm9wdGlvbnM/LmltYWdlUGF0aCAmJiAhdGhpcy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgIGF3YWl0IHRoaXMubG9hZEJhY2tncm91bmQodGhpcy5vcHRpb25zLmltYWdlUGF0aCkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2hpbGUgbG9hZGluZyBwcm9jZXNzb3IgYmFja2dyb3VuZCBpbWFnZTogJywgZXJyKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmx1clJhZGl1cykge1xuICAgICAgdGhpcy5nbD8uc2V0Qmx1clJhZGl1cyh0aGlzLm9wdGlvbnMuYmx1clJhZGl1cyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICBhd2FpdCBzdXBlci5kZXN0cm95KCk7XG4gICAgYXdhaXQgdGhpcy5pbWFnZVNlZ21lbnRlcj8uY2xvc2UoKTtcbiAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gIH1cblxuICBhc3luYyBsb2FkQmFja2dyb3VuZChwYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcbiAgICAgIGltZy5vbmVycm9yID0gKGVycikgPT4gcmVqZWN0KGVycik7XG4gICAgICBpbWcuc3JjID0gcGF0aDtcbiAgICB9KTtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWcpO1xuICAgIHRoaXMuZ2w/LnNldEJhY2tncm91bmRJbWFnZShpbWFnZURhdGEpO1xuICB9XG5cbiAgYXN5bmMgdHJhbnNmb3JtKGZyYW1lOiBWaWRlb0ZyYW1lLCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxWaWRlb0ZyYW1lPikge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIShmcmFtZSBpbnN0YW5jZW9mIFZpZGVvRnJhbWUpIHx8IGZyYW1lLmNvZGVkV2lkdGggPT09IDAgfHwgZnJhbWUuY29kZWRIZWlnaHQgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnZW1wdHkgZnJhbWUgZGV0ZWN0ZWQsIGlnbm9yaW5nJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZnJhbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignQ2FudmFzIG5lZWRzIHRvIGJlIGluaXRpYWxpemVkIGZpcnN0Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGZyYW1lLmRpc3BsYXlXaWR0aDtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGZyYW1lLmRpc3BsYXlIZWlnaHQ7XG4gICAgICBsZXQgc3RhcnRUaW1lTXMgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgdGhpcy5pbWFnZVNlZ21lbnRlcj8uc2VnbWVudEZvclZpZGVvKGZyYW1lLCBzdGFydFRpbWVNcywgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCBzZWdtZW50YXRpb25UaW1lTXMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZU1zO1xuICAgICAgICB0aGlzLnNlZ21lbnRhdGlvblJlc3VsdHMgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuZHJhd0ZyYW1lKGZyYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLndpZHRoID4gMCAmJiB0aGlzLmNhbnZhcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3RnJhbWUgPSBuZXcgVmlkZW9GcmFtZSh0aGlzLmNhbnZhcywge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBmcmFtZS50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJUaW1lTXMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZU1zIC0gc2VnbWVudGF0aW9uVGltZU1zO1xuICAgICAgICAgIGNvbnN0IHN0YXRzOiBGcmFtZVByb2Nlc3NpbmdTdGF0cyA9IHtcbiAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lTXM6IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lTXMsXG4gICAgICAgICAgICBzZWdtZW50YXRpb25UaW1lTXMsXG4gICAgICAgICAgICBmaWx0ZXJUaW1lTXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25GcmFtZVByb2Nlc3NlZD8uKHN0YXRzKTtcblxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXdGcmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZS5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2hpbGUgcHJvY2Vzc2luZyBmcmFtZTogJywgZSk7XG4gICAgICBmcmFtZT8uY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1cGRhdGUob3B0czogQmFja2dyb3VuZE9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0cyB9O1xuICAgIGlmIChvcHRzLmJsdXJSYWRpdXMpIHtcbiAgICAgIHRoaXMuZ2w/LnNldEJsdXJSYWRpdXMob3B0cy5ibHVyUmFkaXVzKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuaW1hZ2VQYXRoKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvYWRCYWNrZ3JvdW5kKG9wdHMuaW1hZ2VQYXRoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkcmF3RnJhbWUoZnJhbWU6IFZpZGVvRnJhbWUpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmdsIHx8ICF0aGlzLnNlZ21lbnRhdGlvblJlc3VsdHMgfHwgIXRoaXMuaW5wdXRWaWRlbykgcmV0dXJuO1xuXG4gICAgY29uc3QgbWFzayA9IHRoaXMuc2VnbWVudGF0aW9uUmVzdWx0cy5jYXRlZ29yeU1hc2s7XG4gICAgaWYgKG1hc2spIHtcbiAgICAgIHRoaXMuZ2wucmVuZGVyKGZyYW1lLCBtYXNrKTtcbiAgICB9XG4gIH1cbn1cbiIsIntcbiAgXCJuYW1lXCI6IFwiQGxpdmVraXQvdHJhY2stcHJvY2Vzc29yc1wiLFxuICBcInZlcnNpb25cIjogXCIwLjUuNFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTGl2ZUtpdCB0cmFjayBwcm9jZXNzb3JzXCIsXG4gIFwibWFpblwiOiBcImRpc3QvaW5kZXguanNcIixcbiAgXCJtb2R1bGVcIjogXCJkaXN0L2luZGV4Lm1qc1wiLFxuICBcInNvdXJjZVwiOiBcInNyYy9pbmRleC50c1wiLFxuICBcInR5cGVzXCI6IFwiZGlzdC9zcmMvaW5kZXguZC50c1wiLFxuICBcInJlcG9zaXRvcnlcIjogXCJnaXRAZ2l0aHViLmNvbTpsaXZla2l0L2xpdmVraXQtdHJhY2stcHJvY2Vzc29ycy5naXRcIixcbiAgXCJhdXRob3JcIjogXCJMdWthcyBTZWlsZXJcIixcbiAgXCJsaWNlbnNlXCI6IFwiQXBhY2hlLTIuMFwiLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnVpbGRcIjogXCJ0c3VwIC0tb25TdWNjZXNzIFxcXCJ0c2MgLS1kZWNsYXJhdGlvbiAtLWVtaXREZWNsYXJhdGlvbk9ubHlcXFwiXCIsXG4gICAgXCJidWlsZC1zYW1wbGVcIjogXCJjZCBleGFtcGxlICYmIHZpdGUgYnVpbGRcIixcbiAgICBcImxpbnRcIjogXCJlc2xpbnQgc3JjXCIsXG4gICAgXCJyZWxlYXNlXCI6IFwicG5wbSBidWlsZCAmJiBjaGFuZ2VzZXQgcHVibGlzaFwiLFxuICAgIFwidGVzdFwiOiBcImplc3RcIixcbiAgICBcInNhbXBsZVwiOiBcInZpdGUgc2VydmUgZXhhbXBsZSAtLXBvcnQgODA4MCAtLW9wZW5cIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcInNyY1wiXG4gIF0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBtZWRpYXBpcGUvdGFza3MtdmlzaW9uXCI6IFwiMC4xMC4xNFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJsaXZla2l0LWNsaWVudFwiOiBcIl4xLjEyLjAgfHwgXjIuMS4wXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGNoYW5nZXNldHMvY2xpXCI6IFwiXjIuMjYuMlwiLFxuICAgIFwiQGxpdmVraXQvY2hhbmdlc2V0cy1jaGFuZ2Vsb2ctZ2l0aHViXCI6IFwiXjAuMC40XCIsXG4gICAgXCJAdHJpdmFnby9wcmV0dGllci1wbHVnaW4tc29ydC1pbXBvcnRzXCI6IFwiXjQuMi4xXCIsXG4gICAgXCJAdHlwZXMvZG9tLW1lZGlhY2FwdHVyZS10cmFuc2Zvcm1cIjogXCJeMC4xLjlcIixcbiAgICBcIkB0eXBlcy9vZmZzY3JlZW5jYW52YXNcIjogXCJeMjAxOS43LjNcIixcbiAgICBcIkB0eXBlc2NyaXB0LWVzbGludC9lc2xpbnQtcGx1Z2luXCI6IFwiXjUuNjIuMFwiLFxuICAgIFwiZXNsaW50XCI6IFwiOC4zOS4wXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLWFpcmJuYi10eXBlc2NyaXB0XCI6IFwiMTcuMC4wXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXByZXR0aWVyXCI6IFwiOC44LjBcIixcbiAgICBcImVzbGludC1wbHVnaW4tZWNtYXNjcmlwdC1jb21wYXRcIjogXCJeMy4xLjBcIixcbiAgICBcImVzbGludC1wbHVnaW4taW1wb3J0XCI6IFwiMi4yNy41XCIsXG4gICAgXCJwcmV0dGllclwiOiBcIl4yLjguOFwiLFxuICAgIFwidHN1cFwiOiBcIl43LjIuMFwiLFxuICAgIFwidHlwZXNjcmlwdFwiOiBcIl41LjguM1wiLFxuICAgIFwidml0ZVwiOiBcIl40LjUuMFwiXG4gIH0sXG4gIFwicGFja2FnZU1hbmFnZXJcIjogXCJwbnBtQDkuMTUuOStzaGE1MTIuNjgwNDYxNDE4OTNjNjZmYWQwMWMwNzkyMzExMjhlOWFmYjg5ZWY4N2UyNjkxZDY5ZTRkNDBlZWUyMjg5ODgyOTVmZDQ2ODIxODFiYWU1NWI1ODQxOGMzYTI1M2JkZTY1YTUwNWVjN2M1Zjk0MDNlY2U1Y2MzY2QzN2RjZjI1MzFcIlxufVxuIiwiLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViR0wgdGV4dHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdFRleHR1cmUoZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIHRleEluZGV4OiBudW1iZXIpIHtcbiAgY29uc3QgdGV4UmVmID0gZ2wuVEVYVFVSRTAgKyB0ZXhJbmRleDtcbiAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXhSZWYpO1xuICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG4gIHJldHVybiB0ZXh0dXJlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFdlYkdMIGZyYW1lYnVmZmVyIHdpdGggdGhlIGdpdmVuIHRleHR1cmUgYXMgY29sb3IgYXR0YWNobWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXIoXG4gIGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LFxuICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuKSB7XG4gIGNvbnN0IGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG5cbiAgLy8gU2V0IHRoZSB0ZXh0dXJlIGFzIHRoZSBjb2xvciBhdHRhY2htZW50XG4gIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG5cbiAgLy8gRW5zdXJlIHRleHR1cmUgZGltZW5zaW9ucyBtYXRjaCB0aGUgcHJvdmlkZWQgd2lkdGggYW5kIGhlaWdodFxuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAvLyBDaGVjayBpZiBmcmFtZWJ1ZmZlciBpcyBjb21wbGV0ZVxuICBjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgaWYgKHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZScpO1xuICB9XG5cbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgcmV0dXJuIGZyYW1lYnVmZmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHZlcnRleCBidWZmZXIgZm9yIGEgZnVsbC1zY3JlZW4gcXVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmVydGV4QnVmZmVyKGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KTogV2ViR0xCdWZmZXIgfCBudWxsIHtcbiAgY29uc3QgdmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpO1xuICBnbC5idWZmZXJEYXRhKFxuICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIC0xLCAxLCAxLCAxLCAtMSwgLTEsIDEsIDEsIDEsIC0xXSksXG4gICAgZ2wuU1RBVElDX0RSQVcsXG4gICk7XG4gIHJldHVybiB2ZXJ0ZXhCdWZmZXI7XG59XG5cbi8qKlxuICogUmVzaXplcyBhbmQgY3JvcHMgYW4gaW1hZ2UgdG8gY292ZXIgYSB0YXJnZXQgY2FudmFzIHdoaWxlIG1haW50YWluaW5nIGFzcGVjdCByYXRpb1xuICogQHBhcmFtIGltYWdlIFRoZSBzb3VyY2UgaW1hZ2VcbiAqIEBwYXJhbSB0YXJnZXRXaWR0aCBUaGUgdGFyZ2V0IHdpZHRoXG4gKiBAcGFyYW0gdGFyZ2V0SGVpZ2h0IFRoZSB0YXJnZXQgaGVpZ2h0XG4gKiBAcmV0dXJucyBBIGNyb3BwZWQgYW5kIHJlc2l6ZWQgSW1hZ2VCaXRtYXBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc2l6ZUltYWdlVG9Db3ZlcihcbiAgaW1hZ2U6IEltYWdlQml0bWFwLFxuICB0YXJnZXRXaWR0aDogbnVtYmVyLFxuICB0YXJnZXRIZWlnaHQ6IG51bWJlcixcbik6IFByb21pc2U8SW1hZ2VCaXRtYXA+IHtcbiAgLy8gQ2FsY3VsYXRlIGRpbWVuc2lvbnMgYW5kIGNyb3AgZm9yIFwiY292ZXJcIiBtb2RlXG4gIGNvbnN0IGltZ0FzcGVjdCA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0O1xuICBjb25zdCB0YXJnZXRBc3BlY3QgPSB0YXJnZXRXaWR0aCAvIHRhcmdldEhlaWdodDtcblxuICBsZXQgc3ggPSAwO1xuICBsZXQgc3kgPSAwO1xuICBsZXQgc1dpZHRoID0gaW1hZ2Uud2lkdGg7XG4gIGxldCBzSGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gIC8vIEZvciBjb3ZlciBtb2RlLCB3ZSBuZWVkIHRvIGNyb3Agc29tZSBwYXJ0cyBvZiB0aGUgaW1hZ2VcbiAgLy8gdG8gZW5zdXJlIGl0IGNvdmVycyB0aGUgY2FudmFzIHdoaWxlIG1haW50YWluaW5nIGFzcGVjdCByYXRpb1xuICBpZiAoaW1nQXNwZWN0ID4gdGFyZ2V0QXNwZWN0KSB7XG4gICAgLy8gSW1hZ2UgaXMgd2lkZXIgdGhhbiB0YXJnZXQgLSBjcm9wIHRoZSBzaWRlc1xuICAgIHNXaWR0aCA9IE1hdGgucm91bmQoaW1hZ2UuaGVpZ2h0ICogdGFyZ2V0QXNwZWN0KTtcbiAgICBzeCA9IE1hdGgucm91bmQoKGltYWdlLndpZHRoIC0gc1dpZHRoKSAvIDIpOyAvLyBDZW50ZXIgdGhlIGNyb3AgaG9yaXpvbnRhbGx5XG4gIH0gZWxzZSBpZiAoaW1nQXNwZWN0IDwgdGFyZ2V0QXNwZWN0KSB7XG4gICAgLy8gSW1hZ2UgaXMgdGFsbGVyIHRoYW4gdGFyZ2V0IC0gY3JvcCB0aGUgdG9wL2JvdHRvbVxuICAgIHNIZWlnaHQgPSBNYXRoLnJvdW5kKGltYWdlLndpZHRoIC8gdGFyZ2V0QXNwZWN0KTtcbiAgICBzeSA9IE1hdGgucm91bmQoKGltYWdlLmhlaWdodCAtIHNIZWlnaHQpIC8gMik7IC8vIENlbnRlciB0aGUgY3JvcCB2ZXJ0aWNhbGx5XG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgSW1hZ2VCaXRtYXAgd2l0aCB0aGUgY3JvcHBlZCBwb3J0aW9uXG4gIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSwgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsIHtcbiAgICByZXNpemVXaWR0aDogdGFyZ2V0V2lkdGgsXG4gICAgcmVzaXplSGVpZ2h0OiB0YXJnZXRIZWlnaHQsXG4gICAgcmVzaXplUXVhbGl0eTogJ21lZGl1bScsXG4gIH0pO1xufVxuXG5jb25zdCBlbXB0eUltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEoMiwgMik7XG5lbXB0eUltYWdlRGF0YS5kYXRhWzBdID0gMDtcbmVtcHR5SW1hZ2VEYXRhLmRhdGFbMV0gPSAwO1xuZW1wdHlJbWFnZURhdGEuZGF0YVsyXSA9IDA7XG5lbXB0eUltYWdlRGF0YS5kYXRhWzNdID0gMDtcblxuY29uc3QgZ2xzbCA9IChzb3VyY2U6IGFueSkgPT4gc291cmNlO1xuXG5leHBvcnQgeyBlbXB0eUltYWdlRGF0YSwgZ2xzbCB9O1xuIiwiLy8gVmVydGV4IHNoYWRlciBzb3VyY2VcbmV4cG9ydCBjb25zdCB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSAoZmxpcFk6IGJvb2xlYW4gPSB0cnVlKSA9PiBgI3ZlcnNpb24gMzAwIGVzXG4gIGluIHZlYzIgcG9zaXRpb247XG4gIG91dCB2ZWMyIHRleENvb3JkcztcblxuICB2b2lkIG1haW4oKSB7XG4gICAgdGV4Q29vcmRzID0gKHBvc2l0aW9uICsgMS4wKSAvIDIuMDtcbiAgICB0ZXhDb29yZHMueSA9ICR7ZmxpcFkgPyAnMS4wIC0gdGV4Q29vcmRzLnknIDogJ3RleENvb3Jkcy55J307XG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLCAxLjApO1xuICB9XG5gO1xuIiwiaW1wb3J0IHsgZ2xzbCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHZlcnRleFNoYWRlclNvdXJjZSB9IGZyb20gJy4vdmVydGV4U2hhZGVyJztcblxuLy8gRGVmaW5lIHRoZSBibHVyIGZyYWdtZW50IHNoYWRlclxuZXhwb3J0IGNvbnN0IGJsdXJGcmFnbWVudFNoYWRlciA9IGdsc2xgI3ZlcnNpb24gMzAwIGVzXG4gIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgaW4gdmVjMiB0ZXhDb29yZHM7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcbiAgdW5pZm9ybSB2ZWMyIHVfdGV4ZWxTaXplO1xuICB1bmlmb3JtIHZlYzIgdV9kaXJlY3Rpb247XG4gIHVuaWZvcm0gZmxvYXQgdV9yYWRpdXM7XG4gIG91dCB2ZWM0IGZyYWdDb2xvcjtcblxuICB2b2lkIG1haW4oKSB7XG4gICAgZmxvYXQgc2lnbWEgPSB1X3JhZGl1cztcbiAgICBmbG9hdCB0d29TaWdtYVNxID0gMi4wICogc2lnbWEgKiBzaWdtYTtcbiAgICBmbG9hdCB0b3RhbFdlaWdodCA9IDAuMDtcbiAgICB2ZWMzIHJlc3VsdCA9IHZlYzMoMC4wKTtcbiAgICBjb25zdCBpbnQgTUFYX1NBTVBMRVMgPSAxNjtcbiAgICBpbnQgcmFkaXVzID0gaW50KG1pbihmbG9hdChNQVhfU0FNUExFUyksIGNlaWwodV9yYWRpdXMpKSk7XG5cbiAgICBmb3IgKGludCBpID0gLU1BWF9TQU1QTEVTOyBpIDw9IE1BWF9TQU1QTEVTOyArK2kpIHtcbiAgICAgIGZsb2F0IG9mZnNldCA9IGZsb2F0KGkpO1xuICAgICAgaWYgKGFicyhvZmZzZXQpID4gZmxvYXQocmFkaXVzKSkgY29udGludWU7XG4gICAgICBmbG9hdCB3ZWlnaHQgPSBleHAoLShvZmZzZXQgKiBvZmZzZXQpIC8gdHdvU2lnbWFTcSk7XG4gICAgICB2ZWMyIHNhbXBsZUNvb3JkID0gdGV4Q29vcmRzICsgdV9kaXJlY3Rpb24gKiB1X3RleGVsU2l6ZSAqIG9mZnNldDtcbiAgICAgIHJlc3VsdCArPSB0ZXh0dXJlKHVfdGV4dHVyZSwgc2FtcGxlQ29vcmQpLnJnYiAqIHdlaWdodDtcbiAgICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcbiAgICB9XG5cbiAgICBmcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCAvIHRvdGFsV2VpZ2h0LCAxLjApO1xuICB9XG5gO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmx1clByb2dyYW0oZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgLy8gQ3JlYXRlIGJsdXIgc2hhZGVyXG4gIGNvbnN0IGJsdXJGcmFnID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gIGlmICghYmx1ckZyYWcpIHtcbiAgICB0aHJvdyBFcnJvcignY2Fubm90IGNyZWF0ZSBibHVyIHNoYWRlcicpO1xuICB9XG4gIGdsLnNoYWRlclNvdXJjZShibHVyRnJhZywgYmx1ckZyYWdtZW50U2hhZGVyKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihibHVyRnJhZyk7XG5cbiAgLy8gR2V0IGNvbXBpbGUgc3RhdHVzIGFuZCBsb2cgZXJyb3JzIGlmIGFueVxuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihibHVyRnJhZywgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgY29uc3QgaW5mbyA9IGdsLmdldFNoYWRlckluZm9Mb2coYmx1ckZyYWcpO1xuICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBibHVyIHNoYWRlcjogJHtpbmZvfWApO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGJsdXIgdmVydGV4IHNoYWRlclxuICBjb25zdCBibHVyVmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICBpZiAoIWJsdXJWZXJ0ZXhTaGFkZXIpIHtcbiAgICB0aHJvdyBFcnJvcignY2Fubm90IGNyZWF0ZSBibHVyIHZlcnRleCBzaGFkZXInKTtcbiAgfVxuICBnbC5zaGFkZXJTb3VyY2UoYmx1clZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU291cmNlKCkpO1xuICBnbC5jb21waWxlU2hhZGVyKGJsdXJWZXJ0ZXhTaGFkZXIpO1xuXG4gIC8vIENyZWF0ZSBibHVyIHByb2dyYW1cbiAgY29uc3QgYmx1clByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmICghYmx1clByb2dyYW0pIHtcbiAgICB0aHJvdyBFcnJvcignY2Fubm90IGNyZWF0ZSBibHVyIHByb2dyYW0nKTtcbiAgfVxuICBnbC5hdHRhY2hTaGFkZXIoYmx1clByb2dyYW0sIGJsdXJWZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIoYmx1clByb2dyYW0sIGJsdXJGcmFnKTtcbiAgZ2wubGlua1Byb2dyYW0oYmx1clByb2dyYW0pO1xuXG4gIC8vIENoZWNrIGJsdXIgcHJvZ3JhbSBsaW5rIHN0YXR1c1xuICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoYmx1clByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIGNvbnN0IGluZm8gPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhibHVyUHJvZ3JhbSk7XG4gICAgdGhyb3cgRXJyb3IoYEZhaWxlZCB0byBsaW5rIGJsdXIgcHJvZ3JhbTogJHtpbmZvfWApO1xuICB9XG5cbiAgLy8gR2V0IHVuaWZvcm0gbG9jYXRpb25zXG4gIGNvbnN0IGJsdXJVbmlmb3JtcyA9IHtcbiAgICBwb3NpdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24oYmx1clByb2dyYW0sICdwb3NpdGlvbicpLFxuICAgIHRleHR1cmU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihibHVyUHJvZ3JhbSwgJ3VfdGV4dHVyZScpLFxuICAgIHRleGVsU2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGJsdXJQcm9ncmFtLCAndV90ZXhlbFNpemUnKSxcbiAgICBkaXJlY3Rpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihibHVyUHJvZ3JhbSwgJ3VfZGlyZWN0aW9uJyksXG4gICAgcmFkaXVzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oYmx1clByb2dyYW0sICd1X3JhZGl1cycpLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgcHJvZ3JhbTogYmx1clByb2dyYW0sXG4gICAgc2hhZGVyOiBibHVyRnJhZyxcbiAgICB2ZXJ0ZXhTaGFkZXI6IGJsdXJWZXJ0ZXhTaGFkZXIsXG4gICAgdW5pZm9ybXM6IGJsdXJVbmlmb3JtcyxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Qmx1cihcbiAgZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsXG4gIHNvdXJjZVRleHR1cmU6IFdlYkdMVGV4dHVyZSxcbiAgd2lkdGg6IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGJsdXJSYWRpdXM6IG51bWJlcixcbiAgYmx1clByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAgYmx1clVuaWZvcm1zOiBhbnksXG4gIHZlcnRleEJ1ZmZlcjogV2ViR0xCdWZmZXIsXG4gIHByb2Nlc3NGcmFtZWJ1ZmZlcnM6IFdlYkdMRnJhbWVidWZmZXJbXSxcbiAgcHJvY2Vzc1RleHR1cmVzOiBXZWJHTFRleHR1cmVbXSxcbikge1xuICBnbC51c2VQcm9ncmFtKGJsdXJQcm9ncmFtKTtcblxuICAvLyBTZXQgY29tbW9uIGF0dHJpYnV0ZXNcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcik7XG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYmx1clVuaWZvcm1zLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShibHVyVW5pZm9ybXMucG9zaXRpb24pO1xuXG4gIGNvbnN0IHRleGVsV2lkdGggPSAxLjAgLyB3aWR0aDtcbiAgY29uc3QgdGV4ZWxIZWlnaHQgPSAxLjAgLyBoZWlnaHQ7XG5cbiAgLy8gRmlyc3QgcGFzcyAtIGhvcml6b250YWwgYmx1clxuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHByb2Nlc3NGcmFtZWJ1ZmZlcnNbMF0pO1xuICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgc291cmNlVGV4dHVyZSk7XG4gIGdsLnVuaWZvcm0xaShibHVyVW5pZm9ybXMudGV4dHVyZSwgMCk7XG4gIGdsLnVuaWZvcm0yZihibHVyVW5pZm9ybXMudGV4ZWxTaXplLCB0ZXhlbFdpZHRoLCB0ZXhlbEhlaWdodCk7XG4gIGdsLnVuaWZvcm0yZihibHVyVW5pZm9ybXMuZGlyZWN0aW9uLCAxLjAsIDAuMCk7IC8vIEhvcml6b250YWxcbiAgZ2wudW5pZm9ybTFmKGJsdXJVbmlmb3Jtcy5yYWRpdXMsIGJsdXJSYWRpdXMpO1xuXG4gIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcblxuICAvLyBTZWNvbmQgcGFzcyAtIHZlcnRpY2FsIGJsdXJcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBwcm9jZXNzRnJhbWVidWZmZXJzWzFdKTtcbiAgZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHByb2Nlc3NUZXh0dXJlc1swXSk7XG4gIGdsLnVuaWZvcm0xaShibHVyVW5pZm9ybXMudGV4dHVyZSwgMCk7XG4gIGdsLnVuaWZvcm0yZihibHVyVW5pZm9ybXMuZGlyZWN0aW9uLCAwLjAsIDEuMCk7IC8vIFZlcnRpY2FsXG5cbiAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuXG4gIC8vIFJlc2V0IGZyYW1lYnVmZmVyXG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cbiAgcmV0dXJuIHByb2Nlc3NUZXh0dXJlc1sxXTtcbn1cbiIsImltcG9ydCB7IGdsc2wgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyB2ZXJ0ZXhTaGFkZXJTb3VyY2UgfSBmcm9tICcuL3ZlcnRleFNoYWRlcic7XG5cbmV4cG9ydCBjb25zdCBib3hCbHVyRnJhZ21lbnRTaGFkZXIgPSBnbHNsYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbmluIHZlYzIgdGV4Q29vcmRzO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XG51bmlmb3JtIHZlYzIgdV90ZXhlbFNpemU7ICAgIC8vIDEuMCAvIHRleHR1cmUgc2l6ZVxudW5pZm9ybSB2ZWMyIHVfZGlyZWN0aW9uOyAgICAvLyAoMS4wLCAwLjApIGZvciBob3Jpem9udGFsLCAoMC4wLCAxLjApIGZvciB2ZXJ0aWNhbFxudW5pZm9ybSBmbG9hdCB1X3JhZGl1czsgICAgICAvLyBibHVyIHJhZGl1cyBpbiB0ZXhlbHNcblxub3V0IHZlYzQgZnJhZ0NvbG9yO1xuXG52b2lkIG1haW4oKSB7XG4gICAgdmVjMyBzdW0gPSB2ZWMzKDAuMCk7XG4gICAgZmxvYXQgY291bnQgPSAwLjA7XG5cbiAgICAvLyBMaW1pdCByYWRpdXMgdG8gYXZvaWQgZXhjZXNzaXZlIGxvb3AgY29zdFxuICAgIGNvbnN0IGludCBNQVhfUkFESVVTID0gMTY7XG4gICAgaW50IHJhZGl1cyA9IGludChtaW4oZmxvYXQoTUFYX1JBRElVUyksIHVfcmFkaXVzKSk7XG5cbiAgICBmb3IgKGludCBpID0gLU1BWF9SQURJVVM7IGkgPD0gTUFYX1JBRElVUzsgKytpKSB7XG4gICAgICAgIGlmIChhYnMoaSkgPiByYWRpdXMpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZlYzIgb2Zmc2V0ID0gdV9kaXJlY3Rpb24gKiB1X3RleGVsU2l6ZSAqIGZsb2F0KGkpO1xuICAgICAgICBzdW0gKz0gdGV4dHVyZSh1X3RleHR1cmUsIHRleENvb3JkcyArIG9mZnNldCkucmdiO1xuICAgICAgICBjb3VudCArPSAxLjA7XG4gIH1cblxuICBmcmFnQ29sb3IgPSB2ZWM0KHN1bSAvIGNvdW50LCAxLjApO1xufVxuYDtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIGJveCBibHVyIHNoYWRlciBwcm9ncmFtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCb3hCbHVyUHJvZ3JhbShnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAvLyBDcmVhdGUgdmVydGV4IHNoYWRlclxuICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gIGlmICghdmVydGV4U2hhZGVyKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgdmVydGV4IHNoYWRlcicpO1xuICB9XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSgpKTtcbiAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gIC8vIENoZWNrIHZlcnRleCBzaGFkZXIgY29tcGlsYXRpb25cbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICBjb25zdCBpbmZvID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpO1xuICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyOiAke2luZm99YCk7XG4gIH1cblxuICAvLyBDcmVhdGUgZnJhZ21lbnQgc2hhZGVyXG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gIGlmICghZnJhZ21lbnRTaGFkZXIpIHtcbiAgICB0aHJvdyBFcnJvcignY2Fubm90IGNyZWF0ZSBmcmFnbWVudCBzaGFkZXInKTtcbiAgfVxuICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGJveEJsdXJGcmFnbWVudFNoYWRlcik7XG4gIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuXG4gIC8vIENoZWNrIGZyYWdtZW50IHNoYWRlciBjb21waWxhdGlvblxuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgY29uc3QgaW5mbyA9IGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpO1xuICAgIHRocm93IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBib3ggYmx1ciBzaGFkZXI6ICR7aW5mb31gKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgcHJvZ3JhbVxuICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBpZiAoIXByb2dyYW0pIHtcbiAgICB0aHJvdyBFcnJvcignY2Fubm90IGNyZWF0ZSBib3ggYmx1ciBwcm9ncmFtJyk7XG4gIH1cbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gIC8vIENoZWNrIHByb2dyYW0gbGluayBzdGF0dXNcbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIGNvbnN0IGluZm8gPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKTtcbiAgICB0aHJvdyBFcnJvcihgRmFpbGVkIHRvIGxpbmsgYm94IGJsdXIgcHJvZ3JhbTogJHtpbmZvfWApO1xuICB9XG5cbiAgLy8gR2V0IGF0dHJpYnV0ZSBhbmQgdW5pZm9ybSBsb2NhdGlvbnNcbiAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgcG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpLFxuICAgIHRleHR1cmU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndV90ZXh0dXJlJyksXG4gICAgdGV4ZWxTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfdGV4ZWxTaXplJyksXG4gICAgZGlyZWN0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfZGlyZWN0aW9uJyksXG4gICAgcmFkaXVzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VfcmFkaXVzJyksXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9ncmFtLFxuICAgIHZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlcixcbiAgICB1bmlmb3JtcyxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGdsc2wgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyB2ZXJ0ZXhTaGFkZXJTb3VyY2UgfSBmcm9tICcuL3ZlcnRleFNoYWRlcic7XG5cbi8vIEZyYWdtZW50IHNoYWRlciBzb3VyY2UgZm9yIGNvbXBvc2l0aW5nXG5leHBvcnQgY29uc3QgY29tcG9zaXRlRnJhZ21lbnRTaGFkZXIgPSBnbHNsYCN2ZXJzaW9uIDMwMCBlc1xuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gIGluIHZlYzIgdGV4Q29vcmRzO1xuICB1bmlmb3JtIHNhbXBsZXIyRCBiYWNrZ3JvdW5kO1xuICB1bmlmb3JtIHNhbXBsZXIyRCBmcmFtZTtcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWFzaztcbiAgb3V0IHZlYzQgZnJhZ0NvbG9yO1xuICBcbiAgdm9pZCBtYWluKCkge1xuICAgICAgXG4gICAgdmVjNCBmcmFtZVRleCA9IHRleHR1cmUoZnJhbWUsIHRleENvb3Jkcyk7XG4gICAgdmVjNCBiZ1RleCA9IHRleHR1cmUoYmFja2dyb3VuZCwgdGV4Q29vcmRzKTtcblxuICAgIGZsb2F0IG1hc2tWYWwgPSB0ZXh0dXJlKG1hc2ssIHRleENvb3JkcykucjtcblxuICAgIC8vIENvbXB1dGUgc2NyZWVuLXNwYWNlIGdyYWRpZW50IHRvIGRldGVjdCBlZGdlIHNoYXJwbmVzc1xuICAgIGZsb2F0IGdyYWQgPSBsZW5ndGgodmVjMihkRmR4KG1hc2tWYWwpLCBkRmR5KG1hc2tWYWwpKSk7XG5cbiAgICBmbG9hdCBlZGdlU29mdG5lc3MgPSAyLjA7IC8vIGhpZ2hlciA9IHNvZnRlclxuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNtb290aCBlZGdlIGFyb3VuZCBiaW5hcnkgdHJhbnNpdGlvblxuICAgIGZsb2F0IHNtb290aEFscGhhID0gc21vb3Roc3RlcCgwLjUgLSBncmFkICogZWRnZVNvZnRuZXNzLCAwLjUgKyBncmFkICogZWRnZVNvZnRuZXNzLCBtYXNrVmFsKTtcblxuICAgIC8vIE9wdGlvbmFsOiBwcmVzZXJ2ZSBmcmFtZSBhbHBoYSwgb3Igb3ZlcnJpZGUgYXMgZnVsbHkgb3BhcXVlXG4gICAgdmVjNCBibGVuZGVkID0gbWl4KGJnVGV4LCB2ZWM0KGZyYW1lVGV4LnJnYiwgMS4wKSwgMS4wIC0gc21vb3RoQWxwaGEpO1xuICAgIFxuICAgIGZyYWdDb2xvciA9IGJsZW5kZWQ7XG4gIFxuICB9XG5gO1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgY29tcG9zaXRlIHNoYWRlciBwcm9ncmFtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21wb3NpdGVQcm9ncmFtKGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gIC8vIENyZWF0ZSB2ZXJ0ZXggc2hhZGVyXG4gIGNvbnN0IHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgaWYgKCF2ZXJ0ZXhTaGFkZXIpIHtcbiAgICB0aHJvdyBFcnJvcignY2Fubm90IGNyZWF0ZSB2ZXJ0ZXggc2hhZGVyJyk7XG4gIH1cbiAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyU291cmNlKCkpO1xuICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG5cbiAgLy8gQ2hlY2sgdmVydGV4IHNoYWRlciBjb21waWxhdGlvblxuICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIGNvbnN0IGluZm8gPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcik7XG4gICAgdGhyb3cgRXJyb3IoYEZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXI6ICR7aW5mb31gKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBmcmFnbWVudCBzaGFkZXJcbiAgY29uc3QgY29tcG9zaXRlU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gIGlmICghY29tcG9zaXRlU2hhZGVyKSB7XG4gICAgdGhyb3cgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgZnJhZ21lbnQgc2hhZGVyJyk7XG4gIH1cbiAgZ2wuc2hhZGVyU291cmNlKGNvbXBvc2l0ZVNoYWRlciwgY29tcG9zaXRlRnJhZ21lbnRTaGFkZXIpO1xuICBnbC5jb21waWxlU2hhZGVyKGNvbXBvc2l0ZVNoYWRlcik7XG5cbiAgLy8gQ2hlY2sgZnJhZ21lbnQgc2hhZGVyIGNvbXBpbGF0aW9uXG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGNvbXBvc2l0ZVNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgY29uc3QgaW5mbyA9IGdsLmdldFNoYWRlckluZm9Mb2coY29tcG9zaXRlU2hhZGVyKTtcbiAgICB0aHJvdyBFcnJvcihgRmFpbGVkIHRvIGNvbXBpbGUgY29tcG9zaXRlIHNoYWRlcjogJHtpbmZvfWApO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBwcm9ncmFtXG4gIGNvbnN0IGNvbXBvc2l0ZVByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmICghY29tcG9zaXRlUHJvZ3JhbSkge1xuICAgIHRocm93IEVycm9yKCdjYW5ub3QgY3JlYXRlIGNvbXBvc2l0ZSBwcm9ncmFtJyk7XG4gIH1cbiAgZ2wuYXR0YWNoU2hhZGVyKGNvbXBvc2l0ZVByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihjb21wb3NpdGVQcm9ncmFtLCBjb21wb3NpdGVTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShjb21wb3NpdGVQcm9ncmFtKTtcblxuICAvLyBDaGVjayBwcm9ncmFtIGxpbmsgc3RhdHVzXG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihjb21wb3NpdGVQcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBjb25zdCBpbmZvID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coY29tcG9zaXRlUHJvZ3JhbSk7XG4gICAgdGhyb3cgRXJyb3IoYEZhaWxlZCB0byBsaW5rIGNvbXBvc2l0ZSBwcm9ncmFtOiAke2luZm99YCk7XG4gIH1cblxuICAvLyBHZXQgYXR0cmlidXRlIGFuZCB1bmlmb3JtIGxvY2F0aW9uc1xuICBjb25zdCBhdHRyaWJMb2NhdGlvbnMgPSB7XG4gICAgcG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKGNvbXBvc2l0ZVByb2dyYW0sICdwb3NpdGlvbicpLFxuICB9O1xuXG4gIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnMgPSB7XG4gICAgbWFzazogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKGNvbXBvc2l0ZVByb2dyYW0sICdtYXNrJykhLFxuICAgIGZyYW1lOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oY29tcG9zaXRlUHJvZ3JhbSwgJ2ZyYW1lJykhLFxuICAgIGJhY2tncm91bmQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihjb21wb3NpdGVQcm9ncmFtLCAnYmFja2dyb3VuZCcpISxcbiAgICBzdGVwV2lkdGg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihjb21wb3NpdGVQcm9ncmFtLCAndV9zdGVwV2lkdGgnKSEsXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9ncmFtOiBjb21wb3NpdGVQcm9ncmFtLFxuICAgIHZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlcjogY29tcG9zaXRlU2hhZGVyLFxuICAgIGF0dHJpYkxvY2F0aW9ucyxcbiAgICB1bmlmb3JtTG9jYXRpb25zLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgTVBNYXNrIH0gZnJvbSAnQG1lZGlhcGlwZS90YXNrcy12aXNpb24nO1xuaW1wb3J0IHsgYXBwbHlCbHVyLCBjcmVhdGVCbHVyUHJvZ3JhbSB9IGZyb20gJy4vc2hhZGVyLXByb2dyYW1zL2JsdXJTaGFkZXInO1xuaW1wb3J0IHsgY3JlYXRlQm94Qmx1clByb2dyYW0gfSBmcm9tICcuL3NoYWRlci1wcm9ncmFtcy9ib3hCbHVyU2hhZGVyJztcbmltcG9ydCB7IGNyZWF0ZUNvbXBvc2l0ZVByb2dyYW0gfSBmcm9tICcuL3NoYWRlci1wcm9ncmFtcy9jb21wb3NpdGVTaGFkZXInO1xuaW1wb3J0IHtcbiAgY3JlYXRlRnJhbWVidWZmZXIsXG4gIGNyZWF0ZVZlcnRleEJ1ZmZlcixcbiAgZW1wdHlJbWFnZURhdGEsXG4gIGluaXRUZXh0dXJlLFxuICByZXNpemVJbWFnZVRvQ292ZXIsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY29uc3Qgc2V0dXBXZWJHTCA9IChjYW52YXM6IE9mZnNjcmVlbkNhbnZhcykgPT4ge1xuICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCB7XG4gICAgYW50aWFsaWFzOiB0cnVlLFxuICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZSxcbiAgfSkgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcblxuICBsZXQgYmx1clJhZGl1czogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgaWYgKCFnbCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgV2ViR0wgY29udGV4dCcpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAvLyBDcmVhdGUgdGhlIGNvbXBvc2l0ZSBwcm9ncmFtXG4gIGNvbnN0IGNvbXBvc2l0ZSA9IGNyZWF0ZUNvbXBvc2l0ZVByb2dyYW0oZ2wpO1xuICBjb25zdCBjb21wb3NpdGVQcm9ncmFtID0gY29tcG9zaXRlLnByb2dyYW07XG4gIGNvbnN0IHBvc2l0aW9uTG9jYXRpb24gPSBjb21wb3NpdGUuYXR0cmliTG9jYXRpb25zLnBvc2l0aW9uO1xuICBjb25zdCB7XG4gICAgbWFzazogbWFza1RleHR1cmVMb2NhdGlvbixcbiAgICBmcmFtZTogZnJhbWVUZXh0dXJlTG9jYXRpb24sXG4gICAgYmFja2dyb3VuZDogYmdUZXh0dXJlTG9jYXRpb24sXG4gIH0gPSBjb21wb3NpdGUudW5pZm9ybUxvY2F0aW9ucztcblxuICAvLyBDcmVhdGUgdGhlIGJsdXIgcHJvZ3JhbSB1c2luZyB0aGUgc2FtZSB2ZXJ0ZXggc2hhZGVyIHNvdXJjZVxuICBjb25zdCBibHVyID0gY3JlYXRlQmx1clByb2dyYW0oZ2wpO1xuICBjb25zdCBibHVyUHJvZ3JhbSA9IGJsdXIucHJvZ3JhbTtcbiAgY29uc3QgYmx1clVuaWZvcm1zID0gYmx1ci51bmlmb3JtcztcblxuICAvLyBDcmVhdGUgdGhlIGJveCBibHVyIHByb2dyYW1cbiAgY29uc3QgYm94Qmx1ciA9IGNyZWF0ZUJveEJsdXJQcm9ncmFtKGdsKTtcbiAgY29uc3QgYm94Qmx1clByb2dyYW0gPSBib3hCbHVyLnByb2dyYW07XG4gIGNvbnN0IGJveEJsdXJVbmlmb3JtcyA9IGJveEJsdXIudW5pZm9ybXM7XG5cbiAgY29uc3QgYmdUZXh0dXJlID0gaW5pdFRleHR1cmUoZ2wsIDApO1xuICBjb25zdCBmcmFtZVRleHR1cmUgPSBpbml0VGV4dHVyZShnbCwgMSk7XG4gIGNvbnN0IHZlcnRleEJ1ZmZlciA9IGNyZWF0ZVZlcnRleEJ1ZmZlcihnbCk7XG5cbiAgaWYgKCF2ZXJ0ZXhCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgdmVydGV4IGJ1ZmZlcicpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFkZGl0aW9uYWwgdGV4dHVyZXMgYW5kIGZyYW1lYnVmZmVycyBmb3IgcHJvY2Vzc2luZ1xuICBsZXQgYmdCbHVyVGV4dHVyZXM6IFdlYkdMVGV4dHVyZVtdID0gW107XG4gIGxldCBiZ0JsdXJGcmFtZUJ1ZmZlcnM6IFdlYkdMRnJhbWVidWZmZXJbXSA9IFtdO1xuICBsZXQgbWFza0JsdXJUZXh0dXJlczogV2ViR0xUZXh0dXJlW10gPSBbXTtcbiAgbGV0IG1hc2tCbHVyRnJhbWVCdWZmZXJzOiBXZWJHTEZyYW1lYnVmZmVyW10gPSBbXTtcblxuICAvLyBDcmVhdGUgdGV4dHVyZXMgZm9yIGJhY2tncm91bmQgcHJvY2Vzc2luZyAoYmx1cilcbiAgYmdCbHVyVGV4dHVyZXMucHVzaChpbml0VGV4dHVyZShnbCwgMykpOyAvLyBGb3IgYmx1ciBwYXNzIDFcbiAgYmdCbHVyVGV4dHVyZXMucHVzaChpbml0VGV4dHVyZShnbCwgNCkpOyAvLyBGb3IgYmx1ciBwYXNzIDJcblxuICAvLyBDcmVhdGUgZnJhbWVidWZmZXJzIGZvciBiYWNrZ3JvdW5kIHByb2Nlc3NpbmdcbiAgYmdCbHVyRnJhbWVCdWZmZXJzLnB1c2goY3JlYXRlRnJhbWVidWZmZXIoZ2wsIGJnQmx1clRleHR1cmVzWzBdLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpKTtcbiAgYmdCbHVyRnJhbWVCdWZmZXJzLnB1c2goY3JlYXRlRnJhbWVidWZmZXIoZ2wsIGJnQmx1clRleHR1cmVzWzFdLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpKTtcblxuICAvLyBDcmVhdGUgdGV4dHVyZXMgZm9yIG1hc2sgcHJvY2Vzc2luZyAoYmx1cilcbiAgbWFza0JsdXJUZXh0dXJlcy5wdXNoKGluaXRUZXh0dXJlKGdsLCA1KSk7IC8vIEZvciBtYXNrIGJsdXIgcGFzcyAxXG4gIG1hc2tCbHVyVGV4dHVyZXMucHVzaChpbml0VGV4dHVyZShnbCwgNikpOyAvLyBGb3IgbWFzayBibHVyIHBhc3MgMlxuXG4gIC8vIENyZWF0ZSBmcmFtZWJ1ZmZlcnMgZm9yIG1hc2sgcHJvY2Vzc2luZ1xuICBtYXNrQmx1ckZyYW1lQnVmZmVycy5wdXNoKFxuICAgIGNyZWF0ZUZyYW1lYnVmZmVyKGdsLCBtYXNrQmx1clRleHR1cmVzWzBdLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLFxuICApO1xuICBtYXNrQmx1ckZyYW1lQnVmZmVycy5wdXNoKFxuICAgIGNyZWF0ZUZyYW1lYnVmZmVyKGdsLCBtYXNrQmx1clRleHR1cmVzWzFdLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLFxuICApO1xuXG4gIC8vIFNldCB1cCB1bmlmb3JtcyBmb3IgdGhlIGNvbXBvc2l0ZSBzaGFkZXJcbiAgZ2wudXNlUHJvZ3JhbShjb21wb3NpdGVQcm9ncmFtKTtcbiAgZ2wudW5pZm9ybTFpKGJnVGV4dHVyZUxvY2F0aW9uLCAwKTtcbiAgZ2wudW5pZm9ybTFpKGZyYW1lVGV4dHVyZUxvY2F0aW9uLCAxKTtcbiAgZ2wudW5pZm9ybTFpKG1hc2tUZXh0dXJlTG9jYXRpb24sIDIpO1xuXG4gIC8vIFN0b3JlIGN1c3RvbSBiYWNrZ3JvdW5kIGltYWdlXG4gIGxldCBjdXN0b21CYWNrZ3JvdW5kSW1hZ2U6IEltYWdlQml0bWFwIHwgSW1hZ2VEYXRhID0gZW1wdHlJbWFnZURhdGE7XG5cbiAgZnVuY3Rpb24gcmVuZGVyKGZyYW1lOiBWaWRlb0ZyYW1lLCBtYXNrOiBNUE1hc2spIHtcbiAgICBpZiAoZnJhbWUuY29kZWRXaWR0aCA9PT0gMCB8fCBtYXNrLndpZHRoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2lkdGggPSBmcmFtZS5kaXNwbGF5V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZnJhbWUuZGlzcGxheUhlaWdodDtcblxuICAgIC8vIFByZXBhcmUgZnJhbWUgdGV4dHVyZVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGZyYW1lVGV4dHVyZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBmcmFtZSk7XG5cbiAgICAvLyBBcHBseSBibHVyIGlmIGVuYWJsZWQgKGFuZCBubyBjdXN0b20gYmFja2dyb3VuZCBpcyBzZXQpXG4gICAgbGV0IGJhY2tncm91bmRUZXh0dXJlID0gYmdUZXh0dXJlO1xuXG4gICAgaWYgKGJsdXJSYWRpdXMpIHtcbiAgICAgIGJhY2tncm91bmRUZXh0dXJlID0gYXBwbHlCbHVyKFxuICAgICAgICBnbCxcbiAgICAgICAgZnJhbWVUZXh0dXJlLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBibHVyUmFkaXVzLFxuICAgICAgICBibHVyUHJvZ3JhbSxcbiAgICAgICAgYmx1clVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhCdWZmZXIhLFxuICAgICAgICBiZ0JsdXJGcmFtZUJ1ZmZlcnMsXG4gICAgICAgIGJnQmx1clRleHR1cmVzLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBiZ1RleHR1cmUpO1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBjdXN0b21CYWNrZ3JvdW5kSW1hZ2UpO1xuICAgICAgYmFja2dyb3VuZFRleHR1cmUgPSBiZ1RleHR1cmU7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgYm94IGJsdXIgdG8gbWFzayB0ZXh0dXJlXG4gICAgY29uc3QgYmx1cnJlZE1hc2tUZXh0dXJlID0gYXBwbHlCbHVyKFxuICAgICAgZ2wsXG4gICAgICBtYXNrLmdldEFzV2ViR0xUZXh0dXJlKCksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJsdXJSYWRpdXMgfHwgMS4wLCAvLyBVc2UgYSBkZWZhdWx0IGJsdXIgcmFkaXVzIGlmIG5vdCBzZXRcbiAgICAgIGJveEJsdXJQcm9ncmFtLFxuICAgICAgYm94Qmx1clVuaWZvcm1zLFxuICAgICAgdmVydGV4QnVmZmVyISxcbiAgICAgIG1hc2tCbHVyRnJhbWVCdWZmZXJzLFxuICAgICAgbWFza0JsdXJUZXh0dXJlcyxcbiAgICApO1xuXG4gICAgLy8gUmVuZGVyIHRoZSBmaW5hbCBjb21wb3NpdGVcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBnbC5jbGVhckNvbG9yKDEuMCwgMS4wLCAxLjAsIDEuMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICBnbC51c2VQcm9ncmFtKGNvbXBvc2l0ZVByb2dyYW0pO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcblxuICAgIC8vIFNldCBiYWNrZ3JvdW5kIHRleHR1cmUgKGVpdGhlciBvcmlnaW5hbCwgYmx1cnJlZCBvciBjdXN0b20pXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYmFja2dyb3VuZFRleHR1cmUpO1xuICAgIGdsLnVuaWZvcm0xaShiZ1RleHR1cmVMb2NhdGlvbiwgMCk7XG5cbiAgICAvLyBTZXQgZnJhbWUgdGV4dHVyZVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGZyYW1lVGV4dHVyZSk7XG4gICAgZ2wudW5pZm9ybTFpKGZyYW1lVGV4dHVyZUxvY2F0aW9uLCAxKTtcblxuICAgIC8vIFNldCBibHVycmVkIG1hc2sgdGV4dHVyZVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTIpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGJsdXJyZWRNYXNrVGV4dHVyZSk7XG4gICAgZ2wudW5pZm9ybTFpKG1hc2tUZXh0dXJlTG9jYXRpb24sIDIpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcblxuICAgIG1hc2suY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3IgdXBkYXRlIHRoZSBiYWNrZ3JvdW5kIGltYWdlXG4gICAqIEBwYXJhbSBpbWFnZSBUaGUgYmFja2dyb3VuZCBpbWFnZSB0byB1c2UsIG9yIG51bGwgdG8gY2xlYXJcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHNldEJhY2tncm91bmRJbWFnZShpbWFnZTogSW1hZ2VCaXRtYXAgfCBudWxsKSB7XG4gICAgLy8gQ2xlYXIgZXhpc3RpbmcgYmFja2dyb3VuZFxuICAgIGN1c3RvbUJhY2tncm91bmRJbWFnZSA9IGVtcHR5SW1hZ2VEYXRhO1xuXG4gICAgaWYgKGltYWdlKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBSZXNpemUgYW5kIGNyb3AgdGhlIGltYWdlIHRvIGNvdmVyIHRoZSBjYW52YXNcbiAgICAgICAgY29uc3QgY3JvcHBlZEltYWdlID0gYXdhaXQgcmVzaXplSW1hZ2VUb0NvdmVyKGltYWdlLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBjcm9wcGVkIGFuZCByZXNpemVkIGltYWdlXG4gICAgICAgIGN1c3RvbUJhY2tncm91bmRJbWFnZSA9IGNyb3BwZWRJbWFnZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIHByb2Nlc3NpbmcgYmFja2dyb3VuZCBpbWFnZSwgZmFsbGluZyBiYWNrIHRvIGJsYWNrIGJhY2tncm91bmQ6JyxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBiZ1RleHR1cmUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgY3VzdG9tQmFja2dyb3VuZEltYWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEJsdXJSYWRpdXMocmFkaXVzOiBudW1iZXIgfCBudWxsKSB7XG4gICAgYmx1clJhZGl1cyA9IHJhZGl1cztcbiAgICBzZXRCYWNrZ3JvdW5kSW1hZ2UobnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGdsLmRlbGV0ZVByb2dyYW0oY29tcG9zaXRlUHJvZ3JhbSk7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShibHVyUHJvZ3JhbSk7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShib3hCbHVyUHJvZ3JhbSk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZShiZ1RleHR1cmUpO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUoZnJhbWVUZXh0dXJlKTtcbiAgICBmb3IgKGNvbnN0IHRleHR1cmUgb2YgYmdCbHVyVGV4dHVyZXMpIHtcbiAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZnJhbWVidWZmZXIgb2YgYmdCbHVyRnJhbWVCdWZmZXJzKSB7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGV4dHVyZSBvZiBtYXNrQmx1clRleHR1cmVzKSB7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZyYW1lYnVmZmVyIG9mIG1hc2tCbHVyRnJhbWVCdWZmZXJzKSB7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgfVxuICAgIGdsLmRlbGV0ZUJ1ZmZlcih2ZXJ0ZXhCdWZmZXIpO1xuXG4gICAgLy8gUmVsZWFzZSBhbnkgSW1hZ2VCaXRtYXAgcmVzb3VyY2VzXG4gICAgaWYgKGN1c3RvbUJhY2tncm91bmRJbWFnZSkge1xuICAgICAgaWYgKGN1c3RvbUJhY2tncm91bmRJbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgICAgIGN1c3RvbUJhY2tncm91bmRJbWFnZS5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgY3VzdG9tQmFja2dyb3VuZEltYWdlID0gZW1wdHlJbWFnZURhdGE7XG4gICAgfVxuICAgIGJnQmx1clRleHR1cmVzID0gW107XG4gICAgYmdCbHVyRnJhbWVCdWZmZXJzID0gW107XG4gICAgbWFza0JsdXJUZXh0dXJlcyA9IFtdO1xuICAgIG1hc2tCbHVyRnJhbWVCdWZmZXJzID0gW107XG4gIH1cblxuICByZXR1cm4geyByZW5kZXIsIHNldEJhY2tncm91bmRJbWFnZSwgc2V0Qmx1clJhZGl1cywgY2xlYW51cCB9O1xufTtcbiIsImltcG9ydCB7IHNldHVwV2ViR0wgfSBmcm9tICcuLi93ZWJnbC9pbmRleCc7XG5pbXBvcnQgeyBWaWRlb1RyYWNrVHJhbnNmb3JtZXIsIFZpZGVvVHJhbnNmb3JtZXJJbml0T3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBWaWRlb1RyYW5zZm9ybWVyPE9wdGlvbnMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj5cbiAgaW1wbGVtZW50cyBWaWRlb1RyYWNrVHJhbnNmb3JtZXI8T3B0aW9ucz5cbntcbiAgdHJhbnNmb3JtZXI/OiBUcmFuc2Zvcm1TdHJlYW07XG5cbiAgY2FudmFzPzogT2Zmc2NyZWVuQ2FudmFzO1xuXG4gIC8vIGN0eD86IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblxuICBpbnB1dFZpZGVvPzogSFRNTFZpZGVvRWxlbWVudDtcblxuICBnbD86IFJldHVyblR5cGU8dHlwZW9mIHNldHVwV2ViR0w+O1xuXG4gIHByb3RlY3RlZCBpc0Rpc2FibGVkPzogQm9vbGVhbiA9IGZhbHNlO1xuXG4gIGFzeW5jIGluaXQoe1xuICAgIG91dHB1dENhbnZhcyxcbiAgICBpbnB1dEVsZW1lbnQ6IGlucHV0VmlkZW8sXG4gIH06IFZpZGVvVHJhbnNmb3JtZXJJbml0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghKGlucHV0VmlkZW8gaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdWaWRlbyB0cmFuc2Zvcm1lciBuZWVkcyBhIEhUTUxWaWRlb0VsZW1lbnQgYXMgaW5wdXQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm06IChmcmFtZSwgY29udHJvbGxlcikgPT4gdGhpcy50cmFuc2Zvcm0oZnJhbWUsIGNvbnRyb2xsZXIpLFxuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzID0gb3V0cHV0Q2FudmFzIHx8IG51bGw7XG4gICAgaWYgKG91dHB1dENhbnZhcykge1xuICAgICAgLy8gdGhpcy5jdHggPSB0aGlzLmNhbnZhcz8uZ2V0Q29udGV4dCgnMmQnKSB8fCB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmdsID0gc2V0dXBXZWJHTChcbiAgICAgICAgdGhpcy5jYW52YXMgfHwgbmV3IE9mZnNjcmVlbkNhbnZhcyhpbnB1dFZpZGVvLnZpZGVvV2lkdGgsIGlucHV0VmlkZW8udmlkZW9IZWlnaHQpLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5pbnB1dFZpZGVvID0gaW5wdXRWaWRlbztcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIHJlc3RhcnQoeyBvdXRwdXRDYW52YXMsIGlucHV0RWxlbWVudDogaW5wdXRWaWRlbyB9OiBWaWRlb1RyYW5zZm9ybWVySW5pdE9wdGlvbnMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IG91dHB1dENhbnZhcyB8fCBudWxsO1xuICAgIHRoaXMuZ2w/LmNsZWFudXAoKTtcbiAgICB0aGlzLmdsID0gc2V0dXBXZWJHTChcbiAgICAgIHRoaXMuY2FudmFzIHx8IG5ldyBPZmZzY3JlZW5DYW52YXMoaW5wdXRWaWRlby52aWRlb1dpZHRoLCBpbnB1dFZpZGVvLnZpZGVvSGVpZ2h0KSxcbiAgICApO1xuXG4gICAgdGhpcy5pbnB1dFZpZGVvID0gaW5wdXRWaWRlbztcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNhbnZhcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdsPy5jbGVhbnVwKCk7XG4gICAgdGhpcy5nbCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFic3RyYWN0IHRyYW5zZm9ybShcbiAgICBmcmFtZTogVmlkZW9GcmFtZSxcbiAgICBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxWaWRlb0ZyYW1lPixcbiAgKTogdm9pZDtcblxuICBhYnN0cmFjdCB1cGRhdGUob3B0aW9uczogT3B0aW9ucyk6IHZvaWQ7XG59XG4iLCJpbXBvcnQgUHJvY2Vzc29yV3JhcHBlciwgeyBQcm9jZXNzb3JXcmFwcGVyT3B0aW9ucyB9IGZyb20gJy4vUHJvY2Vzc29yV3JhcHBlcic7XG5pbXBvcnQgQmFja2dyb3VuZFRyYW5zZm9ybWVyLCB7XG4gIEJhY2tncm91bmRPcHRpb25zLFxuICBGcmFtZVByb2Nlc3NpbmdTdGF0cyxcbiAgU2VnbWVudGVyT3B0aW9ucyxcbn0gZnJvbSAnLi90cmFuc2Zvcm1lcnMvQmFja2dyb3VuZFRyYW5zZm9ybWVyJztcblxuZXhwb3J0ICogZnJvbSAnLi90cmFuc2Zvcm1lcnMvdHlwZXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWaWRlb1RyYW5zZm9ybWVyIH0gZnJvbSAnLi90cmFuc2Zvcm1lcnMvVmlkZW9UcmFuc2Zvcm1lcic7XG5leHBvcnQge1xuICBQcm9jZXNzb3JXcmFwcGVyLFxuICB0eXBlIEJhY2tncm91bmRPcHRpb25zLFxuICB0eXBlIFNlZ21lbnRlck9wdGlvbnMsXG4gIEJhY2tncm91bmRUcmFuc2Zvcm1lcixcbiAgdHlwZSBQcm9jZXNzb3JXcmFwcGVyT3B0aW9ucyxcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIGJhY2tncm91bmQgcHJvY2Vzc29yc1xuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNCYWNrZ3JvdW5kUHJvY2Vzc29ycyA9ICgpID0+XG4gIEJhY2tncm91bmRUcmFuc2Zvcm1lci5pc1N1cHBvcnRlZCAmJiBQcm9jZXNzb3JXcmFwcGVyLmlzU3VwcG9ydGVkO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBtb2Rlcm4gYmFja2dyb3VuZCBwcm9jZXNzb3JzLCB3aGljaCB5aWVsZCBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzTW9kZXJuQmFja2dyb3VuZFByb2Nlc3NvcnMgPSAoKSA9PlxuICBCYWNrZ3JvdW5kVHJhbnNmb3JtZXIuaXNTdXBwb3J0ZWQgJiYgUHJvY2Vzc29yV3JhcHBlci5oYXNNb2Rlcm5BcGlTdXBwb3J0O1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tncm91bmRQcm9jZXNzb3JPcHRpb25zIGV4dGVuZHMgUHJvY2Vzc29yV3JhcHBlck9wdGlvbnMge1xuICBibHVyUmFkaXVzPzogbnVtYmVyO1xuICBpbWFnZVBhdGg/OiBzdHJpbmc7XG4gIHNlZ21lbnRlck9wdGlvbnM/OiBTZWdtZW50ZXJPcHRpb25zO1xuICBhc3NldFBhdGhzPzogeyB0YXNrc1Zpc2lvbkZpbGVTZXQ/OiBzdHJpbmc7IG1vZGVsQXNzZXRQYXRoPzogc3RyaW5nIH07XG4gIG9uRnJhbWVQcm9jZXNzZWQ/OiAoc3RhdHM6IEZyYW1lUHJvY2Vzc2luZ1N0YXRzKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgQmFja2dyb3VuZEJsdXIgPSAoXG4gIGJsdXJSYWRpdXM6IG51bWJlciA9IDEwLFxuICBzZWdtZW50ZXJPcHRpb25zPzogU2VnbWVudGVyT3B0aW9ucyxcbiAgb25GcmFtZVByb2Nlc3NlZD86IChzdGF0czogRnJhbWVQcm9jZXNzaW5nU3RhdHMpID0+IHZvaWQsXG4gIHByb2Nlc3Nvck9wdGlvbnM/OiBQcm9jZXNzb3JXcmFwcGVyT3B0aW9ucyxcbikgPT4ge1xuICByZXR1cm4gQmFja2dyb3VuZFByb2Nlc3NvcihcbiAgICB7XG4gICAgICBibHVyUmFkaXVzLFxuICAgICAgc2VnbWVudGVyT3B0aW9ucyxcbiAgICAgIG9uRnJhbWVQcm9jZXNzZWQsXG4gICAgICAuLi5wcm9jZXNzb3JPcHRpb25zLFxuICAgIH0sXG4gICAgJ2JhY2tncm91bmQtYmx1cicsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgVmlydHVhbEJhY2tncm91bmQgPSAoXG4gIGltYWdlUGF0aDogc3RyaW5nLFxuICBzZWdtZW50ZXJPcHRpb25zPzogU2VnbWVudGVyT3B0aW9ucyxcbiAgb25GcmFtZVByb2Nlc3NlZD86IChzdGF0czogRnJhbWVQcm9jZXNzaW5nU3RhdHMpID0+IHZvaWQsXG4gIHByb2Nlc3Nvck9wdGlvbnM/OiBQcm9jZXNzb3JXcmFwcGVyT3B0aW9ucyxcbikgPT4ge1xuICByZXR1cm4gQmFja2dyb3VuZFByb2Nlc3NvcihcbiAgICB7XG4gICAgICBpbWFnZVBhdGgsXG4gICAgICBzZWdtZW50ZXJPcHRpb25zLFxuICAgICAgb25GcmFtZVByb2Nlc3NlZCxcbiAgICAgIC4uLnByb2Nlc3Nvck9wdGlvbnMsXG4gICAgfSxcbiAgICAndmlydHVhbC1iYWNrZ3JvdW5kJyxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBCYWNrZ3JvdW5kUHJvY2Vzc29yID0gKFxuICBvcHRpb25zOiBCYWNrZ3JvdW5kUHJvY2Vzc29yT3B0aW9ucyxcbiAgbmFtZSA9ICdiYWNrZ3JvdW5kLXByb2Nlc3NvcicsXG4pID0+IHtcbiAgY29uc3QgaXNUcmFuc2Zvcm1lclN1cHBvcnRlZCA9IEJhY2tncm91bmRUcmFuc2Zvcm1lci5pc1N1cHBvcnRlZDtcbiAgY29uc3QgaXNQcm9jZXNzb3JTdXBwb3J0ZWQgPSBQcm9jZXNzb3JXcmFwcGVyLmlzU3VwcG9ydGVkO1xuXG4gIGlmICghaXNUcmFuc2Zvcm1lclN1cHBvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmFja2dyb3VuZCB0cmFuc2Zvcm1lciBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICB9XG5cbiAgaWYgKCFpc1Byb2Nlc3NvclN1cHBvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdOZWl0aGVyIE1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3Igbm9yIGNhbnZhcy5jYXB0dXJlU3RyZWFtKCkgZmFsbGJhY2sgaXMgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicsXG4gICAgKTtcbiAgfVxuXG4gIC8vIEV4dHJhY3QgdHJhbnNmb3JtZXItc3BlY2lmaWMgb3B0aW9ucyBhbmQgcHJvY2Vzc29yIG9wdGlvbnNcbiAgY29uc3Qge1xuICAgIGJsdXJSYWRpdXMsXG4gICAgaW1hZ2VQYXRoLFxuICAgIHNlZ21lbnRlck9wdGlvbnMsXG4gICAgYXNzZXRQYXRocyxcbiAgICBvbkZyYW1lUHJvY2Vzc2VkLFxuICAgIC4uLnByb2Nlc3Nvck9wdHNcbiAgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgdHJhbnNmb3JtZXIgPSBuZXcgQmFja2dyb3VuZFRyYW5zZm9ybWVyKHtcbiAgICBibHVyUmFkaXVzLFxuICAgIGltYWdlUGF0aCxcbiAgICBzZWdtZW50ZXJPcHRpb25zLFxuICAgIGFzc2V0UGF0aHMsXG4gICAgb25GcmFtZVByb2Nlc3NlZCxcbiAgfSk7XG5cbiAgY29uc3QgcHJvY2Vzc29yID0gbmV3IFByb2Nlc3NvcldyYXBwZXIodHJhbnNmb3JtZXIsIG5hbWUsIHByb2Nlc3Nvck9wdHMpO1xuXG4gIHJldHVybiBwcm9jZXNzb3I7XG59O1xuIl0sIm5hbWVzIjpbInNsZWVwIiwidGltZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIndhaXRGb3JUcmFja1Jlc29sdXRpb24iLCJ0cmFjayIsInRpbWVvdXQiLCJzdGFydGVkIiwiRGF0ZSIsIm5vdyIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0U2V0dGluZ3MiLCJQcm9jZXNzb3JXcmFwcGVyIiwiX1Byb2Nlc3NvcldyYXBwZXIiLCJjb25zdHJ1Y3RvciIsInRyYW5zZm9ybWVyIiwibmFtZSIsIm9wdGlvbnMiLCJ1c2VTdHJlYW1GYWxsYmFjayIsInByb2Nlc3NpbmdFbmFibGVkIiwiX2EiLCJtYXhGcHMiLCJpc1N1cHBvcnRlZCIsImhhc1N0cmVhbVByb2Nlc3NvciIsIk1lZGlhU3RyZWFtVHJhY2tHZW5lcmF0b3IiLCJNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yIiwiaGFzRmFsbGJhY2tTdXBwb3J0IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJWaWRlb0ZyYW1lIiwicHJvdG90eXBlIiwiaGFzTW9kZXJuQXBpU3VwcG9ydCIsInNldHVwIiwib3B0cyIsInNvdXJjZSIsInNvdXJjZUR1bW15IiwiZWxlbWVudCIsIkhUTUxWaWRlb0VsZW1lbnQiLCJUeXBlRXJyb3IiLCJleGlzdGluZ0NhbnZhcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImRpc3BsYXlDYW52YXMiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJkaXNwbGF5IiwiZGF0YXNldCIsImxpdmVraXRQcm9jZXNzb3IiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW5kZXJDb250ZXh0IiwiZ2V0Q29udGV4dCIsImNhcHR1cmVkU3RyZWFtIiwiY2FwdHVyZVN0cmVhbSIsImNhbnZhcyIsIk9mZnNjcmVlbkNhbnZhcyIsInByb2Nlc3NvciIsInRyYWNrR2VuZXJhdG9yIiwia2luZCIsInNpZ25hbFRhcmdldCIsImluaXQiLCJvdXRwdXRDYW52YXMiLCJpbnB1dEVsZW1lbnQiLCJpbml0RmFsbGJhY2tQYXRoIiwiaW5pdFN0cmVhbVByb2Nlc3NvclBhdGgiLCJyZWFkYWJsZVN0cmVhbSIsInJlYWRhYmxlIiwicGlwZWRTdHJlYW0iLCJwaXBlVGhyb3VnaCIsInBpcGVUbyIsIndyaXRhYmxlIiwiY2F0Y2giLCJlIiwiY29uc29sZSIsImVycm9yIiwiZmluYWxseSIsImRlc3Ryb3kiLCJwcm9jZXNzZWRUcmFjayIsImdldFZpZGVvVHJhY2tzIiwiZnJhbWVDYWxsYmFjayIsImZyYW1lIiwiY2xvc2UiLCJjb250cm9sbGVyIiwiZW5xdWV1ZSIsInByb2Nlc3NlZEZyYW1lIiwiZHJhd0ltYWdlIiwidHJhbnNmb3JtIiwic3RhcnRSZW5kZXJMb29wIiwibGFzdFZpZGVvVGltZXN0YW1wIiwibGFzdEZyYW1lVGltZSIsInZpZGVvRWxlbWVudCIsIm1pbkZyYW1lSW50ZXJ2YWwiLCJlc3RpbWF0ZWRWaWRlb0ZwcyIsImZyYW1lVGltZUhpc3RvcnkiLCJsYXN0VmlkZW9UaW1lQ2hhbmdlIiwiZnJhbWVDb3VudCIsImxhc3RGcHNMb2ciLCJyZW5kZXJMb29wIiwicGF1c2VkIiwid2FybiIsInBsYXkiLCJ2aWRlb1RpbWUiLCJjdXJyZW50VGltZSIsInBlcmZvcm1hbmNlIiwidGltZVNpbmNlTGFzdEZyYW1lIiwiaGFzTmV3RnJhbWUiLCJ0aW1lQmV0d2VlbkZyYW1lcyIsInB1c2giLCJsZW5ndGgiLCJzaGlmdCIsImF2Z0ZyYW1lVGltZSIsInJlZHVjZSIsInN1bSIsImlzRGV2ZWxvcG1lbnQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwiZGVidWciLCJ0b0ZpeGVkIiwidGltZVRocmVzaG9sZE1ldCIsInJlYWR5U3RhdGUiLCJIVE1MTWVkaWFFbGVtZW50IiwiSEFWRV9DVVJSRU5UX0RBVEEiLCJhbmltYXRpb25GcmFtZUlkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVzdGFydCIsInJlc3RhcnRUcmFuc2Zvcm1lciIsInVwZGF0ZVRyYW5zZm9ybWVyT3B0aW9ucyIsInVwZGF0ZSIsIl9iIiwiX2MiLCJfZCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInN0b3AiLCJ3cml0YWJsZUNvbnRyb2wiLCJ2aXNpb24iLCJkZXBlbmRlbmNpZXMiLCJpbml0VGV4dHVyZSIsImdsIiwidGV4SW5kZXgiLCJ0ZXhSZWYiLCJURVhUVVJFMCIsImFjdGl2ZVRleHR1cmUiLCJ0ZXh0dXJlIiwiY3JlYXRlVGV4dHVyZSIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIkxJTkVBUiIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiZnJhbWVidWZmZXIiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJ0ZXhJbWFnZTJEIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJzdGF0dXMiLCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJFcnJvciIsImNyZWF0ZVZlcnRleEJ1ZmZlciIsInZlcnRleEJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJidWZmZXJEYXRhIiwiRmxvYXQzMkFycmF5IiwiU1RBVElDX0RSQVciLCJyZXNpemVJbWFnZVRvQ292ZXIiLCJpbWFnZSIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwiaW1nQXNwZWN0IiwidGFyZ2V0QXNwZWN0Iiwic3giLCJzeSIsInNXaWR0aCIsInNIZWlnaHQiLCJNYXRoIiwicm91bmQiLCJjcmVhdGVJbWFnZUJpdG1hcCIsInJlc2l6ZVdpZHRoIiwicmVzaXplSGVpZ2h0IiwicmVzaXplUXVhbGl0eSIsImVtcHR5SW1hZ2VEYXRhIiwiSW1hZ2VEYXRhIiwiZGF0YSIsImdsc2wiLCJ2ZXJ0ZXhTaGFkZXJTb3VyY2UiLCJmbGlwWSIsImJsdXJGcmFnbWVudFNoYWRlciIsImNyZWF0ZUJsdXJQcm9ncmFtIiwiYmx1ckZyYWciLCJjcmVhdGVTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJpbmZvIiwiZ2V0U2hhZGVySW5mb0xvZyIsImJsdXJWZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiYmx1clByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJnZXRQcm9ncmFtSW5mb0xvZyIsImJsdXJVbmlmb3JtcyIsInBvc2l0aW9uIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ0ZXhlbFNpemUiLCJkaXJlY3Rpb24iLCJyYWRpdXMiLCJwcm9ncmFtIiwic2hhZGVyIiwidmVydGV4U2hhZGVyIiwidW5pZm9ybXMiLCJhcHBseUJsdXIiLCJzb3VyY2VUZXh0dXJlIiwiYmx1clJhZGl1cyIsInByb2Nlc3NGcmFtZWJ1ZmZlcnMiLCJwcm9jZXNzVGV4dHVyZXMiLCJ1c2VQcm9ncmFtIiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ0ZXhlbFdpZHRoIiwidGV4ZWxIZWlnaHQiLCJ2aWV3cG9ydCIsInVuaWZvcm0xaSIsInVuaWZvcm0yZiIsInVuaWZvcm0xZiIsImRyYXdBcnJheXMiLCJUUklBTkdMRVMiLCJib3hCbHVyRnJhZ21lbnRTaGFkZXIiLCJjcmVhdGVCb3hCbHVyUHJvZ3JhbSIsImZyYWdtZW50U2hhZGVyIiwiY29tcG9zaXRlRnJhZ21lbnRTaGFkZXIiLCJjcmVhdGVDb21wb3NpdGVQcm9ncmFtIiwiY29tcG9zaXRlU2hhZGVyIiwiY29tcG9zaXRlUHJvZ3JhbSIsImF0dHJpYkxvY2F0aW9ucyIsInVuaWZvcm1Mb2NhdGlvbnMiLCJtYXNrIiwiYmFja2dyb3VuZCIsInN0ZXBXaWR0aCIsInNldHVwV2ViR0wiLCJhbnRpYWxpYXMiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJlbmFibGUiLCJCTEVORCIsImJsZW5kRnVuYyIsIlNSQ19BTFBIQSIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJjb21wb3NpdGUiLCJwb3NpdGlvbkxvY2F0aW9uIiwibWFza1RleHR1cmVMb2NhdGlvbiIsImZyYW1lVGV4dHVyZUxvY2F0aW9uIiwiYmdUZXh0dXJlTG9jYXRpb24iLCJibHVyIiwiYm94Qmx1ciIsImJveEJsdXJQcm9ncmFtIiwiYm94Qmx1clVuaWZvcm1zIiwiYmdUZXh0dXJlIiwiZnJhbWVUZXh0dXJlIiwiYmdCbHVyVGV4dHVyZXMiLCJiZ0JsdXJGcmFtZUJ1ZmZlcnMiLCJtYXNrQmx1clRleHR1cmVzIiwibWFza0JsdXJGcmFtZUJ1ZmZlcnMiLCJjdXN0b21CYWNrZ3JvdW5kSW1hZ2UiLCJyZW5kZXIiLCJjb2RlZFdpZHRoIiwiZGlzcGxheVdpZHRoIiwiZGlzcGxheUhlaWdodCIsIlRFWFRVUkUxIiwiYmFja2dyb3VuZFRleHR1cmUiLCJibHVycmVkTWFza1RleHR1cmUiLCJnZXRBc1dlYkdMVGV4dHVyZSIsImNsZWFyQ29sb3IiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJURVhUVVJFMiIsInNldEJhY2tncm91bmRJbWFnZSIsImNyb3BwZWRJbWFnZSIsInNldEJsdXJSYWRpdXMiLCJjbGVhbnVwIiwiZGVsZXRlUHJvZ3JhbSIsImRlbGV0ZVRleHR1cmUiLCJkZWxldGVGcmFtZWJ1ZmZlciIsImRlbGV0ZUJ1ZmZlciIsIkltYWdlQml0bWFwIiwiVmlkZW9UcmFuc2Zvcm1lciIsImlzRGlzYWJsZWQiLCJpbnB1dFZpZGVvIiwiVHJhbnNmb3JtU3RyZWFtIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiQmFja2dyb3VuZFByb2Nlc3NvciIsImJhY2tncm91bmRJbWFnZSIsIl9lIiwiX2YiLCJmaWxlU2V0IiwiRmlsZXNldFJlc29sdmVyIiwiZm9yVmlzaW9uVGFza3MiLCJhc3NldFBhdGhzIiwidGFza3NWaXNpb25GaWxlU2V0IiwiaW1hZ2VTZWdtZW50ZXIiLCJJbWFnZVNlZ21lbnRlciIsImNyZWF0ZUZyb21PcHRpb25zIiwiYmFzZU9wdGlvbnMiLCJtb2RlbEFzc2V0UGF0aCIsImRlbGVnYXRlIiwic2VnbWVudGVyT3B0aW9ucyIsInJ1bm5pbmdNb2RlIiwib3V0cHV0Q2F0ZWdvcnlNYXNrIiwib3V0cHV0Q29uZmlkZW5jZU1hc2tzIiwiaW1hZ2VQYXRoIiwibG9hZEJhY2tncm91bmQiLCJlcnIiLCJwYXRoIiwiaW1nIiwiSW1hZ2UiLCJyZWplY3QiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJpbWFnZURhdGEiLCJjb2RlZEhlaWdodCIsInN0YXJ0VGltZU1zIiwic2VnbWVudEZvclZpZGVvIiwicmVzdWx0Iiwic2VnbWVudGF0aW9uVGltZU1zIiwic2VnbWVudGF0aW9uUmVzdWx0cyIsImRyYXdGcmFtZSIsIm5ld0ZyYW1lIiwidGltZXN0YW1wIiwiZmlsdGVyVGltZU1zIiwic3RhdHMiLCJwcm9jZXNzaW5nVGltZU1zIiwib25GcmFtZVByb2Nlc3NlZCIsImNhbGwiLCJjYXRlZ29yeU1hc2siLCJzdXBwb3J0c0JhY2tncm91bmRQcm9jZXNzb3JzIiwic3VwcG9ydHNNb2Rlcm5CYWNrZ3JvdW5kUHJvY2Vzc29ycyIsIkJhY2tncm91bmRCbHVyIiwicHJvY2Vzc29yT3B0aW9ucyIsIlZpcnR1YWxCYWNrZ3JvdW5kIiwiaXNUcmFuc2Zvcm1lclN1cHBvcnRlZCIsImlzUHJvY2Vzc29yU3VwcG9ydGVkIiwicHJvY2Vzc29yT3B0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@livekit+track-processors@0.5.4_livekit-client@2.11.2/node_modules/@livekit/track-processors/dist/index.mjs\n");

/***/ })

};
;